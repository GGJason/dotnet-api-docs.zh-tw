<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="51795f05b21ad02430b19a88cef2e202a8914a5b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36552911" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>實作 Berkeley 通訊端介面。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>類別會提供一組豐富的方法和屬性的網路通訊。 <xref:System.Net.Sockets.Socket>類別可讓您同時執行同步和非同步資料傳輸使用任何通訊協定中所列<xref:System.Net.Sockets.ProtocolType>列舉型別。  
  
 <xref:System.Net.Sockets.Socket>類別遵循非同步方法的.NET Framework 命名模式。 例如，同步<xref:System.Net.Sockets.Socket.Receive%2A>方法對應於非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>和<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。  
  
 如果您的應用程式只需要一個執行緒在執行期間，使用下列方法，專為同步作業模式。  
  
-   如果您使用連線導向的通訊協定，例如 TCP，您的伺服器可以接聽的連接使用<xref:System.Net.Sockets.Socket.Listen%2A>方法。 <xref:System.Net.Sockets.Socket.Accept%2A>方法會處理任何連入連線要求，並傳回<xref:System.Net.Sockets.Socket>可用來與遠端主機通訊資料。 使用此傳回<xref:System.Net.Sockets.Socket>呼叫<xref:System.Net.Sockets.Socket.Send%2A>或<xref:System.Net.Sockets.Socket.Receive%2A>方法。 呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.Listen%2A>方法，如果您想要指定本機 IP 位址和連接埠號碼。 如果您想要為您指派可用的通訊埠的基礎服務提供者，請使用零的連接埠號碼。 如果您想要連接到接聽的主機，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法。 若要進行通訊的資料，呼叫<xref:System.Net.Sockets.Socket.Send%2A>或<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
-   如果您使用無連接的通訊協定，例如 UDP，您不需要完全接聽的連接。 呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，以接受任何內送的資料包。 使用<xref:System.Net.Sockets.Socket.SendTo%2A>資料包傳送至遠端主機的方法。  
  
 若要處理執行期間使用個別執行緒的通訊，請使用下列方法，專為非同步作業模式。  
  
-   如果您使用連線導向的通訊協定，例如 TCP，使用<xref:System.Net.Sockets.Socket>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>，和<xref:System.Net.Sockets.Socket.EndConnect%2A>要用來接聽主機連接的方法。 使用<xref:System.Net.Sockets.Socket.BeginSend%2A>和<xref:System.Net.Sockets.Socket.EndSend%2A>或<xref:System.Net.Sockets.Socket.BeginReceive%2A>和<xref:System.Net.Sockets.Socket.EndReceive%2A>非同步通訊資料的方法。 可處理連入連線要求使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>和<xref:System.Net.Sockets.Socket.EndAccept%2A>。  
  
-   如果您使用無連接的通訊協定，例如 UDP，您可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>和<xref:System.Net.Sockets.Socket.EndSendTo%2A>傳送資料包，並<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>和<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>來接收資料包。  
  
 如果您執行多個通訊端上的非同步作業，它們不一定會完成啟動它們的順序中。  
  
 當您完成傳送和接收資料，請使用<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以停用<xref:System.Net.Sockets.Socket>。 在呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法釋放相關聯的所有資源<xref:System.Net.Sockets.Socket>。  
  
 <xref:System.Net.Sockets.Socket>類別可讓您設定您<xref:System.Net.Sockets.Socket>使用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。 擷取使用這些設定<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果您要撰寫相當簡單的應用程式，且不需要最大效能，請考慮使用<xref:System.Net.Sockets.TcpClient>， <xref:System.Net.Sockets.TcpListener>，和<xref:System.Net.Sockets.UdpClient>。 這些類別提供更簡單且更容易使用的介面，以<xref:System.Net.Sockets.Socket>通訊。  
  
   
  
## Examples  
 下列程式碼範例示範如何<xref:System.Net.Sockets.Socket>類別可以用來將資料傳送至 HTTP 伺服器，並接收回應。 這個範例會封鎖直到接收整個頁面。  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">若要建立傳出連線，或接受連入要求。</permission>
    <threadsafe>這個類別的執行個體都是安全執行緒。</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Net.Sockets.Socket" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">
          <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 傳回的通訊端資訊。</param>
        <summary>使用從 <see cref="T:System.Net.Sockets.Socket" /> 傳回的指定值，初始化 <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您呼叫<xref:System.Net.Sockets.Socket.%23ctor%2A>多次包含相同的位元組陣列，為每個呼叫的引數的建構函式，您將建立受管理的多個<xref:System.Net.Sockets.Socket>與相同的基礎通訊端。 這種做法不鼓勵。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</param>
        <param name="protocolType">其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</param>
        <summary>使用指定的通訊端類型和通訊協定，初始化 <see cref="T:System.Net.Sockets.Socket" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType`參數指定的型別<xref:System.Net.Sockets.Socket>類別和`protocolType`參數會指定使用的通訊協定<xref:System.Net.Sockets.Socket>。 兩個參數不是獨立的。 通常<xref:System.Net.Sockets.Socket>型別是隱含的通訊協定。 如果的組合<xref:System.Net.Sockets.Socket>類型及通訊協定造成類型無效<xref:System.Net.Sockets.Socket>，這個建構函式會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果這個建構函式擲回<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketType" /> 和 <paramref name="protocolType" /> 組合產生無效通訊端。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">其中一個 <see cref="T:System.Net.Sockets.AddressFamily" /> 值。</param>
        <param name="socketType">其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</param>
        <param name="protocolType">其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</param>
        <summary>使用指定的通訊協定家族 (Family)、通訊端類型和通訊協定，初始化 <see cref="T:System.Net.Sockets.Socket" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily`參數指定的定址配置<xref:System.Net.Sockets.Socket>類別使用，`socketType`參數指定的型別<xref:System.Net.Sockets.Socket>類別，而`protocolType`參數會指定使用的通訊協定<xref:System.Net.Sockets.Socket>。 三個參數不是獨立的。 有些位址系列限制，並通常可以使用哪些通訊協定<xref:System.Net.Sockets.Socket>型別是隱含的通訊協定。 如果位址系列的組合<xref:System.Net.Sockets.Socket>類型和通訊協定無效的輸入結果<xref:System.Net.Sockets.Socket>，這個建構函式會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果這個建構函式擲回<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立執行個體<xref:System.Net.Sockets.Socket>類別。  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="addressFamily" />、<paramref name="socketType" /> 和 <paramref name="protocolType" /> 組合所產生的無效通訊端。</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立新建立連接的新 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>新建立連接的新 <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> 以同步方式暫止的連接要求的第一個擷取的連接要求的佇列接聽的通訊端，然後建立並傳回新<xref:System.Net.Sockets.Socket>。 您無法使用這個傳回<xref:System.Net.Sockets.Socket>接受連線佇列中的任何其他連線。 不過，您可以呼叫<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>方法傳回之<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼。  
  
 封鎖模式中，在<xref:System.Net.Sockets.Socket.Accept%2A>封鎖，直到連入連線嘗試會排入佇列。 一旦接受連線，則原始<xref:System.Net.Sockets.Socket>會繼續佇列的連入連線要求直到您關閉它。  
  
 如果您呼叫這個方法，使用非封鎖<xref:System.Net.Sockets.Socket>，和任何連接要求會排入佇列，<xref:System.Net.Sockets.Socket.Accept%2A>會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法，您必須先呼叫<xref:System.Net.Sockets.Socket.Listen%2A>接聽和內送連接要求排入佇列的方法。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例可接受簡單<xref:System.Net.Sockets.Socket>連線。  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">接受的通訊端並未接聽連線。 您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.Accept" />。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始非同步作業以接受連入的連接嘗試。</summary>
        <returns>如果 I/O 作業暫止，則傳回 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 作業同步完成，則傳回 <see langword="false" />。 不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法來以非同步方式處理傳入的連接嘗試。 以非同步方式接受連線，讓您能夠傳送和接收不同的執行緒中的資料。 然後再呼叫<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>接聽和內送連接要求排入佇列的方法。  
  
 若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並將它連結<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件所需：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可以選擇性地指定現有<xref:System.Net.Sockets.Socket>用於連入連線，藉由指定<xref:System.Net.Sockets.Socket>搭配<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>屬性。  
  
 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>屬性是 null，新<xref:System.Net.Sockets.Socket>建構具有相同<xref:System.Net.Sockets.Socket.AddressFamily%2A>， <xref:System.Net.Sockets.Socket.SocketType%2A>，和<xref:System.Net.Sockets.Socket.ProtocolType%2A>與目前<xref:System.Net.Sockets.Socket>並設定為<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>屬性。  
  
 呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法，如此將可在回呼方法中擷取資訊。 如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。  
  
 （選擇性） 緩衝區可能會提供用來接收資料後，通訊端上的初始區塊<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在此情況下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>屬性必須設為包含資料的緩衝區來接收和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性必須設為接收緩衝區中的資料位元組的數目上限。 這些屬性可以使用設定<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>方法。 傳入緩衝區的一部分會可供內部使用基礎 Winsock AcceptEx 呼叫。 這表示傳回的資料量會一律的值小於<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>提供執行個體。 在內部使用的緩衝區數量有所不同通訊端位址系列。 所需的最小緩衝區大小為 288 個位元組。 如果指定較大的緩衝區大小，則<xref:System.Net.Sockets.Socket>預期某些額外的資料以外 Winsock AcceptEx 呼叫所收到的資料，並會等候，直到接收到此額外的資料。 如果發生逾時，會重設連接。 因此，如果一段指定的預期有額外的資料，然後緩衝區大小應該設定最小緩衝區大小加上此一數量。  
  
 完成回呼方法應該檢查<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>屬性來判斷如果<xref:System.Net.Sockets.Socket.AcceptAsync%2A>作業已順利完成。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>可能已不接受任何連線時，在某些情況下會發生事件，而且會導致<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>屬性設定為<xref:System.Net.Sockets.SocketError.ConnectionReset>。 這可能是因為連接埠掃描使用半開啟 SYN 類型掃描 (SYN]-> [SYN ACK]-> [RST 順序)。 使用應用程式<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法應該準備好處理這個狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引數無效。 如果提供的緩衝區不夠大，就會發生這個例外狀況。 緩衝區必須至少為 2 * (sizeof(SOCKADDR_STORAGE + 16) 位元組。  如果指定多個緩衝區而 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性不是 null，也會發生這個例外狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">引數超出範圍。 如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> 小於 0，就會發生這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException">要求了無效的作業。 如果接受的 <see cref="T:System.Net.Sockets.Socket" /> 不接聽連接或接受的通訊端已繫結，就會發生這個例外狀況。  您必須先呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 和 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 方法，再呼叫 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法。  此例外狀況也會在已與通訊端連線，或是通訊端作業已使用指定的 <paramref name="e" /> 參數進行時發生。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Net.Sockets.Socket" /> 的通訊協定家族 (Family)。</summary>
        <value>其中一個 <see cref="T:System.Net.Sockets.AddressFamily" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily>定址配置，所指定的執行個體<xref:System.Net.Sockets.Socket>類別可以使用。 這個屬性是唯讀的而且時，會設定<xref:System.Net.Sockets.Socket>建立。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>至主控台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得已從網路接收且可供讀取的資料量。</summary>
        <value>從網路收到的和可供讀取的資料位元組數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用非封鎖<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Available%2A>是好的方法，以判斷資料是否會排入佇列進行讀取，然後再呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 可用的資料時的資料總量排入佇列進行讀取的網路緩衝區中。 如果沒有資料會排入佇列中的網路緩衝區，<xref:System.Net.Sockets.Socket.Available%2A>傳回 0。  
  
 如果遠端主機關機或關閉連接，<xref:System.Net.Sockets.Socket.Available%2A>可以擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會比較的結果呼叫 IOControl FIONREAD 與可用的屬性。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始非同步作業以接受連入的連接嘗試。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>開始非同步作業以接受連入的連接嘗試。</summary>
        <returns>參考非同步 <see cref="T:System.IAsyncResult" /> 建立作業的 <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法來以非同步方式處理傳入的連接嘗試。 以非同步方式接受連線，讓您能夠傳送和接收不同的執行緒中的資料。 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>接聽和內送連接要求排入佇列的方法。  
  
 您必須建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 若要這樣做，在非常小，您必須傳遞接聽<xref:System.Net.Sockets.Socket>物件<xref:System.Net.Sockets.Socket.BeginAccept%2A>透過`state`參數。 如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，透過`state`參數。  
  
 叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系統通常會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndAccept%2A>之前擷取暫止的連接。 <xref:System.Net.Sockets.Socket.EndAccept%2A> 會傳回新<xref:System.Net.Sockets.Socket>物件可用來傳送和接收資料的遠端主機。 您無法使用這個傳回<xref:System.Net.Sockets.Socket>接受連線佇列中的任何其他連線。 如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行原始的執行緒時。  
  
 系統可能也會使用呼叫執行緒來叫用回呼方法。 在此情況下，<xref:System.IAsyncResult.CompletedSynchronously%2A>屬性傳回<xref:System.IAsyncResult>設表示<xref:System.Net.Sockets.Socket.BeginAccept%2A>已同步完成的方法。  
  
 如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法呼叫。  後續呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
> [!NOTE]
>  您可以使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性傳回之<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件 MSDN 中錯誤的詳細描述。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會嘗試以非同步方式接收連入連線。  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">接受的通訊端並未接聽連線。 您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  -或-  接受的通訊端已繫結。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> 小於 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">要從寄件者接受的位元組數。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>開始非同步作業以接收連入連線嘗試，並接收用戶端應用程式傳送的第一個資料區塊。</summary>
        <returns>參考非同步 <see cref="T:System.IAsyncResult" /> 建立作業的 <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法來以非同步方式處理傳入的連接嘗試。 以非同步方式接受連線，可讓您傳送和接收不同的執行緒中的資料。 這個多載可讓您指定要接受在初始中傳送的位元組數目`receiveSize`參數。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>接聽和內送連接要求排入佇列的方法。  
  
 您必須建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 若要這樣做，在非常小，您必須傳遞接聽<xref:System.Net.Sockets.Socket>物件<xref:System.Net.Sockets.Socket.BeginAccept%2A>透過`state`參數。 如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，透過`state`參數。  
  
 叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系統通常會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndAccept%2A>之前擷取暫止的連接。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 傳回新<xref:System.Net.Sockets.Socket>可用來傳送和接收資料的遠端主機。 您無法使用這個傳回<xref:System.Net.Sockets.Socket>接受連線佇列中的任何其他連線。 如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行原始的執行緒時。  
  
 系統可能也會使用呼叫執行緒來叫用回呼方法。 在此情況下，<xref:System.IAsyncResult.CompletedSynchronously%2A>屬性傳回<xref:System.IAsyncResult>設表示<xref:System.Net.Sockets.Socket.BeginAccept%2A>已同步完成的方法。  
  
 如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，關閉<xref:System.Net.Sockets.Socket>。  當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法呼叫。  後續呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
> [!NOTE]
>  您可以呼叫使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性傳回之<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼的物件。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會開啟通訊端，並接受非同步連接。 在此範例中，通訊端接受初始的 10 個位元組的資料。 接收的位元組數目和資料會顯示在主控台上的回呼委派。 請參閱<xref:System.Net.Sockets.Socket.BeginReceive%2A>的收到的剩餘資料的方式說明。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">接受的通訊端並未接聽連線。 您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  -或-  接受的通訊端已繫結。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> 小於 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">已接受的 <see cref="T:System.Net.Sockets.Socket" /> 物件。 此值可為 <see langword="null" />。</param>
        <param name="receiveSize">要接收的最大位元組數。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>開始非同步作業以接收指定通訊端的連入連線嘗試，並接收用戶端應用程式傳送的第一個資料區塊。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 物件，參考非同步 <see cref="T:System.Net.Sockets.Socket" /> 物件建立。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法來以非同步方式處理傳入的連接嘗試。 以非同步方式接受連線，讓您能夠傳送和接收不同的執行緒中的資料。 這個多載可讓您指定的可接受通訊端`acceptSocket`參數。 如果這個參數是`null`，由可接受的通訊端<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 您可以指定要接受在初始中傳送的位元組數目`receiveSize`參數。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>接聽和內送連接要求排入佇列的方法。  
  
 您必須建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 若要這樣做，在非常小，您必須傳遞接聽<xref:System.Net.Sockets.Socket>物件<xref:System.Net.Sockets.Socket.BeginAccept%2A>透過`state`參數。 如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，透過`state`參數。  
  
 叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系統通常會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndAccept%2A>之前擷取暫止的連接。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 傳回新<xref:System.Net.Sockets.Socket>物件可用來傳送和接收資料的遠端主機。 您無法使用這個傳回<xref:System.Net.Sockets.Socket>接受連線佇列中的任何其他連線。 如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行原始的執行緒時。  
  
 系統可能也會使用呼叫執行緒來叫用回呼方法。 在此情況下，<xref:System.IAsyncResult.CompletedSynchronously%2A>屬性傳回<xref:System.IAsyncResult>設表示<xref:System.Net.Sockets.Socket.BeginAccept%2A>已同步完成的方法。  
  
 如需有關如何撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法呼叫。  後續呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
> [!NOTE]
>  您可以使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性傳回之<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼的物件。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會開啟通訊端，並接受非同步連接。 在此範例中，通訊端接受初始的 10 個位元組的資料和`acceptSocket`參數是`null`，可以強制<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法來建立可接受的通訊端。 接收的位元組數目和資料會顯示在主控台上的回呼委派。 請參閱<xref:System.Net.Sockets.Socket.BeginReceive%2A>的收到的剩餘資料的方式說明。  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">接受的通訊端並未接聽連線。 您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  -或-  接受的通訊端已繫結。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> 小於 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始遠端主機連接的非同步要求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">To be added.</param>
        <param name="end_point">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>開始遠端主機連接的非同步要求。</summary>
        <returns>參考非同步連接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法會啟動非同步要求，以連接至`remoteEP`參數。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.BeginConnect%2A>建立預設遠端主機。 連接或以非同步方式設定預設遠端主機可讓您傳送和接收不同的執行緒中的資料。  
  
 您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法。 在非常小，您必須傳遞<xref:System.Net.Sockets.Socket>至<xref:System.Net.Sockets.Socket.BeginConnect%2A>透過`state`參數。 如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>，以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，透過`state`參數。  
  
 叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndConnect%2A>直到<xref:System.Net.Sockets.Socket>順利連線，或擲回例外狀況。 如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A>。 在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行原始的執行緒時。 如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>和<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>與遠端主機通訊。 如果您呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，從指定的預設值以外的位址到達任何資料包都會被捨棄。 如果您想要設定預設遠端主機到廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>且設定為廣播`true`。 如果您不能<xref:System.Net.Sockets.Socket.BeginConnect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。 如果您使用無連接的通訊協定，服務提供者會指派本機網路位址和連接埠號碼直到您呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>或<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法一次所需的端點。  
  
 若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法呼叫。  後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  如果此通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束執行緒上呼叫。 這是基礎提供者的限制。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會起始非同步連接嘗試。  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address">遠端主機的 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">包含連線作業資訊的使用者定義物件。 作業完成時，這個物件會傳遞給 <c>requestCallback</c> 委派。</param>
        <summary>開始遠端主機連接的非同步要求。 此主機是由 <see cref="T:System.Net.IPAddress" /> 和連接埠號碼所指定。</summary>
        <returns>參考非同步連接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 一般而言，方法由叫用`requestCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Connect%2A>方法多載，或<xref:System.Net.Sockets.Socket.EndConnect%2A>。  
  
 若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法呼叫。  後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[非同步呼叫同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  如果此通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束執行緒上呼叫。 這是基礎提供者的限制。 也<xref:System.Net.EndPoint>也就是使用必須不同。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會起始非同步連接嘗試。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Sockets.Socket" /> 不在通訊端系列。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的長度為零。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses">至少一個 <see cref="T:System.Net.IPAddress" />，指定遠端主機。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">包含連線作業資訊的使用者定義物件。 作業完成時，這個物件會傳遞給 <c>requestCallback</c> 委派。</param>
        <summary>開始遠端主機連接的非同步要求。 主機是由 <see cref="T:System.Net.IPAddress" /> 陣列和通訊埠編號指定。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" />，其會參考非同步連接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 一般而言，方法由叫用`requestCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Connect%2A>方法多載。  
  
 若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法呼叫。  後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  如果此通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束執行緒上呼叫。 這是基礎提供者的限制。 也<xref:System.Net.EndPoint>也就是使用必須不同。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會起始非同步連接嘗試。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法對使用 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 的通訊端有效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的長度為零。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host">遠端主機的名稱。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">包含連線作業資訊的使用者定義物件。 作業完成時，這個物件會傳遞給 <c>requestCallback</c> 委派。</param>
        <summary>開始遠端主機連接的非同步要求。 此主機是由主機名稱和連接埠號碼指定。</summary>
        <returns>參考非同步連接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 一般而言，方法由叫用`requestCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Connect%2A>方法多載。  
  
 若要取消暫止呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時呼叫方法時，回呼提供給<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法呼叫。  後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[非同步呼叫同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  如果此通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束執行緒上呼叫。 這是基礎提供者的限制。 也<xref:System.Net.EndPoint>也就是使用必須不同。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會起始非同步連接嘗試。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果這個通訊端可以在關閉連接後重複使用，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>開始非同步要求，以中斷遠端端點的連接。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 物件，參考非同步作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，您可以呼叫<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>方法，以從遠端端點要求中斷連接。 如果`reuseSocket`是`true`，您可以重複使用的通訊端。  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>方法使用另一個執行緒來叫用指定的回呼方法。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>方法會封鎖直到暫止的中斷連線已完成。 如需有關如何撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立通訊端的非同步通訊，並將部分資料傳送至遠端主機。 當已傳送資料時，<xref:System.Net.Sockets.Socket.Shutdown%2A>呼叫來停止傳送和接收活動。 然後<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>呼叫來開始中斷連線要求。 當要求完成時，<xref:System.Net.Sockets.Socket.Connected%2A>屬性會查詢以測試是否已中斷連線通訊端。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義的物件，包含接收作業的相關資訊。 作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</param>
        <summary>開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 一般而言，方法由叫用`callback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode">
          <see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義的物件，包含接收作業的相關資訊。 作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</param>
        <summary>開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 一般而言，方法由叫用`callback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="offset">「緩衝區」<c></c>參數中要儲存已接收資料的以零起始的位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義的物件，包含接收作業的相關資訊。 作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</param>
        <summary>開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 一般而言，方法由叫用`callback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會開始以非同步方式接收的資料連接<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="offset">「緩衝區」<c></c>中存放已接收資料的位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義的物件，包含接收作業的相關資訊。 作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</param>
        <summary>開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 一般而言，方法由叫用`callback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="offset">「緩衝區」<c></c>參數中要儲存資料的以零起始的位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>開始從指定的網路裝置非同步接收資料。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法開始非同步讀取從遠端主機的 無連接的資料包。 呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法可讓您接收不同的執行緒中的資料。  
  
 您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法，透過`state`參數。  
  
 叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，系統會使用另一個執行緒來執行指定的回呼方法，它會封鎖在<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>直到<xref:System.Net.Sockets.Socket>擲回例外狀況或讀取資料。 如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 當您想要繼續執行原始的執行緒時，請在 T:System.Threading.ManualResetEvent 在回呼方法上呼叫 Set 方法。 如需有關如何撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，您必須明確繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，或<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 這個方法會讀取資料到`buffer`參數，以及擷取遠端裝載傳送資料的端點。 如需如何擷取此端點資訊，請參閱<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。 這個方法是最有用，如果您想要以非同步方式接收來自未知的主機或多部主機的 無連接的資料包。 在這些情況下，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>會讀取第一個收到的區域網路緩衝區中的加入佇列資料包。 如果您接收的資料包大於大小`buffer`、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法將會填滿`buffer`一樣多的訊息是盡可能，，並擲回與<xref:System.Net.Sockets.SocketException>。 如果您使用的不可靠的通訊協定，將會遺失過多的資料。 如果您使用可靠的通訊協定、 過多的資料會保留服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法夠大的緩衝區。  
  
 若要保證，應用程式應該明確繫結遠端主機端點便會永遠傳回<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，然後再呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法`optionLevel`參數設定為<xref:System.Net.Sockets.SocketOptionLevel.IP>或<xref:System.Net.Sockets.SocketOptionLevel.IPv6>適時`optionName`參數設定為<xref:System.Net.Sockets.SocketOptionName.PacketInformation>，而`optionValue`參數以啟用此選項，然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 否則，便可將不會傳回當寄件者已傳送的資料包的數字之前已呼叫收件者, 的遠端主機端點<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。  
  
 雖然<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>適用於無連接的通訊協定，您可以使用連線導向的通訊協定以及。 如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，或藉由呼叫接受連入連線要求<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法，然後再建立或接受連線，您會收到<xref:System.Net.Sockets.SocketException>。 您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 在任一情況下，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法將會忽略`remoteEP`參數，只接收來自已連接的資料或預設遠端主機。  
  
 使用連線導向的通訊端<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>會讀取位於最高達指定的位元組數目的資料量`size`參數。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會從遠端主機，以非同步方式接收無連接的資料包。  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  -或-  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="offset">「緩衝區」<c></c>參數中要儲存資料的以零起始的位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，表示資料的來源。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，開始以非同步方式接收指定之位元組數目的資料至資料緩衝區的指定位置，並儲存端點和封包資訊。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步接收作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>方法。 一般而言，方法由叫用`asyncCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖的作業完成之前，請使用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[非同步呼叫同步方法](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 這個方法會讀取資料到`buffer`參數，和擷取遠端裝載的端點從中傳送資料，以及收到的封包的相關資訊。 如需如何擷取此端點資訊，請參閱<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。 這個方法是最有用，如果您想要以非同步方式接收來自未知的主機或多部主機的 無連接的資料包。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  -或-  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您不先呼叫會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您傳送不同的執行緒中的資料。  
  
 您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果您的回呼需要詳細資訊，您可以建立小型類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。  
  
 叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。 如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 當您想要繼續執行原始的執行緒時，請在 T:System.Threading.ManualResetEvent 在回呼方法上呼叫 Set 方法。 如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 還是可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包無連接的通訊協定。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 是空的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode">
          <see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您不先呼叫會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您傳送不同的執行緒中的資料。  
  
 您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果您的回呼需要詳細資訊，您可以建立小型類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。  
  
 叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。 如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行原始的執行緒時。 如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 還是可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包無連接的通訊協定。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 是空的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</param>
        <param name="offset">「緩衝區」<c></c>參數中要開始傳送資料的以零起始的位置。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode">
          <see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您不先呼叫會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您傳送不同的執行緒中的資料。  
  
 您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果您的回呼需要詳細資訊，您可以建立小型類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。  
  
 叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。 如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 當您想要繼續執行原始的執行緒時，請在 T:System.Threading.ManualResetEvent 在回呼方法上呼叫 Set 方法。 如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 還是可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包無連接的通訊協定。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 小於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</param>
        <param name="offset">「緩衝區」<c></c>參數中要開始傳送資料的以零起始的位置。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您不先呼叫會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您傳送不同的執行緒中的資料。  
  
 您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果您的回呼需要詳細資訊，您可以建立小型類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。  
  
 叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。 如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 當您想要繼續執行原始的執行緒時，請在 T:System.Threading.ManualResetEvent 在回呼方法上呼叫 Set 方法。 如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 還是可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包無連接的通訊協定。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會開始以非同步方式將資料傳送至遠端主機。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 小於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將檔案以非同步方式傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">字串，包含要傳送之檔案的路徑和名稱。 這個參數可以是 <see langword="null" />。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 旗標，將檔案 <paramref name="fileName" /> 傳送至已連接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 物件。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 物件，表示非同步傳送。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載會將該檔案傳送`fileName`連線通訊端。 如果`fileName`是在本機目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案名稱。 使用萬用字元 (「...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。 如果檔案找不到，例外狀況<xref:System.IO.FileNotFoundException>就會擲回。  
  
 這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。 如需有關`TransmitFile`函式和其旗標，請參閱 MSDN Library 中的 Windows Sockets 文件。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>，<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 擲回例外狀況，如果您不先呼叫<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法可讓您傳送不同的執行緒中的檔案。  
  
 若要完成此作業，您可以建立所叫用回呼方法<xref:System.AsyncCallback>委派參數。 若要這樣做，請在最起碼`state`參數必須包含<xref:System.Net.Sockets.Socket>物件正在使用的通訊。 如果您的回呼需要詳細資訊，您可以建立類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。 傳遞至這個自訂物件的執行個體<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法，透過`state`參數。  
  
 叫用回呼方法必須<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndSendFile%2A>直到<xref:System.Net.Sockets.Socket>傳送整個檔案，或擲回例外狀況。 如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSendFile%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 無連接的通訊協定，您必須確定檔案的大小不會超過基礎的服務提供者的最大的封包。 如果是的話，不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSendFile%2A>會擲回<xref:System.Net.Sockets.SocketException>例外狀況。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會建立，並連接的非同步通訊的通訊端。 首先，「 text.txt"的檔案會非同步地傳送至遠端主機。 委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成傳輸。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.NotSupportedException">通訊端未連線至遠端主機。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">字串，包含要傳送之檔案的路徑和名稱。 這個參數可以是 <see langword="null" />。</param>
        <param name="preBuffer">包含傳送檔案前要傳送之資料的 <see cref="T:System.Byte" /> 陣列。 這個參數可以是 <see langword="null" />。</param>
        <param name="postBuffer">包含傳送檔案後要傳送之資料的 <see cref="T:System.Byte" /> 陣列。 這個參數可以是 <see langword="null" />。</param>
        <param name="flags">
          <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值的位元組合。</param>
        <param name="callback">這個作業完成時要叫用的 <see cref="T:System.AsyncCallback" /> 委派。 這個參數可以是 <see langword="null" />。</param>
        <param name="state">使用者定義的物件，包含這個要求的狀態資訊。 這個參數可以是 <see langword="null" />。</param>
        <summary>將檔案和資料緩衝區以非同步方式傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> 物件，表示非同步作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載都需要您想要傳送的檔案和的位元組合名稱<xref:System.Net.Sockets.TransmitFileOptions>值。 `preBuffer`參數會包含您想要位在檔案之前的任何資料。 `postBuffer` 包含您想要遵循之檔案的資料。 如果`fileName`是在本機目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案名稱。 使用萬用字元 (「...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。 如果檔案找不到，例外狀況<xref:System.IO.FileNotFoundException>就會擲回。  
  
 `flags`參數提供視窗通訊端服務提供者，以及其他資訊的檔案傳輸。 如需如何使用這個參數的詳細資訊，請參閱<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。 如需有關`TransmitFile`函式和其旗標，請參閱 MSDN Library 中的 Windows Sockets 文件。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 擲回例外狀況，如果您不先呼叫<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法可讓您傳送不同的執行緒中的檔案。  
  
 若要完成此作業，您可以建立所叫用回呼方法<xref:System.AsyncCallback>委派參數。 若要這樣做，請在最起碼`state`參數必須包含<xref:System.Net.Sockets.Socket>物件正在使用的通訊。 如果您的回呼需要詳細資訊，您可以建立類別或結構來保留<xref:System.Net.Sockets.Socket>以及其他必要的資訊。 傳遞至這個自訂物件的執行個體<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法，透過`state`參數。  
  
 叫用回呼方法必須<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndSendFile%2A>直到<xref:System.Net.Sockets.Socket>傳送整個檔案，或擲回例外狀況。 如需撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.BeginSendFile%2A>也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 您也必須確定檔案的大小不超過最大的封包大小基礎的服務提供者的無連接的通訊協定。 如果是的話，不會傳送資料包和<xref:System.Net.Sockets.Socket.BeginSendFile%2A>會擲回<xref:System.Net.Sockets.SocketException>例外狀況。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會建立連接的非同步通訊的通訊端並開始以非同步方式至遠端主機傳送檔案"text.txt"。 在此範例中，`preBuffer`和`postBuffer`的資料建立檔案與預設傳送<xref:System.Net.Sockets.TransmitFileOptions>會使用值。 委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成傳輸。  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.NotSupportedException">作業系統不是 Windows NT (含) 以後版本。  \- 或 -  通訊端未連線至遠端主機。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案 <paramref name="fileName" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</param>
        <param name="offset">「緩衝區」<c></c>中以零起始的位置，資料要在此處開始傳送。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，包含這個要求的狀態資訊。</param>
        <summary>以非同步方式將資料傳送至特定的遠端主機。</summary>
        <returns>參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法會啟動非同步傳送作業中指定遠端主機`remoteEP`參數。 呼叫<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法可讓您傳送不同的執行緒中的資料。 適用於無連接的通訊協定，雖然<xref:System.Net.Sockets.Socket.BeginSendTo%2A>無連線和連線導向的通訊協定的運作方式。  
  
 您可以建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果您的回呼需要詳細資訊，您可以建立可保留的小型類別<xref:System.Net.Sockets.Socket>，以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法，透過`state`參數。  
  
 叫用回呼方法應該<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSendTo%2A>，系統將使用不同的執行緒執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSendTo%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。 如果您想要封鎖您呼叫之後，原始執行緒<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 當您想要繼續執行原始的執行緒時，請在 T:System.Threading.ManualResetEvent 在回呼方法上呼叫 Set 方法。 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 如果您使用連線導向的通訊協定，您必須先呼叫<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，或<xref:System.Net.Sockets.Socket.BeginSendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 將會忽略`remoteEP`參數，並將傳送資料至<xref:System.Net.EndPoint>中建立<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。 您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`參數會覆寫指定的預設遠端主機，如，傳送作業只。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法。 在此情況下，基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。 如果您希望基礎的服務提供者，選取可用的通訊埠，請使用零的連接埠號碼。 如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法成功完成。  
  
 如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 -您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.EndSendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  （安全性內容、 模擬的使用者和呼叫的內容） 的執行內容會快取非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用之後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體和指定的回撥)，後續使用該內容會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例以非同步方式將資料傳送至指定的遠端主機。  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  -或-  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">要與 <see cref="T:System.Net.EndPoint" /> 關聯的本機 <see cref="T:System.Net.Sockets.Socket" />。</param>
        <summary>使 <see cref="T:System.Net.Sockets.Socket" /> 與本機端點建立關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，如果您需要使用特定的本機端點。 您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>才能呼叫<xref:System.Net.Sockets.Socket.Listen%2A>方法。 您不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前使用<xref:System.Net.Sockets.Socket.Connect%2A>方法除非您需要使用特定的本機端點。 您可以使用<xref:System.Net.Sockets.Socket.Bind%2A>無連線和連線導向的通訊協定上的方法。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.Bind%2A>，您必須先建立本機<xref:System.Net.IPEndPoint>從您要通訊的資料。 如果您並不在意哪些本機位址指派，您可以建立<xref:System.Net.IPEndPoint>使用<xref:System.Net.IPAddress.Any?displayProperty=nameWithType>位址參數，以及基礎的服務提供者會指派最適當的網路位址。 這有助於簡化您的應用程式，如果您有多個網路介面。 如果您並不在意哪些本機連接埠使用，您可以建立<xref:System.Net.IPEndPoint>使用連接埠號碼 0。 在此情況下，服務提供者會指派可用的通訊埠編號介於 1024年到 5000 之間。  
  
 如果您使用上述的方法，您可以探索哪些本機網路位址和通訊埠編號已被指派藉由呼叫<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>之後所做的呼叫，則不會傳回在本機指派的網路位址，直到<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 如果您使用無連接的通訊協定，您不會存取此資訊之前，您已經完成傳送或接收。  
  
 如果想要接收介面資訊上收到的封包的 UDP 通訊端<xref:System.Net.Sockets.Socket.SetSocketOption%2A>通訊端選項設為應該明確地呼叫方法<xref:System.Net.Sockets.SocketOptionName.PacketInformation>後立即呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法。  
  
> [!NOTE]
>  如果您想要接收多點傳送的資料包，您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>多點傳送連接埠號碼的方法。  
  
> [!NOTE]
>  您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，如果您想要接收無連接的資料包使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>呼叫時<xref:System.Net.Sockets.Socket.Bind%2A>方法，請使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例繫結<xref:System.Net.Sockets.Socket>使用指定的本機端點。  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自所定義的主機連接的<paramref name="localEP" />。 相關聯的列舉型別： <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出 <see cref="T:System.Net.Sockets.Socket" /> 是否處於區塊模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 可區塊化，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A>屬性會指出是否<xref:System.Net.Sockets.Socket>處於封鎖模式。  
  
 如果您封鎖模式中，而使方法呼叫它不會立即完成，您的應用程式將會封鎖執行，直到完成要求的作業。 如果您想要繼續，即使未完成要求的作業、 變更執行<xref:System.Net.Sockets.Socket.Blocking%2A>屬性`false`。 <xref:System.Net.Sockets.Socket.Blocking%2A>屬性具有非同步方法沒有作用。 如果您是傳送和接收資料，以非同步方式，而且想要封鎖執行，使用<xref:System.Threading.ManualResetEvent>類別。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，藉由呼叫一個 <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> 方法來要求與遠端主機連接。</param>
        <summary>取消遠端主機連接的非同步要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A>方法會取消遠端主機連接的非同步要求。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 參數不可為 null，而且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 也不可為 null。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>關閉 <see cref="T:System.Net.Sockets.Socket" /> 連接並釋放所有相關資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉 <see cref="T:System.Net.Sockets.Socket" /> 連接並釋放所有相關資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>方法關閉遠端主機連接，並釋放所有 managed 和 unmanaged 資源相關聯<xref:System.Net.Sockets.Socket>。 在關閉時<xref:System.Net.Sockets.Socket.Connected%2A>屬性設定為`false`。  
  
 如需連線導向的通訊協定，建議您呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。 這可確保所有資料都傳送及接收連線的通訊端上之前它已關閉。  
  
 如果您需要呼叫<xref:System.Net.Sockets.Socket.Close%2A>情況下先呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，您可以確保資料佇列的傳出傳輸將傳送藉由設定<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>選項設定為`false`並指定非零逾時間隔。 <xref:System.Net.Sockets.Socket.Close%2A> 然後會封鎖直到這項資料會傳送，或直到指定的逾時過期為止。 如果您設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>至`false`並指定為零的逾時間隔，<xref:System.Net.Sockets.Socket.Close%2A>釋放連接，並會自動捨棄傳出佇列的資料。  
  
> [!NOTE]
>  若要設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項`false`，建立<xref:System.Net.Sockets.LingerOption>，enabled 的屬性設定為`true`，並設定<xref:System.Net.Sockets.LingerOption.LingerTime%2A>屬性所需的逾時期間。 使用此<xref:System.Net.Sockets.LingerOption>連同<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項來呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會關閉<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">最多等候 <c>timeout</c> 秒以傳送任何剩餘的資料，然後關閉通訊端。</param>
        <summary>關閉 <see cref="T:System.Net.Sockets.Socket" /> 連線，並釋放所有具指定逾時的關聯資源，以允許傳送佇列的資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>方法關閉遠端主機連接，並釋放所有 managed 和 unmanaged 資源相關聯<xref:System.Net.Sockets.Socket>。 在關閉時<xref:System.Net.Sockets.Socket.Connected%2A>屬性設定為`false`。  
  
 如需連線導向的通訊協定，建議您呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Close%2A>。 這可確保所有資料都傳送及接收連線的通訊端上之前它已關閉。  
  
 如果您需要呼叫<xref:System.Net.Sockets.Socket.Close%2A>情況下先呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，您可以確保資料佇列的傳出傳輸將傳送藉由設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>選項設定為`false`並指定非零逾時間隔。 <xref:System.Net.Sockets.Socket.Close%2A> 然後會封鎖直到這項資料會傳送，或直到指定的逾時過期為止。 如果您設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>至`false`並指定為零的逾時間隔，<xref:System.Net.Sockets.Socket.Close%2A>釋放連接，並會自動捨棄傳出佇列的資料。  
  
> [!NOTE]
>  若要設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項`false`，建立<xref:System.Net.Sockets.LingerOption>，enabled 的屬性設定為`true`，並設定<xref:System.Net.Sockets.LingerOption.LingerTime%2A>所需的逾時期限的屬性。 使用此<xref:System.Net.Sockets.LingerOption>連同<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項來呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何關閉<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立與遠端主機的連線。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">代表遠端裝置的 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>建立與遠端主機的連線。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，例如 TCP、<xref:System.Net.Sockets.Socket.Connect%2A>方法同步網路之間建立連接，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端端點。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。 在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>，您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>以同步方式與遠端主機通訊。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，從指定的預設值以外的位址到達任何資料包都會被捨棄。 如果您想要設定預設遠端主機到廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>方法將會封鎖，除非您特別設定<xref:System.Net.Sockets.Socket.Blocking%2A>屬性`false`之前呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。 如果您要使用連線導向的通訊協定，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連接。 因為它們只是建立預設遠端主機，不需連線的通訊協定不會擲回例外狀況。 您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。 如果 WSAEWOULDBLOCK 傳回的錯誤，遠端主機連接已起始連線導向<xref:System.Net.Sockets.Socket>，但並未尚未順利完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。  
  
> [!NOTE]
>  如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會指派本機網路位址和通訊埠編號。 如果您使用無連接的通訊協定，服務提供者會指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。  
  
> [!NOTE]
>  如果通訊端具有先前中斷連線，然後您就無法使用這個方法還原連接。 使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以重新連線。 這是基礎提供者的限制。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會連接到遠端端點，然後驗證該連接。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</exception>
        <permission cref="T:System.Net.SocketPermission">用於連接至遠端主機。 相關聯的列舉型別： <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">遠端主機的 IP 位址。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <summary>建立與遠端主機的連線。 此主機是由 IP 位址和連接埠號碼所指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，例如 TCP、<xref:System.Net.Sockets.Socket.Connect%2A>方法同步網路之間建立連接，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端端點。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。 在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>以同步方式與遠端主機通訊。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>從指定的預設值以外的位址到達任何資料包都會被捨棄。 如果您想要設定預設遠端主機到廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法會封鎖，除非您特別設定<xref:System.Net.Sockets.Socket.Blocking%2A>屬性`false`之前呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。 如果您要使用連線導向的通訊協定，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連接。 因為它們只是建立預設遠端主機，不需連線的通訊協定不會擲回例外狀況。 您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。 如果 WSAEWOULDBLOCK 傳回的錯誤，遠端主機連接已起始連線導向<xref:System.Net.Sockets.Socket>，但並未尚未順利完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。  
  
> [!NOTE]
>  如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會指派本機網路位址和通訊埠編號。 如果您使用無連接的通訊協定，服務提供者會指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。  
  
> [!NOTE]
>  如果通訊端具有先前中斷連線，然後您就無法使用這個方法還原連接。 使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以重新連線。 這是基礎提供者的限制。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會連接到遠端端點，然後驗證該連接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的長度為零。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">遠端主機的 IP 位址。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <summary>建立與遠端主機的連線。 主機是由 IP 位址陣列和連接埠號碼所指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法通常用來呼叫之後立即<xref:System.Net.Dns.GetHostAddresses%2A>，其可以傳回多個 IP 位址的單一主機。 如果您使用連線導向的通訊協定，例如 TCP、<xref:System.Net.Sockets.Socket.Connect%2A>方法同步網路之間建立連接，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端端點。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。 在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>以同步方式與遠端主機通訊。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>從指定的預設值以外的位址到達任何資料包都會被捨棄。 如果您想要設定預設遠端主機到廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法會封鎖，除非您特別設定<xref:System.Net.Sockets.Socket.Blocking%2A>屬性`false`之前呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。 如果您要使用連線導向的通訊協定，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連接。 因為它們只是建立預設遠端主機，不需連線的通訊協定不會擲回例外狀況。 您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。 如果 WSAEWOULDBLOCK 傳回的錯誤，遠端主機連接已起始連線導向<xref:System.Net.Sockets.Socket>，但並未尚未順利完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。  
  
> [!NOTE]
>  如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會指派本機網路位址和通訊埠編號。 如果您使用無連接的通訊協定，服務提供者會指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。  
  
> [!NOTE]
>  如果通訊端具有先前中斷連線，然後您就無法使用這個方法還原連接。 使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以重新連線。 這是基礎提供者的限制。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會連接到遠端端點，然後驗證該連接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> 的長度為零。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">遠端主機的名稱。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <summary>建立與遠端主機的連線。 此主機是由主機名稱和連接埠號碼指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，例如 TCP、<xref:System.Net.Sockets.Socket.Connect%2A>方法同步網路之間建立連接，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端主機。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。 在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>以同步方式與遠端主機通訊。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>從指定的預設值以外的位址到達任何資料包都會被捨棄。 如果您想要設定預設遠端主機到廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法會封鎖，除非您特別設定<xref:System.Net.Sockets.Socket.Blocking%2A>屬性`false`之前呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。 如果您要使用連線導向的通訊協定，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連接。 因為它們只是建立預設遠端主機，不需連線的通訊協定不會擲回例外狀況。 您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。 如果 WSAEWOULDBLOCK 傳回的錯誤，遠端主機連接已起始連線導向<xref:System.Net.Sockets.Socket>，但並未尚未順利完成。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。  
  
 如果已啟用 IPv6 和<xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29>呼叫方法來連線到主機解析為這兩個 IPv6 和 IPv4 位址，來嘗試連接到 IPv6 位址將會先的 IPv4 位址。 這可能會有延遲的時間來建立連接，如果主機並未接聽 IPv6 位址的效果。  
  
> [!NOTE]
>  如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會指派本機網路位址和通訊埠編號。 如果您使用無連接的通訊協定，服務提供者會指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。  
  
> [!NOTE]
>  如果通訊端具有先前中斷連線，然後您就無法使用這個方法還原連接。 使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以重新連線。 這是基礎提供者的限制。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會連接到遠端端點，然後驗證該連接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始與遠端主機連接的非同步要求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始與遠端主機連接的非同步要求。</summary>
        <returns>如果 I/O 作業暫止，則傳回 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 作業同步完成，則傳回 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會啟動遠端主機連接的非同步要求。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>建立預設遠端主機。  
  
 若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並附加至回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性<xref:System.Net.IPEndPoint>連線至遠端主機。  
  
 呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，如此將可在回呼方法中擷取資訊。 如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。  
  
 如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendToAsync%2A>和<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>與遠端主機通訊。 如果您呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，從指定的預設值以外的位址到達任何資料包都會被捨棄。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法一次所需的端點。  
  
 如果您想要設定預設遠端主機的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>且設定為廣播`true`。 如果不這麼做，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件所需：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （選擇性） 緩衝區可能會提供其會以不可分割方式之後通訊端上傳送<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在此情況下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>屬性必須設為包含資料的緩衝區，才能傳送和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性必須設定以傳送緩衝區中的資料位元組數。 一旦建立連接之後，會傳送此緩衝區的資料。  
  
 如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。  
  
 如果您使用無連接的通訊協定，服務提供者會指派本機網路 IP 位址和連接埠號碼直到您呼叫<xref:System.Net.Sockets.Socket.SendAsync%2A>或<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.NotSupportedException>如果的位址系列<xref:System.Net.Sockets.Socket>和<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>不相同的位址系列。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>呼叫此方法時，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引數無效。 如果指定多個緩衝區而 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性不是 null，就會發生這個例外狀況。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 參數不可為 null，而且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 也不可為 null。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 正在接聽，或是通訊端作業正在進行並且使用 <paramref name="e" /> 參數所指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。 如果本機端點和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是同一個通訊協定家族 (Family)，也會發生這個例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</param>
        <param name="protocolType">其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</param>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始與遠端主機連接的非同步要求。</summary>
        <returns>如果 I/O 作業暫止，則傳回 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 作業同步完成，則傳回 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) 方法開始的非同步要求連接至遠端主機。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>建立預設遠端主機所指定`socketType`和`protocolType`參數。  
  
 若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並附加至回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性<xref:System.Net.IPEndPoint>連線至遠端主機。  
  
 呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，如此將可在回呼方法中擷取資訊。 如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。  
  
 如果您使用無連接的通訊協定，例如 UDP，您不必呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendToAsync%2A>和<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>與遠端主機通訊。 如果您呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，從指定的預設值以外的位址到達任何資料包都會被捨棄。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法一次所需的端點。  
  
 如果您想要設定預設遠端主機的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>且設定為廣播`true`。 如果不這麼做，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件所需：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （選擇性） 緩衝區可能會提供其會以不可分割方式之後通訊端上傳送<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在此情況下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>屬性必須設為包含資料的緩衝區，才能傳送和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性必須設定以傳送緩衝區中的資料位元組數。 一旦建立連接之後，會傳送此緩衝區的資料。  
  
 如果您使用連線導向的通訊協定並沒有呼叫<xref:System.Net.Sockets.Socket.Bind%2A>之前先呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。  
  
 如果您使用無連接的通訊協定，服務提供者會指派本機網路 IP 位址和連接埠號碼直到您呼叫<xref:System.Net.Sockets.Socket.SendAsync%2A>或<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.NotSupportedException>如果的位址系列<xref:System.Net.Sockets.Socket>和<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>不相同的位址系列。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>呼叫此方法時，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引數無效。 如果指定多個緩衝區而 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性不是 null，就會發生這個例外狀況。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 參數不可為 null，而且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 也不可為 null。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 正在接聽，或是通訊端作業正在進行並且使用 <paramref name="e" /> 參數所指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。 如果本機端點和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是同一個通訊協定家族 (Family)，也會發生這個例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出上一個 <see cref="T:System.Net.Sockets.Socket" /> 或 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 作業是否將 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 連接至遠端主機。</summary>
        <value>如果最近一次的作業是將 <see cref="T:System.Net.Sockets.Socket" /> 連接到遠端資源，則為 <see langword="true" />，否則，即為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected`屬性取得的連接狀態<xref:System.Net.Sockets.Socket>最後一次的 I/O 作業。 當它傳回`false`、<xref:System.Net.Sockets.Socket>可能永遠不會連線，或已中斷連線。  
  
 值<xref:System.Net.Sockets.Socket.Connected%2A>屬性會反映最新的作業連接的狀態。 如果您需要判斷目前的連接狀態，請呼叫未封鎖、 零位元組傳送。 如果呼叫成功傳回，或是擲回 WAEWOULDBLOCK 錯誤程式碼 (10035)，是仍然會連接通訊端。否則，通訊端已中斷連線。  
  
 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>使用者資料包通訊協定 (UDP) 通訊端上<xref:System.Net.Sockets.Socket.Connected%2A>屬性一律會傳回`true`; 不過，此動作不會變更 UDP 固有無連線性質。  
  
   
  
## Examples  
 下列程式碼範例會連接到遠端端點，檢查<xref:System.Net.Sockets.Socket.Connected%2A>屬性，並檢查連接的目前狀態。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果這個通訊端可以在關閉目前連線後重複使用，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>關閉通訊端連線並允許重複使用通訊端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，您可以使用這個方法，以關閉通訊端。 這個方法會結束連接與集<xref:System.Net.Sockets.Socket.Connected%2A>屬性`false`。 不過，如果`reuseSocket`是`true`，您可以重複使用的通訊端。  
  
 若要確保所有資料都傳送及接收通訊端關閉之前，您應該呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>之前先呼叫<xref:System.Net.Sockets.Socket.Disconnect%2A>方法。  
  
 如果您需要呼叫<xref:System.Net.Sockets.Socket.Disconnect%2A>情況下先呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，您可以設定<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>選項設定為`false`並指定非零的逾時間隔，以確保資料佇列的傳出傳輸傳送。 <xref:System.Net.Sockets.Socket.Disconnect%2A> 然後會封鎖直到傳送資料，或直到指定的逾時過期為止。 如果您設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>至`false`並指定為零的逾時間隔，<xref:System.Net.Sockets.Socket.Close%2A>釋放連接，並會自動捨棄傳出佇列的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立同步通訊的通訊端，並將部分資料傳送至遠端主機。 然後它會呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，以停止傳送並接收活動，以及<xref:System.Net.Sockets.Socket.Disconnect%2A>以關閉通訊端連線。  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">這個方法需要 Windows 2000 (含) 以前版本，否則會擲回例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始非同步要求，以中斷遠端端點的連接。</summary>
        <returns>如果 I/O 作業暫止，則傳回 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 作業同步完成，則傳回 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用連線導向的通訊協定，當呼叫<xref:System.Net.Sockets.Socket.DisconnectAsync%2A>方法會要求中斷連線從遠端端點。 如果您設定<xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType>至`true`中`e`參數時，通訊端可以重複使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> 參數不可以是 null。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 <see cref="T:System.Net.Sockets.Socket" /> 類別目前的執行個體所使用的資源全部釋出。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將 <see cref="T:System.Net.Sockets.Socket" /> 類別目前的執行個體所使用的資源全部釋出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dispose` 使用完畢時，請呼叫 <xref:System.Net.Sockets.Socket>。 `Dispose` 方法會將 <xref:System.Net.Sockets.Socket> 保留在無法使用的狀態。 在呼叫`Dispose`，您必須釋放所有參考<xref:System.Net.Sockets.Socket>讓記憶體回收行程可以回收記憶體的<xref:System.Net.Sockets.Socket>所佔用。  
  
 如需詳細資訊，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)和[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  在您釋放最後一個 `Dispose` 參考之前，請務必呼叫 <xref:System.Net.Sockets.Socket>。 否則工作窗格所使用的資源不會釋放，直到記憶體回收行程呼叫 <xref:System.Net.Sockets.Socket> 物件的 `Finalize` 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示會同時釋放 Managed 和 Unmanaged 資源；<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.Net.Sockets.Socket" /> 所使用的 Unmanaged 資源，並選擇性處置 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose()` 叫用受保護`Dispose(Boolean)`方法`disposing`參數設定為`true`。 <xref:System.Object.Finalize%2A> 叫用`Dispose`與`disposing`設`false`。  
  
 `disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.Net.Sockets.Socket> 參考的任何 Managed 物件所掌握的資源。 這個方法會叫用每個參考物件的 `Dispose()` 方法。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 可以被其他物件呼叫多次。覆寫 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> 時，請小心不要參考到先前已在對 <see langword="Dispose" /> 的早期呼叫中被處置 (Dispose) 的物件。如需有關如何實作<see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />，請參閱 [實作 Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md)。如需有關<see langword="Dispose" />和<see cref="M:System.Object.Finalize" />，請參閱 [清理 Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) 上和 [覆寫 Finalize 方法] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否允許將網際網路通訊協定 (IP) 資料包分散。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允許資料包分散，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 資料包需要片段，其大小超過最大傳輸單位 (MTU) 的傳輸媒介時。 傳送主控件 （所有的網際網路通訊協定版本） 或中繼路由器 (Internet Protocol Version 4 只) 可能分段資料包。 如果必須分散資料包 (datagram)，而<xref:System.Net.Sockets.Socket.DontFragment%2A>選項設定，資料包作業會捨棄，並且傳回給寄件者的資料包傳送網際網路控制訊息通訊協定 (ICMP) 錯誤訊息。  
  
 傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會有任何作用。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.DontFragment%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">這個屬性只可為 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 家族中的通訊端設定。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否為適用於 IPv4 和 IPv6 的雙重模式通訊端。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 是雙重模式通訊端，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">建立重複通訊端參考的目標處理序 ID。</param>
        <summary>複製目標處理序的通訊端參考，並關閉這個處理序的通訊端。</summary>
        <returns>要傳遞至目標處理序的通訊端參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目標處理序應使用<xref:System.Net.Sockets.Socket.%23ctor%2A>建立重複的通訊端執行個體。  
  
 如果您呼叫<xref:System.Net.Sockets.Socket.%23ctor%2A>多次包含相同的位元組陣列，為每個呼叫的引數的建構函式，您將建立受管理的多個<xref:System.Net.Sockets.Socket>具有相同的基礎通訊端的執行個體。 這種做法不鼓勵。  
  
 如果處理程序建立通訊端會使用非同步方法 (<xref:System.Net.Sockets.Socket.BeginReceive%2A>或<xref:System.Net.Sockets.Socket.BeginSend%2A>)，必須先設定處理程序<xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A>屬性設為 true，否則繫結至所建立的處理序，可能會造成完成通訊埠的通訊端<xref:System.ArgumentNullException>上目標處理序擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="targetProcessID" /> 不是有效的處理序識別碼。-或-  複製通訊端參考失敗。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否可以傳送或接收廣播封包。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允許廣播封包，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 廣播限制為特定的子網路，而且必須使用使用者資料包通訊協定 (UDP)。針對網際網路通訊協定第 4 版，您可以廣播給您本機子網路封包傳送為 255.255.255.255。或者，您可以使用導向的廣播的位址，也就是使用中的主機部分設定的所有位元的網際網路通訊協定 (IP) 位址的網路部分。 例如，如果您的 IP 位址為 192.168.1.40 （類別 C 位址，與網路遮罩為 255.255.255.0 的網路部分是的前三個八位元及主機部分是最後一個八位元） 導向的廣播的位址為 192.168.1.255。  
  
 傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會有任何作用。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.EnableBroadcast%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">這個選項只對資料包通訊端有效。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同步接受連入連線嘗試。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，包含已傳輸的位元組。</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊以及任何使用者定義的資料。</param>
        <summary>以非同步方式接受連入連線嘗試，並建立新的 <see cref="T:System.Net.Sockets.Socket" /> 物件，以處理遠端主機通訊。 這個方法會傳回包含已傳輸之初始資料的緩衝區。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> 物件，可處理與遠端主機的通訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，您必須建立回呼方法所叫用<xref:System.AsyncCallback>委派。 這個回呼方法會在個別的執行緒中執行，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法會傳回。  
  
 在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>順利完成連接嘗試的方法。 `buffer`的這個多載的參數包含資料的呼叫中收到<xref:System.Net.Sockets.Socket.BeginAccept%2A>和`bytesTransferred`參數會包含在呼叫中已傳送的位元組數目。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法會封鎖，直到連接已暫止的連入連線佇列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受連入連線，並傳回新<xref:System.Net.Sockets.Socket>，可以用來傳送和接收來自遠端主機的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>即可建立和連線通訊端並接受初始的 10 個位元組的資料。 委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndAccept%2A>來結束非同步的要求。 傳送的位元組數和資料會傳回`buffer`和`bytesTransferred`參數，這個方法會顯示在主控台上。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 是空的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不是由呼叫 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的方式所建立。</exception>
        <exception cref="T:System.InvalidOperationException">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生錯誤</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>以非同步方式接受連入的連接嘗試，並建立新的 <see cref="T:System.Net.Sockets.Socket" /> 來處理遠端主機通訊。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" />，將處理與遠端主機的通訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。 這個回呼方法會在個別的執行緒中執行，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法會傳回。 它必須接受`asyncResult`參數所傳回的<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>順利完成連接嘗試的方法。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法會封鎖，直到連接已暫止的連入連線佇列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受連入連線，並傳回新<xref:System.Net.Sockets.Socket>，可以用來傳送和接收來自遠端主機的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會結束的非同步要求，並建立新<xref:System.Net.Sockets.Socket>接受連入連線要求。 如需示範如何透過通訊端的非同步通訊的完整範例，請參閱[通訊端程式碼範例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不是由呼叫 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的方式所建立。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 如需詳細資訊，請參閱＜備註＞一節。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，包含已傳輸的位元組。</param>
        <param name="bytesTransferred">已傳輸的位元組數。</param>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊以及任何使用者定義的資料。</param>
        <summary>以非同步方式接受連入連線嘗試，並建立新的 <see cref="T:System.Net.Sockets.Socket" /> 物件，以處理遠端主機通訊。 這個方法會傳回包含已傳輸之初始資料和位元組數的緩衝區。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> 物件，可處理與遠端主機的通訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，您必須建立回呼方法所叫用<xref:System.AsyncCallback>委派。 這個回呼方法會在個別的執行緒中執行，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法會傳回。 它必須接受`asyncResult`參數所傳回的<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>順利完成連接嘗試的方法。 `buffer`的這個多載的參數包含資料的呼叫中收到<xref:System.Net.Sockets.Socket.BeginAccept%2A>和`bytesTransferred`參數會包含在呼叫中已傳送的位元組數目。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法會封鎖，直到連接已暫止的連入連線佇列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法接受連入連線，並傳回新<xref:System.Net.Sockets.Socket>，可以用來傳送和接收來自遠端主機的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>即可建立和連線通訊端並接受初始的 10 個位元組的資料。 委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndAccept%2A>來結束非同步的要求。 傳送的位元組數和資料會傳回`buffer`和`bytesTransferred`參數，這個方法會顯示在主控台上。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 是空的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不是由呼叫 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的方式所建立。</exception>
        <exception cref="T:System.InvalidOperationException">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>結束擱置的非同步連接要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> 完成非同步的遠端主機連接要求的封鎖方法以啟動<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。 不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginConnect%2A>做為參數的方法。  
  
 在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>順利完成連接嘗試的方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會結束非同步的連接嘗試。 如需示範如何透過通訊端的非同步通訊的完整範例，請參閱[通訊端程式碼範例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> 是先前用來呼叫非同步連接。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊以及任何使用者定義的資料。</param>
        <summary>結束暫止非同步中斷連接要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>方法會封鎖，直到完成中斷連線為止。 如需非同步作業的資訊，請參閱 MSDN library 中的非同步程式設計的概觀主題。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立通訊端的非同步通訊，並將部分資料傳送至遠端主機。 當已傳送資料時，<xref:System.Net.Sockets.Socket.Shutdown%2A>呼叫來停止傳送和接收活動。 然後<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>呼叫來開始中斷連線要求。 委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndDisconnect%2A>來結束非同步的要求。 當要求完成時，<xref:System.Net.Sockets.Socket.Connected%2A>屬性會查詢以測試是否已中斷連線通訊端。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> 是先前用來呼叫非同步連接。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.Net.WebException">中斷連接要求已逾時。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>結束擱置的非同步讀取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>結束擱置的非同步讀取。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成非同步的讀取的作業，以啟動<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。 不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginReceive%2A>做為參數的方法。  
  
 在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>取得狀態物件傳遞至<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 擷取接收<xref:System.Net.Sockets.Socket>從這個狀態物件。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法已成功完成讀取的作業，並傳回讀取的位元組數目。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法將會封鎖直到資料為止。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>會讀取內送的網路緩衝區中有可用的第一個加入佇列資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會讀取使用最多為您所指定的位元組數目的資料量`size`參數<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會立即完成，並傳回零個位元組。  
  
 若要取得已接收的資料，請呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>，然後將解壓縮所產生的狀態物件中包含的緩衝區。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會暫止的非同步讀取。 如需示範如何透過通訊端的非同步通訊的完整範例，請參閱[通訊端程式碼範例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <param name="errorCode">
          <see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>結束擱置的非同步讀取。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成非同步的讀取的作業，以啟動<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。 不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginReceive%2A>做為參數的方法。  
  
 在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>取得狀態物件傳遞至<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 擷取接收<xref:System.Net.Sockets.Socket>從這個狀態物件。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法已成功完成讀取的作業，並傳回讀取的位元組數目。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法將會封鎖直到資料為止。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>會讀取內送的網路緩衝區中有可用的第一個加入佇列資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會讀取使用最多為您所指定的位元組數目的資料量`size`參數<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會立即完成，並傳回零個位元組。  
  
 若要取得已接收的資料，請呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>，然後將解壓縮所產生的狀態物件中包含的緩衝區。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <param name="endPoint">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary>從指定的端點結束暫止的非同步讀取。</summary>
        <returns>如果成功，則傳回接收的位元組數目。 如果不成功，則傳回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法完成非同步的讀取的作業，以啟動<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。 不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>做為參數的方法。  
  
 在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>取得狀態物件傳遞至<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 擷取接收<xref:System.Net.Sockets.Socket>從這個狀態物件。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法已成功完成讀取的作業，並傳回讀取的位元組數目。  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法將會封鎖直到資料為止。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>會讀取內送的網路緩衝區中有可用的第一個加入佇列資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法會讀取使用最多為您所指定的位元組數目的資料量`size`參數<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法會立即完成，並傳回零個位元組。 若要取得已接收的資料，請呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>物件，並擷取產生的狀態物件中包含的緩衝區。 若要識別原始主機，請解壓縮<xref:System.Net.EndPoint>並將其轉換<xref:System.Net.IPEndPoint>。 使用<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法，以取得 IP 位址和<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法，以取得連接埠號碼。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會暫止的非同步讀取從特定<xref:System.Net.EndPoint>。  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <param name="socketFlags">接收封包之 <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="endPoint">來源 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">接收之封包的 <see cref="T:System.Net.IPAddress" /> 和介面。</param>
        <summary>從指定的端點結束暫止的非同步讀取。 這個方法還會比 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> 提供更多的封包資訊。</summary>
        <returns>如果成功，則傳回接收的位元組數目。 如果不成功，則傳回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果作業尚未完成，這個方法會封鎖，直到它執行。  
  
 若要以同步方式執行這項作業，使用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 檢查`ipPacketInformation`如果您需要知道資料包使用單點傳播、 多點傳送或廣播位址來傳送。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />  -或-  <paramref name="endPoint" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>結束暫止的非同步傳送。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>結束暫止的非同步傳送。</summary>
        <returns>如果成功，則將位元組數目傳送至 <see cref="T:System.Net.Sockets.Socket" />，否則，則產生一個無效的 <see cref="T:System.Net.Sockets.Socket" /> 錯誤。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成非同步傳送作業啟動<xref:System.Net.Sockets.Socket.BeginSend%2A>。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。 不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginSend%2A>做為參數的方法。  
  
 在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數來取得傳送<xref:System.Net.Sockets.Socket>。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSend%2A>方法已成功完成傳送作業並傳回傳送的位元組數目。  
  
 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>會阻擋，直到傳送資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>會阻擋，直到緩衝區的某些訊息已傳送。 如果傳回的值從<xref:System.Net.Sockets.Socket.EndSend%2A>表示緩衝區無法完全傳送時，呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法一次，修改要保存未傳送的資料的緩衝區。  
  
 沒有保證您傳送的資料就會立即出現在網路。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.BeginSend%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會結束暫止的非同步傳送。  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步傳送呼叫 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" />，存放這個非同步作業的狀態資訊。</param>
        <param name="errorCode">
          <see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>結束暫止的非同步傳送。</summary>
        <returns>如果成功，則將位元組數目傳送至 <see cref="T:System.Net.Sockets.Socket" />，否則，則產生一個無效的 <see cref="T:System.Net.Sockets.Socket" /> 錯誤。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成非同步傳送作業啟動<xref:System.Net.Sockets.Socket.BeginSend%2A>。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。 不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginSend%2A>做為參數的方法。  
  
 在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數來取得傳送<xref:System.Net.Sockets.Socket>。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSend%2A>方法已成功完成傳送作業並傳回傳送的位元組數目。  
  
 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>會阻擋，直到傳送資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>會阻擋，直到緩衝區的某些訊息已傳送。 如果傳回的值從<xref:System.Net.Sockets.Socket.EndSend%2A>表示緩衝區無法完全傳送時，呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法一次，修改要保存未傳送的資料的緩衝區。  
  
 沒有保證您傳送的資料就會立即出現在網路。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.BeginSend%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  該執行緒結束時，會取消給定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步傳送呼叫 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊。</param>
        <summary>結束檔案的暫止非同步傳送。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 完成非同步傳送作業啟動<xref:System.Net.Sockets.Socket.BeginSendFile%2A>。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，您必須建立實作的回呼方法<xref:System.AsyncCallback>委派。 不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>所傳回物件<xref:System.Net.Sockets.Socket.BeginSendFile%2A>做為參數的方法。  
  
 在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數來取得傳送<xref:System.Net.Sockets.Socket>。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSendFile%2A>順利完成傳送作業的方法。  
  
 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSendFile%2A>封鎖，直到傳送資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSendFile%2A>封鎖，直到整個檔案傳送。 沒有保證您傳送的資料就會立即出現在網路。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立連接的非同步通訊的通訊端並開始以非同步方式至遠端主機傳送檔案"text.txt"。 委派會呼叫回呼<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成傳輸。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 是空的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> 用於非同步 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>結束暫止的非同步傳送至指定的位置。</summary>
        <returns>如果成功，則傳送位元組數目，否則，則產生一個無效的 <see cref="T:System.Net.Sockets.Socket" /> 錯誤。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 完成非同步傳送作業啟動<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginSendTo%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。 不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>傳回<xref:System.Net.Sockets.Socket.BeginSendTo%2A>做為參數的方法。  
  
 在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數來取得傳送<xref:System.Net.Sockets.Socket>。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法已成功完成傳送作業並傳回傳送的位元組數目。  
  
 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSendTo%2A>會阻擋，直到傳送資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSendTo%2A>會阻擋，直到傳送要求的位元組數目。 沒有保證您傳送的資料就會立即出現在網路。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會結束非同步傳送至特定位置。  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步傳送呼叫 <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否只允許一個處理序繫結至通訊埠。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 只允許一個通訊端繫結至特定通訊埠，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是<see langword="true" />為 Windows Server 2003 和 Windows XP Service Pack 2 和<see langword="false" />對於所有其他版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>是`false`，可以使用多個通訊端<xref:System.Net.Sockets.Socket.Bind%2A>繫結至特定的連接埠的方法，不過只有其中一個通訊端可以執行網路流量傳送至連接埠的作業。 如果多個通訊端嘗試使用<xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29>方法來將繫結至特定的連接埠，然後更特定的 IP 位址，一個會處理傳送至該通訊埠的網路流量。  
  
 如果<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>是`true`，第一次使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，以嘗試繫結至特定的連接埠，不論網際網路通訊協定 (IP) 位址，將會成功，則會使用所有後續的<xref:System.Net.Sockets.Socket.Bind%2A>會嘗試將該連接埠繫結的方法失敗，直到原始的繫結通訊端被終結。  
  
 這個屬性必須先設定<xref:System.Net.Sockets.Socket.Bind%2A>呼叫; 否則為<xref:System.InvalidOperationException>就會擲回。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">已為這個 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 呼叫 <see cref="T:System.Net.Sockets.Socket" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Net.Sockets.Socket" /> 類別所使用的資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>類別完成項呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法，關閉<xref:System.Net.Sockets.Socket>以及釋放相關聯的資源<xref:System.Net.Sockets.Socket>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回 <see cref="T:System.Net.Sockets.Socket" /> 選項值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <summary>傳回指定 <see cref="T:System.Net.Sockets.Socket" /> 選項的值，表示為物件。</summary>
        <returns>表示選項值的物件。 當 <paramref name="optionName" /> 參數設為 <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> 時，傳回值將會是 <see cref="T:System.Net.Sockets.LingerOption" /> 類別的執行個體。 當 <paramref name="optionName" /> 設為 <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> 或 <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> 時，傳回值將會是 <see cref="T:System.Net.Sockets.MulticastOption" /> 類別的執行個體。 當 <paramref name="optionName" /> 是其他的任何值時，傳回的值則是一個整數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 若要取得使用此多載<xref:System.Net.Sockets.SocketOptionName.Linger>， <xref:System.Net.Sockets.SocketOptionName.AddMembership>，和<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>選項。 如<xref:System.Net.Sockets.SocketOptionName.Linger>選項，請使用<xref:System.Net.Sockets.Socket>如`optionLevel`參數。 如<xref:System.Net.Sockets.SocketOptionName.AddMembership>和<xref:System.Net.Sockets.SocketOptionName.DropMembership>，使用<xref:System.Net.Sockets.SocketOptionLevel.IP>。 如果您想要設定任何上述選項的值，請使用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會擷取<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時的值，並加以顯示到主控台。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。  -或-  <paramref name="optionName" /> 設定為不支援的值 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionValue">
          <see cref="T:System.Byte" /> 型別的陣列，將要接收選項設定。</param>
        <summary>傳回指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設定，表示為位元組陣列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 在此方法成功完成時，陣列會指定由`optionValue`參數包含指定的值<xref:System.Net.Sockets.Socket>選項。  
  
 當長度`optionValue`陣列的儲存值加上指定所需的位元組數目小於<xref:System.Net.Sockets.Socket>選項，<xref:System.Net.Sockets.Socket.GetSocketOption%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。 布林值或整數都由任何通訊端使用這個多載。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會擷取<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時的值，並加以顯示到主控台。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。  \- 或 -  在 .NET Compact Framework 應用程式中，Windows CE 的預設緩衝區空間設為 32,768 個位元組。 您可以呼叫 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，以變更每個通訊端緩衝區空間。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionLength">要限制的傳回值長度，以位元組為單位。</param>
        <summary>以陣列傳回指定 <see cref="T:System.Net.Sockets.Socket" /> 選項的值。</summary>
        <returns>
          <see cref="T:System.Byte" /> 型別的陣列，包含通訊端選項值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength`參數集傳回的位元組陣列的大小上限。 如果選項值需要更少個位元組，陣列將只包含多個位元組。 如果選項值需要更多的位元組<xref:System.Net.Sockets.Socket.GetSocketOption%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 布林值或整數都由任何通訊端使用這個多載。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會擷取<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時的值，並加以顯示到主控台。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。  \- 或 -  在 .NET Compact Framework 應用程式中，Windows CE 的預設緩衝區空間設為 32,768 個位元組。 您可以呼叫 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，以變更每個通訊端緩衝區空間。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Net.Sockets.Socket" /> 的作業系統處理。</summary>
        <value>
          <see cref="T:System.IntPtr" />，表示 <see cref="T:System.Net.Sockets.Socket" /> 的作業系統控制代碼。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>設定 <see cref="T:System.Net.Sockets.Socket" /> 的低階作業系統模式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">
          <see cref="T:System.Int32" /> 值，指定要執行之作業的控制碼。</param>
        <param name="optionInValue">
          <see cref="T:System.Byte" /> 陣列，包含作業所需的輸入資料。</param>
        <param name="optionOutValue">
          <see cref="T:System.Byte" /> 陣列，包含作業傳回的輸出資料。</param>
        <summary>使用數值控制碼，設定 <see cref="T:System.Net.Sockets.Socket" /> 的低階作業模式。</summary>
        <returns>
          <paramref name="optionOutValue" /> 中的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A>方法提供低層級存取作業系統<xref:System.Net.Sockets.Socket>基礎的目前執行個體<xref:System.Net.Sockets.Socket>類別。 如需詳細資訊，請參閱 MSDN library 中的 WSAIoctl 文件。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會比較 FIONREAD 和 [可用性] 內容的結果。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">已嘗試不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 屬性來變更封鎖模式。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">執行 unmanaged 程式碼。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">
          <see cref="T:System.Net.Sockets.IOControlCode" /> 值，指定要執行之作業的控制碼。</param>
        <param name="optionInValue">
          <see cref="T:System.Byte" /> 型別的陣列，包含作業所需的輸入資料。</param>
        <param name="optionOutValue">
          <see cref="T:System.Byte" /> 型別的陣列，包含作業傳回的輸出資料。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 列舉型別指定控制碼，以設定 <see cref="T:System.Net.Sockets.IOControlCode" /> 的低階作業模式。</summary>
        <returns>
          <paramref name="optionOutValue" /> 中的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供作業系統的低層級存取<xref:System.Net.Sockets.Socket>基礎的目前執行個體<xref:System.Net.Sockets.Socket>類別。 如需詳細資訊，請參閱 MSDN library 中的 WSAIoctl 文件。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會比較呼叫的結果<xref:System.Net.Sockets.Socket.IOControl%2A>與<xref:System.Net.Sockets.IOControlCode.DataToRead>和<xref:System.Net.Sockets.Socket.Available%2A>屬性。  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">已嘗試不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 屬性來變更封鎖模式。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">執行 unmanaged 程式碼。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Net.Sockets.Socket" /> 是否繫結至特定的本機通訊埠。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 繫結至本機通訊埠，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通訊端視為已繫結至本機連接埠如果明確繫結呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，或隱含地繫結，透過呼叫的成員，像是<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，會使用暫時的本機連接埠 （可用的通訊埠大於1024，選取作業系統。)伺服器會使用<xref:System.Net.Sockets.Socket.Bind%2A>繫結的已知的連接埠，讓用戶端可能會連線到它們的方法。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.IsBound%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否會延遲關閉通訊端，以嘗試傳送所有暫止資料。</summary>
        <value>
          <see cref="T:System.Net.Sockets.LingerOption" />，指定關閉通訊端時如何延遲。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A>屬性變更的方式<xref:System.Net.Sockets.Socket.Close%2A>方法的行為。 這個屬性集修改的條件的連線可以來重設 Winsock 時。 連接重設仍可能是根據 IP 通訊協定行為。  
  
 這個屬性會控制的呼叫之後，連線導向的連接將維持開啟的時間長度<xref:System.Net.Sockets.Socket.Close%2A>時仍可傳送資料。  
  
 當您呼叫方法，將資料傳送至對等時，這項資料會在傳出的網路緩衝區中。 這個屬性可以用來確保這些資料會傳送至遠端主機之前<xref:System.Net.Sockets.TcpClient.Close%2A>方法會卸除連接。  
  
 若要啟用延遲，請建立<xref:System.Net.Sockets.LingerOption>執行個體包含所需的值，並設定<xref:System.Net.Sockets.Socket.LingerState%2A>屬性與這個執行個體。  
  
 下表描述的行為<xref:System.Net.Sockets.Socket.Close%2A>的可能值的方法<xref:System.Net.Sockets.LingerOption.Enabled%2A>屬性和<xref:System.Net.Sockets.LingerOption.LingerTime%2A>屬性儲存在<xref:System.Net.Sockets.Socket.LingerState%2A>屬性。  
  
|LingerState.Enabled|LingerState.LingerTime|行為|  
|-------------------------|----------------------------|--------------|  
|`false` （已停用），預設值|不適用，在逾時 （預設值）。|嘗試將預設 IP 通訊協定等候逾時到期之前傳送暫止的資料。|  
|`true` （已啟用）|非零的逾時|嘗試傳送暫止資料，直到指定的逾時到期，而如果嘗試失敗，則 Winsock 重設連接。|  
|`true` （已啟用）|零逾時。|會捨棄任何暫止的資料。 連接導向通訊端 (例如 TCP)，Winsock 重設連接。|  
  
 IP 堆疊計算預設 IP 通訊協定逾時期間，若要使用的連線的來回時間為基礎。 在大部分情況下，堆疊計算的逾時值為更有相關性比其中一個應用程式所定義的。 這是預設行為是通訊端時<xref:System.Net.Sockets.Socket.LingerState%2A>屬性未設定。  
  
 當<xref:System.Net.Sockets.LingerOption.LingerTime%2A>屬性儲存在<xref:System.Net.Sockets.Socket.LingerState%2A>屬性設定大於預設 IP 通訊協定等候逾時，仍將套用的預設 IP 通訊協定逾時，覆寫。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.LingerState%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">暫止連接佇列的最大長度。</param>
        <summary>將 <see cref="T:System.Net.Sockets.Socket" /> 置於接聽狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> 會導致連線導向<xref:System.Net.Sockets.Socket>接聽連入連線嘗試。 `backlog`參數會指定可排入佇列接受連入連線的數目。 若要判斷您可以指定的連線的數目上限，擷取<xref:System.Net.Sockets.SocketOptionName.MaxConnections>值。 <xref:System.Net.Sockets.Socket.Listen%2A> 不會封鎖。  
  
 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。 使用<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.BeginAccept%2A>以接受來自佇列的連線。  
  
> [!NOTE]
>  您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法之前先呼叫<xref:System.Net.Sockets.Socket.Listen%2A>，或<xref:System.Net.Sockets.Socket.Listen%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  待處理項目參數會限制為不同的值視作業系統而定。 您可以指定較高的值，但是待處理項目會受到限制基礎作業系統。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.Socket>來接聽連入連線。  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得本機端點。</summary>
        <value>
          <see cref="T:System.Net.EndPoint" />，<see cref="T:System.Net.Sockets.Socket" /> 正將它用於通訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性會取得<xref:System.Net.EndPoint>本機 IP 位址和連接埠編號，其中包含您<xref:System.Net.Sockets.Socket>繫結。 您必須將此轉型<xref:System.Net.EndPoint>至<xref:System.Net.IPEndPoint>之前擷取的任何資訊。 您可以接著呼叫<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法來擷取本機<xref:System.Net.IPAddress>，而<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法來擷取本機連接埠號碼。  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性通常設定進行的呼叫之後<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果您允許系統在將通訊端的本機 IP 位址和連接埠號碼指派<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>之後第一項 I/O 作業將會設定屬性。 連線導向的通訊協定，第一項 I/O 作業將會是呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 無連接的通訊協定，第一項 I/O 作業會是任何傳送或接收呼叫。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會擷取，並顯示本機和遠端端點。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定輸出多點傳送封包是否會傳遞至傳送應用程式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 會接收輸出多點傳送封包，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多點傳送是網際網路上的多對多通訊的擴充方法。 處理序會訂閱的多點傳送位址。接著，每個訂閱多點傳送位址的處理序會接收任何已訂閱的處理序所傳送的封包。  
  
 傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會有任何作用。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.MulticastLoopback%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定資料流 <see cref="T:System.Net.Sockets.Socket" /> 是否使用 Nagle 演算法。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 使用 Nagle 演算法，則為 <see langword="false" />，否則為 <see langword="true" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle 演算法被為了減少網路流量，讓通訊端緩衝小型封包然後結合並在某些情況下一個封包中傳送它們。 TCP 封包包含 40 個位元組的標頭加上傳送的資料。 小型資料封包傳送時使用的 TCP，TCP 標頭造成的負擔可能會變得的網路流量的重要部分。在繁重的網路壅塞造成這項負擔可能會導致遺失的資料包和重新傳輸，以及因壅塞的過多的傳播時間。 Nagle 演算法禁止傳送新的 TCP segmentswhen 新輸出的資料到達時使用者如果在連接上的任何 previouslytransmitted 資料會維持未認可。  
  
 大部分的網路應用程式應該使用 Nagle 演算法。  
  
 使用者資料包通訊協定 (UDP) 通訊端上設定這個屬性會有任何作用。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.NoDelay%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指出基礎作業系統和網路配置器是否支援網際網路通訊協定第 4 版 (IPv4)。</summary>
        <value>如果作業系統和網路配置器支援 IPv4 通訊協定則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作業系統可能會支援 IPv4 和 IPv6 通訊協定。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指出基礎作業系統和網路配置器是否支援網際網路通訊協定第 6 版 (IPv6)。</summary>
        <value>如果作業系統和網路配置器支援 IPv6 通訊協定則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作業系統可能會支援 IPv4 和 IPv6 通訊協定。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">等待回應的時間，以微秒為單位。</param>
        <param name="mode">其中一個 <see cref="T:System.Net.Sockets.SelectMode" /> 值。</param>
        <summary>決定 <see cref="T:System.Net.Sockets.Socket" /> 的狀態。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> 的狀態，根據從 <paramref name="mode" /> 參數中傳遞的輪詢模式值而定。  
  
 <list type="table"><listheader><term> 模式  </term><description> 傳回值  如果已呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 且連線暫止時，則為 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" />；或如果資料可供讀取，則為 <see langword="true" />；或如果連線已經關閉、重設或終止，則為 <see langword="true" />；否則，傳回 <see langword="false" />。如果處理 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> 且已成功建立連線，則為 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />；或如果可以傳送資料，則為 <see langword="true" />；否則，傳回 <see langword="false" />。如果處理的 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> 沒有封鎖且連線已失敗時，則為 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" />；或如果未設定 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> 且 Out-of-Band Data 可用時，則為 <see langword="true" />；否則，傳回 <see langword="false" />。</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A>方法會檢查的狀態<xref:System.Net.Sockets.Socket>。 指定<xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType>如`selectMode`參數，來判斷如果<xref:System.Net.Sockets.Socket>是否可讀取。 指定<xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType>判斷<xref:System.Net.Sockets.Socket>是可寫入。 使用<xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType>偵測錯誤狀況。 <xref:System.Net.Sockets.Socket.Poll%2A> 將會封鎖執行，直到指定的時間長度，以測量`microseconds`，捨棄。 設定`microSeconds`負整數，如果您想要無限期地等待回應的參數。 如果您想要檢查多個通訊端的狀態，您可能會偏好使用<xref:System.Net.Sockets.Socket.Select%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  這個方法無法偵測某些類型的連線問題，例如中斷的網路纜線，或遠端主機已強制關閉。 您必須嘗試傳送或接收資料，以偵測這類錯誤。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立通訊端、 連接到伺服器，並使用<xref:System.Net.Sockets.Socket.Poll%2A>檢查通訊端的狀態。  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="mode" /> 參數不是其中一個 <see cref="T:System.Net.Sockets.SelectMode" /> 值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱下面的＜備註＞。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Net.Sockets.Socket" /> 的通訊協定 (Protocol) 類型。</summary>
        <value>其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A>時設定屬性<xref:System.Net.Sockets.Socket>建立，並指定所使用的通訊協定<xref:System.Net.Sockets.Socket>。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>至主控台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從已繫結的 <see cref="T:System.Net.Sockets.Socket" /> 接收資料。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <summary>從已繫結的 <see cref="T:System.Net.Sockets.Socket" /> 接收資料至接收緩衝區中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。 您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。  
  
 這個多載只會要求您提供接收緩衝區。 緩衝區位移的預設值為 0，大小預設為參數的長度的緩衝區，而<xref:System.Net.Sockets.SocketFlags>值預設為<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中建立資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取到緩衝區的大小，可用的資料量。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您接收的資料包大於大小`buffer`參數，`buffer`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會收到上連接的資料<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，包含已接收的資料。</param>
        <summary>從已繫結的 <see cref="T:System.Net.Sockets.Socket" /> 接收資料至接收緩衝區清單中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會將資料讀入緩衝區參數，並傳回成功讀取的位元組數目。 您可以從連線導向和無連線通訊端呼叫。  
  
 這個多載都需要您提供一個或多個接收緩衝區。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自中建立的遠端主機連接的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取到緩衝區的大小，可用的資料量。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您接收的資料包大於大小`buffers`參數，`buffers`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
 **請注意**應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。 您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。  
  
 這個多載只會要求您提供接收緩衝區和必要<xref:System.Net.Sockets.SocketFlags>。 緩衝區位移的預設值為 0，且大小預設值為位元組參數的長度。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中建立資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法將會封鎖直到資料為止。 如果您是在未封鎖模式中，而且沒有可用的通訊協定堆疊緩衝區中的資料<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，再試一次您接收作業。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取到緩衝區的大小可用的資料量。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您接收的資料包大於大小`buffer`參數，`buffer`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會指定資料緩衝區，並<xref:System.Net.Sockets.SocketFlags>接收上連接的資料<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，包含已接收的資料。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區清單中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取資料到`buffers`參數，並傳回成功讀取的位元組數目。 您可以從連線導向和無連線通訊端呼叫。  
  
 這個多載都需要您提供一個或多個接收緩衝區。 <xref:System.Net.Sockets.SocketFlags>值預設為<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自中建立的遠端主機連接的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取到緩衝區的大小，可用的資料量。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您接收的資料包大於大小`buffers`參數，`buffers`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何接收的資料連接的<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 為 <see langword="null" />。  -或-  <paramref name="buffers" />.Count 為零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 將指定位元組數的資料接收至接收緩衝區中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取資料到`buffer`參數，並傳回成功讀取的位元組數目。 您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。  
  
 這個多載只會要求您提供接收緩衝區中，您想要接收的位元組和必要數目<xref:System.Net.Sockets.SocketFlags>。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中建立資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，再試一次您接收作業。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，最多為指定的位元組數目的資料量`size`參數。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您接收的資料包大於大小`buffer`參數，`buffer`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列接收資料找到`buffer`，並指定<xref:System.Net.Sockets.SocketFlags.None>如<xref:System.Net.Sockets.SocketFlags>。  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> 超過 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，包含已接收的資料。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode">
          <see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區清單中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取資料到`buffers`參數，並傳回成功讀取的位元組數目。 您可以從連線導向和無連線通訊端呼叫。  
  
 這個多載都需要您提供一個或多個接收緩衝區。 <xref:System.Net.Sockets.SocketFlags>值預設為<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自中建立的遠端主機連接的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取到緩衝區的大小，可用的資料量。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您接收的資料包大於大小`buffers`參數，`buffers`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 為 <see langword="null" />。  -或-  <paramref name="buffers" />.Count 為零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</param>
        <param name="offset">「緩衝區」<c></c>中存放已接收資料的位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 將指定的位元組數接收到接收緩衝區的指定位移位置。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。 您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中建立資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 嘗試存取通訊端時發生錯誤。 請參閱下面的備註。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，最多的 size 參數所指定的位元組數目的資料量。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您接收的資料包大於大小`buffer`參數，`buffer`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例指定資料緩衝區、 位移、 大小和通訊端旗標才能接收資料，在連接上的<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值組合。  -或-  未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。  -或-  在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="offset">「緩衝區」<c></c>參數中的位置，可儲存接收的資料。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode">
          <see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。 您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線，然後才呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中建立資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收資料抵達的任何主機。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法會封鎖，直到資料可用，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 嘗試存取通訊端時發生錯誤。 請參閱下面的備註。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，最多的 size 參數所指定的位元組數目的資料量。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連線<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您接收的資料包大於大小`buffer`參數，`buffer`填入訊息的第一個部分，與過多的資料會遺失與<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值組合。  -或-  未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。  -或-  在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始非同步要求，以接收來自已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件的資料。</summary>
        <returns>如果 I/O 作業暫止，則傳回 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 作業同步完成，則傳回 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法用在通訊端或繫結無連接的通訊端連線，以及用來讀取內送資料。 必須知道通訊端的本機位址。  
  
 繫結無連接的通訊端，此函式會限制已接受已接收的訊息的位址。 函式只會傳回在連接中指定的遠端位址的訊息。 從其他位址的訊息被丟棄。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>屬性`e`參數提供視窗通訊端服務提供者，以及讀取要求的其他資訊。 如需如何使用這個參數的詳細資訊，請參閱<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法，如此將可在回呼方法中擷取資訊。 如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。  
  
 位元組資料流樣式通訊端，內送資料放入緩衝區為止緩衝區已滿，連接會關閉，或已用完內部的資料。  
  
 訊息導向的通訊端，內送訊息會放入之前的相關聯的緩衝區大小總計的緩衝區`e`參數。 如果訊息是大於緩衝區，訊息的第一個部分填滿緩衝區。  
  
 連線導向的通訊端，<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法可以指定其中一種相依於通訊端是否位元組資料流或訊息導向的兩個虛擬電路正常終止。 位元組資料流，讀取零個位元組表示正常關閉，曾將讀取任何多個位元組。 訊息導向的通訊端，其中是通常允許零個位元組的訊息，<xref:System.Net.Sockets.SocketException>與<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>設為原生的 Winsock WSAEDISCON 錯誤程式碼 (10101) 用來表示非失誤性結束。 在任何情況下，<xref:System.Net.Sockets.SocketException>與<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>設為原生 Winsock WSAECONNRESET 錯誤碼 (10054) 會指出發生失敗的關閉。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引數無效。 <paramref name="e" /> 參數上的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性必須參考有效的緩衝區。 這兩個屬性可能有一個已經設定，但不會同時都已設定。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 之接收緩衝區的大小。</summary>
        <value>
          <see cref="T:System.Int32" />，包含接收緩衝區的大小 (以位元組為單位)。 預設值為 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 較大的緩衝區大小可能會減少空認可 （TCP 封包沒有資料部分），但也可能會延遲連線困難的辨識。 請考慮增加緩衝區大小，如果您正在傳送大型檔案，或您使用高頻寬、 高延遲的連線 （例如衛星寬頻提供者。）  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">為設定作業指定的值小於 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收資料包以及儲存來源端點。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</param>
        <param name="remoteEP">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</param>
        <summary>接收資料包至資料緩衝區中，並儲存端點。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並將擷取遠端主機的端點已從中傳送資料。 這個方法很有用，如果您想要收到未知的主機或多部主機的無連接的資料包。  
  
 這個多載只會要求您提供接收`buffer`，和<xref:System.Net.EndPoint>表示遠端主機。 緩衝區位移預設值為 0。 大小的預設值的長度為`buffer`參數和`socketFlags`值預設為<xref:System.Net.Sockets.SocketFlags.None>。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果您不這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 無連接的通訊協定<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取第一個收到的區域網路緩衝區中的加入佇列資料包。 如果您接收的資料包大於大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`一樣多的訊息是盡可能，，並擲回與<xref:System.Net.Sockets.SocketException>。 如果您使用的不可靠的通訊協定，將會遺失過多的資料。 如果您使用可靠的通訊協定、 過多的資料會保留服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法夠大的緩衝區。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料為止。 如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。  
  
 雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連接的通訊協定，您可以使用連線導向的通訊協定以及。 如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您要建立或接受連線，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，您會收到<xref:System.Net.Sockets.SocketException>。 您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在任一情況下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數，只接收來自已連接的資料或預設遠端主機。  
  
 使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取最多資料，因為可用的大小直到`buffer`。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會從遠端主機接收無連線的資料包。  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  -或-  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，接收資料包至資料緩衝區中，並儲存端點。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並將擷取遠端主機的端點已從中傳送資料。 這個方法很有用，如果您想要收到未知的主機或多部主機的無連接的資料包。  
  
 這個多載只會要求您提供接收緩衝區，視需要<xref:System.Net.Sockets.SocketFlags>，和<xref:System.Net.EndPoint>表示遠端主機。 位移的預設值為 0 而且大小預設為緩衝區參數的長度。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果您不這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 無連接的通訊協定<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取第一個收到的區域網路緩衝區中的加入佇列資料包。 如果您接收的資料包大於大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`一樣多的訊息是盡可能，，並擲回與<xref:System.Net.Sockets.SocketException>。 如果您使用的不可靠的通訊協定，將會遺失過多的資料。 如果您使用可靠的通訊協定、 過多的資料會保留服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法夠大的緩衝區。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料為止。 如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。  
  
 雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連接的通訊協定，您可以使用連線導向的通訊協定以及。 如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您要建立或接受連線，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，您會收到<xref:System.Net.Sockets.SocketException>。 您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在任一情況下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數，只接收來自已連接的資料或預設遠端主機。  
  
 使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取最多資料，因為可用的大小直到`buffer`。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會從遠端主機接收無連線的資料包。 <xref:System.Net.Sockets.SocketFlags> 傳遞至<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  -或-  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，接收指定的位元組數至資料緩衝區中，並儲存端點。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並將擷取遠端主機的端點已從中傳送資料。 這個方法很有用，如果您想要收到未知的主機或多部主機的無連接的資料包。  
  
 這個多載只會要求您提供接收緩衝區中，您想要接收所需的位元組數目<xref:System.Net.Sockets.SocketFlags>，和<xref:System.Net.EndPoint>表示遠端主機。 緩衝區位移預設值為 0。  
  
 無連接的通訊協定<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取第一個收到的區域網路緩衝區中的加入佇列資料包。 如果您接收的資料包大於大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`一樣多的訊息是盡可能，，並擲回與<xref:System.Net.Sockets.SocketException>。 如果您使用的不可靠的通訊協定，將會遺失過多的資料。 如果您使用可靠的通訊協定、 過多的資料會保留服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法夠大的緩衝區。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料為止。 如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。  
  
 雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連接的通訊協定，您可以使用連線導向的通訊協定以及。 如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您要建立或接受連線，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，您會收到<xref:System.Net.Sockets.SocketException>。 您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在任一情況下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數，只接收來自已連接的資料或預設遠端主機。  
  
 使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取位於最高達指定的位元組數目的資料量`size`參數。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果您不這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會從遠端主機接收無連線的資料包。 緩衝區大小，和<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  -或-  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值組合。  -或-  未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。  -或-  在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</param>
        <param name="offset">「緩衝區」<c></c>參數中的位置，可儲存接收的資料。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，將指定的資料位元組數目接收至資料緩衝區的指定位置，並儲存端點。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並將擷取遠端主機的端點已從中傳送資料。 這個方法很有用，如果您想要收到未知的主機或多部主機的無連接的資料包。  
  
 無連接的通訊協定<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取第一個收到的區域網路緩衝區中的加入佇列資料包。 如果您接收的資料包大於大小`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`一樣多的訊息是盡可能，，並擲回與<xref:System.Net.Sockets.SocketException>。 如果您使用的不可靠的通訊協定，將會遺失過多的資料。 如果您使用可靠的通訊協定、 過多的資料會保留服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法夠大的緩衝區。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料為止。 如果您是在未封鎖模式中，而且沒有使用中的資料通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，則擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>為非零，接收作業的重試。  
  
 雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連接的通訊協定，您可以使用連線導向的通訊協定以及。 如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您要建立或接受連線，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，您會收到<xref:System.Net.Sockets.SocketException>。 您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在任一情況下，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數，只接收來自已連接的資料或預設遠端主機。  
  
 使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取最多到所指定的位元組數量可用的資料量`size`參數。 如果遠端主機關機<xref:System.Net.Sockets.Socket>與連線<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已經收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果您不這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會從遠端主機接收無連線的資料包。 位移、 緩衝區大小和<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  -或-  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去位移參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值組合。  -或-  未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。  -或-  嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始從指定的網路裝置非同步接收資料。</summary>
        <returns>如果 I/O 作業暫止，則傳回 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 作業同步完成，則傳回 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>方法主要用來接收無連接的通訊端上的資料。 必須知道通訊端的本機位址。  
  
 呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性<xref:System.Net.IPEndPoint>的接收來源資料之遠端主機。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>屬性`e`參數提供視窗通訊端服務提供者，以及讀取要求的其他資訊。 如需如何使用這個參數的詳細資訊，請參閱<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>方法，如此將可在回呼方法中擷取資訊。 如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。  
  
 訊息導向的通訊端，內送訊息會放入緩衝區的大小總計之前的緩衝區。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>屬性決定放置資料緩衝區的位置及資料量。  
  
 位元組資料流樣式通訊端，內送資料放入緩衝區為止緩衝區已滿，連接會關閉，或已用完內部的資料。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>屬性決定放置資料緩衝區的位置及資料量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不可以是 null。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</param>
        <param name="offset">「緩衝區」<c></c>參數中的位置，可儲存接收的資料。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</param>
        <param name="ipPacketInformation">保留位址及介面資訊的 <see cref="T:System.Net.Sockets.IPPacketInformation" />。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，將指定的資料位元組數目接收至資料緩衝區的指定位置，並儲存端點及封包資訊。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並將擷取遠端主機資料已傳送的端點，以及收到的封包的相關資訊。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法主要用來接收訊息資料，無連接的通訊端上。 必須知道通訊端的本機位址。 這個方法只用於資料包與原始通訊端。 必須初始化通訊端通訊端類型設定為<xref:System.Net.Sockets.SocketType.Dgram>或<xref:System.Net.Sockets.SocketType.Raw>之前呼叫這個方法。 這可以使用建構通訊端時<xref:System.Net.Sockets.Socket.%23ctor%2A>。  
  
 訊息導向的通訊端，內送訊息會放入`buffer`參數中指定的總大小最`size`參數。 `offset`參數會決定在何處`buffer`將資料放在。 實際的資料量放入`buffer`傳回<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法方法會設定自動<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項`true`它稱為第一次指定<xref:System.Net.Sockets.Socket>。 不過，傳回<xref:System.Net.Sockets.IPPacketInformation>物件才會對封包抵達本機電腦，設定通訊端選項之後有效。 如果通訊端時繫結至本機端點傳送封包之間 (明確地<xref:System.Net.Sockets.Socket.Bind%2A>方法，或以隱含方式的其中一個<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法) 和其第一次呼叫<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>若要呼叫的方法，<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法會傳回不正確<xref:System.Net.Sockets.IPPacketInformation>這些封包的物件。  
  
 為了確保所有<xref:System.Net.Sockets.IPPacketInformation>物件有效，而且應用程式應該設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項`true`本機端點，使用繫結之前<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>方法。  
  
 應用程式可以檢查`ipPacketInformation`參數，需要知道資料包使用單點傳播、 多點傳送或廣播位址來傳送。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  \- 或 -  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去位移參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值組合。  -或-  未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。  -或-  .NET Framework 正在 AMD 64 位元處理器上執行。  -或-  嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>使用指定的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />，開始以非同步方式將指定之位元組數目的資料，接收至資料緩衝區的指定位置，並儲存端點和封包資訊。</summary>
        <returns>如果 I/O 作業暫止，則傳回 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 作業同步完成，則傳回 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法主要用來接收訊息資料，無連接的通訊端上。 必須知道通訊端的本機位址。 這個方法只用於資料包與原始通訊端。 必須初始化通訊端通訊端類型設定為<xref:System.Net.Sockets.SocketType.Dgram>或<xref:System.Net.Sockets.SocketType.Raw>之前呼叫這個方法。 這可以使用建構通訊端時<xref:System.Net.Sockets.Socket.%23ctor%2A>。  
  
 呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性<xref:System.Net.IPEndPoint>的接收來源資料之遠端主機。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法，如此將可在回呼方法中擷取資訊。 如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。  
  
 訊息導向的通訊端，內送訊息會放入緩衝區的大小總計之前的緩衝區。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>屬性決定放置資料緩衝區的位置及資料量。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法會自動設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項`true`它稱為第一次指定<xref:System.Net.Sockets.Socket>。 不過，<xref:System.Net.Sockets.IPPacketInformation>物件才會對封包抵達本機電腦，設定通訊端選項之後有效。 如果通訊端通訊端繫結至本機端點時傳送封包之間 (明確地<xref:System.Net.Sockets.Socket.Bind%2A>方法，或以隱含方式的其中一個<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法) 和第一個呼叫<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法，呼叫<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法將會導致無效<xref:System.Net.Sockets.IPPacketInformation>這些封包的物件。  
  
 為了確保所有<xref:System.Net.Sockets.IPPacketInformation>物件有效，而且應用程式應該設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項`true`本機端點，使用繫結之前<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>方法。  
  
 應用程式可以檢查所產生的<xref:System.Net.Sockets.IPPacketInformation>物件是否需要知道資料包使用單點傳播、 多點傳送或廣播位址來傳送。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不可以是 null。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定同步 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 呼叫逾時之前的時間長度。</summary>
        <value>逾時值 (以毫秒為單位)。 預設值為 0，表示無限的逾時期間。 指定 -1 也表示無限的逾時期間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此選項適用於同步<xref:System.Net.Sockets.Socket.Receive%2A>僅呼叫。 如果超過逾時期限，<xref:System.Net.Sockets.Socket.Receive%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">為設定作業指定的值小於 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得遠端端點。</summary>
        <value>
          <see cref="T:System.Net.EndPoint" />，<see cref="T:System.Net.Sockets.Socket" /> 正在與其通訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性會取得<xref:System.Net.EndPoint>，其中包含遠端 IP 位址和連接埠號碼的<xref:System.Net.Sockets.Socket>連接。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>包含預設遠端 IP 位址和連接埠號碼與<xref:System.Net.Sockets.Socket>將與其通訊。 您必須將此轉型<xref:System.Net.EndPoint>至<xref:System.Net.IPEndPoint>之前擷取的任何資訊。 您可以接著呼叫<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法來擷取遠端<xref:System.Net.IPAddress>，而<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法來擷取遠端連接埠號碼。  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>設定後呼叫<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.Connect%2A>。 如果您嘗試存取此屬性之前，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會擷取，並顯示本機和遠端端點。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">要檢查可讀性的 <see cref="T:System.Net.Sockets.Socket" /> 執行個體的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite">要檢查可寫性的 <see cref="T:System.Net.Sockets.Socket" /> 執行個體的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkError">要檢查錯誤的 <see cref="T:System.Net.Sockets.Socket" /> 執行個體的 <see cref="T:System.Collections.IList" />。</param>
        <param name="microSeconds">逾時值 (以微秒為單位)。 -1 值表示無限逾時。</param>
        <summary>判斷一或多個通訊端的狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> 是一種靜態方法，會判斷一或多個狀態<xref:System.Net.Sockets.Socket>執行個體。 您必須將放入一個或多個通訊端<xref:System.Collections.IList>才能夠使用<xref:System.Net.Sockets.Socket.Select%2A>方法。 藉由呼叫檢查可讀性<xref:System.Net.Sockets.Socket.Select%2A>與<xref:System.Collections.IList>為`checkRead`參數。 若要檢查您的通訊端的可寫性，請使用`checkWrite`參數。 用於偵測錯誤狀態，請使用`checkError`。 在呼叫<xref:System.Net.Sockets.Socket.Select%2A>、<xref:System.Collections.IList>將會填入符合條件的通訊端。  
  
 如果您是在接聽狀態中，可讀性表示呼叫<xref:System.Net.Sockets.Socket.Accept%2A>而不會封鎖將會成功。 如果您已接受連接，可讀性表示資料可供讀取。 在這些情況下，所有的接收作業會成功，而不會封鎖。 也可能表示可讀性是否遠端<xref:System.Net.Sockets.Socket>已關閉連線關閉，則在此情況下呼叫<xref:System.Net.Sockets.Socket.Receive%2A>會立即傳回並傳回零個位元組。  
  
 <xref:System.Net.Sockets.Socket.Select%2A> 傳回時至少要有一個感興趣的通訊端 (在通訊端`checkRead`， `checkWrite`，和`checkError`列出) 符合指定的準則，或`microSeconds`參數超出、 何者較早。 設定`microSeconds`為-1 指定無限逾時。  
  
 若要以非封鎖式呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，可寫性表示您已成功連接。 如果您已經建立連接，可寫性表示所有傳送的作業將會成功而不會封鎖。  
  
 如果您所做的非封鎖式呼叫<xref:System.Net.Sockets.Socket.Connect%2A>、`checkerror`參數會識別尚未成功連線的通訊端。  
  
> [!NOTE]
>  使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，如果您只想要判斷狀態的單一<xref:System.Net.Sockets.Socket>。  
  
> [!NOTE]
>  這個方法無法偵測某些類型的連線問題，例如中斷的網路纜線，或遠端主機已強制關閉。 您必須嘗試傳送或接收資料，以偵測這類錯誤。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.Socket.Select%2A>來判斷哪些接聽的通訊端具有連線要求。  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="checkRead" /> 參數是 <see langword="null" /> 或空白。  -和-  <paramref name="checkWrite" /> 參數是 <see langword="null" /> 或空白且 <paramref name="checkError" /> 參數是 <see langword="null" /> 或空白。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <summary>傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。 <xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線的通訊協定。  
  
 這個多載都需要緩衝區，其中包含您想要傳送的資料。 <xref:System.Net.Sockets.SocketFlags>將預設值為 0，緩衝區位移的預設值為 0，而且要傳送的緩衝區大小的預設值的位元組數目。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。  
  
 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到所有的緩衝區中的位元組傳送時，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使它在緩衝區中傳送的位元組數目少於可順利完成。 負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送緩衝區中的位元組。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何在連接上傳送的資料<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，其中包含要傳送的資料。</param>
        <summary>將清單中的緩衝區集合傳送至連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線的通訊協定。  
  
 這個多載都需要至少一個緩衝區，其中包含您想要傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。  
  
 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到所有的緩衝區中的位元組傳送時，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使它在緩衝區中傳送的位元組數目少於可順利完成。 負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送緩衝區中的位元組。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 是空的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，傳送資料至已連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中建立<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。 <xref:System.Net.Sockets.Socket.Send%2A>方法可以使用連線導向和無連接通訊協定。  
  
 其中包含您想要傳送的資料緩衝區和的位元組合，這個多載需要<xref:System.Net.Sockets.SocketFlags>。 緩衝區位移為 0，而且要傳送的緩衝區大小的預設值的位元組數目的預設值。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數的值，將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。  
  
 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法，再每次呼叫<xref:System.Net.Sockets.Socket.Send%2A>。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到所有的緩衝區中的位元組傳送時，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使它在緩衝區中傳送的位元組數目少於可順利完成。 負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  您必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何在連接上傳送的資料<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，其中包含要傳送的資料。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，將清單中的緩衝區集合傳送至連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載都需要至少一個緩衝區，其中包含您想要傳送的資料。 <xref:System.Net.Sockets.SocketFlags>值預設為 0。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketFlags`參數，將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。  
  
 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到所有的緩衝區中的位元組傳送時，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在非封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使它在緩衝區中傳送的位元組數目少於可順利完成。 負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送緩衝區中的位元組。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 是空的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，傳送指定的資料位元組數至已連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中建立<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。 <xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線的通訊協定。  
  
 這個多載都需要包含您想要傳送，您想要傳送的位元組數目和任何的位元組合的資料的緩衝區<xref:System.Net.Sockets.SocketFlags>。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。  
  
 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法，再每次呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到傳送要求的位元組數目，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送您要求的位元組數目少於可順利完成。 負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  您必須確定大小不會超過基礎的服務提供者的最大的封包。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將傳送緩衝區中找到的資料，並指定<xref:System.Net.Sockets.SocketFlags.None>如<xref:System.Net.Sockets.SocketFlags>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> 小於 0 或超過緩衝區的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值組合。  -或-  存取通訊端時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">
          <see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，其中包含要傳送的資料。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode">
          <see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，將清單中的緩衝區集合傳送至連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載都需要至少一個緩衝區，其中包含您想要傳送的資料。 <xref:System.Net.Sockets.SocketFlags>值預設為 0。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketFlags`參數，將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。  
  
 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到所有的緩衝區中的位元組傳送時，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在非封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使它在緩衝區中傳送的位元組數目少於可順利完成。 負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送緩衝區中的位元組。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> 是空的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="offset">資料緩衝區中要開始傳送資料的位置。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>從指定位移開始，並使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，將資料的指定位元組數傳送到連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。 <xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線的通訊協定。  
  
 在這個多載，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。  
  
 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>。 如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 還是可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 您也必須確定大小不會超過基礎的服務提供者的最大的封包。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到傳送要求的位元組數目，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送您要求的位元組數目少於可順利完成。 負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會指定資料緩衝區、 位移、 大小，和<xref:System.Net.Sockets.SocketFlags>將資料傳送至連接<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值組合。  -或-  在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="offset">資料緩衝區中要開始傳送資料的位置。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode">
          <see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>從指定的位移開始並使用指定的 <see cref="T:System.Net.Sockets.Socket" />，將指定的資料位元組數傳送至已連接的 <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。 <xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線的通訊協定。  
  
 在這個多載，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。  
  
 如果您使用無連接的通訊協定和計劃將資料傳送到數個不同的主機，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>。 如果您未使用<xref:System.Net.Sockets.Socket.SendTo%2A>，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 還是可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立的預設遠端主機之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，然後才呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 您也必須確定大小不會超過基礎的服務提供者的最大的封包。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>會阻擋，直到傳送要求的位元組數目，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值，<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送您要求的位元組數目少於可順利完成。 負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  傳送成功完成並不表示已成功傳送資料。 如果沒有緩衝區空間來保存資料傳輸的傳輸系統中，除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會指定資料緩衝區、 位移、 大小，和<xref:System.Net.Sockets.SocketFlags>將資料傳送至連接<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值組合。  -或-  在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>將資料以非同步方式傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</summary>
        <returns>如果 I/O 作業暫止，則傳回 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 作業同步完成，則傳回 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法用來寫入輸出資料從一個或多個連線導向的通訊端使用緩衝區。 這個方法也可用，不過，在無連線通訊端連線作業中指定遠端主機上。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法會啟動非同步傳送作業中建立遠端主機<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.SendAsync%2A>方法，如此將可在回呼方法中擷取資訊。 如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法會擲回例外狀況，如果您不先呼叫<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>。  
  
 呼叫<xref:System.Net.Sockets.Socket.SendAsync%2A>方法可讓您傳送不同的執行緒中的資料。  
  
 訊息導向的通訊端，並不會超過訊息大小上限為基礎的 Windows 通訊端服務提供者。 如果資料太長，無法透過基礎的服務提供者以不可分割方式傳遞，傳送任何資料而<xref:System.Net.Sockets.Socket.SendAsync%2A>方法會擲回<xref:System.Net.Sockets.SocketException>與<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>設為原生的 Winsock WSAEMSGSIZE 錯誤程式碼 (10040)。  
  
 請注意，成功完成<xref:System.Net.Sockets.Socket.SendAsync%2A>方法並不表示已成功傳送資料。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="e" /> 參數上的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性必須參考有效的緩衝區。 這兩個屬性可能有一個已經設定，但不會同時都已設定。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尚未透過 <see cref="T:System.Net.Sockets.Socket" />、<see cref="M:System.Net.Sockets.Socket.Accept" /> 或 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法取得 <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />，或尚未連接。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 之傳送緩衝區的大小。</summary>
        <value>
          <see cref="T:System.Int32" />，包含傳送緩衝區的大小 (以位元組為單位)。 預設值為 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 較大的緩衝區大小可能會延遲連線困難的辨識。 請考慮增加緩衝區大小，如果您正在傳送大型檔案，或您使用高頻寬、 高延遲的連線 （例如衛星寬頻提供者。）  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.SendBufferSize%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">為設定作業指定的值小於 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將檔案和選擇性資料同步傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">包含要傳送之檔案的路徑與名稱的 <see cref="T:System.String" />。 這個參數可以是 <see langword="null" />。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 傳輸旗標，將檔案 <paramref name="fileName" /> 傳送至已連接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載會將該檔案傳送`fileName`連線通訊端。 `flags`參數預設值為<xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread>(0)，而`preBuffer`和`postBuffer`參數預設為`null`。 如果`fileName`是在本機目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案名稱。 使用萬用字元 (「...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。 如果檔案找不到，例外狀況<xref:System.IO.FileNotFoundException>就會擲回。  
  
 這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。 如需有關`TransmitFile`函式和其旗標，請參閱 MSDN Library 中的 Windows Sockets 文件。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 以同步方式將檔案傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可用來同時連線導向及無連接的通訊協定。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，否則<xref:System.Net.Sockets.Socket.SendFile%2A>會擲回<xref:System.Net.Sockets.SocketException>例外狀況。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.SendFile%2A>封鎖，直到檔案傳送。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.SendFile%2A>可能之前已傳送整個檔案已成功完成。 沒有保證您傳送的資料就會立即出現在網路。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.SendFile%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立和連接通訊端，然後將檔案傳送至遠端主機。 檔案"test.txt"位於本機電腦的根目錄中。  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">通訊端未連線至遠端主機。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 物件不是處於封鎖模式，而且無法接受此同步呼叫。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">包含要傳送之檔案的路徑與名稱的 <see cref="T:System.String" />。 這個參數可以是 <see langword="null" />。</param>
        <param name="preBuffer">包含傳送檔案前要傳送之資料的 <see cref="T:System.Byte" /> 陣列。 這個參數可以是 <see langword="null" />。</param>
        <param name="postBuffer">包含傳送檔案後要傳送之資料的 <see cref="T:System.Byte" /> 陣列。 這個參數可以是 <see langword="null" />。</param>
        <param name="flags">一或多個 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值，將檔案 <paramref name="fileName" /> 和資料緩衝區傳送到連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載都需要您想要傳送的檔案和的位元組合名稱<xref:System.Net.Sockets.TransmitFileOptions>值。 `preBuffer`參數會包含您想要位在檔案之前的任何資料。 `postBuffer` 包含您想要遵循之檔案的資料。 如果`fileName`是在目前工作目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案名稱。 使用萬用字元 (「...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。  
  
 `flags`參數提供視窗通訊端服務提供者，以及其他資訊的檔案傳輸。 如需如何使用這個參數的詳細資訊，請參閱<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。 如需有關`TransmitFile`函式和其旗標，請參閱 MSDN Library 中的 Windows Sockets 文件。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 以同步方式將檔案傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可用來同時連線導向及無連接的通訊協定。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法; 否則<xref:System.Net.Sockets.Socket.SendFile%2A>會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>接受連入連線。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.SendFile%2A>封鎖，直到整個檔案傳送。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.SendFile%2A>可能之前已傳送整個檔案已成功完成。 沒有保證您傳送的資料就會立即出現在網路。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.SendFile%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立，並連接通訊端。 檔案"test.txt"位於本機電腦的根目錄中。 在此範例中，我們建立緩衝和後置的資料，並將它們傳送給遠端主機中的檔案。 預設值<xref:System.Net.Sockets.TransmitFileOptions>可用。  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">作業系統不是 Windows NT (含) 以後版本。  \- 或 -  通訊端未連線至遠端主機。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> 物件不是處於封鎖模式，而且無法接受此同步呼叫。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>以非同步的方式將檔案的集合或記憶體中資料緩衝區傳送至連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</summary>
        <returns>如果 I/O 作業暫止，則傳回 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 作業同步完成，則傳回 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法用來將集合的檔案，或在記憶體中資料緩衝區傳送至遠端主機。 <xref:System.Net.Sockets.Socket>必須先連接至遠端主機。  
  
 如果<xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType>的工作目錄中檔案的參考，可能會識別與檔案的名稱; 否則必須指定完整路徑和檔案名稱。 支援萬用字元和 UNC 共用名稱。 如果找不到檔案，<xref:System.IO.FileNotFoundException>就會擲回。  
  
 若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並附加至回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>屬性`e`參數提供視窗通訊端服務提供者，以及其他資訊的檔案傳輸。 如需如何使用這個參數的詳細資訊，請參閱<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法，如此將可在回呼方法中擷取資訊。 如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。  
  
 這個方法會使用位於 Windows Sockets 2 API TransmitPackets 函式。 如需有關 TransmitPackets 函式和其旗標的詳細資訊，請參閱 MSDN Library 中的 Windows Sockets 文件。  
  
 雖然適合連線導向的通訊協定，但<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法也適用於無連接的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，以建立預設遠端主機。 您也必須確定檔案的大小不超過最大的封包大小基礎的服務提供者的無連接的通訊協定。 如果是的話，不會傳送資料包和<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>會擲回<xref:System.Net.Sockets.SocketException>例外狀況。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法最適合根據自選的作業系統，使用它。 在 Windows server 版本，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法最適合用於高效能。  
  
 在 Windows 用戶端版本，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法最適合用於最小記憶體和資源使用率。  
  
 使用<xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType>加上旗標<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>屬性`e`參數可以提供效能優勢明顯。 如果執行緒起始<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法呼叫的使用大量計算，可能是，雖然不太可能，Apc 可能無法啟動。 請注意，核心和使用者模式 Apc 之間的差異。 在執行緒處於等候狀態時，就會啟動核心 Apc。 當執行緒在警示的等待狀態時，會啟動使用者模式 Apc  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> 屬性中指定的檔案。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。 如果 <see cref="T:System.Net.Sockets.Socket" /> 未連接至遠端主機，也會發生這個例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">正在使用無連接的 <see cref="T:System.Net.Sockets.Socket" />，且正在傳送的檔案超出基礎傳輸的封包大小上限。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定同步 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 呼叫逾時之前的時間長度。</summary>
        <value>逾時值 (以毫秒為單位)。 如果您將屬性設為 1 到 499 之間的值，則會將值變更為 500。 預設值為 0，表示無限的逾時期間。 指定 -1 也表示無限的逾時期間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此選項適用於同步<xref:System.Net.Sockets.Socket.Send%2A>僅呼叫。 如果超過逾時期限，<xref:System.Net.Sockets.Socket.Send%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.SendTimeout%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">為設定作業指定的值小於 -1。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳送資料至特定的端點。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，表示資料的目的端。</param>
        <summary>傳送資料至指定的端點。</summary>
        <returns>已傳送的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在這個多載，緩衝區位移為 0 時，要傳送的大小的預設值的位元組數目的預設值`buffer`參數，而<xref:System.Net.Sockets.SocketFlags>值預設為 0。  
  
 如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。 您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`參數會覆寫指定的預設遠端主機，如，傳送作業只。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。 如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 適用於無連接的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也可以使用連線導向的通訊協定。 如果您使用連線導向的通訊協定，您必須先呼叫來建立遠端主機連接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您要建立或接受遠端主機連接，<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在任一情況下，<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只傳送資料給已連接或預設遠端主機。  
  
 封鎖的通訊端會阻擋，直到傳送的所有位元組緩衝區中。 因為未封鎖<xref:System.Net.Sockets.Socket>完成立即，它可能未傳送的位元組中的所有`buffer`。 您的應用程式必須負責記錄傳送的位元組數，以及重試此作業，直到應用程式傳送的位元組中的所有`buffer`。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量的連出的資料。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
 如果您使用無連接的通訊協定在封鎖模式中，<xref:System.Net.Sockets.Socket.SendTo%2A>會阻擋，直到傳送資料包。 如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也必須確定傳送的位元組數目不超過最大的封包大小基礎的服務提供者。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無連線資料包傳送至指定的遠端主機。  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  -或-  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，表示資料的目的位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，傳送資料至特定端點。</summary>
        <returns>已傳送的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在這個多載，緩衝區位移為 0，而且要傳送的大小的預設值的位元組數目的預設值`buffer`。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。 您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`參數會覆寫指定的預設遠端主機，如，傳送作業只。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。 如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 適用於無連接的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也可以使用連線導向的通訊協定。 如果您使用連線導向的通訊協定，您必須先呼叫來建立遠端主機連接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您要建立或接受遠端主機連接，<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在任一情況下，<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只傳送資料給已連接或預設遠端主機。  
  
 封鎖的通訊端將會封鎖直到所要求的位元組中的所有`buffer`傳送。 因為未封鎖<xref:System.Net.Sockets.Socket>完成立即，它可能未傳送的位元組中的所有`buffer`。 您的應用程式必須負責記錄傳送的位元組數，以及重試此作業，直到應用程式傳送的位元組中的所有`buffer`。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量傳出資料。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
 如果您使用無連接的通訊協定在封鎖模式中，<xref:System.Net.Sockets.Socket.SendTo%2A>會阻擋，直到傳送資料包。 如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也必須確定傳送的位元組數目不超過最大的封包大小基礎的服務提供者。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無連線資料包傳送至指定的遠端主機。 <xref:System.Net.Sockets.SocketFlags> 傳遞至<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  -或-  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，表示資料的目的位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，傳送指定位元組數目的資料至指定的端點。</summary>
        <returns>已傳送的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在這個多載，緩衝區位移預設值為 0。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。 您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`參數會覆寫指定的預設遠端主機，如，傳送作業只。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。 如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 適用於無連接的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也可以使用連線導向的通訊協定。 如果您使用連線導向的通訊協定，您必須先呼叫來建立遠端主機連接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您要建立或接受遠端主機連接，<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在任一情況下，<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只傳送資料給已連接或預設遠端主機。  
  
 封鎖的通訊端會阻擋，直到傳送要求的位元組數目。 因為未封鎖<xref:System.Net.Sockets.Socket>完成立即，它可能未傳送的所有要求在單一作業中的位元組。 負責應用程式的記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量傳出資料。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
 如果您使用無連接的通訊協定在封鎖模式中，<xref:System.Net.Sockets.Socket.SendTo%2A>會阻擋，直到傳送資料包。 如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也必須確定傳送的位元組數目不超過最大的封包大小基礎的服務提供者。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無連線資料包傳送至指定的遠端主機。 大小和<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  -或-  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的 <paramref name="size" /> 超過 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="offset">資料緩衝區中要開始傳送資料的位置。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">
          <see cref="T:System.Net.EndPoint" />，表示資料的目的位置。</param>
        <summary>從緩衝區中的指定位置開始且使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，傳送指定位元組數目的資料至指定的端點。</summary>
        <returns>已傳送的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在這個多載，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。 您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`參數會覆寫指定的預設遠端主機，如，傳送作業只。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的本機網路位址和通訊埠編號。 如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 適用於無連接的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也可以使用連線導向的通訊協定。 如果您使用連線導向的通訊協定，您必須先呼叫來建立遠端主機連接<xref:System.Net.Sockets.Socket.Connect%2A>方法或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您要建立或接受遠端主機連接，<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 您也可以建立無連接的通訊協定，然後才會呼叫預設遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在任一情況下，<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只傳送資料給已連接或預設遠端主機。  
  
 封鎖的通訊端會阻擋，直到傳送要求的位元組數目。 因為非封鎖<xref:System.Net.Sockets.Socket>完成立即，它可能未傳送的所有要求在單一作業中的位元組。 您必須負責應用程式記錄傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 也是您所傳送的資料就會立即出現在網路不保證。 若要增加網路效率，基礎的系統可能會延遲傳輸，直到收集大量傳出資料。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示的基礎系統已加入您網路的資料傳送的緩衝區空間。  
  
 如果您使用無連接的通訊協定在封鎖模式中，<xref:System.Net.Sockets.Socket.SendTo%2A>會阻擋，直到傳送資料包。 如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也必須確定大小不會超過基礎的服務提供者的最大的封包。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無連線資料包傳送至指定的遠端主機。 位移、 大小和<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。  -或-  <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 小於 0。  -或-  <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  -或-  <paramref name="size" /> 小於 0。  -或-  <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> 不是有效的值組合。  -或-  在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>以非同步方式將資料傳送至特定的遠端主機。</summary>
        <returns>如果 I/O 作業暫止，則傳回 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  如果 I/O 作業同步完成，則傳回 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A>方法會啟動非同步傳送作業中指定遠端主機<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性`e`參數。 呼叫<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法可讓您傳送不同的執行緒中的資料。 雖然這個方法適用於無連接的通訊協定<xref:System.Net.Sockets.Socket.SendToAsync%2A>無連線和連線導向的通訊協定的運作方式。  
  
 若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並附加至回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>之前先呼叫需要任何使用者的狀態物件的屬性<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法，如此將可在回呼方法中擷取資訊。 如果回呼必須比單一物件的詳細資訊，您就可以建立小型類別保存做為成員的其他必要的狀態資訊。  
  
 如果您使用連線導向的通訊協定，您必須先呼叫<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。 否則<xref:System.Net.Sockets.Socket.SendToAsync%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 當使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法將會忽略<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性，並將傳送資料至<xref:System.Net.EndPoint?displayProperty=nameWithType>中建立<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。  
  
 如果您使用無連接的通訊協定，您不需要建立預設遠端主機與<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendToAsync%2A>。 您只需要執行這項操作，如果您想要呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>或<xref:System.Net.Sockets.Socket.SendAsync%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendToAsync%2A>、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性將會覆寫指定的預設遠端主機，如，傳送作業只。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法。 在此情況下，基礎的服務提供者將會指派最適當的區域網路 IP 位址和連接埠號碼。 如果您希望基礎的服務提供者，選取可用的通訊埠，請使用零的連接埠號碼。 如果您需要識別指派的本機網路 IP 位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件發出信號和呼叫相關聯的委派。  
  
 如果您想要將資料傳送至廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法並將通訊端選項<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>為 true。 您也必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包。 如果是的話，將不會傳送資料包和<xref:System.Net.Sockets.Socket.SendToAsync%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定中的 DontRoute 旗標<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>屬性，將不會路由傳送的資料。  
  
 訊息導向的通訊端，必須小心不必超過訊息大小上限為基礎的傳輸。 如果緩衝區的大小超過最大的封包大小基礎的服務提供者，不會傳送資料包和<xref:System.Net.Sockets.Socket.SendToAsync%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 成功完成<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法並不表示已成功傳送資料。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不可以是 null。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定的通訊協定是連接導向的，但尚未連接 <see cref="T:System.Net.Sockets.Socket" />。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">要設定在這個通訊端上的 IP 保護層級。</param>
        <summary>設定通訊端上的 IP 保護層級。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>方法可讓限制來接聽指定的範圍，例如具有相同位址連結本機或網站本機首碼的 IPv6 或 IP 通訊端。 這個通訊端選項可讓應用程式置於 IPv6 或 IP 通訊端的存取限制。 這類限制可以讓應用程式在私人 LAN 上執行，簡便又穩當地強化應用程式對外部攻擊的抵禦。 這個通訊端選項也可用來移除存取限制，如果`level`參數設定為<xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>。 這個通訊端選項可放大或縮小接聽通訊端的範圍，根據需要啟用公用和私用使用者的無限制存取，或視需要限制成僅可存取相同的站台。  
  
 這個通訊端選項已定義 <xref:System.Net.Sockets.IPProtectionLevel> 列舉中所指定的保護層級。  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>方法用來啟用或停用網路位址周遊 (NAT) 的<xref:System.Net.Sockets.Socket>執行個體。 您可以使用 Teredo、 6to4 或 ISATAP 通道提供 NAT 周遊。  
  
 當`level`參數設定為<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>，或<xref:System.Net.Sockets.IPProtectionLevel.Restricted>，這明確停用的 NAT 周遊<xref:System.Net.Sockets.Socket>執行個體。  
  
 當`level`參數設定為<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>，這可能會讓 NAT 周遊<xref:System.Net.Sockets.Socket>根據在系統上的防火牆規則。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="level" /> 參數不可為 <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />。 IP 保護層級不能設定為未指定。</exception>
        <exception cref="T:System.NotSupportedException">通訊端的 <see cref="T:System.Net.Sockets.AddressFamily" /> 必須是 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 或  <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />。</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>設定 <see cref="T:System.Net.Sockets.Socket" /> 選項。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionValue">選項的值，表示為 <see cref="T:System.Boolean" />。</param>
        <summary>將指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設為指定的 <see cref="T:System.Boolean" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 設定`optionValue`至`true`啟用選項，或`false`停用選項。  
  
 <xref:System.Net.Sockets.Socket> 選項會分組層級的通訊協定支援。  
  
 以下列出各種<xref:System.Net.Sockets.Socket>可以使用這個多載來設定的選項。 這些選項會依適當分組<xref:System.Net.Sockets.SocketOptionLevel>值。 如果您想要設定任何這些選項，請務必使用適當<xref:System.Net.Sockets.SocketOptionLevel>值`optionLevel`參數。 若要設定您選擇的選項中必須指定`optionName`參數。 如果您想要取得任何所列的選項的目前值，請使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 您可以將使用這個多載的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 您可以將使用這個多載的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 您可以將使用這個多載的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 您可以將使用這個多載的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 如需有關這些選項的詳細資訊，請參閱<xref:System.Net.Sockets.SocketOptionName>列舉型別。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
   
  
## Examples  
 下列程式碼範例會開啟通訊端，並可讓`DontLinger`和`OutOfBandInline`通訊端選項。  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionValue">
          <see cref="T:System.Byte" /> 型別的陣列，表示選項的值。</param>
        <summary>將指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設定為指定值，表示為位元組陣列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 使用這個多載，來設定那些<xref:System.Net.Sockets.Socket>需要做為選項值的位元組陣列的選項。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionValue">選項的值。</param>
        <summary>將指定 <see cref="T:System.Net.Sockets.Socket" /> 選項設定為指定的整數值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 選項與<xref:System.Boolean>資料類型，請啟用選項，則為非零值和零值，以停用此選項。 具有整數資料類型的選項，指定適當的值。 <xref:System.Net.Sockets.Socket> 選項會分組層級的通訊協定支援。  
  
 以下列出各種<xref:System.Net.Sockets.Socket>可以使用這個多載來設定的選項。 這些選項會依適當分組<xref:System.Net.Sockets.SocketOptionLevel>。 如果您想要設定任何這些選項，請務必使用適當<xref:System.Net.Sockets.SocketOptionLevel>如`optionLevel`參數。 若要設定您選擇的選項中必須指定`optionName`參數。 如果您想要取得任何所列的選項的目前值，請使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 您可以將使用這個多載的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 您可以將使用這個多載的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 您可以將使用這個多載的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 您可以將使用這個多載的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> 您可以將使用這個多載的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 如需有關這些選項的詳細資訊，請參閱<xref:System.Net.Sockets.SocketOptionName>列舉型別。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionValue">
          <see cref="T:System.Net.Sockets.LingerOption" /> 或 <see cref="T:System.Net.Sockets.MulticastOption" />，包含選項值。</param>
        <summary>將指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設定為指定值，表示為物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 若要設定使用這個多載<xref:System.Net.Sockets.SocketOptionName.Linger>， <xref:System.Net.Sockets.SocketOptionName.AddMembership>，和<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>選項。 如<xref:System.Net.Sockets.SocketOptionName.Linger>選項，請使用<xref:System.Net.Sockets.Socket>如`optionLevel`參數。 如<xref:System.Net.Sockets.SocketOptionName.AddMembership>和<xref:System.Net.Sockets.SocketOptionName.DropMembership>，使用<xref:System.Net.Sockets.SocketOptionLevel.IP>。 如果您想要取得任何上述選項的目前值，請使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">其中一個 <see cref="T:System.Net.Sockets.SocketShutdown" /> 值，指定將不再允許的作業。</param>
        <summary>暫停 <see cref="T:System.Net.Sockets.Socket" /> 上的傳送和接收作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用連線導向<xref:System.Net.Sockets.Socket>，務必呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>方法在關閉前的<xref:System.Net.Sockets.Socket>。 這可確保所有資料都傳送及接收連線的通訊端上之前它已關閉。  
  
 呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法來釋放所有 managed 和 unmanaged 資源相關聯<xref:System.Net.Sockets.Socket>。 請勿嘗試重複使用<xref:System.Net.Sockets.Socket>關閉後。  
  
 下表顯示<xref:System.Net.Sockets.SocketShutdown>列舉值的有效`how`參數。  
  
|值|描述|  
|-----------|-----------------|  
|傳送|停用傳送這個<xref:System.Net.Sockets.Socket>。|  
|接收|停用接收此<xref:System.Net.Sockets.Socket>。|  
|兩種模式|停用傳送和接收此<xref:System.Net.Sockets.Socket>。|  
  
 設定`how`至<xref:System.Net.Sockets.SocketShutdown.Send>指定後續的呼叫<xref:System.Net.Sockets.Socket.Send%2A>不允許。 如果您使用無連線<xref:System.Net.Sockets.Socket>，並指定<xref:System.Net.Sockets.SocketShutdown.Send>會有任何作用。  
  
 設定`how`至<xref:System.Net.Sockets.SocketShutdown.Receive>指定後續的呼叫<xref:System.Net.Sockets.Socket.Receive%2A>不允許。 這會有較低的通訊協定層不會影響。 如果您使用連線導向的通訊協定，則連線會終止，如果下列條件存在之後呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>:  
  
-   正在等待接收內送的網路緩衝區的資料。  
  
-   詳細資料已送達。  
  
 如果您使用無連接的通訊協定，資料包所接受和排入佇列。 不過，如果沒有緩衝區空間供其他傳入資料包，都會被捨棄，寄件者會傳回任何錯誤。 使用<xref:System.Net.Sockets.Socket.Shutdown%2A>上無連線<xref:System.Net.Sockets.Socket>不建議使用。  
  
 設定`how`至<xref:System.Net.Sockets.SocketShutdown.Both>停用這兩個傳送和接收 （如上所述）。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>呼叫時<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，請使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.Socket.Shutdown%2A>停用<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Net.Sockets.Socket" /> 的類型。</summary>
        <value>其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> 是唯讀的而且會設定當<xref:System.Net.Sockets.Socket>建立。  
  
   
  
## Examples  
 下列程式碼範例顯示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>至主控台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 IPv4 支援是否可用並在目前的主機上啟用。</summary>
        <value>如果目前的主機支援 IPv4 通訊協定，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作業系統可能會支援 IPv4 和 IPv6 通訊協定。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出「架構」是否對某些已過時 <see cref="T:System.Net.Dns" /> 成員支援 IPv6。</summary>
        <value>如果「架構」對某些已過時的 <see cref="T:System.Net.Dns" /> 方法支援 IPv6，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作業系統可能會支援 IPv4 和 IPv6 通訊協定。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 傳送之網際網路通訊協定 (IP) 封包的存留時間 (TTL) 值。</summary>
        <value>TTL 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 值會指出最大的封包可以周遊路由器捨棄封包，以及網際網路控制訊息通訊協定 (ICMP) 」 已經超過 TTL"之前的路由器數目寄件者會傳回錯誤訊息。  
  
 TTL 值可能設定的值，從 0 到 255。 當未設定這個屬性時，通訊端的預設 TTL 值為 32。  
  
 如果已建立成功的連線使用通訊端傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會忽略 TCP/IP 堆疊。  
  
 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得這個程式碼之後，請參閱 Windows Sockets 版本 2 API 錯誤的程式碼文件 MSDN library 中如需詳細的錯誤說明。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Net.Sockets.Socket.Ttl%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 值不能設定為負數。</exception>
        <exception cref="T:System.NotSupportedException">這個屬性只可為 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 家族中的通訊端設定。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 當嘗試將 TTL 設定為大於 255 的值時，也會傳回這個錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定通訊端是否只應使用重疊的 I/O 模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 只使用重疊的 I/O，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將此屬性設定為`true`如<xref:System.Net.Sockets.Socket>您想要呼叫<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。 否則，架構可能會指派完成連接埠通訊端，會禁止使用<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通訊端已繫結至完成通訊埠。</exception>
      </Docs>
    </Member>
  </Members>
</Type>