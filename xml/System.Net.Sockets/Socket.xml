<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6808af7c97188ea08a3159ec1991b02538d2e81c" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58702284" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>實作 Berkeley 通訊端介面。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>類別提供一組豐富的方法和屬性進行網路通訊。 <xref:System.Net.Sockets.Socket>類別可讓您執行同步和非同步資料傳輸使用任何通訊協定中所列<xref:System.Net.Sockets.ProtocolType>列舉型別。  
  
 <xref:System.Net.Sockets.Socket>類別遵循非同步方法的.NET Framework 命名模式。 例如，同步<xref:System.Net.Sockets.Socket.Receive%2A>方法對應於非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>和<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。  
  
 如果您的應用程式只需要一個執行緒在執行期間，使用下列方法，專為同步作業模式。  
  
-   如果您使用連線導向的通訊協定，例如 TCP，您的伺服器可以接聽連線使用<xref:System.Net.Sockets.Socket.Listen%2A>方法。 <xref:System.Net.Sockets.Socket.Accept%2A>方法會處理任何連入連線要求，並傳回<xref:System.Net.Sockets.Socket>可用來與遠端主機通訊資料。 使用此傳回<xref:System.Net.Sockets.Socket>來呼叫<xref:System.Net.Sockets.Socket.Send%2A>或<xref:System.Net.Sockets.Socket.Receive%2A>方法。 呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.Listen%2A>方法，如果您想要指定本機 IP 位址和連接埠號碼。 如果您想要指派給您的 可用的連接埠基礎的服務提供者，請使用連接埠號碼為零。 如果您想要連線到接聽的主機，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法。 若要進行通訊的資料，呼叫<xref:System.Net.Sockets.Socket.Send%2A>或<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
-   如果您使用無連線的通訊協定，例如 UDP，則您不需要完全接聽連線。 呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，以接受任何內送的資料包。 使用<xref:System.Net.Sockets.Socket.SendTo%2A>資料包傳送至遠端主機的方法。  
  
 若要處理執行期間使用個別執行緒的通訊，請使用下列方法，專為非同步作業模式。  
  
-   如果您使用連線導向的通訊協定，例如 TCP，使用<xref:System.Net.Sockets.Socket>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>，和<xref:System.Net.Sockets.Socket.EndConnect%2A>方法來連線到接聽的主機。 使用<xref:System.Net.Sockets.Socket.BeginSend%2A>並<xref:System.Net.Sockets.Socket.EndSend%2A>或是<xref:System.Net.Sockets.Socket.BeginReceive%2A>和<xref:System.Net.Sockets.Socket.EndReceive%2A>方法進行非同步通訊資料。 可以使用處理內送連接要求<xref:System.Net.Sockets.Socket.BeginAccept%2A>和<xref:System.Net.Sockets.Socket.EndAccept%2A>。  
  
-   如果您使用無連線的通訊協定，例如 UDP，您可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>並<xref:System.Net.Sockets.Socket.EndSendTo%2A>傳送資料包，並<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>和<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>來接收資料包。  
  
 如果您執行多個通訊端上的非同步作業時，沒有一定是在完成會在啟動的順序。  
  
 當您完成傳送和接收資料，請使用<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以停用<xref:System.Net.Sockets.Socket>。 之後呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法來釋放相關聯的所有資源<xref:System.Net.Sockets.Socket>。  
  
 <xref:System.Net.Sockets.Socket>類別可讓您設定您<xref:System.Net.Sockets.Socket>使用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。 擷取使用這些設定<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果您正在撰寫相當簡單的應用程式，並不需要最大效能，請考慮使用<xref:System.Net.Sockets.TcpClient>， <xref:System.Net.Sockets.TcpListener>，和<xref:System.Net.Sockets.UdpClient>。 這些類別提供更簡單且更方便使用的介面來<xref:System.Net.Sockets.Socket>通訊。  
  
   
  
## Examples  
 下列程式碼範例示範如何<xref:System.Net.Sockets.Socket>類別可用來將資料傳送至 HTTP 伺服器，並接收回應。 此範例會封鎖直到收到整個頁面。  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">若要建立傳出連線，或接受連入要求。</permission>
    <threadsafe>此類別的執行個體都是安全執行緒。</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">以 .NET Framework 進行網路程式設計</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">System.Net 類別的最佳作法</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">網路應用程式的快取管理</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">網際網路通訊協定第 6 版</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">網路程式設計範例</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">以 .NET Framework 進行網路追蹤</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">網路程式設計的安全性</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">3.5 版中的通訊端效能增強功能</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Net.Sockets.Socket" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 傳回的通訊端資訊。</param>
        <summary>使用從 <see cref="T:System.Net.Sockets.Socket" /> 傳回的指定值，初始化 <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您呼叫<xref:System.Net.Sockets.Socket.%23ctor%2A>多次使用相同的位元組陣列，為每個呼叫的引數的建構函式，您將建立受管理的多個<xref:System.Net.Sockets.Socket>秒，使用相同的基礎通訊端。 這種做法不鼓勵。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</param>
        <param name="protocolType">其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</param>
        <summary>使用指定的通訊端類型和通訊協定，初始化 <see cref="T:System.Net.Sockets.Socket" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType`參數指定的型別<xref:System.Net.Sockets.Socket>類別和`protocolType`參數指定所使用的通訊協定<xref:System.Net.Sockets.Socket>。 兩個參數不是獨立的。 通常<xref:System.Net.Sockets.Socket>類型是隱含的通訊協定。 如果的組合<xref:System.Net.Sockets.Socket>類型和通訊協定的結果則會在無效的類型<xref:System.Net.Sockets.Socket>，這個建構函式會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果這個建構函式會擲回<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketType" /> 和 <paramref name="protocolType" /> 組合產生無效通訊端。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">其中一個 <see cref="T:System.Net.Sockets.AddressFamily" /> 值。</param>
        <param name="socketType">其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</param>
        <param name="protocolType">其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</param>
        <summary>使用指定的通訊協定家族 (Family)、通訊端類型和通訊協定，初始化 <see cref="T:System.Net.Sockets.Socket" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily`參數指定的位址配置<xref:System.Net.Sockets.Socket>類別使用，`socketType`參數指定的型別<xref:System.Net.Sockets.Socket>類別，而`protocolType`參數指定所使用的通訊協定<xref:System.Net.Sockets.Socket>。 三個參數不是獨立的。 有些位址家族限制可以使用哪些通訊協定，與它們，且經常<xref:System.Net.Sockets.Socket>類型是隱含的通訊協定。 如果位址家族的組合<xref:System.Net.Sockets.Socket>類型和類型中無效時，產生的通訊協定<xref:System.Net.Sockets.Socket>，這個建構函式會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果這個建構函式會擲回<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立的執行個體<xref:System.Net.Sockets.Socket>類別。  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="addressFamily" />、<paramref name="socketType" /> 和 <paramref name="protocolType" /> 組合所產生的無效通訊端。</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立新建立連接的新 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>新建立連接的新 <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> 以同步方式暫止連接要求的第一個擷取連線要求的佇列接聽的通訊端，然後建立並傳回新<xref:System.Net.Sockets.Socket>。 您無法使用此傳回<xref:System.Net.Sockets.Socket>接受任何其他的連線，連線佇列中。 不過，您可以呼叫<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>方法傳回的<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼。  
  
 處於封鎖模式，<xref:System.Net.Sockets.Socket.Accept%2A>封鎖，直到連入連線嘗試會排入佇列。 接受連接時，原始<xref:System.Net.Sockets.Socket>繼續佇列的連入連線要求直到您關閉它。  
  
 如果您呼叫這個方法，使用非封鎖<xref:System.Net.Sockets.Socket>，且要求會排入佇列，沒有連線<xref:System.Net.Sockets.Socket.Accept%2A>就會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法中，您必須先呼叫<xref:System.Net.Sockets.Socket.Listen%2A>來接聽並連入連線要求排入佇列的方法。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例接受簡單<xref:System.Net.Sockets.Socket>連接。  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">接受的通訊端並未接聽連線。 您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.Accept" />。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始非同步作業以接受連入的連接嘗試。</summary>
        <returns>若 I/O 作業暫止，則為 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 若 I/O 作業同步完成，則為 <see langword="false" />。 不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法以非同步方式處理連入連線嘗試。 以非同步方式接受連線，讓您能夠傳送和接收不同的執行緒內的資料。 然後再呼叫<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>來接聽並連入連線要求排入佇列的方法。  
  
 若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並將它以連結<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件所需：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可以選擇性地指定的現有<xref:System.Net.Sockets.Socket>要用於連入連線，藉由指定<xref:System.Net.Sockets.Socket>搭配使用<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>屬性。  
  
 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>屬性是 null，新<xref:System.Net.Sockets.Socket>建構具有相同<xref:System.Net.Sockets.Socket.AddressFamily%2A>， <xref:System.Net.Sockets.Socket.SocketType%2A>，並<xref:System.Net.Sockets.Socket.ProtocolType%2A>與目前<xref:System.Net.Sockets.Socket>並將設為<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>屬性。  
  
 呼叫端可能會設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>呼叫之前所需的任何使用者狀態物件的屬性<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法，如此會在回呼方法中擷取資訊。 如果回呼需要比單一物件的詳細資訊，就可以建立小型的類別來保存為成員的其他必要的狀態資訊。  
  
 （選擇性） 緩衝區可能會提供用來接收之後在通訊端上的資料的初始區塊<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在此情況下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>屬性必須設定為包含資料的緩衝區，以接收和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性必須設為接收緩衝區中資料的位元組數目上限。 可以設定這些屬性，使用<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>方法。 傳入緩衝區的一部分會可供內部使用基礎 Winsock 發生 AcceptEx 呼叫。 這表示傳回的資料量會一律的值小於<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性上的<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>提供執行個體。 在內部使用的緩衝區數量而有所不同的通訊端通訊協定家族。 所需的最小緩衝區大小是 288 個位元組。 如果指定較大的緩衝區大小，則<xref:System.Net.Sockets.Socket>就會預期收到一些額外的資料以外的 Winsock 發生 AcceptEx 呼叫所收到的資料，並會等候，直到接收到此額外的資料。 如果發生逾時，會重設連接。 因此如果特定數量的預期額外的資料，則緩衝區大小應該設為最小緩衝區大小，加上此數量。  
  
 完成回呼方法應該檢查<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>屬性來判斷<xref:System.Net.Sockets.Socket.AcceptAsync%2A>作業是否成功。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件可能發生在某些情況下，已接受沒有連線時，導致<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>屬性設為<xref:System.Net.Sockets.SocketError.ConnectionReset>。 這可能是因為連接埠掃描使用半開啟 SYN 類型掃描 (SYN]-> [同步認可]-> [RST 順序)。 使用應用程式<xref:System.Net.Sockets.Socket.AcceptAsync%2A>方法應該準備好處理這個狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引數無效。 如果提供的緩衝區不夠大，就會發生這個例外狀況。 緩衝區必須至少為 2 * (sizeof(SOCKADDR_STORAGE + 16) 位元組。  
  
如果指定多個緩衝區而 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性不是 null，也會發生這個例外狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">引數超出範圍。 如果 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> 小於 0，就會發生這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException">要求了無效的作業。 如果接受的 <see cref="T:System.Net.Sockets.Socket" /> 不接聽連接或接受的通訊端已繫結，就會發生這個例外狀況。  
  
您必須先呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 和 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 方法，再呼叫 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法。  
  
此例外狀況也會在已與通訊端連線，或是通訊端作業已使用指定的 <paramref name="e" /> 參數進行時發生。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Net.Sockets.Socket" /> 的通訊協定家族 (Family)。</summary>
        <value>其中一個 <see cref="T:System.Net.Sockets.AddressFamily" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily>指定的位址配置的執行個體<xref:System.Net.Sockets.Socket>類別可以使用。 這個屬性是唯讀的而且時，會設定<xref:System.Net.Sockets.Socket>建立。  
  
   
  
## Examples  
 下列程式碼範例會顯示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>到主控台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得已從網路接收且可供讀取的資料量。</summary>
        <value>從網路收到的和可供讀取的資料位元組數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用非封鎖<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Available%2A>是一個好的方法，以判斷資料是否已排入佇列進行讀取，然後再呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 可用的資料是總資料量已排入佇列進行讀取的網路緩衝區中。 如果沒有資料會排入佇列中的網路緩衝區中，<xref:System.Net.Sockets.Socket.Available%2A>會傳回 0。  
  
 如果遠端主機關機或關閉連接，<xref:System.Net.Sockets.Socket.Available%2A>可能會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會比較呼叫 IOControl FIONREAD 與可用屬性的結果。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始非同步作業以接受連入的連接嘗試。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>開始非同步作業以接受連入的連接嘗試。</summary>
        <returns>參考非同步 <see cref="T:System.IAsyncResult" /> 建立作業的 <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以非同步方式處理連入連線嘗試。 以非同步方式接受連線，讓您能夠傳送和接收不同的執行緒內的資料。 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>來接聽並連入連線要求排入佇列的方法。  
  
 您必須建立回呼方法可實作<xref:System.AsyncCallback>委派，並將其名稱來傳遞<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 若要這樣做，請在非常小，您必須傳遞接聽<xref:System.Net.Sockets.Socket>物件至<xref:System.Net.Sockets.Socket.BeginAccept%2A>透過`state`參數。 如果回呼需要更多的資訊時，您可以建立小型類別以包裝<xref:System.Net.Sockets.Socket>和其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，透過`state`參數。  
  
 您的回呼方法應該叫用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系統通常會使用個別的執行緒來執行指定的回呼方法，並封鎖上<xref:System.Net.Sockets.Socket.EndAccept%2A>之前擷取暫止的連接。 <xref:System.Net.Sockets.Socket.EndAccept%2A> 會傳回新<xref:System.Net.Sockets.Socket>物件，您可以用來傳送和接收資料，與遠端主機。 您無法使用此傳回<xref:System.Net.Sockets.Socket>接受任何其他的連線，連線佇列中。 如果您想封鎖之後呼叫的原始執行緒<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行的原始執行緒時。  
  
 系統可能也會使用呼叫執行緒叫用回呼方法。 在此情況下，<xref:System.IAsyncResult.CompletedSynchronously%2A>對傳回的屬性<xref:System.IAsyncResult>將會設定為表示<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以同步方式完成。  
  
 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消擱置中的呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時，會呼叫方法，來提供回呼<xref:System.Net.Sockets.Socket.BeginAccept%2A>呼叫方法。  後續呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
> [!NOTE]
>  您可以使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性傳回之<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會嘗試以非同步方式接收連入連線。  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">接受的通訊端並未接聽連線。 您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  
  
-或- 
接受的通訊端已繫結。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> 小於 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize">要從寄件者接受的位元組數。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>開始非同步作業以接收連入連線嘗試，並接收用戶端應用程式傳送的第一個資料區塊。</summary>
        <returns>參考非同步 <see cref="T:System.IAsyncResult" /> 建立作業的 <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以非同步方式處理連入連線嘗試。 以非同步方式接受連線，可讓您傳送和接收不同的執行緒內的資料。 這個多載可讓您指定要接受在初始中傳送的位元組數目`receiveSize`參數。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>來接聽並連入連線要求排入佇列的方法。  
  
 您必須建立回呼方法可實作<xref:System.AsyncCallback>委派，並將其名稱來傳遞<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 若要這樣做，請在非常小，您必須傳遞接聽<xref:System.Net.Sockets.Socket>物件至<xref:System.Net.Sockets.Socket.BeginAccept%2A>透過`state`參數。 如果回呼需要更多的資訊時，您可以建立小型類別以包裝<xref:System.Net.Sockets.Socket>和其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，透過`state`參數。  
  
 您的回呼方法應該叫用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系統通常會使用個別的執行緒來執行指定的回呼方法，並封鎖上<xref:System.Net.Sockets.Socket.EndAccept%2A>之前擷取暫止的連接。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 傳回新<xref:System.Net.Sockets.Socket>可用來傳送和接收資料，與遠端主機。 您無法使用此傳回<xref:System.Net.Sockets.Socket>接受任何其他的連線，連線佇列中。 如果您想封鎖之後呼叫的原始執行緒<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行的原始執行緒時。  
  
 系統可能也會使用呼叫執行緒叫用回呼方法。 在此情況下，<xref:System.IAsyncResult.CompletedSynchronously%2A>對傳回的屬性<xref:System.IAsyncResult>將會設定為表示<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以同步方式完成。  
  
 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消擱置中的呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，關閉<xref:System.Net.Sockets.Socket>。  當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時，會呼叫方法，來提供回呼<xref:System.Net.Sockets.Socket.BeginAccept%2A>呼叫方法。  後續呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
> [!NOTE]
>  您可以呼叫使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性傳回的<xref:System.Net.Sockets.Socket>物件來識別遠端主機的網路位址和連接埠號碼。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會開啟通訊端，並接受非同步連線。 在此範例中，通訊端會接受初始的 10 個位元組的資料。 接收的位元組數目和資料會顯示在主控台上的回呼委派。 請參閱<xref:System.Net.Sockets.Socket.BeginReceive%2A>的收到的剩餘資料的方式說明。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">接受的通訊端並未接聽連線。 您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  
  
-或- 
接受的通訊端已繫結。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> 小於 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">已接受的 <see cref="T:System.Net.Sockets.Socket" /> 物件。 此值可為 <see langword="null" />。</param>
        <param name="receiveSize">要接收的最大位元組數。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>開始非同步作業以接收指定通訊端的連入連線嘗試，並接收用戶端應用程式傳送的第一個資料區塊。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 物件，參考非同步 <see cref="T:System.Net.Sockets.Socket" /> 物件建立。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以使用連線導向的通訊協定<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以非同步方式處理連入連線嘗試。 以非同步方式接受連線，讓您能夠傳送和接收不同的執行緒內的資料。 這個多載可讓您指定可接受通訊端`acceptSocket`參數。 如果這個參數是`null`，接受的通訊端由<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 您可以指定要接受在初始中傳送的位元組數目`receiveSize`參數。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，您必須呼叫<xref:System.Net.Sockets.Socket.Listen%2A>來接聽並連入連線要求排入佇列的方法。  
  
 您必須建立回呼方法可實作<xref:System.AsyncCallback>委派，並將其名稱來傳遞<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 若要這樣做，請在非常小，您必須傳遞接聽<xref:System.Net.Sockets.Socket>物件至<xref:System.Net.Sockets.Socket.BeginAccept%2A>透過`state`參數。 如果回呼需要更多的資訊時，您可以建立小型類別以包裝<xref:System.Net.Sockets.Socket>和其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，透過`state`參數。  
  
 您的回呼方法應該叫用<xref:System.Net.Sockets.Socket.EndAccept%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，系統通常會使用個別的執行緒來執行指定的回呼方法，並封鎖上<xref:System.Net.Sockets.Socket.EndAccept%2A>之前擷取暫止的連接。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 傳回新<xref:System.Net.Sockets.Socket>物件，您可以用來傳送和接收資料，與遠端主機。 您無法使用此傳回<xref:System.Net.Sockets.Socket>接受任何其他的連線，連線佇列中。 如果您想封鎖之後呼叫的原始執行緒<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行的原始執行緒時。  
  
 系統可能也會使用呼叫執行緒叫用回呼方法。 在此情況下，<xref:System.IAsyncResult.CompletedSynchronously%2A>對傳回的屬性<xref:System.IAsyncResult>將會設定為表示<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法以同步方式完成。  
  
 如需有關如何撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 若要取消擱置中的呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時，會呼叫方法，來提供回呼<xref:System.Net.Sockets.Socket.BeginAccept%2A>呼叫方法。  後續呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
> [!NOTE]
>  您可以使用<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性傳回的<xref:System.Net.Sockets.Socket>物件來識別遠端主機的網路位址和連接埠號碼。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會開啟通訊端，並接受非同步連線。 在此範例中，通訊端接受初始的 10 個位元組的資料並`acceptSocket`參數是`null`，可以強制<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法用來建立接受通訊端。 接收的位元組數目和資料會顯示在主控台上的回呼委派。 請參閱<xref:System.Net.Sockets.Socket.BeginReceive%2A>的收到的剩餘資料的方式說明。  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.InvalidOperationException">接受的通訊端並未接聽連線。 您必須在呼叫 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 之前呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 和 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />。  
  
-或- 
接受的通訊端已繫結。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> 小於 0。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始遠端主機連接的非同步要求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，表示遠端主機。</param>
        <param name="end_point"><see cref="T:System.Net.EndPoint" />，表示遠端主機。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>開始遠端主機連接的非同步要求。</summary>
        <returns>參考非同步連接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法會啟動連線到的非同步要求`remoteEP`參數。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.BeginConnect%2A>建立預設遠端主機。 連接或以非同步方式設定預設遠端主機可讓您能夠傳送和接收不同的執行緒內的資料。  
  
 您可以建立回呼方法可實作<xref:System.AsyncCallback>委派，並將其名稱來傳遞<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法。 至少，您必須傳遞<xref:System.Net.Sockets.Socket>要<xref:System.Net.Sockets.Socket.BeginConnect%2A>透過`state`參數。 如果回呼需要更多的資訊時，您可以建立小型類別以包裝<xref:System.Net.Sockets.Socket>，以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，透過`state`參數。  
  
 您的回呼方法應該叫用<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndConnect%2A>直到<xref:System.Net.Sockets.Socket>成功連線，或擲回例外狀況。 如果您想封鎖之後呼叫的原始執行緒<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A>。 在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行的原始執行緒時。 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 如果您使用無連線的通訊協定，例如 UDP，您就不必呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>和<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>與遠端主機通訊。 如果您呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，將會捨棄任何資料包來自指定的預設值以外的位址。 如果您想要設定預設遠端主機的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>且設定為廣播`true`。 如果您不能<xref:System.Net.Sockets.Socket.BeginConnect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您使用連線導向的通訊協定並不會呼叫<xref:System.Net.Sockets.Socket.Bind%2A>再呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，基礎的服務提供者會指派最適當的區域網路位址和連接埠號碼。 如果您使用無連接的通訊協定，服務提供者將未指派本機網路位址和連接埠號碼直到您呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>或<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法一次所需的端點。  
  
 若要取消擱置中的呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時，會呼叫方法，來提供回呼<xref:System.Net.Sockets.Socket.BeginConnect%2A>呼叫方法。  後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  如果這個通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束的執行緒上呼叫。 這是基礎提供者的限制。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會起始非同步連接嘗試。  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">遠端主機的 <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> 委派，會於連接作業完成時參考要叫用的方法。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派，會於連接作業完成時參考要叫用的方法。</param>
        <param name="state">包含連線作業資訊的使用者定義物件。 作業完成時會將這個物件傳遞至 <paramref name="requestCallback" /> 委派。</param>
        <summary>開始遠端主機連接的非同步要求。 此主機是由 <see cref="T:System.Net.IPAddress" /> 和連接埠號碼所指定。</summary>
        <returns>參考非同步連接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 一般而言，會叫用方法`requestCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Connect%2A>方法多載，或<xref:System.Net.Sockets.Socket.EndConnect%2A>。  
  
 若要取消擱置中的呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時，會呼叫方法，來提供回呼<xref:System.Net.Sockets.Socket.BeginConnect%2A>呼叫方法。  後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  如果這個通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束的執行緒上呼叫。 這是基礎提供者的限制。 也<xref:System.Net.EndPoint>也就是使用必須不同。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會起始非同步連接嘗試。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.Socket" /> 不在通訊端系列。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的長度為零。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">至少一個 <see cref="T:System.Net.IPAddress" />，指定遠端主機。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> 委派，會於連接作業完成時參考要叫用的方法。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派，會於連接作業完成時參考要叫用的方法。</param>
        <param name="state">包含連線作業資訊的使用者定義物件。 作業完成時會將這個物件傳遞至 <paramref name="requestCallback" /> 委派。</param>
        <summary>開始遠端主機連接的非同步要求。 主機是由 <see cref="T:System.Net.IPAddress" /> 陣列和通訊埠編號指定。</summary>
        <returns><see cref="T:System.IAsyncResult" />，其會參考非同步連接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 一般而言，會叫用方法`requestCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Connect%2A>方法多載。  
  
 若要取消擱置中的呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時，會呼叫方法，來提供回呼<xref:System.Net.Sockets.Socket.BeginConnect%2A>呼叫方法。  後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱 < [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  如果這個通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束的執行緒上呼叫。 這是基礎提供者的限制。 也<xref:System.Net.EndPoint>也就是使用必須不同。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會起始非同步連接嘗試。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法對使用 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 的通訊端有效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的長度為零。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">遠端主機的名稱。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <param name="requestCallback"><see cref="T:System.AsyncCallback" /> 委派，會於連接作業完成時參考要叫用的方法。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派，會於連接作業完成時參考要叫用的方法。</param>
        <param name="state">包含連線作業資訊的使用者定義物件。 作業完成時會將這個物件傳遞至 <paramref name="requestCallback" /> 委派。</param>
        <summary>開始遠端主機連接的非同步要求。 此主機是由主機名稱和連接埠號碼指定。</summary>
        <returns>參考非同步連接的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 一般而言，會叫用方法`requestCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Connect%2A>方法多載。  
  
 若要取消擱置中的呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，關閉<xref:System.Net.Sockets.Socket>。 當<xref:System.Net.Sockets.Socket.Close%2A>非同步作業正在進行時，會呼叫方法，來提供回呼<xref:System.Net.Sockets.Socket.BeginConnect%2A>呼叫方法。  後續呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法會擲回<xref:System.ObjectDisposedException>來指出已取消作業。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  如果這個通訊端先前已中斷連線，然後<xref:System.Net.Sockets.Socket.BeginConnect%2A>必須在作業完成之前，不會結束的執行緒上呼叫。 這是基礎提供者的限制。 也<xref:System.Net.EndPoint>也就是使用必須不同。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會起始非同步連接嘗試。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態，或者非同步作業已在進行中。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果這個通訊端可以在關閉連接後重複使用，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>開始非同步要求，以中斷遠端端點的連接。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 物件，參考非同步作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，您可以呼叫<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>方法來要求從遠端端點的中斷連線。 如果`reuseSocket`是`true`，您可以重複使用通訊端。  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>方法會使用個別的執行緒叫用指定的回呼方法。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>方法會封鎖直到暫止中斷連線已完成。 如需有關如何撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立非同步通訊的通訊端，並將部分資料傳送至遠端主機。 當資料已傳送時，<xref:System.Net.Sockets.Socket.Shutdown%2A>稱為停止傳送及接收活動。 然後<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>呼叫以開始中斷連接要求。 要求完成時，<xref:System.Net.Sockets.Socket.Connected%2A>屬性查詢來測試是否已中斷連線的通訊端。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義的物件，包含接收作業的相關資訊。 作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</param>
        <summary>開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 一般而言，會叫用方法`callback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱 < [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義的物件，包含接收作業的相關資訊。 作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</param>
        <summary>開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 一般而言，會叫用方法`callback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱 < [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="offset"><paramref name="buffer" /> 參數中要儲存已接收資料的以零起始的位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義的物件，包含接收作業的相關資訊。 作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</param>
        <summary>開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 一般而言，會叫用方法`callback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱 < [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會開始以非同步方式接收來自已連接的 資料<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="offset"><paramref name="buffer" /> 中存放已接收資料的位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <param name="error"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派，會於作業完成時參考要叫用的方法。</param>
        <param name="state">使用者定義的物件，包含接收作業的相關資訊。 作業完成時會將這個物件傳遞至 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> 委派。</param>
        <summary>開始從已連接的 <see cref="T:System.Net.Sockets.Socket" /> 非同步接收資料。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步<xref:System.Net.Sockets.Socket.BeginReceive%2A>作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法。 一般而言，會叫用方法`callback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Sockets.Socket.Receive%2A>方法多載。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱 < [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">這個 <see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="offset"><paramref name="buffer" /> 參數中要儲存資料的以零起始的位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，表示資料的來源。</param>
        <param name="remote_end"><see cref="T:System.Net.EndPoint" />，表示資料的來源。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>開始從指定的網路裝置非同步接收資料。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法可讓您開始以非同步方式讀取從遠端主機的 無連接的資料包。 呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法可讓您能夠接收不同的執行緒內的資料。  
  
 您可以建立回呼方法可實作<xref:System.AsyncCallback>委派，並將其名稱來傳遞<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果回呼需要更多的資訊時，您可以建立小型類別以包裝<xref:System.Net.Sockets.Socket>和其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法，透過`state`參數。  
  
 您的回呼方法應該叫用<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，系統會使用個別的執行緒來執行指定的回呼方法，它就會封鎖<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>直到<xref:System.Net.Sockets.Socket>讀取資料，或擲回例外狀況。 如果您想封鎖之後呼叫的原始執行緒<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>。 當您想要繼續執行原始執行緒時，呼叫 T:System.Threading.ManualResetEvent 在回呼方法中的 Set 方法。 如需有關如何撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，您必須明確地繫結<xref:System.Net.Sockets.Socket>本機端點，使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，或<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 這個方法會讀取資料到`buffer`參數，而擷取的遠端主機傳送資料的端點。 如需如何擷取此端點的資訊，請參閱<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。 這個方法是最有用，如果您想要以非同步方式接收來自未知的主機或多部主機的 無連接的資料包。 在這些情況下，<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>會讀取到區域網路緩衝區收到第一個加入佇列的資料包。 如果您收到的資料包大於的大小`buffer`，則<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法將會填滿`buffer`盡可能是盡可能，，並擲回的訊息與<xref:System.Net.Sockets.SocketException>。 如果您使用的不可靠的通訊協定，超過的資料將會遺失。 如果您使用可靠的通訊協定、 過多的資料會保留由服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>夠大的緩衝區的方法。  
  
 若要保證，一律會傳回遠端主機的端點，應用程式應該明確繫結<xref:System.Net.Sockets.Socket>本機端點，使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，然後呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法`optionLevel`參數設定為<xref:System.Net.Sockets.SocketOptionLevel.IP>或<xref:System.Net.Sockets.SocketOptionLevel.IPv6>適時`optionName`參數設定為<xref:System.Net.Sockets.SocketOptionName.PacketInformation>，而`optionValue`參數來啟用此選項，然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 否則，可能會遠端主機的端點，並不會傳回當接收者已呼叫之前，傳送者已傳送的資料包數目<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。  
  
 雖然<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>適用於無連線的通訊協定，您可以使用連線導向的通訊協定以及。 如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，或藉由呼叫接受連入連線要求<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法建立，或接受連線之前，您就有<xref:System.Net.Sockets.SocketException>。 您也可以建立預設遠端主機的無連線的通訊協定，才能呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 在這些情況下，任一<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法將會忽略`remoteEP`參數和只接收來自已連接的資料或預設遠端主機。  
  
 使用連線導向的通訊端<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>會讀取位於不超過所指定的位元組數目的資料量`size`參數。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例以非同步方式接收來自遠端主機的無連接的資料包。  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="offset"><paramref name="buffer" /> 參數中要儲存資料的以零起始的位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，表示資料的來源。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，開始以非同步方式接收指定位元組數目的資料至資料緩衝區所指定位置，並儲存端點和封包資訊。</summary>
        <returns>參考非同步讀取的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同步接收作業必須完成呼叫<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>方法。 一般而言，會叫用方法`asyncCallback`委派。  
  
 這個方法不會封鎖直到作業完成為止。 若要封鎖，直到作業完成為止，使用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
 如需使用非同步程式設計模型的詳細資訊，請參閱[Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 這個方法會讀取資料到`buffer`參數，和擷取的遠端主機資料會傳送的端點，以及收到的封包的相關資訊。 如需如何擷取此端點的資訊，請參閱<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>。 這個方法是最有用，如果您想要以非同步方式接收來自未知的主機或多部主機的 無連接的資料包。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中所建立的遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您未先呼叫將會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您能夠傳送不同的執行緒中的資料。  
  
 您可以建立回呼方法可實作<xref:System.AsyncCallback>委派，並將其名稱來傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果回呼需要更多的資訊時，您可以建立的小型類別或結構以容納<xref:System.Net.Sockets.Socket>和其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。  
  
 您的回呼方法應該叫用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。 如果您想封鎖之後呼叫的原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 當您想要繼續執行原始執行緒時，呼叫 T:System.Threading.ManualResetEvent 在回呼方法中的 Set 方法。 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 適用於連線導向的通訊協定，雖然<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連線的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由再次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 您也必須確定您的緩衝區的大小未超過最大的封包大小為基礎的服務提供者無連接的通訊協定。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，您要將不會路由傳送的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 是空的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中所建立的遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您未先呼叫將會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您能夠傳送不同的執行緒中的資料。  
  
 您可以建立回呼方法可實作<xref:System.AsyncCallback>委派，並將其名稱來傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果回呼需要更多的資訊時，您可以建立的小型類別或結構以容納<xref:System.Net.Sockets.Socket>和其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。  
  
 您的回呼方法應該叫用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。 如果您想封鎖之後呼叫的原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 在上呼叫 Set 方法<xref:System.Threading.ManualResetEvent>在回呼方法，當您想要繼續執行的原始執行緒時。 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 適用於連線導向的通訊協定，雖然<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連線的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由再次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 您也必須確定您的緩衝區的大小未超過最大的封包大小為基礎的服務提供者無連接的通訊協定。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，您要將不會路由傳送的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 是空的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</param>
        <param name="offset"><paramref name="buffer" /> 參數中要開始傳送資料的以零起始的位置。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中所建立的遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您未先呼叫將會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您能夠傳送不同的執行緒中的資料。  
  
 您可以建立回呼方法可實作<xref:System.AsyncCallback>委派，並將其名稱來傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果回呼需要更多的資訊時，您可以建立的小型類別或結構以容納<xref:System.Net.Sockets.Socket>和其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。  
  
 您的回呼方法應該叫用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。 如果您想封鎖之後呼叫的原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 當您想要繼續執行原始執行緒時，呼叫 T:System.Threading.ManualResetEvent 在回呼方法中的 Set 方法。 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 適用於連線導向的通訊協定，雖然<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連線的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由再次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 您也必須確定您的緩衝區的大小未超過最大的封包大小為基礎的服務提供者無連接的通訊協定。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，您要將不會路由傳送的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 小於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</param>
        <param name="offset"><paramref name="buffer" /> 參數中要開始傳送資料的以零起始的位置。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>非同步傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>方法會啟動非同步傳送作業中所建立的遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 如果您未先呼叫將會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法可讓您能夠傳送不同的執行緒中的資料。  
  
 您可以建立回呼方法可實作<xref:System.AsyncCallback>委派，並將其名稱來傳遞<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果回呼需要更多的資訊時，您可以建立的小型類別或結構以容納<xref:System.Net.Sockets.Socket>和其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，透過`state`參數。  
  
 您的回呼方法應該叫用<xref:System.Net.Sockets.Socket.EndSend%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSend%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。 如果您想封鎖之後呼叫的原始執行緒<xref:System.Net.Sockets.Socket.BeginSend%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 當您想要繼續執行原始執行緒時，呼叫 T:System.Threading.ManualResetEvent 在回呼方法中的 Set 方法。 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 適用於連線導向的通訊協定，雖然<xref:System.Net.Sockets.Socket.BeginSend%2A>也適用於無連線的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。 可以使用<xref:System.Net.Sockets.Socket.BeginSendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>藉由再次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 您也必須確定您的緩衝區的大小未超過最大的封包大小為基礎的服務提供者無連接的通訊協定。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.BeginSend%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，您要將不會路由傳送的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  `state` 是使用者定義的具現化。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會開始以非同步方式將資料傳送至遠端主機。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 小於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同步用戶端通訊端範例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同步伺服器通訊端範例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將檔案以非同步方式傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">字串，包含要傳送之檔案的路徑和名稱。 這個參數可以是 <see langword="null" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 旗標，將檔案 <paramref name="fileName" /> 傳送至已連接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 物件。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 物件，表示非同步傳送。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載會將該檔案傳送`fileName`要連接的通訊端。 如果`fileName`是在本機目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案的名稱。 萬用字元 ("...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。 如果檔案找不到，例外狀況<xref:System.IO.FileNotFoundException>就會擲回。  
  
 這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。 如需詳細資訊`TransmitFile`函式和它的旗標，請參閱 < [Windows 通訊端](/windows/desktop/WinSock/)文件。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法會啟動非同步傳送作業中所建立的遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>，<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 如果您未先呼叫，會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法可讓您傳送不同的執行緒中的檔案。  
  
 若要完成此作業，您可以建立會叫用的回呼方法<xref:System.AsyncCallback>委派參數。 若要這樣做，在非常小`state`參數必須包含<xref:System.Net.Sockets.Socket>物件正在使用的通訊。 如果回呼需要更多的資訊時，您可以建立類別或結構來保存<xref:System.Net.Sockets.Socket>和其他必要的資訊。 傳遞至這個自訂物件的執行個體<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法，透過`state`參數。  
  
 您的回呼方法必須叫用<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndSendFile%2A>直到<xref:System.Net.Sockets.Socket>會傳送整個檔案，或擲回例外狀況。 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 適用於連線導向的通訊協定，雖然<xref:System.Net.Sockets.Socket.BeginSendFile%2A>也適用於無連線的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 無連接的通訊協定，您必須確定檔案的大小未超過基礎的服務提供者的最大的封包大小。 若是如此，不會傳送資料包並<xref:System.Net.Sockets.Socket.BeginSendFile%2A>會擲回<xref:System.Net.Sockets.SocketException>例外狀況。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會建立並連接通訊端的非同步通訊。 首先，到遠端主機時以非同步方式傳送檔案"text.txt 」。 回呼委派呼叫<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成傳輸。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.NotSupportedException">通訊端未連線至遠端主機。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">字串，包含要傳送之檔案的路徑和名稱。 這個參數可以是 <see langword="null" />。</param>
        <param name="preBuffer">包含傳送檔案前要傳送之資料的 <see cref="T:System.Byte" /> 陣列。 這個參數可以是 <see langword="null" />。</param>
        <param name="postBuffer">包含傳送檔案後要傳送之資料的 <see cref="T:System.Byte" /> 陣列。 這個參數可以是 <see langword="null" />。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值的位元組合。</param>
        <param name="callback">這個作業完成時要叫用的 <see cref="T:System.AsyncCallback" /> 委派。 這個參數可以是 <see langword="null" />。</param>
        <param name="state">使用者定義的物件，包含這個要求的狀態資訊。 這個參數可以是 <see langword="null" />。</param>
        <summary>將檔案和資料緩衝區以非同步方式傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 物件，表示非同步作業。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載都需要您想要傳送的檔案和的位元組合名稱<xref:System.Net.Sockets.TransmitFileOptions>值。 `preBuffer`參數包含您想要在檔案的所有資料。 `postBuffer` 包含您想要按照檔案中的資料。 如果`fileName`是在本機目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案的名稱。 萬用字元 ("...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。 如果檔案找不到，例外狀況<xref:System.IO.FileNotFoundException>就會擲回。  
  
 `flags`參數提供的視窗通訊端服務提供者的檔案傳輸的其他資訊。 如需如何使用此參數的詳細資訊，請參閱<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。 如需詳細資訊`TransmitFile`函式和它的旗標，請參閱 < [Windows 通訊端](/windows/desktop/WinSock/)文件。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法會啟動非同步傳送作業中所建立的遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 如果您未先呼叫，會擲回例外狀況<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.BeginConnect%2A>。 呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法可讓您能夠傳送不同的執行緒中的檔案。  
  
 若要完成此作業，您可以建立會叫用的回呼方法<xref:System.AsyncCallback>委派參數。 若要這樣做，在非常小`state`參數必須包含<xref:System.Net.Sockets.Socket>物件正在使用的通訊。 如果回呼需要更多的資訊時，您可以建立類別或結構來保存<xref:System.Net.Sockets.Socket>和其他必要的資訊。 傳遞至這個自訂物件的執行個體<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法，透過`state`參數。  
  
 您的回呼方法必須叫用<xref:System.Net.Sockets.Socket.EndSendFile%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.Socket.EndSendFile%2A>直到<xref:System.Net.Sockets.Socket>會傳送整個檔案，或擲回例外狀況。 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 適用於連線導向的通訊協定，雖然<xref:System.Net.Sockets.Socket.BeginSendFile%2A>也適用於無連線的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法，以建立預設遠端主機。 您也必須確定檔案的大小未超過最大的封包大小為基礎的服務提供者無連接的通訊協定。 若是如此，不會傳送資料包並<xref:System.Net.Sockets.Socket.BeginSendFile%2A>會擲回<xref:System.Net.Sockets.SocketException>例外狀況。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例會建立和連接的非同步通訊的通訊端並開始以非同步方式遠端主機傳送檔案"text.txt 」。 在此範例中，`preBuffer`並`postBuffer`的資料建立用來傳送檔案與預設<xref:System.Net.Sockets.TransmitFileOptions>會使用值。 回呼委派呼叫<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成傳輸。  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.NotSupportedException">作業系統不是 Windows NT (含) 以後版本。  
  
-或- 
通訊端未連線至遠端主機。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案 <paramref name="fileName" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，包含要傳送的資料。</param>
        <param name="offset"><paramref name="buffer" /> 中以零起始的位置，資料要在此處開始傳送。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">代表遠端裝置的 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="remote_end">代表遠端裝置的 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> 委派。</param>
        <param name="state">物件，含有這個要求的狀態資訊。</param>
        <summary>以非同步方式將資料傳送至特定的遠端主機。</summary>
        <returns>參考非同步傳送的 <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法會啟動非同步傳送作業中指定遠端主機`remoteEP`參數。 呼叫<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法可讓您能夠傳送不同的執行緒中的資料。 適用於無連線的通訊協定，雖然<xref:System.Net.Sockets.Socket.BeginSendTo%2A>無連線和連線導向的通訊協定的運作方式。  
  
 您可以建立回呼方法可實作<xref:System.AsyncCallback>委派，並將其名稱來傳遞<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法。 若要這樣做，在非常小，您`state`參數必須包含已連接，或預設<xref:System.Net.Sockets.Socket>正在使用的通訊。 如果回呼需要更多的資訊時，您可以建立小型類別以包裝<xref:System.Net.Sockets.Socket>，以及其他必要的資訊。 傳遞至這個類別的執行個體<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法，透過`state`參數。  
  
 您的回呼方法應該叫用<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法。 當您的應用程式呼叫<xref:System.Net.Sockets.Socket.BeginSendTo%2A>，系統會使用個別的執行緒來執行指定的回呼方法，並會封鎖<xref:System.Net.Sockets.Socket.EndSendTo%2A>直到<xref:System.Net.Sockets.Socket>傳送要求的位元組數目，或擲回例外狀況。 如果您想封鎖之後呼叫的原始執行緒<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法，請使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法。 當您想要繼續執行原始執行緒時，呼叫 T:System.Threading.ManualResetEvent 在回呼方法中的 Set 方法。 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理為回呼方法的委派](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)。  
  
 如果您使用連線導向的通訊協定，您必須先呼叫<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法，或<xref:System.Net.Sockets.Socket.BeginSendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 將會忽略`remoteEP`參數並傳送資料到<xref:System.Net.EndPoint>中建立<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Accept%2A>，或<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 如果您使用無連接的通訊協定，您不需要建立的預設遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>或是<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。 您只需要這樣做，如果您想要呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>，則`remoteEP`參數會覆寫指定的預設遠端主機，可傳送作業才。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法。 在此情況下，基礎的服務提供者會指派最適當的區域網路位址和連接埠號碼。 如果您想要選取可用的連接埠基礎的服務提供者，請使用連接埠號碼為零。 如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法成功完成。  
  
 如果您想要將資料傳送至的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，並設定通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 -您也必須確定您的緩衝區的大小未超過基礎的服務提供者的最大的封包大小。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.EndSendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，您要將不會路由傳送的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  執行內容 （的安全性內容中，模擬的使用者和呼叫的內容） 快取以供非同步<xref:System.Net.Sockets.Socket>方法。 在特定內容的第一次使用後 (特定非同步<xref:System.Net.Sockets.Socket>方法中，特定<xref:System.Net.Sockets.Socket>執行個體與指定的回撥)，該內容的後續使用將會看見效能改進。  
  
   
  
## Examples  
 下列程式碼範例以非同步方式將資料傳送至指定的遠端主機。  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">做為回呼方法，委派封送處理</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">要與 <see cref="T:System.Net.EndPoint" /> 關聯的本機 <see cref="T:System.Net.Sockets.Socket" />。</param>
        <summary>使 <see cref="T:System.Net.Sockets.Socket" /> 與本機端點建立關聯。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，如果您需要使用特定的本機端點。 您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>您可以呼叫之前<xref:System.Net.Sockets.Socket.Listen%2A>方法。 您不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>才能使用<xref:System.Net.Sockets.Socket.Connect%2A>方法除非您需要使用特定的本機端點。 您可以使用<xref:System.Net.Sockets.Socket.Bind%2A>無連線和連線導向的通訊協定上的方法。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.Bind%2A>，您必須先建立本機<xref:System.Net.IPEndPoint>從您要通訊的資料。 如果您並不在意指派的本機位址，您可以建立<xref:System.Net.IPEndPoint>使用<xref:System.Net.IPAddress.Any?displayProperty=nameWithType>位址參數，以及基礎的服務提供者會指派最適當的網路位址。 這有助於簡化您的應用程式，如果您有多個網路介面。 如果您並不在意哪些本機連接埠，您可以建立<xref:System.Net.IPEndPoint>使用 0 連接埠號碼。 在此情況下，服務提供者會指派可用的通訊埠編號介於 1024年到 5000 之間。  
  
 如果您使用上述的方法，您可以探索哪些本機網路位址和連接埠號碼已被指派藉由呼叫<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>之後所做的呼叫，則不會傳回在本機指派的網路位址，直到<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.EndConnect%2A>方法。 如果您使用無連接的通訊協定，您不會存取此資訊之前便已完成傳送或接收。  
  
 如果想要接收已接收的封包的介面資訊的 UDP 通訊端<xref:System.Net.Sockets.Socket.SetSocketOption%2A>通訊端選項設為應該明確地呼叫方法<xref:System.Net.Sockets.SocketOptionName.PacketInformation>後立即呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法。  
  
> [!NOTE]
>  如果您想要接收多點傳送的資料包，您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法的多點傳送連接埠號碼。  
  
> [!NOTE]
>  您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，如果您想要接收無連接的資料包使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>呼叫時<xref:System.Net.Sockets.Socket.Bind%2A>方法，請使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例繫結<xref:System.Net.Sockets.Socket>使用指定的本機端點。  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自所定義的主機連線<paramref name="localEP" />。 相關聯的列舉型別： <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出 <see cref="T:System.Net.Sockets.Socket" /> 是否處於區塊模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 可區塊化，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A>屬性會指出是否<xref:System.Net.Sockets.Socket>處於封鎖模式。  
  
 如果您處於封鎖模式中，而且您在進行方法呼叫的未立即完成，您的應用程式會封鎖執行，直到完成要求的作業。 如果您想要繼續，即使未完成要求的作業、 變更執行<xref:System.Net.Sockets.Socket.Blocking%2A>屬性設`false`。 <xref:System.Net.Sockets.Socket.Blocking%2A>屬性沒有任何作用，非同步方法。 如果您是傳送和接收資料，以非同步方式想要封鎖執行，使用<xref:System.Threading.ManualResetEvent>類別。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，藉由呼叫一個 <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> 方法來要求與遠端主機連接。</param>
        <summary>取消遠端主機連接的非同步要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A>方法就會取消遠端主機連接的非同步要求。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 參數不可為 null，而且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 也不可為 null。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>關閉 <see cref="T:System.Net.Sockets.Socket" /> 連接並釋放所有相關資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉 <see cref="T:System.Net.Sockets.Socket" /> 連接並釋放所有相關資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>方法會關閉連接遠端主機和版本的所有 managed 和 unmanaged 資源相關聯<xref:System.Net.Sockets.Socket>。 時結語<xref:System.Net.Sockets.Socket.Connected%2A>屬性設定為`false`。  
  
 連線導向的通訊協定，建議您呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>再呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。 這可確保所有資料都傳送及它在關閉之前，連接的通訊端上接收。  
  
 如果您需要呼叫<xref:System.Net.Sockets.Socket.Close%2A>情況下先呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，您可以確定資料中，會傳送所設定的連出傳輸佇列<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>選項設定為`false`並指定非零逾時間隔。 <xref:System.Net.Sockets.Socket.Close%2A> 就會封鎖直到這項資料會傳送，或直到指定的逾時過期為止。 如果您設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>要`false`並指定為零的逾時間隔，<xref:System.Net.Sockets.Socket.Close%2A>釋出連線，並會自動捨棄 外寄佇列的資料。  
  
> [!NOTE]
>  若要設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項來`false`，建立<xref:System.Net.Sockets.LingerOption>，將啟用的屬性設定為`true`，並設定<xref:System.Net.Sockets.LingerOption.LingerTime%2A>屬性所需的逾時期間。 使用此<xref:System.Net.Sockets.LingerOption>連同<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項來呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會關閉<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout">最多等候 <paramref name="timeout" /> 秒以傳送任何剩餘的資料，然後關閉通訊端。</param>
        <summary>關閉 <see cref="T:System.Net.Sockets.Socket" /> 連線，並釋放所有具指定逾時的關聯資源，以允許傳送佇列的資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>方法會關閉連接遠端主機和版本的所有 managed 和 unmanaged 資源相關聯<xref:System.Net.Sockets.Socket>。 時結語<xref:System.Net.Sockets.Socket.Connected%2A>屬性設定為`false`。  
  
 連線導向的通訊協定，建議您呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>再呼叫<xref:System.Net.Sockets.Socket.Close%2A>。 這可確保所有資料都傳送及它在關閉之前，連接的通訊端上接收。  
  
 如果您需要呼叫<xref:System.Net.Sockets.Socket.Close%2A>情況下先呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，您可以確定資料中，會傳送所設定的連出傳輸佇列<xref:System.Net.Sockets.SocketOptionName.DontLinger>選項設定為`false`並指定非零逾時間隔。 <xref:System.Net.Sockets.Socket.Close%2A> 就會封鎖直到這項資料會傳送，或直到指定的逾時過期為止。 如果您設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>要`false`並指定為零的逾時間隔，<xref:System.Net.Sockets.Socket.Close%2A>釋出連線，並會自動捨棄 外寄佇列的資料。  
  
> [!NOTE]
>  若要設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項來`false`，建立<xref:System.Net.Sockets.LingerOption>，enabled 的屬性設為`true`，並設定<xref:System.Net.Sockets.LingerOption.LingerTime%2A>的所需的逾時期限的屬性。 使用此<xref:System.Net.Sockets.LingerOption>連同<xref:System.Net.Sockets.SocketOptionName.DontLinger>通訊端選項來呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何關閉<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立與遠端主機的連線。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">代表遠端裝置的 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>建立與遠端主機的連線。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，例如 TCP<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式建立之間的網路連線<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端端點。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。 在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>，您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果您使用無連線的通訊協定，例如 UDP，您就不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>進行同步通訊與遠端主機。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，將會捨棄任何資料包來自指定的預設值以外的位址。 如果您想要設定預設遠端主機的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，並設定通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>方法將會封鎖，除非您特別設定<xref:System.Net.Sockets.Socket.Blocking%2A>屬性設`false`才能呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。 如果您使用連線導向的通訊協定時，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連線。 因為它們只是建立預設遠端主機，無連線通訊協定不會擲回例外狀況。 您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。 如果 WSAEWOULDBLOCK 傳回的錯誤，連接遠端主機已起始連線導向<xref:System.Net.Sockets.Socket>，但尚未完成成功。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。  
  
> [!NOTE]
>  如果您使用連線導向的通訊協定，才會呼叫<xref:System.Net.Sockets.Socket.Bind%2A>再呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會將指派的本機網路位址和連接埠編號。 如果您使用無連接的通訊協定，服務提供者將未指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。  
  
> [!NOTE]
>  如果通訊端具有先前中斷連接，然後您就無法使用此方法以還原連線。 使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>重新連線的方法。 這是基礎提供者的限制。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會連線到遠端端點，然後驗證該連接。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</exception>
        <permission cref="T:System.Net.SocketPermission">用於連接至遠端主機。 相關聯的列舉型別： <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">遠端主機的 IP 位址。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <summary>建立與遠端主機的連線。 此主機是由 IP 位址和連接埠號碼所指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，例如 TCP<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式建立之間的網路連線<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端端點。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。 在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果您使用無連線的通訊協定，例如 UDP，您就不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>進行同步通訊與遠端主機。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>任何資料包來自指定的預設值以外的位址將會被捨棄。 如果您想要設定預設遠端主機的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，並設定通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法會封鎖，除非您特別設定，否則<xref:System.Net.Sockets.Socket.Blocking%2A>屬性，以`false`才能呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。 如果您使用連線導向的通訊協定時，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連線。 因為它們只是建立預設遠端主機，無連線通訊協定不會擲回例外狀況。 您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。 如果 WSAEWOULDBLOCK 傳回的錯誤，連接遠端主機已起始連線導向<xref:System.Net.Sockets.Socket>，但尚未完成成功。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。  
  
> [!NOTE]
>  如果您使用連線導向的通訊協定，才會呼叫<xref:System.Net.Sockets.Socket.Bind%2A>再呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會將指派的本機網路位址和連接埠編號。 如果您使用無連接的通訊協定，服務提供者將未指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。  
  
> [!NOTE]
>  如果通訊端具有先前中斷連接，然後您就無法使用此方法以還原連線。 使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>重新連線的方法。 這是基礎提供者的限制。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會連線到遠端端點，然後驗證該連接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的長度為零。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">遠端主機的 IP 位址。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <summary>建立與遠端主機的連線。 主機是由 IP 位址陣列和連接埠號碼所指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法通常用來呼叫之後立即<xref:System.Net.Dns.GetHostAddresses%2A>，這可以傳回多個 IP 位址的單一主機。 如果您使用連線導向的通訊協定，例如 TCP<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式建立之間的網路連線<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端端點。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。 在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果您使用無連線的通訊協定，例如 UDP，您就不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>進行同步通訊與遠端主機。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>任何資料包來自指定的預設值以外的位址將會被捨棄。 如果您想要設定預設遠端主機的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，並設定通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法會封鎖，除非您特別設定，否則<xref:System.Net.Sockets.Socket.Blocking%2A>屬性，以`false`才能呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。 如果您使用連線導向的通訊協定時，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連線。 因為它們只是建立預設遠端主機，無連線通訊協定不會擲回例外狀況。 您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。 如果 WSAEWOULDBLOCK 傳回的錯誤，連接遠端主機已起始連線導向<xref:System.Net.Sockets.Socket>，但尚未完成成功。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。  
  
> [!NOTE]
>  如果您使用連線導向的通訊協定，才會呼叫<xref:System.Net.Sockets.Socket.Bind%2A>再呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會將指派的本機網路位址和連接埠編號。 如果您使用無連接的通訊協定，服務提供者將未指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。  
  
> [!NOTE]
>  如果通訊端具有先前中斷連接，然後您就無法使用此方法以還原連線。 使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>重新連線的方法。 這是基礎提供者的限制。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會連線到遠端端點，然後驗證該連接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> 的長度為零。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">遠端主機的名稱。</param>
        <param name="port">遠端主機的連接埠號碼。</param>
        <summary>建立與遠端主機的連線。 此主機是由主機名稱和連接埠號碼指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，例如 TCP<xref:System.Net.Sockets.Socket.Connect%2A>方法以同步方式建立之間的網路連線<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>和指定的遠端主機。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.Connect%2A>建立預設遠端主機。 在您呼叫後<xref:System.Net.Sockets.Socket.Connect%2A>您可以將資料傳送到遠端裝置與<xref:System.Net.Sockets.Socket.Send%2A>方法，或從遠端裝置與接收資料<xref:System.Net.Sockets.Socket.Receive%2A>方法。  
  
 如果您使用無連線的通訊協定，例如 UDP，您就不必呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>和<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>進行同步通訊與遠端主機。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>任何資料包來自指定的預設值以外的位址將會被捨棄。 如果您想要設定預設遠端主機的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，並設定通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>，或<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 方法會封鎖，除非您特別設定，否則<xref:System.Net.Sockets.Socket.Blocking%2A>屬性，以`false`才能呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。 如果您使用連線導向的通訊協定時，例如 TCP 和您不要停用封鎖<xref:System.Net.Sockets.Socket.Connect%2A>將會擲回<xref:System.Net.Sockets.SocketException>因為它需要時間來進行連線。 因為它們只是建立預設遠端主機，無連線通訊協定不會擲回例外狀況。 您可以使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>來取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。 如果 WSAEWOULDBLOCK 傳回的錯誤，連接遠端主機已起始連線導向<xref:System.Net.Sockets.Socket>，但尚未完成成功。 使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，以判斷何時<xref:System.Net.Sockets.Socket>完成連接。  
  
 如果已啟用 IPv6 和<xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29>呼叫方法來連線到主機解析為這兩個 IPv6 和 IPv4 位址、 IPv6 位址將會連接嘗試之前的 IPv4 位址的第一個。 這可能會有延遲的時間來建立連接，如果主機並未接聽 IPv6 位址的效果。  
  
> [!NOTE]
>  如果您使用連線導向的通訊協定，才會呼叫<xref:System.Net.Sockets.Socket.Bind%2A>再呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，基礎的服務提供者會將指派的本機網路位址和連接埠編號。 如果您使用無連接的通訊協定，服務提供者將未指派本機網路位址和連接埠號碼直到您完成傳送或接收作業。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.Connect%2A>再次使用所需的端點。  
  
> [!NOTE]
>  如果通訊端具有先前中斷連接，然後您就無法使用此方法以還原連線。 使用其中一種非同步<xref:System.Net.Sockets.Socket.BeginConnect%2A>重新連線的方法。 這是基礎提供者的限制。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會連線到遠端端點，然後驗證該連接。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">連接埠號碼無效。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">這個方法對 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 系列通訊端是有效的。</exception>
        <exception cref="T:System.InvalidOperationException">藉由呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 已令 <see cref="T:System.Net.Sockets.Socket" /> 處於接聽狀態。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開始與遠端主機連接的非同步要求。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始與遠端主機連接的非同步要求。</summary>
        <returns>若 I/O 作業暫止，則為 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 若 I/O 作業同步完成，則為 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會啟動遠端主機連接的非同步要求。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>建立預設遠端主機。  
  
 若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並將附加的回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性設<xref:System.Net.IPEndPoint>連線至遠端主機。  
  
 呼叫端可能會設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>呼叫之前所需的任何使用者狀態物件的屬性<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，如此會在回呼方法中擷取資訊。 如果回呼需要比單一物件的詳細資訊，就可以建立小型的類別來保存為成員的其他必要的狀態資訊。  
  
 如果您使用無連線的通訊協定，例如 UDP，您就不必呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendToAsync%2A>和<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>與遠端主機通訊。 如果您呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，將會捨棄任何資料包來自指定的預設值以外的位址。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法一次所需的端點。  
  
 如果您想要設定預設遠端主機的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>且設定為廣播`true`。 如果不這麼做，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件所需：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （選擇性） 緩衝區可能會提供這將會以不可分割方式傳送之後在通訊端上<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在此情況下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>屬性必須設定為包含資料的緩衝區，以傳送和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性必須設定為從緩衝區傳送資料的位元組數目。 一旦建立連線時，就會傳送此緩衝區的資料。  
  
 如果您使用連線導向的通訊協定並不會呼叫<xref:System.Net.Sockets.Socket.Bind%2A>再呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，基礎的服務提供者會指派最適當的區域網路位址和連接埠號碼。  
  
 如果您使用無連接的通訊協定，服務提供者將未指派區域網路 IP 位址和連接埠號碼直到您呼叫<xref:System.Net.Sockets.Socket.SendAsync%2A>或<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.NotSupportedException>如果 family<xref:System.Net.Sockets.Socket>而<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>不相同的位址系列。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>呼叫這個方法時，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引數無效。 如果指定多個緩衝區而 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性不是 null，就會發生這個例外狀況。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 參數不可為 null，而且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 也不可為 null。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 正在接聽，或是通訊端作業正在進行並且使用 <paramref name="e" /> 參數所指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。 如果本機端點和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是同一個通訊協定家族 (Family)，也會發生這個例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</param>
        <param name="protocolType">其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</param>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始與遠端主機連接的非同步要求。</summary>
        <returns>若 I/O 作業暫止，則為 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 若 I/O 作業同步完成，則為 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) 方法啟動的非同步要求連接至遠端主機。 如果您使用無連接的通訊協定<xref:System.Net.Sockets.Socket.ConnectAsync%2A>建立預設遠端主機所指定`socketType`和`protocolType`參數。  
  
 若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並將附加的回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性設<xref:System.Net.IPEndPoint>連線至遠端主機。  
  
 呼叫端可能會設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>呼叫之前所需的任何使用者狀態物件的屬性<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，如此會在回呼方法中擷取資訊。 如果回呼需要比單一物件的詳細資訊，就可以建立小型的類別來保存為成員的其他必要的狀態資訊。  
  
 如果您使用無連線的通訊協定，例如 UDP，您就不必呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>之前傳送和接收資料。 您可以使用<xref:System.Net.Sockets.Socket.SendToAsync%2A>和<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>與遠端主機通訊。 如果您呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，將會捨棄任何資料包來自指定的預設值以外的位址。 如果您想要變更預設遠端主機時，呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法一次所需的端點。  
  
 如果您想要設定預設遠端主機的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>且設定為廣播`true`。 如果不這麼做，<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件所需：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 （選擇性） 緩衝區可能會提供這將會以不可分割方式傳送之後在通訊端上<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法成功。 在此情況下，<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>屬性必須設定為包含資料的緩衝區，以傳送和<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>屬性必須設定為從緩衝區傳送資料的位元組數目。 一旦建立連線時，就會傳送此緩衝區的資料。  
  
 如果您使用連線導向的通訊協定並不會呼叫<xref:System.Net.Sockets.Socket.Bind%2A>再呼叫<xref:System.Net.Sockets.Socket.ConnectAsync%2A>，基礎的服務提供者會指派最適當的區域網路位址和連接埠號碼。  
  
 如果您使用無連接的通訊協定，服務提供者將未指派區域網路 IP 位址和連接埠號碼直到您呼叫<xref:System.Net.Sockets.Socket.SendAsync%2A>或<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法會擲回<xref:System.NotSupportedException>如果 family<xref:System.Net.Sockets.Socket>而<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>不相同的位址系列。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>呼叫這個方法時，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引數無效。 如果指定多個緩衝區而 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性不是 null，就會發生這個例外狀況。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 參數不可為 null，而且 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 也不可為 null。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 正在接聽，或是通訊端作業正在進行並且使用 <paramref name="e" /> 參數所指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。 如果本機端點和 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不是同一個通訊協定家族 (Family)，也會發生這個例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">在呼叫堆疊中位置較高的呼叫端對於要求的作業沒有權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出上一個 <see cref="T:System.Net.Sockets.Socket" /> 或 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 作業是否將 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 連接至遠端主機。</summary>
        <value>如果最近一次的作業是將 <see cref="T:System.Net.Sockets.Socket" /> 連接到遠端資源，則為 <see langword="true" />，否則，即為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected`屬性取得的連接狀態<xref:System.Net.Sockets.Socket>截至最後一個 I/O 作業。 當它傳回`false`，則<xref:System.Net.Sockets.Socket>永遠不會連接，或已中斷連線。  
  
 值<xref:System.Net.Sockets.Socket.Connected%2A>屬性會反映最新的作業連接的狀態。 如果您需要判斷目前的連接狀態，請呼叫非封鎖，零位元組傳送。 如果呼叫成功傳回，或擲回 WAEWOULDBLOCK 錯誤程式碼 (10035)，然後連接通訊端仍;否則，通訊端已中斷連線。  
  
 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>使用者資料包通訊協定 (UDP) 通訊端上<xref:System.Net.Sockets.Socket.Connected%2A>屬性一律會傳回`true`; 不過，此動作不會變更 UDP 原本就不需連線性質。  
  
   
  
## Examples  
 下列程式碼範例會連線到遠端端點，檢查<xref:System.Net.Sockets.Socket.Connected%2A>屬性，並檢查連線的目前狀態。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">如果這個通訊端可以在關閉目前連線後重複使用，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>關閉通訊端連線並允許重複使用通訊端。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，您可以使用這個方法，以關閉通訊端。 此方法結束的連接和集合<xref:System.Net.Sockets.Socket.Connected%2A>屬性設`false`。 不過，如果`reuseSocket`是`true`，您可以重複使用通訊端。  
  
 若要確保所有資料都傳送及接收通訊端關閉之前，您應該呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>再呼叫<xref:System.Net.Sockets.Socket.Disconnect%2A>方法。  
  
 如果您需要呼叫<xref:System.Net.Sockets.Socket.Disconnect%2A>情況下先呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，您可以設定<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>選項設定為`false`並指定非零的逾時間隔，以確保資料在傳送 傳出傳輸排入佇列。 <xref:System.Net.Sockets.Socket.Disconnect%2A> 然後會封鎖直到將資料傳送，或直到指定的逾時過期為止。 如果您設定<xref:System.Net.Sockets.SocketOptionName.DontLinger>要`false`並指定為零的逾時間隔，<xref:System.Net.Sockets.Socket.Close%2A>釋出連線，並會自動捨棄 外寄佇列的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立同步通訊的通訊端，並將部分資料傳送至遠端主機。 然後它會呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>，以停止傳送及接收活動，以及<xref:System.Net.Sockets.Socket.Disconnect%2A>以關閉通訊端連線。  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">這個方法需要 Windows 2000 (含) 以前版本，否則會擲回例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始非同步要求，以中斷遠端端點的連接。</summary>
        <returns>若 I/O 作業暫止，則為 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 若 I/O 作業同步完成，則為 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用連線導向的通訊協定，當呼叫<xref:System.Net.Sockets.Socket.DisconnectAsync%2A>方法會要求從遠端端點的中斷連線。 如果您設定<xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType>要`true`在`e`參數，可以重複使用通訊端。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> 參數不可以是 null。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>釋放 <see cref="T:System.Net.Sockets.Socket" /> 類別目前的執行個體所使用的全部資源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Net.Sockets.Socket" /> 類別目前的執行個體所使用的全部資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dispose` 使用完畢時，請呼叫 <xref:System.Net.Sockets.Socket>。 `Dispose` 方法會將 <xref:System.Net.Sockets.Socket> 保留在無法使用的狀態。 之後呼叫`Dispose`，您必須釋放所有的參考<xref:System.Net.Sockets.Socket>讓記憶體回收行程可以回收記憶體，<xref:System.Net.Sockets.Socket>所佔用。  
  
 如需詳細資訊，請參閱 <<c0> [ 清除 Unmanaged 資源向上](~/docs/standard/garbage-collection/unmanaged.md)並[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  在您釋放最後一個 `Dispose` 參考之前，請務必呼叫 <xref:System.Net.Sockets.Socket>。 否則工作窗格所使用的資源不會釋放，直到記憶體回收行程呼叫 <xref:System.Net.Sockets.Socket> 物件的 `Finalize` 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示會同時釋放 Managed 和 Unmanaged 資源；<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.Net.Sockets.Socket" /> 所使用的 Unmanaged 資源，並選擇性處置 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。 `Dispose()` 叫用受保護`Dispose(Boolean)`方法`disposing`參數設為`true`。 <xref:System.Object.Finalize%2A> 叫用`Dispose`具有`disposing`設定為`false`。  
  
 `disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.Net.Sockets.Socket> 參考的任何 Managed 物件所掌握的資源。 這個方法會叫用每個參考物件的 `Dispose()` 方法。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> 可以被其他物件呼叫多次。 覆寫 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> 時，請小心不要參考到先前已在對 <see langword="Dispose" /> 的早期呼叫中被處置 (Dispose) 的物件。 如需有關如何實作<see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />，請參閱 &lt;&lt;c2&gt; [ 實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
如需詳細資訊<see langword="Dispose" />和<see cref="M:System.Object.Finalize" />，請參閱[清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)並[覆寫 Finalize 方法](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))。</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否允許將網際網路通訊協定 (IP) 資料包分散。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允許資料包分散，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 資料包需要分散，當其大小超過最大傳輸單位 (MTU) 的傳輸媒介。 可能分散資料包，藉由傳送主機 （所有的網際網路通訊協定版本） 或中繼路由器 (Internet Protocol Version 4 僅)。 如果必須分割資料包 (datagram)，而<xref:System.Net.Sockets.Socket.DontFragment%2A>選項設定，會捨棄的資料包，網際網路控制訊息通訊協定 (ICMP) 錯誤訊息傳回給寄件者的資料包。  
  
 傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會有任何作用。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.DontFragment%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">這個屬性只可為 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 家族中的通訊端設定。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否為適用於 IPv4 和 IPv6 的雙重模式通訊端。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 是雙重模式通訊端，則為 <see langword="true" />；否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">建立重複通訊端參考的目標處理序 ID。</param>
        <summary>複製目標處理序的通訊端參考，並關閉這個處理序的通訊端。</summary>
        <returns>要傳遞至目標處理序的通訊端參考。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目標處理序應該使用<xref:System.Net.Sockets.Socket.%23ctor%2A>建立重複通訊端執行個體。  
  
 如果您呼叫<xref:System.Net.Sockets.Socket.%23ctor%2A>多次使用相同的位元組陣列，為每個呼叫的引數的建構函式，您將建立受管理的多個<xref:System.Net.Sockets.Socket>具有相同的基礎通訊端的執行個體。 這種做法不鼓勵。  
  
 如果建立通訊端處理程序會使用非同步方法 (<xref:System.Net.Sockets.Socket.BeginReceive%2A>或<xref:System.Net.Sockets.Socket.BeginSend%2A>)，必須先設定程序<xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A>屬性設為 true，否則繫結至建立的程序，這可能會造成的完成連接埠的通訊端<xref:System.ArgumentNullException>目標處理序上被擲回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" /> 不是有效的處理序 ID。 
-或- 
複製通訊端參考失敗。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否可以傳送或接收廣播封包。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 允許廣播封包，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 廣播限制為特定的子網路，而且必須使用使用者資料包通訊協定 (UDP)。針對網際網路通訊協定第 4 版，您可以廣播到本機子網路的封包傳送至 255.255.255.255;或者，您可以使用導向的廣播的位址，也就是使用中的主機部分設定的所有位元的網際網路通訊協定 (IP) 位址的網路部分。 例如，如果您的 IP 位址為 192.168.1.40 （類別 C 位址，與網路遮罩 255.255.255.0-網路部分是前三個八位元，而的主機部分是最後一個八位元），則導向的廣播的位址為 192.168.1.255。  
  
 傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會有任何作用。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.EnableBroadcast%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">這個選項只對資料包通訊端有效。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同步接受連入連線嘗試。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，包含已傳輸的位元組。</param>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊以及任何使用者定義的資料。</param>
        <summary>以非同步方式接受連入連線嘗試，並建立新的 <see cref="T:System.Net.Sockets.Socket" /> 物件，以處理遠端主機通訊。 這個方法會傳回包含已傳輸之初始資料的緩衝區。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> 物件，可處理與遠端主機的通訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，您必須建立會叫用的回呼方法<xref:System.AsyncCallback>委派。 此回呼方法會在個別的執行緒中執行和之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法會傳回。  
  
 在回呼方法中，呼叫<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法成功完成連線嘗試。 `buffer`的這個多載的參數包含收到的呼叫中的資料<xref:System.Net.Sockets.Socket.BeginAccept%2A>而`bytesTransferred`參數會包含已在呼叫中傳送的位元組數目。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法會封鎖直到暫止的連接，就連入連線佇列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法會接受連入連線，並傳回新<xref:System.Net.Sockets.Socket>，可用來傳送和接收來自遠端主機的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>來建立並連接通訊端，並接受初始的 10 個位元組的資料。 回呼委派呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>結束非同步要求。 已傳送的位元組數目和資料會傳回`buffer`和`bytesTransferred`參數，這個方法會顯示在主控台上。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 是空的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不是由呼叫 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的方式所建立。</exception>
        <exception cref="T:System.InvalidOperationException">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生錯誤</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，儲存這個非同步作業的狀態資訊以及任何使用者定義的資料。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，儲存這個非同步作業的狀態資訊以及任何使用者定義的資料。</param>
        <summary>以非同步方式接受連入的連接嘗試，並建立新的 <see cref="T:System.Net.Sockets.Socket" /> 來處理遠端主機通訊。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" />，將處理與遠端主機的通訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，您必須建立實作的回呼方法<xref:System.AsyncCallback>委派。 此回呼方法會在個別的執行緒中執行和之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法會傳回。 它必須接受`asyncResult`參數傳回<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 在回呼方法中，呼叫<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法成功完成連線嘗試。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法會封鎖直到暫止的連接，就連入連線佇列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法會接受連入連線，並傳回新<xref:System.Net.Sockets.Socket>，可用來傳送和接收來自遠端主機的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會結束的非同步要求，並建立新<xref:System.Net.Sockets.Socket>接受連入連線要求。 如需示範如何使用通訊端的非同步通訊的完整範例，請參閱 <<c0> [ 通訊端程式碼範例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不是由呼叫 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的方式所建立。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 如需詳細資訊，請參閱＜備註＞一節。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，包含已傳輸的位元組。</param>
        <param name="bytesTransferred">已傳輸的位元組數。</param>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊以及任何使用者定義的資料。</param>
        <summary>以非同步方式接受連入連線嘗試，並建立新的 <see cref="T:System.Net.Sockets.Socket" /> 物件，以處理遠端主機通訊。 這個方法會傳回包含已傳輸之初始資料和位元組數的緩衝區。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> 物件，可處理與遠端主機的通訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>。 然後再呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>，您必須建立會叫用的回呼方法<xref:System.AsyncCallback>委派。 此回呼方法會在個別的執行緒中執行和之後系統便會呼叫<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法會傳回。 它必須接受`asyncResult`參數傳回<xref:System.Net.Sockets.Socket.BeginAccept%2A>方法。  
  
 在回呼方法中，呼叫<xref:System.IAsyncResult.AsyncState%2A>方法`asyncResult`參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>方法成功完成連線嘗試。 `buffer`的這個多載的參數包含收到的呼叫中的資料<xref:System.Net.Sockets.Socket.BeginAccept%2A>而`bytesTransferred`參數會包含已在呼叫中傳送的位元組數目。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法會封鎖直到暫止的連接，就連入連線佇列中。 <xref:System.Net.Sockets.Socket.EndAccept%2A>方法會接受連入連線，並傳回新<xref:System.Net.Sockets.Socket>，可用來傳送和接收來自遠端主機的資料。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.Socket.BeginAccept%2A>來建立並連接通訊端，並接受初始的 10 個位元組的資料。 回呼委派呼叫<xref:System.Net.Sockets.Socket.EndAccept%2A>結束非同步要求。 已傳送的位元組數目和資料會傳回`buffer`和`bytesTransferred`參數，這個方法會顯示在主控台上。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 是空的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不是由呼叫 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> 的方式所建立。</exception>
        <exception cref="T:System.InvalidOperationException">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> 方法。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <summary>結束擱置的非同步連接要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> 完成非同步的遠端主機連線要求的封鎖方法以啟動<xref:System.Net.Sockets.Socket.BeginConnect%2A>方法。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>，您必須建立實作的回呼方法<xref:System.AsyncCallback>委派。 這個回呼方法會在個別的執行緒中執行之後, 系統便會呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>所傳回<xref:System.Net.Sockets.Socket.BeginConnect%2A>做為參數的方法。  
  
 在回呼方法中，呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數來取得<xref:System.Net.Sockets.Socket>上它正在嘗試連線。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndConnect%2A>方法成功完成連線嘗試。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會結束非同步的連線嘗試。 如需示範如何使用通訊端的非同步通訊的完整範例，請參閱 <<c0> [ 通訊端程式碼範例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> 是先前用來呼叫非同步連接。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊以及任何使用者定義的資料。</param>
        <summary>結束暫止非同步中斷連接要求。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 完成呼叫<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>方法會封鎖直到完成中斷連線為止。 如需非同步作業的資訊，請參閱 MSDN library 中的非同步程式設計的概觀主題。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立非同步通訊的通訊端，並將部分資料傳送至遠端主機。 當資料已傳送時，<xref:System.Net.Sockets.Socket.Shutdown%2A>稱為停止傳送及接收活動。 然後<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>呼叫以開始中斷連接要求。 回呼委派呼叫<xref:System.Net.Sockets.Socket.EndDisconnect%2A>結束非同步要求。 要求完成時，<xref:System.Net.Sockets.Socket.Connected%2A>屬性查詢來測試是否已中斷連線的通訊端。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> 是先前用來呼叫非同步連接。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.Net.WebException">中斷連接要求已逾時。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>結束擱置的非同步讀取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <summary>結束擱置的非同步讀取。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成非同步的讀取的作業，以啟動<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>，您必須建立實作的回呼方法<xref:System.AsyncCallback>委派。 這個回呼方法會在個別的執行緒中執行之後, 系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>所傳回<xref:System.Net.Sockets.Socket.BeginReceive%2A>做為參數的方法。  
  
 在回呼方法中，呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>取得狀態物件傳遞至<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 擷取接收<xref:System.Net.Sockets.Socket>從這個狀態物件。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法成功完成讀取的作業，並傳回讀取的位元組數目。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法將會封鎖直到資料可供使用。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>會讀取連入的網路緩衝區中有可用的第一個加入佇列的資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會讀取位於不超過您指定的位元組數目的資料量`size`參數<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會立即完成，並傳回零個位元組。  
  
 若要取得已接收的資料，請呼叫<xref:System.IAsyncResult.AsyncState%2A>方法的<xref:System.IAsyncResult>，並將解壓縮所產生的狀態物件中所含的緩衝區。  
  
 若要取消暫止<xref:System.Net.Sockets.Socket.BeginReceive%2A>，呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會結束暫止的非同步讀取。 如需示範如何使用通訊端的非同步通訊的完整範例，請參閱 <<c0> [ 通訊端程式碼範例](~/docs/framework/network-programming/socket-code-examples.md)。  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>結束擱置的非同步讀取。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法完成非同步的讀取的作業，以啟動<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>，您必須建立實作的回呼方法<xref:System.AsyncCallback>委派。 這個回呼方法會在個別的執行緒中執行之後, 系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>所傳回<xref:System.Net.Sockets.Socket.BeginReceive%2A>做為參數的方法。  
  
 在回呼方法中，呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>取得狀態物件傳遞至<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 擷取接收<xref:System.Net.Sockets.Socket>從這個狀態物件。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndReceive%2A>方法成功完成讀取的作業，並傳回讀取的位元組數目。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>方法將會封鎖直到資料可供使用。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>會讀取連入的網路緩衝區中有可用的第一個加入佇列的資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會讀取位於不超過您指定的位元組數目的資料量`size`參數<xref:System.Net.Sockets.Socket.BeginReceive%2A>方法。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.EndReceive%2A>方法會立即完成，並傳回零個位元組。  
  
 若要取得已接收的資料，請呼叫<xref:System.IAsyncResult.AsyncState%2A>方法的<xref:System.IAsyncResult>，並將解壓縮所產生的狀態物件中所含的緩衝區。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <param name="endPoint">來源 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point">來源 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>從指定的端點結束暫止的非同步讀取。</summary>
        <returns>如果成功，則傳回接收的位元組數目。 如果不成功，則傳回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法完成非同步的讀取的作業，以啟動<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>，您必須建立實作的回呼方法<xref:System.AsyncCallback>委派。 這個回呼方法會在個別的執行緒中執行之後, 系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>所傳回<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>做為參數的方法。  
  
 在回呼方法中，呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>取得狀態物件傳遞至<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 擷取接收<xref:System.Net.Sockets.Socket>從這個狀態物件。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法成功完成讀取的作業，並傳回讀取的位元組數目。  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法將會封鎖直到資料可供使用。 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>會讀取連入的網路緩衝區中有可用的第一個加入佇列的資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法會讀取位於不超過您指定的位元組數目的資料量`size`參數<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>方法。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>方法會立即完成，並傳回零個位元組。 若要取得已接收的資料，請呼叫<xref:System.IAsyncResult.AsyncState%2A>方法的<xref:System.IAsyncResult>物件，並將解壓縮所產生的狀態物件中所含的緩衝區。 若要識別原始的主機，擷取<xref:System.Net.EndPoint>將它轉換成<xref:System.Net.IPEndPoint>。 使用<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法，以取得 IP 位址和<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法，以取得連接埠號碼。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會結束暫止的非同步讀取從特定<xref:System.Net.EndPoint>。  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <param name="socketFlags">接收封包之 <see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="endPoint">來源 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">接收之封包的 <see cref="T:System.Net.IPAddress" /> 和介面。</param>
        <summary>從指定的端點結束暫止的非同步讀取。 這個方法還會比 <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> 提供更多的封包資訊。</summary>
        <returns>如果成功，則傳回接收的位元組數目。 如果不成功，則傳回 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果作業尚未完成，這個方法會封鎖，直到它執行。  
  
 若要以同步方式執行這項作業，使用<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 檢查`ipPacketInformation`如果您需要知道是否資料包所傳送的單點傳播、 多點傳送或廣播位址。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 是 <see langword="null" />  
  
-或- 
 <paramref name="endPoint" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步讀取呼叫 <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>結束暫止的非同步傳送。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，存放這個非同步作業的狀態資訊。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，存放這個非同步作業的狀態資訊。</param>
        <summary>結束暫止的非同步傳送。</summary>
        <returns>如果成功，則將位元組數目傳送至 <see cref="T:System.Net.Sockets.Socket" />，否則，則產生一個無效的 <see cref="T:System.Net.Sockets.Socket" /> 錯誤。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成非同步傳送作業中啟動<xref:System.Net.Sockets.Socket.BeginSend%2A>。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，您必須建立實作的回呼方法<xref:System.AsyncCallback>委派。 這個回呼方法會在個別的執行緒中執行之後, 系統便會呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>所傳回<xref:System.Net.Sockets.Socket.BeginSend%2A>做為參數的方法。  
  
 在回呼方法中，呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數，以取得傳送<xref:System.Net.Sockets.Socket>。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSend%2A>方法成功完成傳送作業，並傳回傳送的位元組數目。  
  
 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>將會封鎖直到傳送資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>將會封鎖直到某些緩衝區已傳送。 如果傳回的值從<xref:System.Net.Sockets.Socket.EndSend%2A>表示緩衝區未完全傳送時，呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法同樣地，修改保留未傳送的資料緩衝區。  
  
 則您傳送的資料就會立即出現在網路無法保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.BeginSend%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會結束暫止的非同步傳送。  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步傳送呼叫 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，存放這個非同步作業的狀態資訊。</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>結束暫止的非同步傳送。</summary>
        <returns>如果成功，則將位元組數目傳送至 <see cref="T:System.Net.Sockets.Socket" />，否則，則產生一個無效的 <see cref="T:System.Net.Sockets.Socket" /> 錯誤。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 完成非同步傳送作業中啟動<xref:System.Net.Sockets.Socket.BeginSend%2A>。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>，您必須建立實作的回呼方法<xref:System.AsyncCallback>委派。 這個回呼方法會在個別的執行緒中執行之後, 系統便會呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>所傳回<xref:System.Net.Sockets.Socket.BeginSend%2A>做為參數的方法。  
  
 在回呼方法中，呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數，以取得傳送<xref:System.Net.Sockets.Socket>。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSend%2A>方法成功完成傳送作業，並傳回傳送的位元組數目。  
  
 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>將會封鎖直到傳送資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSend%2A>將會封鎖直到某些緩衝區已傳送。 如果傳回的值從<xref:System.Net.Sockets.Socket.EndSend%2A>表示緩衝區未完全傳送時，呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>方法同樣地，修改保留未傳送的資料緩衝區。  
  
 則您傳送的資料就會立即出現在網路無法保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.BeginSend%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  該執行緒結束時，會取消指定的執行緒所起始的所有 I/O。 如果執行緒結束的作業完成之前，暫止的非同步作業可能會失敗。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步傳送呼叫 <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> 物件，儲存這個非同步作業的狀態資訊。</param>
        <summary>結束檔案的暫止非同步傳送。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 完成非同步傳送作業中啟動<xref:System.Net.Sockets.Socket.BeginSendFile%2A>。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>，您必須建立實作的回呼方法<xref:System.AsyncCallback>委派。 這個回呼方法會在個別的執行緒中執行之後, 系統便會呼叫<xref:System.Net.Sockets.Socket.BeginSendFile%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>所傳回的物件<xref:System.Net.Sockets.Socket.BeginSendFile%2A>做為參數的方法。  
  
 在回呼方法中，呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數，以取得傳送<xref:System.Net.Sockets.Socket>。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSendFile%2A>才能順利完成傳送作業的方法。  
  
 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSendFile%2A>封鎖，直到傳送資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSendFile%2A>封鎖，直到傳送整個檔案。 則您傳送的資料就會立即出現在網路無法保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.BeginSendFile%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立和連接的非同步通訊的通訊端並開始以非同步方式遠端主機傳送檔案"text.txt 」。 回呼委派呼叫<xref:System.Net.Sockets.Socket.EndSendFile%2A>完成傳輸。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows NT。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 是空的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已呼叫 <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> 用於非同步 <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <param name="result"><see cref="T:System.IAsyncResult" />，存放此非同步作業 (Asynchronous Operation) 的狀態資訊和任何使用者定義的資料。</param>
        <summary>結束暫止的非同步傳送至指定的位置。</summary>
        <returns>如果成功，則傳送位元組數目，否則，則產生一個無效的 <see cref="T:System.Net.Sockets.Socket" /> 錯誤。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 完成非同步傳送作業中啟動<xref:System.Net.Sockets.Socket.BeginSendTo%2A>。  
  
 然後再呼叫<xref:System.Net.Sockets.Socket.BeginSendTo%2A>，您必須建立實作的回呼方法<xref:System.AsyncCallback>委派。 這個回呼方法會在個別的執行緒中執行之後, 系統便會呼叫<xref:System.Net.Sockets.Socket.BeginReceive%2A>傳回。 回呼方法必須接受<xref:System.IAsyncResult>所傳回<xref:System.Net.Sockets.Socket.BeginSendTo%2A>做為參數的方法。  
  
 在回呼方法中，呼叫<xref:System.IAsyncResult.AsyncState%2A>方法<xref:System.IAsyncResult>參數，以取得傳送<xref:System.Net.Sockets.Socket>。 取得之後<xref:System.Net.Sockets.Socket>，您可以呼叫<xref:System.Net.Sockets.Socket.EndSendTo%2A>方法成功完成傳送作業，並傳回傳送的位元組數目。  
  
 如果您使用無連接的通訊協定，<xref:System.Net.Sockets.Socket.EndSendTo%2A>將會封鎖直到傳送資料包。 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.EndSendTo%2A>將會封鎖直到傳送要求的位元組數目。 則您傳送的資料就會立即出現在網路無法保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.BeginSendTo%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會結束非同步傳送至特定位置。  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> 不會經由對 <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> 方法的呼叫傳回。</exception>
        <exception cref="T:System.InvalidOperationException">先前已針對非同步傳送呼叫 <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否只允許一個處理序繫結至通訊埠。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 只允許一個通訊端繫結至特定通訊埠，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值是<see langword="true" />Windows Server 2003 和 Windows XP Service Pack 2 和<see langword="false" />對於所有其他版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>已`false`，可以使用多個通訊端<xref:System.Net.Sockets.Socket.Bind%2A>方法繫結到特定的連接埠，不過只有其中一個通訊端可以對執行作業傳送至連接埠的網路流量。 如果多個通訊端嘗試使用<xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29>方法繫結至特定的連接埠，則具有更特定的 IP 位址，一個會處理傳送到該連接埠的網路流量。  
  
 如果<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>是`true`，第一次使用<xref:System.Net.Sockets.Socket.Bind%2A>方法，以嘗試繫結至特定的連接埠，不論網際網路通訊協定 (IP) 位址，將會成功，所有後續的用法<xref:System.Net.Sockets.Socket.Bind%2A>會嘗試繫結至該連接埠的方法失敗，直到原始的繫結通訊端被終結。  
  
 必須先設定此屬性才<xref:System.Net.Sockets.Socket.Bind%2A>被呼叫，否則為<xref:System.InvalidOperationException>就會擲回。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">已為這個 <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> 呼叫 <see cref="T:System.Net.Sockets.Socket" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Net.Sockets.Socket" /> 類別所使用的資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>類別完成項呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法以關閉<xref:System.Net.Sockets.Socket>釋放相關聯的資源和<xref:System.Net.Sockets.Socket>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Net.Sockets.Socket" /> 執行個體的雜湊值。</summary>
        <returns>整數雜湊值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
GetHashCode 方法會傳回這個執行個體的雜湊碼。 此值可用來當做雜湊表中的索引鍵。

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回 <see cref="T:System.Net.Sockets.Socket" /> 選項值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <summary>傳回指定 <see cref="T:System.Net.Sockets.Socket" /> 選項的值，表示為物件。</summary>
        <returns>表示選項值的物件。 當 <paramref name="optionName" /> 參數設為 <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> 時，傳回值將會是 <see cref="T:System.Net.Sockets.LingerOption" /> 類別的執行個體。 當 <paramref name="optionName" /> 設為 <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> 或 <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> 時，傳回值將會是 <see cref="T:System.Net.Sockets.MulticastOption" /> 類別的執行個體。 當 <paramref name="optionName" /> 是其他的任何值時，傳回的值則是一個整數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 若要取得使用此多載<xref:System.Net.Sockets.SocketOptionName.Linger>， <xref:System.Net.Sockets.SocketOptionName.AddMembership>，並<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>選項。 針對<xref:System.Net.Sockets.SocketOptionName.Linger>選項，請使用<xref:System.Net.Sockets.Socket>如`optionLevel`參數。 針對<xref:System.Net.Sockets.SocketOptionName.AddMembership>並<xref:System.Net.Sockets.SocketOptionName.DropMembership>，使用<xref:System.Net.Sockets.SocketOptionLevel.IP>。 如果您想要設定任何上述選項的值，請使用<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會擷取<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時的值，並加以顯示到主控台。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。  
  
-或- 
 <paramref name="optionName" /> 設定為不支援的值 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionValue"><see cref="T:System.Byte" /> 型別的陣列，將要接收選項設定。</param>
        <summary>傳回指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設定，表示為位元組陣列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 這個方法成功完成，陣列會指定由`optionValue`參數會包含指定的值<xref:System.Net.Sockets.Socket>選項。  
  
 當的長度`optionValue`陣列的儲存值，指定所需的位元組數目小於<xref:System.Net.Sockets.Socket>選項時，<xref:System.Net.Sockets.Socket.GetSocketOption%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。 使用此多載的布林值或整數都由任何通訊端。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會擷取<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時的值，並加以顯示到主控台。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。  
  
-或- 
在 .NET Compact Framework 應用程式中，Windows CE 的預設緩衝區空間設為 32768 個位元組。 您可以呼叫 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，以變更每個通訊端緩衝區空間。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionLength">要限制的傳回值長度，以位元組為單位。</param>
        <summary>以陣列傳回指定 <see cref="T:System.Net.Sockets.Socket" /> 選項的值。</summary>
        <returns><see cref="T:System.Byte" /> 型別的陣列，包含通訊端選項值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength`參數會設定傳回的位元組陣列的大小上限。 如果選項值需要更少個位元組，陣列將只包含位元組數。 如果選項值需要更多的位元組<xref:System.Net.Sockets.Socket.GetSocketOption%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 使用此多載的布林值或整數都由任何通訊端。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會擷取<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時的值，並加以顯示到主控台。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。  
  
-或- 
在 .NET Compact Framework 應用程式中，Windows CE 的預設緩衝區空間設為 32768 個位元組。 您可以呼叫 <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />，以變更每個通訊端緩衝區空間。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Net.Sockets.Socket" /> 的作業系統處理。</summary>
        <value><see cref="T:System.IntPtr" />，表示 <see cref="T:System.Net.Sockets.Socket" /> 的作業系統控制代碼。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>設定 <see cref="T:System.Net.Sockets.Socket" /> 的低階作業系統模式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><see cref="T:System.Int32" /> 值，指定要執行之作業的控制碼。</param>
        <param name="optionInValue"><see cref="T:System.Byte" /> 陣列，包含作業所需的輸入資料。</param>
        <param name="optionOutValue"><see cref="T:System.Byte" /> 陣列，包含作業傳回的輸出資料。</param>
        <summary>使用數值控制碼，設定 <see cref="T:System.Net.Sockets.Socket" /> 的低階作業模式。</summary>
        <returns><paramref name="optionOutValue" /> 中的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A>方法會提供低階作業系統存取權<xref:System.Net.Sockets.Socket>基礎的目前執行個體<xref:System.Net.Sockets.Socket>類別。 如需詳細資訊，請參閱 < [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)文件。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會比較 FIONREAD 和可用屬性的結果。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">已嘗試不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 屬性來變更封鎖模式。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要執行 unmanaged 程式碼。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><see cref="T:System.Net.Sockets.IOControlCode" /> 值，指定要執行之作業的控制碼。</param>
        <param name="optionInValue"><see cref="T:System.Byte" /> 型別的陣列，包含作業所需的輸入資料。</param>
        <param name="optionOutValue"><see cref="T:System.Byte" /> 型別的陣列，包含作業傳回的輸出資料。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 列舉型別指定控制碼，以設定 <see cref="T:System.Net.Sockets.IOControlCode" /> 的低階作業模式。</summary>
        <returns><paramref name="optionOutValue" /> 中的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會提供低階作業系統存取權<xref:System.Net.Sockets.Socket>基礎的目前執行個體<xref:System.Net.Sockets.Socket>類別。 如需詳細資訊，請參閱 < [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)文件。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會比較呼叫的結果<xref:System.Net.Sockets.Socket.IOControl%2A>具有<xref:System.Net.Sockets.IOControlCode.DataToRead>而<xref:System.Net.Sockets.Socket.Available%2A>屬性。  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.InvalidOperationException">已嘗試不使用 <see cref="P:System.Net.Sockets.Socket.Blocking" /> 屬性來變更封鎖模式。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">若要執行 unmanaged 程式碼。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Net.Sockets.Socket" /> 是否繫結至特定的本機通訊埠。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 繫結至本機通訊埠，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通訊端會被視為本機連接埠的繫結，如果呼叫明確繫結<xref:System.Net.Sockets.Socket.Bind%2A>方法，或以隱含方式繫結所呼叫的成員，像是<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，其中使用暫時的本機連接埠 （可用的連接埠大於1024，選取作業系統。)伺服器會使用<xref:System.Net.Sockets.Socket.Bind%2A>繫結的已知的連接埠，讓用戶端可以連線到它們的方法。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.IsBound%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 是否會延遲關閉通訊端，以嘗試傳送所有暫止資料。</summary>
        <value><see cref="T:System.Net.Sockets.LingerOption" />，指定關閉通訊端時如何延遲。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A>屬性變更的方式<xref:System.Net.Sockets.Socket.Close%2A>方法的行為。 這個屬性時設定修改用以連接可以重設的 Winsock 的條件。 連接重設，仍然會根據 IP 通訊協定行為。  
  
 此屬性控制的連線導向的連線會維持開啟狀態之後呼叫的時間長度<xref:System.Net.Sockets.Socket.Close%2A>資料保持傳送。  
  
 當您呼叫方法，以將資料傳送至對等時，這項資料會在傳出的網路緩衝區中。 這個屬性可以用來確保這項資料會傳送到遠端主機，才能進行<xref:System.Net.Sockets.TcpClient.Close%2A>方法會卸除連接。  
  
 若要啟用延遲，請建立<xref:System.Net.Sockets.LingerOption>執行個體包含所需的值，並設定<xref:System.Net.Sockets.Socket.LingerState%2A>，這個執行個體的屬性。  
  
 下表描述的行為<xref:System.Net.Sockets.Socket.Close%2A>方法的可能值<xref:System.Net.Sockets.LingerOption.Enabled%2A>屬性並<xref:System.Net.Sockets.LingerOption.LingerTime%2A>屬性儲存在<xref:System.Net.Sockets.Socket.LingerState%2A>屬性。  
  
|LingerState.Enabled|LingerState.LingerTime|行為|  
|-------------------------|----------------------------|--------------|  
|`false` （已停用），預設值|逾時並不適用，（預設值）。|嘗試將預設 IP 通訊協定等候逾時到期之前傳送暫止資料。|  
|`true` （已啟用）|非零的逾時|嘗試傳送暫止資料，直到指定的逾時到期，但如果嘗試失敗，然後 Winsock 重設連接。|  
|`true` （已啟用）|零逾時。|會捨棄任何暫止的資料。 連接導向通訊端 (例如 TCP)，Winsock 重設連接。|  
  
 IP 堆疊預設 IP 通訊協定逾時期限，將會根據計算的連線的來回時間。 在大部分情況下，堆疊所計算的逾時則是更為相關應用程式所定義的其中一個項目。 這是通訊端的預設行為時<xref:System.Net.Sockets.Socket.LingerState%2A>屬性未設定。  
  
 當<xref:System.Net.Sockets.LingerOption.LingerTime%2A>屬性會儲存在<xref:System.Net.Sockets.Socket.LingerState%2A>屬性設定為大於預設 IP 通訊協定等候逾時，預設 IP 通訊協定等候逾時仍會在套用，並覆寫。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.LingerState%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">暫止連接佇列的最大長度。</param>
        <summary>將 <see cref="T:System.Net.Sockets.Socket" /> 置於接聽狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> 會導致連線導向<xref:System.Net.Sockets.Socket>來接聽連入連線嘗試。 `backlog`參數會指定可排入佇列進行接受度測試的連入連線的數目。 若要判斷您可以指定的連線的最大數目，請擷取<xref:System.Net.Sockets.SocketOptionName.MaxConnections>值。 <xref:System.Net.Sockets.Socket.Listen%2A> 不會封鎖。  
  
 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。 使用<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.BeginAccept%2A>接受來自佇列的連接。  
  
> [!NOTE]
>  您必須呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.Listen%2A>，或<xref:System.Net.Sockets.Socket.Listen%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
> [!NOTE]
>  待處理項目參數會限制為不同的值，視作業系統而定。 您可以指定較高的值，但待處理項目將會限定作業系統為基礎。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.Socket>來接聽連入連線。  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得本機端點。</summary>
        <value><see cref="T:System.Net.EndPoint" />，<see cref="T:System.Net.Sockets.Socket" /> 正將它用於通訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性會取得<xref:System.Net.EndPoint>本機 IP 位址和連接埠編號，其中包含您<xref:System.Net.Sockets.Socket>繫結。 您必須將此轉型<xref:System.Net.EndPoint>至<xref:System.Net.IPEndPoint>之前擷取任何資訊。 您可以接著呼叫<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法來擷取本機<xref:System.Net.IPAddress>，和<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法來擷取本機連接埠號碼。  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>進行呼叫之後，通常設定屬性<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果您允許系統在將通訊端的本機 IP 位址和連接埠號碼指派<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>之後第一項 I/O 作業將會設定屬性。 連線導向的通訊協定，第一項 I/O 作業會呼叫<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 無連線的通訊協定，第一項 I/O 作業會是任何傳送或接收呼叫。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會擷取，並顯示本機和遠端端點。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定輸出多點傳送封包是否會傳遞至傳送應用程式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 會接收輸出多點傳送封包，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多點傳送是可擴充的方法，在網際網路上的多對多通訊。 處理序會訂閱的多點傳送位址;然後，任何已訂閱的程序所傳送的封包都會收到每個訂閱的多點傳送位址的程序。  
  
 傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會有任何作用。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.MulticastLoopback%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Boolean" /> 值，指定資料流 <see cref="T:System.Net.Sockets.Socket" /> 是否使用 Nagle 演算法。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 使用 Nagle 演算法，則為 <see langword="false" />，否則為 <see langword="true" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle 演算法被設計來減少網路流量造成緩衝小型封包然後結合並在某些情況下一個封包傳送給他們的通訊端。 TCP 封包是由 40 個位元組的標頭加上所傳送之資料所組成。 當小型資料封包傳送使用 TCP 時，TCP 標頭所產生的額外負荷可能會變得的網路流量的重要部分。在負載極高的網路中，所產生的這項負擔壅塞會導致遺失的資料包和重新傳輸，以及因壅塞的過多的傳播時間而定。 Nagle 演算法禁止傳送新的 TCP segmentswhen 新傳出資料抵達時向使用者如果在連接上的任何 previouslytransmitted 資料會維持未認可。  
  
 大部分的網路應用程式應該使用 Nagle 演算法。  
  
 使用者資料包通訊協定 (UDP) 通訊端上設定這個屬性會有任何作用。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.NoDelay%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指出基礎作業系統和網路配置器是否支援網際網路通訊協定第 4 版 (IPv4)。</summary>
        <value>如果作業系統和網路配置器支援 IPv4 通訊協定則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作業系統可支援 IPv4 和 IPv6 通訊協定。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指出基礎作業系統和網路配置器是否支援網際網路通訊協定第 6 版 (IPv6)。</summary>
        <value>如果作業系統和網路配置器支援 IPv6 通訊協定則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作業系統可支援 IPv4 和 IPv6 通訊協定。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds">等待回應的時間，以微秒為單位。</param>
        <param name="mode">其中一個 <see cref="T:System.Net.Sockets.SelectMode" /> 值。</param>
        <summary>決定 <see cref="T:System.Net.Sockets.Socket" /> 的狀態。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> 的狀態，根據從 <paramref name="mode" /> 參數中傳遞的輪詢模式值而定。  
  
 <list type="table"><listheader><term> 模式 
 </term><description> 傳回值 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description>如果已呼叫 <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> 且連接暫止時，則為 <see langword="true" />； 
-或- 
 如果資料可供讀取，則為 <see langword="true" />； 
-或- 
 如果連接已經關閉、重設或結束，則為 <see langword="true" />； 
否則，傳回 <see langword="false" />。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description>如果處理 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> 且已成功建立連接時，則為 <see langword="true" />； 
-或- 
 如果可以傳送資料，則為 <see langword="true" />； 
否則，傳回 <see langword="false" />。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description>如果處理的 <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> 沒有封鎖且連接已失敗時，則為 <see langword="true" />； 
-或- 
 如果未設定 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> 且 Out-of-Band Data 可用時，則為 <see langword="true" />； 
否則，傳回 <see langword="false" />。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A>方法會檢查的狀態<xref:System.Net.Sockets.Socket>。 指定<xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType>for`selectMode`參數，來判斷如果<xref:System.Net.Sockets.Socket>讀取。 指定<xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType>判斷<xref:System.Net.Sockets.Socket>是可寫入。 使用<xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType>偵測錯誤狀況。 <xref:System.Net.Sockets.Socket.Poll%2A> 將會封鎖執行，直到指定的時間長度，以測量`microseconds`，經過。 設定`microSeconds`負整數，如果您想要無限期地等待回應的參數。 如果您想要檢查多個通訊端的狀態，您可能會偏好使用<xref:System.Net.Sockets.Socket.Select%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  這個方法無法偵測某些類型的連線問題，例如中斷的網路纜線，或遠端主機已強制關閉。 您必須嘗試傳送或接收資料，以偵測這些類型的錯誤。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立通訊端、 連接到伺服器，並使用<xref:System.Net.Sockets.Socket.Poll%2A>檢查通訊端的狀態。  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="mode" /> 參數不是其中一個 <see cref="T:System.Net.Sockets.SelectMode" /> 值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱下面的＜備註＞。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Net.Sockets.Socket" /> 的通訊協定 (Protocol) 類型。</summary>
        <value>其中一個 <see cref="T:System.Net.Sockets.ProtocolType" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A>屬性時，會設定<xref:System.Net.Sockets.Socket>會建立，並指定所使用的通訊協定<xref:System.Net.Sockets.Socket>。  
  
   
  
## Examples  
 下列程式碼範例會顯示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>到主控台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從已繫結的 <see cref="T:System.Net.Sockets.Socket" /> 接收資料。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <summary>從已繫結的 <see cref="T:System.Net.Sockets.Socket" /> 接收資料至接收緩衝區中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。 您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。  
  
 這個多載只會要求您提供的接收緩衝區。 緩衝區位移的預設值為 0，則大小會預設為參數長度的緩衝區，而<xref:System.Net.Sockets.SocketFlags>值預設為<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>來連接遠端主機，或是<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線才能呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中所建立的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收任何主機從送達的資料。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法將會封鎖直到資料為止，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在非封鎖模式中，而且沒有使用中的資料以通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，接收作業重試一次。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>，則<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，但不超過緩衝區的大小的資料量。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您收到的資料包大於的大小`buffer`參數，`buffer`取得填滿與訊息的第一個部分，過多的資料都會遺失，<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會接收上已連接的資料<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，包含已接收的資料。</param>
        <summary>從已繫結的 <see cref="T:System.Net.Sockets.Socket" /> 接收資料至接收緩衝區清單中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會將資料讀入緩衝區參數，並傳回成功讀取的位元組數目。 您可以從連線導向和無連線通訊端呼叫。  
  
 這個多載會要求您提供一個或多個接收緩衝區。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>來連接遠端主機，或是<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線才能呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自中建立的遠端主機連接的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收任何主機從送達的資料。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法將會封鎖直到資料為止，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在非封鎖模式中，而且沒有使用中的資料以通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，接收作業重試一次。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>，則<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，但不超過緩衝區的大小的資料量。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您收到的資料包大於的大小`buffers`參數，`buffers`取得填滿與訊息的第一個部分，過多的資料都會遺失，<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
 **請注意**應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。 您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。  
  
 這個多載只需要您提供的接收緩衝區和必要<xref:System.Net.Sockets.SocketFlags>。 緩衝區位移的預設值為 0，且大小預設值為位元組參數的長度。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>來連接遠端主機，或是<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線才能呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中所建立的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收任何主機從送達的資料。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法將會封鎖直到資料可供使用。 如果您是在非封鎖模式中，而且沒有可用的通訊協定堆疊緩衝區中的資料<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，再試一次您接收作業。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>，則<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取但不超過緩衝區的大小可用的資料量。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您收到的資料包大於的大小`buffer`參數，`buffer`取得填滿與訊息的第一個部分，過多的資料都會遺失，<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會指定資料緩衝區，並<xref:System.Net.Sockets.SocketFlags>接收資料的連接<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，包含已接收的資料。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區清單中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取資料到`buffers`參數並傳回成功讀取的位元組數目。 您可以從連線導向和無連線通訊端呼叫。  
  
 這個多載會要求您提供一個或多個接收緩衝區。 <xref:System.Net.Sockets.SocketFlags>值預設為<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>來連接遠端主機，或是<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線才能呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自中建立的遠端主機連接的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收任何主機從送達的資料。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法將會封鎖直到資料為止，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在非封鎖模式中，而且沒有使用中的資料以通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，接收作業重試一次。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>，則<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，但不超過緩衝區的大小的資料量。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您收到的資料包大於的大小`buffers`參數，`buffers`取得填滿與訊息的第一個部分，過多的資料都會遺失，<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何接收連線的資料<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="buffers" />.Count 為零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 將指定位元組數的資料接收至接收緩衝區中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取資料到`buffer`參數並傳回成功讀取的位元組數目。 您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。  
  
 這個多載只要求您提供的接收緩衝區中，您想要接收的位元組和必要的數目<xref:System.Net.Sockets.SocketFlags>。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>來連接遠端主機，或是<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線才能呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中所建立的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收任何主機從送達的資料。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法將會封鎖直到資料為止，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在非封鎖模式中，而且沒有使用中的資料以通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，再試一次您接收作業。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>，則<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，最多所指定的位元組數目的資料量`size`參數。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您收到的資料包大於的大小`buffer`參數，`buffer`取得填滿與訊息的第一個部分，過多的資料都會遺失，<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列接收到找到的資料`buffer`，並指定<xref:System.Net.Sockets.SocketFlags.None>如<xref:System.Net.Sockets.SocketFlags>。  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> 超過 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，包含已接收的資料。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區清單中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會讀取資料到`buffers`參數並傳回成功讀取的位元組數目。 您可以從連線導向和無連線通訊端呼叫。  
  
 這個多載會要求您提供一個或多個接收緩衝區。 <xref:System.Net.Sockets.SocketFlags>值預設為<xref:System.Net.Sockets.SocketFlags.None>。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>來連接遠端主機，或是<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線才能呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自中建立的遠端主機連接的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收任何主機從送達的資料。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法將會封鎖直到資料為止，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在非封鎖模式中，而且沒有使用中的資料以通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，接收作業重試一次。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>，則<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，但不超過緩衝區的大小的資料量。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您收到的資料包大於的大小`buffers`參數，`buffers`取得填滿與訊息的第一個部分，過多的資料都會遺失，<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="buffers" />.Count 為零。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</param>
        <param name="offset"><paramref name="buffer" /> 中存放已接收資料的位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 將指定的位元組數接收到接收緩衝區的指定位移位置。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。 您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>來連接遠端主機，或是<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線才能呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中所建立的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收任何主機從送達的資料。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法將會封鎖直到資料為止，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在非封鎖模式中，而且沒有使用中的資料以通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 嘗試存取通訊端時發生錯誤。 請參閱下方註解。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，接收作業重試一次。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>，則<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，最多的 size 參數所指定的位元組數目的資料量。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您收到的資料包大於的大小`buffer`參數，`buffer`取得填滿與訊息的第一個部分，過多的資料都會遺失，<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例指定資料緩衝區、 位移、 大小和通訊端旗標接收上已連接的資料之前<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值組合。  
  
-或- 
未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。  
  
-或- 
在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="offset"><paramref name="buffer" /> 參數中的位置，可儲存接收的資料。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，從已繫結的 <see cref="T:System.Net.Sockets.SocketFlags" /> 接收資料至接收緩衝區中。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>方法會將資料讀入緩衝區參數並傳回成功讀取的位元組數目。 您可以呼叫<xref:System.Net.Sockets.Socket.Receive%2A>從連線導向和無連線通訊端。  
  
 如果您使用連線導向的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>來連接遠端主機，或是<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線才能呼叫<xref:System.Net.Sockets.Socket.Receive%2A>。 <xref:System.Net.Sockets.Socket.Receive%2A>方法只會讀取來自遠端主機中所建立的資料<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您使用無連接的通訊協定，您也可以使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 可讓您接收任何主機從送達的資料。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.Receive%2A>方法將會封鎖直到資料為止，除非使用已設定的逾時值<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Receive%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 如果您是在非封鎖模式中，而且沒有使用中的資料以通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 嘗試存取通訊端時發生錯誤。 請參閱下方註解。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，接收作業重試一次。  
  
 如果您使用連線導向<xref:System.Net.Sockets.Socket>，則<xref:System.Net.Sockets.Socket.Receive%2A>方法會讀取可供使用，最多的 size 參數所指定的位元組數目的資料量。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.Receive%2A>方法會立即完成，並傳回零個位元組。  
  
 如果您使用無連接<xref:System.Net.Sockets.Socket>，<xref:System.Net.Sockets.Socket.Receive%2A>會從您在中指定的目的地位址讀取第一個加入佇列的資料包<xref:System.Net.Sockets.Socket.Connect%2A>方法。 如果您收到的資料包大於的大小`buffer`參數，`buffer`取得填滿與訊息的第一個部分，過多的資料都會遺失，<xref:System.Net.Sockets.SocketException>就會擲回。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值組合。  
  
-或- 
未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。  
  
-或- 
在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始非同步要求，以接收來自已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件的資料。</summary>
        <returns>若 I/O 作業暫止，則為 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 若 I/O 作業同步完成，則為 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法可在連線通訊端或繫結的無連線通訊端和用來讀取內送資料。 必須知道通訊端的本機位址。  
  
 繫結的無連線通訊端，此函式會限制已接受已接收的訊息的位址。 函式只會傳回在連接中指定的遠端位址的訊息。 以無訊息模式已捨棄來自其他位址的訊息。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>屬性上的`e`參數提供的視窗通訊端服務提供者的其他讀取要求的相關資訊。 如需如何使用此參數的詳細資訊，請參閱<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件，才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能會設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>呼叫之前所需的任何使用者狀態物件的屬性<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法，如此會在回呼方法中擷取資訊。 如果回呼需要比單一物件的詳細資訊，就可以建立小型的類別來保存為成員的其他必要的狀態資訊。  
  
 位元組資料流樣式的通訊端，內送資料被放入緩衝區，直到緩衝區已滿、 關閉連線，或已用完內部緩衝的資料。  
  
 訊息導向的通訊端，內送訊息會放入之前的相關聯的緩衝區大小總計的緩衝區`e`參數。 如果訊息大於緩衝區，緩衝區會填入訊息的第一個部分。  
  
 連線導向的通訊端，<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>方法可以指定其中一種取決於通訊端是位元組資料流或訊息導向的兩個此虛擬電路正常終止。 已讀取的零位元組位元組資料流，表示正常關閉，以往會讀取任何更多的位元組。 訊息導向通訊端，其中通常是可允許零位元組的訊息，如<xref:System.Net.Sockets.SocketException>與<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>設為原生的 Winsock WSAEDISCON 錯誤程式碼 (10101) 用來表示非失誤性結束。 在任何情況下，<xref:System.Net.Sockets.SocketException>與<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>設為原生的 Winsock WSAECONNRESET 錯誤碼 (10054) 會指出發生失敗的關閉。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引數無效。 <paramref name="e" /> 參數上的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性必須參考有效的緩衝區。 這兩個屬性可能有一個已經設定，但不會同時都已設定。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 之接收緩衝區的大小。</summary>
        <value><see cref="T:System.Int32" />，包含接收緩衝區的大小 (以位元組為單位)。 預設值為 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 較大的緩衝區大小可能減少的空白通知 （TCP 封包，沒有資料部分），但也可能會延遲連線困難的辨識。 請考慮增加緩衝區大小，如果您正在傳送大型檔案，或您使用的高頻寬、 高延遲連線 （例如衛星寬頻提供者。）  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">為設定作業指定的值小於 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接收資料包以及儲存來源端點。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</param>
        <param name="remoteEP">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</param>
        <summary>接收資料包至資料緩衝區中，並儲存端點。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並擷取資料已傳送遠端主機端點。 這個方法很有用，如果您想要收到未知的主機或多個主控件的無連接的資料包。  
  
 這個多載只要求您提供接收`buffer`，並有<xref:System.Net.EndPoint>表示遠端主機。 緩衝區位移為 0 的預設值。 大小的預設值的長度`buffer`參數與`socketFlags`值預設為<xref:System.Net.Sockets.SocketFlags.None>。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確地繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果您未這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 無連接的通訊協定，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取到區域網路緩衝區收到第一個加入佇列的資料包。 如果您收到的資料包大於的大小`buffer`，則<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`盡可能是盡可能，，並擲回的訊息與<xref:System.Net.Sockets.SocketException>。 如果您使用的不可靠的通訊協定，超過的資料將會遺失。 如果您使用可靠的通訊協定、 過多的資料會保留由服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>夠大的緩衝區的方法。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料可供使用。 如果您是在非封鎖模式中，而且沒有使用中的資料以通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，接收作業重試一次。  
  
 雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連線的通訊協定，您可以使用連線導向的通訊協定以及。 如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您不要建立或接受連接，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，將會取得<xref:System.Net.Sockets.SocketException>。 您也可以建立預設遠端主機的無連線的通訊協定，才能呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在這些情況下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數和只接收來自已連接的資料或預設遠端主機。  
  
 使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將讀取的大小可用的資料量`buffer`。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無資料包 (datagram) 接收遠端主機。  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><see cref="T:System.Byte" /> 型別的陣列，為收到資料的存放位置。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，接收資料包至資料緩衝區中，並儲存端點。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並擷取資料已傳送遠端主機端點。 這個方法很有用，如果您想要收到未知的主機或多個主控件的無連接的資料包。  
  
 這個多載只要求您提供必要的接收緩衝區<xref:System.Net.Sockets.SocketFlags>，並有<xref:System.Net.EndPoint>表示遠端主機。 位移的預設值為 0，則大小會預設為緩衝區參數的長度。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確地繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果您未這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 無連接的通訊協定，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取到區域網路緩衝區收到第一個加入佇列的資料包。 如果您收到的資料包大於的大小`buffer`，則<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`盡可能是盡可能，，並擲回的訊息與<xref:System.Net.Sockets.SocketException>。 如果您使用的不可靠的通訊協定，超過的資料將會遺失。 如果您使用可靠的通訊協定、 過多的資料會保留由服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>夠大的緩衝區的方法。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料可供使用。 如果您是在非封鎖模式中，而且沒有使用中的資料以通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，接收作業重試一次。  
  
 雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連線的通訊協定，您可以使用連線導向的通訊協定以及。 如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您不要建立或接受連接，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，將會取得<xref:System.Net.Sockets.SocketException>。 您也可以建立預設遠端主機的無連線的通訊協定，才能呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在這些情況下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數和只接收來自已連接的資料或預設遠端主機。  
  
 使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將讀取的大小可用的資料量`buffer`。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無資料包 (datagram) 接收遠端主機。 <xref:System.Net.Sockets.SocketFlags> 傳遞至<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，接收指定的位元組數至資料緩衝區中，並儲存端點。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並擷取資料已傳送遠端主機端點。 這個方法很有用，如果您想要收到未知的主機或多個主控件的無連接的資料包。  
  
 這個多載只要求您提供接收緩衝區中，您想要接收，必要的位元組數目<xref:System.Net.Sockets.SocketFlags>，並有<xref:System.Net.EndPoint>表示遠端主機。 緩衝區位移為 0 的預設值。  
  
 無連接的通訊協定，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取到區域網路緩衝區收到第一個加入佇列的資料包。 如果您收到的資料包大於的大小`buffer`，則<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`盡可能是盡可能，，並擲回的訊息與<xref:System.Net.Sockets.SocketException>。 如果您使用的不可靠的通訊協定，超過的資料將會遺失。 如果您使用可靠的通訊協定、 過多的資料會保留由服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>夠大的緩衝區的方法。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料可供使用。 如果您是在非封鎖模式中，而且沒有使用中的資料以通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，接收作業重試一次。  
  
 雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連線的通訊協定，您可以使用連線導向的通訊協定以及。 如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您不要建立或接受連接，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，將會取得<xref:System.Net.Sockets.SocketException>。 您也可以建立預設遠端主機的無連線的通訊協定，才能呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在這些情況下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數和只接收來自已連接的資料或預設遠端主機。  
  
 使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取位於不超過所指定的位元組數目的資料量`size`參數。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確地繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果您未這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無資料包 (datagram) 接收遠端主機。 緩衝區大小，以及<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值組合。  
  
-或- 
未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。  
  
-或- 
在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</param>
        <param name="offset"><paramref name="buffer" /> 參數中的位置，可儲存接收的資料。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，將指定的資料位元組數目接收至資料緩衝區的指定位置，並儲存端點。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並擷取資料已傳送遠端主機端點。 這個方法很有用，如果您想要收到未知的主機或多個主控件的無連接的資料包。  
  
 無連接的通訊協定，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取到區域網路緩衝區收到第一個加入佇列的資料包。 如果您收到的資料包大於的大小`buffer`，則<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會填滿`buffer`盡可能是盡可能，，並擲回的訊息與<xref:System.Net.Sockets.SocketException>。 如果您使用的不可靠的通訊協定，超過的資料將會遺失。 如果您使用可靠的通訊協定、 過多的資料會保留由服務提供者，而且您可以呼叫來擷取<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>夠大的緩衝區的方法。  
  
 如果沒有資料可供讀取，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會封鎖直到資料可供使用。 如果您是在非封鎖模式中，而且沒有使用中的資料以通訊協定堆疊緩衝區<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並擲回<xref:System.Net.Sockets.SocketException>。 您可以使用<xref:System.Net.Sockets.Socket.Available%2A>屬性來判斷資料是否可供讀取。 當<xref:System.Net.Sockets.Socket.Available%2A>是不是零，接收作業重試一次。  
  
 雖然<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>適用於無連線的通訊協定，您可以使用連線導向的通訊協定以及。 如果您選擇這樣做，您必須先請建立遠端主機連接藉由呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受連入遠端主機連線，藉由呼叫<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您不要建立或接受連接，然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法，將會取得<xref:System.Net.Sockets.SocketException>。 您也可以建立預設遠端主機的無連線的通訊協定，才能呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。 在這些情況下，任一<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法將會忽略`remoteEP`參數和只接收來自已連接的資料或預設遠端主機。  
  
 使用連線導向的通訊端<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>會讀取位於所指定的位元組之數量為上限的資料量`size`參數。 如果遠端主機已關閉<xref:System.Net.Sockets.Socket>與連接<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，以及所有可用的資料已收到，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法會立即完成，並傳回零個位元組。  
  
> [!NOTE]
>  然後再呼叫<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>，您必須明確地繫結<xref:System.Net.Sockets.Socket>本機端點使用<xref:System.Net.Sockets.Socket.Bind%2A>方法。 如果您未這麼做，<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無資料包 (datagram) 接收遠端主機。 位移、 緩衝區大小，以及<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去位移參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值組合。  
  
-或- 
未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。  
  
-或- 
嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>開始從指定的網路裝置非同步接收資料。</summary>
        <returns>若 I/O 作業暫止，則為 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 若 I/O 作業同步完成，則為 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>方法主要用來接收無連線的通訊端上的資料。 必須知道通訊端的本機位址。  
  
 呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性設<xref:System.Net.IPEndPoint>為接收資料來源的遠端主機。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>屬性上的`e`參數提供的視窗通訊端服務提供者的其他讀取要求的相關資訊。 如需如何使用此參數的詳細資訊，請參閱<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件，才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能會設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>呼叫之前所需的任何使用者狀態物件的屬性<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>方法，如此會在回呼方法中擷取資訊。 如果回呼需要比單一物件的詳細資訊，就可以建立小型的類別來保存為成員的其他必要的狀態資訊。  
  
 訊息導向的通訊端，內送訊息會放入之前將緩衝區的總大小的緩衝區。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>屬性決定放置資料緩衝區的位置及的資料量。  
  
 位元組資料流樣式的通訊端，內送資料被放入緩衝區，直到緩衝區已滿、 關閉連線，或已用完內部緩衝的資料。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>屬性決定放置資料緩衝區的位置及的資料量。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不可以是 null。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，此為接收資料的儲存位置。</param>
        <param name="offset"><paramref name="buffer" /> 參數中的位置，可儲存接收的資料。</param>
        <param name="size">要接收的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP">以傳址方式傳遞的 <see cref="T:System.Net.EndPoint" />，表示遠端伺服器。</param>
        <param name="ipPacketInformation">保留位址及介面資訊的 <see cref="T:System.Net.Sockets.IPPacketInformation" />。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，將指定的資料位元組數目接收至資料緩衝區的指定位置，並儲存端點及封包資訊。</summary>
        <returns>收到的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法會讀取資料到`buffer`參數，會傳回成功讀取的位元組數目，並擷取遠端主機資料已傳送的端點，以及收到的封包的相關資訊。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法主要用來接收無連線的通訊端上的訊息資料。 必須知道通訊端的本機位址。 這個方法只會搭配資料包和原始通訊端中。 通訊端必須先初始化通訊端類型設定為<xref:System.Net.Sockets.SocketType.Dgram>或<xref:System.Net.Sockets.SocketType.Raw>之前呼叫這個方法。 這可以使用建構通訊端時<xref:System.Net.Sockets.Socket.%23ctor%2A>。  
  
 訊息導向的通訊端，內送訊息會放入`buffer`參數中指定的總大小最`size`參數。 `offset`參數會決定在何處`buffer`將資料放在。 實際的資料量放入`buffer`由<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法會自動設定方法<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項來`true`呼叫的第一次指定<xref:System.Net.Sockets.Socket>。 不過，傳回<xref:System.Net.Sockets.IPPacketInformation>物件只會對封包抵達本機電腦，設定通訊端選項之後有效。 如果通訊端會傳送之間的封包，當它繫結至本機端點 (明確地<xref:System.Net.Sockets.Socket.Bind%2A>方法或由其中一個隱含<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法) 和其第一次呼叫<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>若要呼叫的方法，<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>方法會傳回無效<xref:System.Net.Sockets.IPPacketInformation>這些封包的物件。  
  
 為了確保所有<xref:System.Net.Sockets.IPPacketInformation>物件有效，而且應用程式應該設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項來`true`它會繫結至本機端點使用之前<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>方法。  
  
 應用程式可以檢查`ipPacketInformation`參數，如果它需要知道是否資料包所傳送的單點傳播、 多點傳送或廣播位址。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>必須符合<xref:System.Net.Sockets.AddressFamily>的<xref:System.Net.EndPoint>用於<xref:System.Net.Sockets.Socket.SendTo%2A>。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
\-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去位移參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值組合。  
  
-或- 
未設定 <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> 屬性。  
  
-或- 
.NET Framework 正在 AMD 64 位元處理器上執行。  
  
-或- 
嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.NotSupportedException">作業系統是 Windows 2000 (含) 以前版本，但這個方法需要的是 Windows XP。</exception>
        <permission cref="T:System.Net.SocketPermission">接受來自網路的連線。 關聯的列舉型別：<see cref="F:System.Net.NetworkAccess.Accept" />。</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>使用指定的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />，開始以非同步方式將指定之位元組數目的資料，接收至資料緩衝區的指定位置，並儲存端點和封包資訊。</summary>
        <returns>若 I/O 作業暫止，則為 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 若 I/O 作業同步完成，則為 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法主要用來接收無連線的通訊端上的訊息資料。 必須知道通訊端的本機位址。 這個方法只會搭配資料包和原始通訊端中。 通訊端必須先初始化通訊端類型設定為<xref:System.Net.Sockets.SocketType.Dgram>或<xref:System.Net.Sockets.SocketType.Raw>之前呼叫這個方法。 這可以使用建構通訊端時<xref:System.Net.Sockets.Socket.%23ctor%2A>。  
  
 呼叫端必須將<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性設<xref:System.Net.IPEndPoint>為接收資料來源的遠端主機。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件，才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能會設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>呼叫之前所需的任何使用者狀態物件的屬性<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法，如此會在回呼方法中擷取資訊。 如果回呼需要比單一物件的詳細資訊，就可以建立小型的類別來保存為成員的其他必要的狀態資訊。  
  
 訊息導向的通訊端，內送訊息會放入之前將緩衝區的總大小的緩衝區。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>和<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>屬性決定放置資料緩衝區的位置及的資料量。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法會自動設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項來`true`呼叫的第一次指定<xref:System.Net.Sockets.Socket>。 不過，<xref:System.Net.Sockets.IPPacketInformation>物件只會對封包抵達本機電腦，設定通訊端選項之後有效。 如果通訊端通訊端繫結至本機端點時傳送封包之間 (明確地<xref:System.Net.Sockets.Socket.Bind%2A>方法或由其中一個隱含<xref:System.Net.Sockets.Socket.Connect%2A>， <xref:System.Net.Sockets.Socket.ConnectAsync%2A>， <xref:System.Net.Sockets.Socket.SendTo%2A>，或<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法) 和第一個呼叫<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法，呼叫<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>方法將會導致無效<xref:System.Net.Sockets.IPPacketInformation>這些封包的物件。  
  
 為了確保所有<xref:System.Net.Sockets.IPPacketInformation>物件有效，而且應用程式應該設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>通訊端選項來`true`它會繫結至本機端點使用之前<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>方法。  
  
 應用程式可以檢查所產生的<xref:System.Net.Sockets.IPPacketInformation>物件是否需要知道是否資料包所傳送的單點傳播、 多點傳送或廣播位址。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不可以是 null。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定同步 <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 呼叫逾時之前的時間長度。</summary>
        <value>逾時值 (以毫秒為單位)。 預設值為 0，表示無限的逾時期間。 指定 -1 也表示無限的逾時期間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此選項適用於同步<xref:System.Net.Sockets.Socket.Receive%2A>僅呼叫。 如果超過逾時期限<xref:System.Net.Sockets.Socket.Receive%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">為設定作業指定的值小於 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得遠端端點。</summary>
        <value><see cref="T:System.Net.EndPoint" />，<see cref="T:System.Net.Sockets.Socket" /> 正在與其通訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性會取得<xref:System.Net.EndPoint>包含遠端 IP 位址和連接埠號碼的<xref:System.Net.Sockets.Socket>連線。 如果您使用無連接的通訊協定<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>包含的預設遠端 IP 位址和連接埠號碼與<xref:System.Net.Sockets.Socket>會進行通訊。 您必須將此轉型<xref:System.Net.EndPoint>至<xref:System.Net.IPEndPoint>之前擷取任何資訊。 您可以接著呼叫<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>方法來擷取遠端<xref:System.Net.IPAddress>，和<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>方法來擷取遠端連接埠號碼。  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>設定後呼叫<xref:System.Net.Sockets.Socket.Accept%2A>或<xref:System.Net.Sockets.Socket.Connect%2A>。 如果您嘗試存取此屬性稍早<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會擷取，並顯示本機和遠端端點。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="checkRead">要檢查可讀性的 <see cref="T:System.Net.Sockets.Socket" /> 執行個體的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite">要檢查可寫性的 <see cref="T:System.Net.Sockets.Socket" /> 執行個體的 <see cref="T:System.Collections.IList" />。</param>
        <param name="checkError">要檢查錯誤的 <see cref="T:System.Net.Sockets.Socket" /> 執行個體的 <see cref="T:System.Collections.IList" />。</param>
        <param name="microSeconds">逾時值 (以微秒為單位)。 -1 值表示無限逾時。</param>
        <summary>判斷一或多個通訊端的狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> 是一種靜態方法，決定一或多個狀態<xref:System.Net.Sockets.Socket>執行個體。 您必須將放入一或多個通訊端<xref:System.Collections.IList>您可以使用之前<xref:System.Net.Sockets.Socket.Select%2A>方法。 藉由呼叫檢查可讀性<xref:System.Net.Sockets.Socket.Select%2A>具有<xref:System.Collections.IList>做為`checkRead`參數。 若要檢查可寫性通訊端，使用`checkWrite`參數。 偵測錯誤狀況，使用`checkError`。 之後呼叫<xref:System.Net.Sockets.Socket.Select%2A>，則<xref:System.Collections.IList>會填滿滿足上述條件的通訊端。  
  
 如果您是處於接聽狀態，可讀性表示呼叫<xref:System.Net.Sockets.Socket.Accept%2A>而不會封鎖將會成功。 如果您已接受連線，可讀性表示資料可供讀取。 在這些情況下，所有的接收作業會成功，而不會封鎖。 可讀性也可以指定是否在遠端<xref:System.Net.Sockets.Socket>已關閉連接下，在此情況下呼叫<xref:System.Net.Sockets.Socket.Receive%2A>會立即傳回，以傳回零位元組。  
  
 <xref:System.Net.Sockets.Socket.Select%2A> 時傳回至少一個感興趣的通訊端 (在通訊端`checkRead`， `checkWrite`，並`checkError`列出) 符合指定的準則，或`microSeconds`超過參數時，視何者先。 設定`microSeconds`為-1 指定無限逾時。  
  
 若要以非封鎖式呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，可寫性表示您已成功連線。 如果您已經建立連接，可寫性表示，所有傳送作業會成功而不會封鎖。  
  
 如果您所做的非封鎖式呼叫<xref:System.Net.Sockets.Socket.Connect%2A>，則`checkerror`參數會識別尚未成功連線的通訊端。  
  
> [!NOTE]
>  使用<xref:System.Net.Sockets.Socket.Poll%2A>方法，如果您只想要判斷的單一狀態<xref:System.Net.Sockets.Socket>。  
  
> [!NOTE]
>  這個方法無法偵測某些類型的連線問題，例如中斷的網路纜線，或遠端主機已強制關閉。 您必須嘗試傳送或接收資料，以偵測這些類型的錯誤。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Net.Sockets.Socket.Select%2A>判斷哪一個接聽的通訊端連線要求。  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="checkRead" /> 參數是 <see langword="null" /> 或空白。  
  
-和- 
<paramref name="checkWrite" /> 參數是 <see langword="null" /> 或空白。 
-和- 
<paramref name="checkError" /> 參數是 <see langword="null" /> 或空白。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <summary>傳送資料至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。 <xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線通訊協定。  
  
 這個多載都需要此緩衝區包含您想要傳送的資料。 <xref:System.Net.Sockets.SocketFlags>值會預設為 0，緩衝區位移為 0，而且要傳送的緩衝區大小的預設值的位元組數目的預設值。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或是<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線。  
  
 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您不要使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法中，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>將會封鎖直到所有緩衝區的位元組傳送，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送的位元組數目小於緩衝區中可能會順利完成。 是記錄傳送的位元組數，以及重試此作業，直到應用程式可將位元組傳送緩衝區中的應用程式的責任。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何在已連接的資料傳送<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，其中包含要傳送的資料。</param>
        <summary>將清單中的緩衝區集合傳送至連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線通訊協定。  
  
 這個多載都需要至少一個緩衝區，其中包含您想要傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或是<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線。  
  
 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您不要使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法中，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>將會封鎖直到所有緩衝區的位元組傳送，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送的位元組數目小於緩衝區中可能會順利完成。 是記錄傳送的位元組數，以及重試此作業，直到應用程式可將位元組傳送緩衝區中的應用程式的責任。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 是空的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 請參閱以下註解章節。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，傳送資料至已連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中建立<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。 <xref:System.Net.Sockets.Socket.Send%2A>方法可以用於連接導向和無連線的通訊協定。  
  
 這個多載都需要此緩衝區包含您想要傳送的資料和的位元組合<xref:System.Net.Sockets.SocketFlags>。 緩衝區位移為 0，而且要傳送的緩衝區大小的預設值的位元組數目的預設值。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數值、 您要將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或是<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線。  
  
 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您不要使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法中，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法，然後再每次呼叫<xref:System.Net.Sockets.Socket.Send%2A>。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>將會封鎖直到所有緩衝區的位元組傳送，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送的位元組數目小於緩衝區中可能會順利完成。 負責您的應用程式來追蹤已傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  您必須確定您的緩衝區大小不會超過基礎的服務提供者的最大的封包。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何在已連接的資料傳送<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，其中包含要傳送的資料。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，將清單中的緩衝區集合傳送至連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載都需要至少一個緩衝區，其中包含您想要傳送的資料。 <xref:System.Net.Sockets.SocketFlags>值預設為 0。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketFlags`參數，您要將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或是<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線。  
  
 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您不要使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法中，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>將會封鎖直到所有緩衝區的位元組傳送，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在非封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送的位元組數目小於緩衝區中可能會順利完成。 是記錄傳送的位元組數，以及重試此作業，直到應用程式可將位元組傳送緩衝區中的應用程式的責任。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 是空的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，傳送指定的資料位元組數至已連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中建立<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。 <xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線通訊協定。  
  
 這個多載都需要包含您想要傳送，您想要傳送的位元組數目的位元組合的任何的資料的緩衝區<xref:System.Net.Sockets.SocketFlags>。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，您要將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或是<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線。  
  
 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您不要使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法中，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法，然後再每次呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>將會封鎖直到傳送要求的位元組數目，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送小於您要求的位元組數目可能會順利完成。 負責您的應用程式來追蹤已傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  您必須確定大小不超過最大的封包大小為基礎的服務提供者。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將傳送緩衝區中找到的資料，並指定<xref:System.Net.Sockets.SocketFlags.None>針對<xref:System.Net.Sockets.SocketFlags>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> 小於 0 或超過緩衝區的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值組合。  
  
-或- 
存取通訊端時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><see cref="T:System.ArraySegment`1" /> 型別的 <see cref="T:System.Byte" /> 清單，其中包含要傳送的資料。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.Socket" />，將清單中的緩衝區集合傳送至連接的 <see cref="T:System.Net.Sockets.SocketFlags" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載都需要至少一個緩衝區，其中包含您想要傳送的資料。 <xref:System.Net.Sockets.SocketFlags>值預設為 0。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketFlags`參數，您要將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法，或是<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線。  
  
 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 如果您不要使用<xref:System.Net.Sockets.Socket.SendTo%2A>方法中，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 您可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>將會封鎖直到所有緩衝區的位元組傳送，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在非封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送的位元組數目小於緩衝區中可能會順利完成。 是記錄傳送的位元組數，以及重試此作業，直到應用程式可將位元組傳送緩衝區中的應用程式的責任。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> 是空的。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="offset">資料緩衝區中要開始傳送資料的位置。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <summary>從指定位移開始，並使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，將資料的指定位元組數傳送到連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。 <xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線通訊協定。  
  
 在這個多載，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，您要將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線。  
  
 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>。 如果您不要使用<xref:System.Net.Sockets.Socket.SendTo%2A>，您就必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 您也必須確定大小未超過基礎的服務提供者的最大的封包大小。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>將會封鎖直到傳送要求的位元組數目，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送小於您要求的位元組數目可能會順利完成。 負責您的應用程式來追蹤已傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會指定資料緩衝區、 位移、 大小、 及<xref:System.Net.Sockets.SocketFlags>將資料傳送至已連接<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值組合。  
  
-或- 
在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="offset">資料緩衝區中要開始傳送資料的位置。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="errorCode"><see cref="T:System.Net.Sockets.SocketError" /> 物件，儲存通訊端錯誤。</param>
        <summary>從指定的位移開始並使用指定的 <see cref="T:System.Net.Sockets.Socket" />，將指定的資料位元組數傳送至已連接的 <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>已傳送到 <see cref="T:System.Net.Sockets.Socket" /> 的位元組數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 以同步方式將資料傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法並傳回成功傳送的位元組數目。 <xref:System.Net.Sockets.Socket.Send%2A> 可用的連線導向和無連線通訊協定。  
  
 在這個多載，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，您要將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法或<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線。  
  
 如果您使用無連線的通訊協定和計劃將資料傳送至數個不同的主控件，您應該使用<xref:System.Net.Sockets.Socket.SendTo%2A>。 如果您不要使用<xref:System.Net.Sockets.Socket.SendTo%2A>，您就必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>每次呼叫之前<xref:System.Net.Sockets.Socket.Send%2A>。 可以使用<xref:System.Net.Sockets.Socket.SendTo%2A>即使您已建立預設遠端主機與之後<xref:System.Net.Sockets.Socket.Connect%2A>。 您也可以變更預設遠端主機，才能呼叫<xref:System.Net.Sockets.Socket.Send%2A>藉由另一個呼叫<xref:System.Net.Sockets.Socket.Connect%2A>。  
  
 您也必須確定大小未超過基礎的服務提供者的最大的封包大小。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.Send%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.Send%2A>將會封鎖直到傳送要求的位元組數目，除非逾時已設定使用<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>。 如果已超過逾時值<xref:System.Net.Sockets.Socket.Send%2A>呼叫會擲回<xref:System.Net.Sockets.SocketException>。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.Send%2A>即使傳送小於您要求的位元組數目可能會順利完成。 負責您的應用程式來追蹤已傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.Send%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  成功完成傳送不表示已成功傳遞資料。 如果沒有緩衝區可用空間來保存資料傳輸的傳輸系統內，則除非通訊端已處於未封鎖模式，將會封鎖傳送。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會指定資料緩衝區、 位移、 大小、 及<xref:System.Net.Sockets.SocketFlags>將資料傳送至已連接<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值組合。  
  
-或- 
在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>將資料以非同步方式傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</summary>
        <returns>若 I/O 作業暫止，則為 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 若 I/O 作業同步完成，則為 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法用來從連線導向的通訊端上的一個或多個緩衝區寫入輸出資料。 這個方法也可用，不過，在無連接的通訊端 connect 作業指定遠端主機上。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法會啟動非同步傳送作業中所建立的遠端主機<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件，才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> 或 <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 如果<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能會設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>呼叫之前所需的任何使用者狀態物件的屬性<xref:System.Net.Sockets.Socket.SendAsync%2A>方法，如此會在回呼方法中擷取資訊。 如果回呼需要比單一物件的詳細資訊，就可以建立小型的類別來保存為成員的其他必要的狀態資訊。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>方法會擲回例外狀況，如果您未先呼叫<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>。  
  
 呼叫<xref:System.Net.Sockets.Socket.SendAsync%2A>方法可讓您能夠傳送不同的執行緒中的資料。  
  
 訊息導向的通訊端，不會超過訊息大小上限為基礎的 Windows 通訊端服務提供者。 如果資料太長而無法透過基礎的服務提供者以不可分割方式傳遞，則傳送任何資料而<xref:System.Net.Sockets.Socket.SendAsync%2A>方法會擲回<xref:System.Net.Sockets.SocketException>使用<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>設為原生的 Winsock WSAEMSGSIZE 錯誤程式碼 (10040)。  
  
 請注意，成功完成<xref:System.Net.Sockets.Socket.SendAsync%2A>方法不會指出已成功傳遞資料。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="e" /> 參數上的 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> 或 <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> 屬性必須參考有效的緩衝區。 這兩個屬性可能有一個已經設定，但不會同時都已設定。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">尚未透過 <see cref="T:System.Net.Sockets.Socket" />、<see cref="M:System.Net.Sockets.Socket.Accept" /> 或 <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> 方法取得 <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />，或尚未連接。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 之傳送緩衝區的大小。</summary>
        <value><see cref="T:System.Int32" />，包含傳送緩衝區的大小 (以位元組為單位)。 預設值為 8192。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 較大的緩衝區大小可能會延遲連線困難的辨識。 請考慮增加緩衝區大小，如果您正在傳送大型檔案，或您使用的高頻寬、 高延遲連線 （例如衛星寬頻提供者。）  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.SendBufferSize%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">為設定作業指定的值小於 0。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將檔案和選擇性資料同步傳送至已連接的 <see cref="T:System.Net.Sockets.Socket" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">包含要傳送之檔案的路徑與名稱的 <see cref="T:System.String" />。 這個參數可以是 <see langword="null" />。</param>
        <summary>使用 <see cref="T:System.Net.Sockets.Socket" /> 傳輸旗標，將檔案 <paramref name="fileName" /> 傳送至已連接的 <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載會將該檔案傳送`fileName`要連接的通訊端。 `flags`參數的預設值<xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread>(0)，而`preBuffer`並`postBuffer`參數預設為`null`。 如果`fileName`是在本機目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案的名稱。 萬用字元 ("...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。 如果檔案找不到，例外狀況<xref:System.IO.FileNotFoundException>就會擲回。  
  
 這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。 如需詳細資訊`TransmitFile`函式和它的旗標，請參閱 < [Windows 通訊端](/windows/desktop/WinSock/)文件。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 以同步方式將檔案傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可用來同時連線導向及無連線的通訊協定。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>呼叫這個方法之前，否則為<xref:System.Net.Sockets.Socket.SendFile%2A>就會擲回<xref:System.Net.Sockets.SocketException>例外狀況。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>來建立連接遠端主機，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.SendFile%2A>封鎖，直到傳送檔案。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.SendFile%2A>可能會傳送整個檔案之前順利完成。 則您傳送的資料就會立即出現在網路無法保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.SendFile%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立和連接通訊端，並再將檔案傳送至遠端主機。 檔案"test.txt"位於本機電腦的根目錄。  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">通訊端未連線至遠端主機。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 物件不是處於封鎖模式，而且無法接受此同步呼叫。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">包含要傳送之檔案的路徑與名稱的 <see cref="T:System.String" />。 這個參數可以是 <see langword="null" />。</param>
        <param name="preBuffer">包含傳送檔案前要傳送之資料的 <see cref="T:System.Byte" /> 陣列。 這個參數可以是 <see langword="null" />。</param>
        <param name="postBuffer">包含傳送檔案後要傳送之資料的 <see cref="T:System.Byte" /> 陣列。 這個參數可以是 <see langword="null" />。</param>
        <param name="flags">一或多個 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 值，將檔案 <paramref name="fileName" /> 和資料緩衝區傳送到連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個多載都需要您想要傳送的檔案和的位元組合名稱<xref:System.Net.Sockets.TransmitFileOptions>值。 `preBuffer`參數包含您想要在檔案的所有資料。 `postBuffer` 包含您想要按照檔案中的資料。 如果`fileName`是在目前的工作目錄中，它可能會用來識別檔案的名稱; 否則必須指定完整路徑和檔案的名稱。 萬用字元 ("...\\\myfile.txt") 和 UNC 共用名稱 ("\\\\\\\shared 目錄\\\myfile.txt 」) 支援。  
  
 `flags`參數提供的視窗通訊端服務提供者的檔案傳輸的其他資訊。 如需如何使用此參數的詳細資訊，請參閱<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 這個方法會使用`TransmitFile`函式位於 Windows Sockets 2 API。 如需詳細資訊`TransmitFile`函式和它的旗標，請參閱 < [Windows 通訊端](/windows/desktop/WinSock/)文件。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 以同步方式將檔案傳送至遠端主機中指定<xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.Accept%2A>方法。 <xref:System.Net.Sockets.Socket.SendFile%2A> 可用來同時連線導向及無連線的通訊協定。  
  
 如果您使用無連接的通訊協定，您必須呼叫<xref:System.Net.Sockets.Socket.Connect%2A>之前呼叫這個方法; 否則為<xref:System.Net.Sockets.Socket.SendFile%2A>就會擲回<xref:System.Net.Sockets.SocketException>。 如果您使用連線導向的通訊協定，您必須使用<xref:System.Net.Sockets.Socket.Connect%2A>建立遠端主機連線，或使用<xref:System.Net.Sockets.Socket.Accept%2A>以接受連入連線。  
  
 如果您使用連線導向的通訊協定，<xref:System.Net.Sockets.Socket.SendFile%2A>封鎖，直到傳送整個檔案。 在未封鎖模式中，<xref:System.Net.Sockets.Socket.SendFile%2A>可能會傳送整個檔案之前順利完成。 則您傳送的資料就會立即出現在網路無法保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.SendFile%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立並連接通訊端。 檔案"test.txt"位於本機電腦的根目錄。 在此範例中，我們會建立緩衝和後置的資料，並將它們傳送至遠端主機的檔案。 預設值<xref:System.Net.Sockets.TransmitFileOptions>習慣。  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">作業系統不是 Windows NT (含) 以後版本。  
  
-或- 
通訊端未連線至遠端主機。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> 物件不是處於封鎖模式，而且無法接受此同步呼叫。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案 <paramref name="fileName" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>以非同步的方式將檔案的集合或記憶體中資料緩衝區傳送至連接的 <see cref="T:System.Net.Sockets.Socket" /> 物件。</summary>
        <returns>若 I/O 作業暫止，則為 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 若 I/O 作業同步完成，則為 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法用來將集合的檔案，或在記憶體中資料緩衝區傳送至遠端主機。 <xref:System.Net.Sockets.Socket>必須先連接至遠端主機。  
  
 如果<xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType>參考的工作目錄中的檔案，可能會用來識別它的檔案名稱; 否則必須指定完整路徑和檔案的名稱。 支援萬用字元和 UNC 共用名稱。 如果找不到檔案，<xref:System.IO.FileNotFoundException>就會擲回。  
  
 若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並將附加的回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>屬性上的`e`參數提供的視窗通訊端服務提供者的檔案傳輸的其他資訊。 如需如何使用此參數的詳細資訊，請參閱<xref:System.Net.Sockets.TransmitFileOptions>。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件，才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能會設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>呼叫之前所需的任何使用者狀態物件的屬性<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法，如此會在回呼方法中擷取資訊。 如果回呼需要比單一物件的詳細資訊，就可以建立小型的類別來保存為成員的其他必要的狀態資訊。  
  
 這個方法會使用位於 Windows Sockets 2 API TransmitPackets 函式。 如需 TransmitPackets 函式和它的旗標的詳細資訊，請參閱 < [Windows 通訊端](/windows/desktop/WinSock/)文件。  
  
 適用於連線導向的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法也適用於無連線的通訊協定，前提是您第一次呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法，以建立預設遠端主機。 您也必須確定檔案的大小未超過最大的封包大小為基礎的服務提供者無連接的通訊協定。 若是如此，不會傳送資料包並<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>會擲回<xref:System.Net.Sockets.SocketException>例外狀況。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法最適合根據在其使用的作業系統。 在 Windows server 版本，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法最適合用於高效能。  
  
 在 Windows 用戶端版本，<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法最適合用於最小記憶體和資源使用率。  
  
 使用的<xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType>中的旗標<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>屬性上的`e`參數可提供顯著的效能優點。 如果執行緒起始<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>方法呼叫用於大量的計算，您可以，但不太可能，Apc 可能無法啟動。 請注意，核心和使用者模式的 Apc 之間的差異。 當執行緒處於等候狀態時，就會啟動核心 Apc。 當執行緒在可警示等待狀態時，會啟動使用者模式 Apc  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> 屬性中指定的檔案。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。 如果 <see cref="T:System.Net.Sockets.Socket" /> 未連接至遠端主機，也會發生這個例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">正在使用無連接的 <see cref="T:System.Net.Sockets.Socket" />，且正在傳送的檔案超出基礎傳輸的封包大小上限。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定同步 <see cref="Overload:System.Net.Sockets.Socket.Send" /> 呼叫逾時之前的時間長度。</summary>
        <value>逾時值 (以毫秒為單位)。 如果您將屬性設為 1 到 499 之間的值，則會將值變更為 500。 預設值為 0，表示無限的逾時期間。 指定 -1 也表示無限的逾時期間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此選項適用於同步<xref:System.Net.Sockets.Socket.Send%2A>僅呼叫。 如果超過逾時期限<xref:System.Net.Sockets.Socket.Send%2A>方法會擲回<xref:System.Net.Sockets.SocketException>。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.SendTimeout%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">為設定作業指定的值小於 -1。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳送資料至特定的端點。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，表示資料的目的端。</param>
        <summary>傳送資料至指定的端點。</summary>
        <returns>傳送的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在這個多載，緩衝區位移為 0 時，要傳送的大小的預設值的位元組數目的預設值`buffer`參數，而<xref:System.Net.Sockets.SocketFlags>值預設為 0。  
  
 如果您使用無連接的通訊協定，您不需要建立的預設遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。 您只需要這樣做，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>，則`remoteEP`參數會覆寫指定的預設遠端主機，可傳送作業才。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的區域網路位址和連接埠號碼。 如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 適用於無連線的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也適用於使用連線導向的通訊協定。 如果您使用連線導向的通訊協定，您必須先透過呼叫建立連接遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您不要建立或接受連接遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 您也可以建立預設遠端主機的無連線的通訊協定，才能呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在這些情況下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只將資料傳送至已連接或預設遠端主機。  
  
 封鎖通訊端，將會封鎖直到傳送的所有位元組緩衝區中。 因為未封鎖<xref:System.Net.Sockets.Socket>完成立即執行，它可能會不傳送的位元組中的所有`buffer`。 您的應用程式必須負責記錄傳送的位元組數，以及重試此作業，直到應用程式傳送的位元組中的所有`buffer`。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
 如果您在封鎖模式中，使用無連接的通訊協定<xref:System.Net.Sockets.Socket.SendTo%2A>將會封鎖直到傳送資料包。 如果您想要將資料傳送至的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，並設定通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也必須確定傳送的位元組數目未超過基礎的服務提供者的最大的封包大小。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無連線的資料包傳送至指定的遠端主機。  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，表示資料的目的位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，傳送資料至特定端點。</summary>
        <returns>傳送的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在這個多載，緩衝區位移為 0，並將預設值的大小的位元組數目的預設值`buffer`。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，您要將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您不需要建立的預設遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。 您只需要這樣做，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>，則`remoteEP`參數會覆寫指定的預設遠端主機，可傳送作業才。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的區域網路位址和連接埠號碼。 如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 適用於無連線的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也適用於使用連線導向的通訊協定。 如果您使用連線導向的通訊協定，您必須先透過呼叫建立連接遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您不要建立或接受連接遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 您也可以建立預設遠端主機的無連線的通訊協定，才能呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在這些情況下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只將資料傳送至已連接或預設遠端主機。  
  
 封鎖通訊端將會封鎖直到要求所有位元組的`buffer`傳送。 因為未封鎖<xref:System.Net.Sockets.Socket>完成立即執行，它可能會不傳送的位元組中的所有`buffer`。 您的應用程式必須負責記錄傳送的位元組數，以及重試此作業，直到應用程式傳送的位元組中的所有`buffer`。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
 如果您在封鎖模式中，使用無連接的通訊協定<xref:System.Net.Sockets.Socket.SendTo%2A>將會封鎖直到傳送資料包。 如果您想要將資料傳送至的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，並設定通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也必須確定傳送的位元組數目未超過基礎的服務提供者的最大的封包大小。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無連線的資料包傳送至指定的遠端主機。 <xref:System.Net.Sockets.SocketFlags> 傳遞至<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，表示資料的目的位置。</param>
        <summary>使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，傳送指定位元組數目的資料至指定的端點。</summary>
        <returns>傳送的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在這個多載，緩衝區位移為 0 的預設值。 如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，您要將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您不需要建立的預設遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。 您只需要這樣做，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>，則`remoteEP`參數會覆寫指定的預設遠端主機，可傳送作業才。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的區域網路位址和連接埠號碼。 如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 適用於無連線的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也適用於使用連線導向的通訊協定。 如果您使用連線導向的通訊協定，您必須先透過呼叫建立連接遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您不要建立或接受連接遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 您也可以建立預設遠端主機的無連線的通訊協定，才能呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在這些情況下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只將資料傳送至已連接或預設遠端主機。  
  
 封鎖通訊端，將會封鎖直到傳送要求的位元組數目。 因為未封鎖<xref:System.Net.Sockets.Socket>完成立即執行，它可能會不傳送所有在單一作業中要求的位元組。 負責您的應用程式來追蹤已傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
 如果您在封鎖模式中，使用無連接的通訊協定<xref:System.Net.Sockets.Socket.SendTo%2A>將會封鎖直到傳送資料包。 如果您想要將資料傳送至的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，並設定通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也必須確定傳送的位元組數目未超過基礎的服務提供者的最大的封包大小。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無連線的資料包傳送至指定的遠端主機。 大小和<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定的 <paramref name="size" /> 超過 <paramref name="buffer" /> 的大小。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">類型 <see cref="T:System.Byte" /> 的陣列，其中包含要傳送的資料。</param>
        <param name="offset">資料緩衝區中要開始傳送資料的位置。</param>
        <param name="size">要傳送的位元組數。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 值的位元組合。</param>
        <param name="remoteEP"><see cref="T:System.Net.EndPoint" />，表示資料的目的位置。</param>
        <summary>從緩衝區中的指定位置開始且使用指定的 <see cref="T:System.Net.Sockets.SocketFlags" />，傳送指定位元組數目的資料至指定的端點。</summary>
        <returns>傳送的位元組數目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在這個多載，如果您指定<xref:System.Net.Sockets.SocketFlags.DontRoute>旗標標示為`socketflags`參數，您要將不會路由傳送的資料。  
  
 如果您使用無連接的通訊協定，您不需要建立的預設遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>。 您只需要這樣做，如果您想要呼叫<xref:System.Net.Sockets.Socket.Send%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.Connect%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>，則`remoteEP`參數會覆寫指定的預設遠端主機，可傳送作業才。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法，因為基礎的服務提供者會指派最適當的區域網路位址和連接埠號碼。 如果您需要識別指派的本機網路位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.Socket.SendTo%2A>方法成功完成。  
  
 適用於無連線的通訊協定，雖然<xref:System.Net.Sockets.Socket.SendTo%2A>也適用於使用連線導向的通訊協定。 如果您使用連線導向的通訊協定，您必須先透過呼叫建立連接遠端主機<xref:System.Net.Sockets.Socket.Connect%2A>方法，或接受連入的連接要求使用<xref:System.Net.Sockets.Socket.Accept%2A>方法。 如果您不要建立或接受連接遠端主機<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 您也可以建立預設遠端主機的無連線的通訊協定，才能呼叫<xref:System.Net.Sockets.Socket.SendTo%2A>方法。 在這些情況下，任一<xref:System.Net.Sockets.Socket.SendTo%2A>將會忽略`remoteEP`參數並只將資料傳送至已連接或預設遠端主機。  
  
 封鎖通訊端，將會封鎖直到傳送要求的位元組數目。 因為非封鎖<xref:System.Net.Sockets.Socket>完成立即執行，它可能會不傳送所有在單一作業中要求的位元組。 您必須負責應用程式來追蹤已傳送的位元組數，以及重試此作業，直到應用程式傳送要求的位元組數目。 另外還有您傳送的資料就會立即出現在網路不保證。 若要提高網路效率，基礎的系統可能會延遲傳輸，直到收集大量的傳出的資料。 成功完成<xref:System.Net.Sockets.Socket.SendTo%2A>方法表示基礎的系統有網路資料傳送的緩衝區空間。  
  
 如果您在封鎖模式中，使用無連接的通訊協定<xref:System.Net.Sockets.Socket.SendTo%2A>將會封鎖直到傳送資料包。 如果您想要將資料傳送至的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，並設定通訊端選項設定為<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>。 您也必須確定大小未超過基礎的服務提供者的最大的封包大小。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.SendTo%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會將無連線的資料包傳送至指定的遠端主機。 位移、 大小、 及<xref:System.Net.Sockets.SocketFlags>傳遞至<xref:System.Net.Sockets.Socket.SendTo%2A>方法。  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="remoteEP" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> 小於 0。  
  
-或- 
 <paramref name="offset" /> 大於 <paramref name="buffer" /> 的長度。  
  
-或- 
 <paramref name="size" /> 小於 0。  
  
-或- 
 <paramref name="size" /> 大於 <paramref name="buffer" /> 的長度減去 <paramref name="offset" /> 參數的值。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> 不是有效的值組合。  
  
-或- 
在存取 <see cref="T:System.Net.Sockets.Socket" /> 時發生作業系統錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫堆疊中的呼叫端沒有所需的使用權限。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件，用於這個非同步通訊端作業。</param>
        <summary>以非同步方式將資料傳送至特定的遠端主機。</summary>
        <returns>若 I/O 作業暫止，則為 <see langword="true" />。 作業完成時會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件。  
  
 若 I/O 作業同步完成，則為 <see langword="false" />。 在這個情況下，就不會引發與 <paramref name="e" /> 參數有關的 <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> 事件，而在方法呼叫傳回後會立即檢查做為參數傳遞的 <paramref name="e" /> 物件，以擷取作業的結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A>方法會啟動非同步傳送作業中指定遠端主機<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性`e`參數。 呼叫<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法可讓您能夠傳送不同的執行緒中的資料。 雖然此方法適用於無連線的通訊協定，<xref:System.Net.Sockets.Socket.SendToAsync%2A>無連線和連線導向的通訊協定的運作方式。  
  
 若要完成的通知，您必須建立實作事件處理常式的回呼方法\<SocketAsyncEventArgs > 委派，並將附加的回呼<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件。  
  
 下列的屬性和事件<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>物件，才能成功呼叫這個方法：  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼叫端可能會設定<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>呼叫之前所需的任何使用者狀態物件的屬性<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法，如此會在回呼方法中擷取資訊。 如果回呼需要比單一物件的詳細資訊，就可以建立小型的類別來保存為成員的其他必要的狀態資訊。  
  
 如果您使用連線導向的通訊協定，您必須先呼叫<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。 否則<xref:System.Net.Sockets.Socket.SendToAsync%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 使用連線導向的通訊協定，當<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法將會忽略<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性並傳送資料到<xref:System.Net.EndPoint?displayProperty=nameWithType>中所建立<xref:System.Net.Sockets.Socket.Accept%2A>， <xref:System.Net.Sockets.Socket.AcceptAsync%2A>， <xref:System.Net.Sockets.Socket.BeginAccept%2A>， <xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法。  
  
 如果您使用無連接的通訊協定，您不需要建立的預設遠端主機<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法之前呼叫<xref:System.Net.Sockets.Socket.SendToAsync%2A>。 您只需要這樣做，如果您想要呼叫<xref:System.Net.Sockets.Socket.BeginSend%2A>或<xref:System.Net.Sockets.Socket.SendAsync%2A>方法。 如果您呼叫<xref:System.Net.Sockets.Socket.BeginConnect%2A>， <xref:System.Net.Sockets.Socket.Connect%2A>，或<xref:System.Net.Sockets.Socket.ConnectAsync%2A>方法呼叫之前<xref:System.Net.Sockets.Socket.SendToAsync%2A>，則<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>屬性將會覆寫指定的預設遠端主機，可傳送作業才。 您也不需要呼叫<xref:System.Net.Sockets.Socket.Bind%2A>方法。 在此情況下，基礎的服務提供者會指派最適當的區域網路 IP 位址和連接埠號碼。 如果您想要選取可用的連接埠基礎的服務提供者，請使用連接埠號碼為零。 如果您需要識別已指派的區域網路的 IP 位址和連接埠號碼，您可以使用<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>屬性之後<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>事件收到信號，而且會呼叫相關聯的委派。  
  
 如果您想要將資料傳送至的廣播位址，您必須先呼叫<xref:System.Net.Sockets.Socket.SetSocketOption%2A>方法，並設定通訊端選項<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>設為 true。 您也必須確定您的緩衝區的大小未超過基礎的服務提供者的最大的封包大小。 若是如此，將不會傳送資料包並<xref:System.Net.Sockets.Socket.SendToAsync%2A>將會擲回<xref:System.Net.Sockets.SocketException>。  
  
 如果您指定的 DontRoute 旗標<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>屬性中，您要將不會路由傳送的資料。  
  
 訊息導向的通訊端，必須小心不能超過訊息大小上限為基礎的傳輸。 如果緩衝區的大小超過最大的封包大小為基礎的服務提供者，不會傳送資料包並<xref:System.Net.Sockets.Socket.SendToAsync%2A>將會擲回<xref:System.Net.Sockets.SocketException>。 成功完成<xref:System.Net.Sockets.Socket.SendToAsync%2A>方法不會指出已成功傳遞資料。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> 不可以是 null。</exception>
        <exception cref="T:System.InvalidOperationException">通訊端作業已使用 <paramref name="e" /> 參數內指定的 <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> 物件正在進行中。</exception>
        <exception cref="T:System.NotSupportedException">這個方法需要 Windows XP (含) 以後版本。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定的通訊協定是連接導向的，但尚未連接 <see cref="T:System.Net.Sockets.Socket" />。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="level">要設定在這個通訊端上的 IP 保護層級。</param>
        <summary>設定通訊端上的 IP 保護層級。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>方法可讓限制 IPv6 或 IP 通訊端接聽指定的範圍，例如地址的相同連結本機或網站本機首碼。 這個通訊端選項可讓 IPv6 或 IP 的通訊端的存取限制的應用程式。 這類限制可以讓應用程式在私人 LAN 上執行，簡便又穩當地強化應用程式對外部攻擊的抵禦。 這個通訊端選項也可用來移除存取限制，如果`level`參數設為<xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>。 這個通訊端選項可放大或縮小接聽通訊端的範圍，根據需要啟用公用和私用使用者的無限制存取，或視需要限制成僅可存取相同的站台。  
  
 這個通訊端選項已定義 <xref:System.Net.Sockets.IPProtectionLevel> 列舉中所指定的保護層級。  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>方法用來啟用或停用網路位址周遊 (NAT) for<xref:System.Net.Sockets.Socket>執行個體。 您可以使用 Teredo，6to4 或 ISATAP 通道提供 NAT 周遊。  
  
 當`level`參數設定為<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>，或<xref:System.Net.Sockets.IPProtectionLevel.Restricted>，這明確停用 NAT 周遊<xref:System.Net.Sockets.Socket>執行個體。  
  
 當`level`參數設定為<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>，這可能會讓 NAT 周遊<xref:System.Net.Sockets.Socket>根據就地的系統上的防火牆規則。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="level" /> 參數不可為 <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />。 IP 保護層級不能設定為未指定。</exception>
        <exception cref="T:System.NotSupportedException">通訊端的 <see cref="T:System.Net.Sockets.AddressFamily" /> 必須是 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 或  <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />。</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>設定 <see cref="T:System.Net.Sockets.Socket" /> 選項。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionValue">選項的值，表示為 <see cref="T:System.Boolean" />。</param>
        <summary>將指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設為指定的 <see cref="T:System.Boolean" /> 值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 設定`optionValue`要`true`若要啟用的選項，或`false`停用選項。  
  
 <xref:System.Net.Sockets.Socket> 選項會依通訊協定支援的層級。  
  
 以下列出各種<xref:System.Net.Sockets.Socket>可以使用這個多載來設定的選項。 這些選項會依適當<xref:System.Net.Sockets.SocketOptionLevel>值。 如果您想要設定任何這些選項，請務必使用適當<xref:System.Net.Sockets.SocketOptionLevel>值`optionLevel`參數。 若要設定您選擇的選項必須指定`optionName`參數。 如果您想要取得任何所列的選項的目前值，請使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 您可以使用這個多載設定的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 您可以使用這個多載設定的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 您可以使用這個多載設定的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 您可以使用這個多載設定的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 如需有關這些選項的詳細資訊，請參閱<xref:System.Net.Sockets.SocketOptionName>列舉型別。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>例外狀況，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
   
  
## Examples  
 下列程式碼範例會開啟通訊端，並可讓`DontLinger`而`OutOfBandInline`通訊端選項。  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" />物件已關閉。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionValue"><see cref="T:System.Byte" /> 型別的陣列，表示選項的值。</param>
        <summary>將指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設定為指定值，表示為位元組陣列。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 若要設定與使用此多載<xref:System.Net.Sockets.Socket>需要做為選項值的位元組陣列的選項。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionValue">選項的值。</param>
        <summary>將指定 <see cref="T:System.Net.Sockets.Socket" /> 選項設定為指定的整數值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 如需使用選項<xref:System.Boolean>資料類型，指定非零的值，以啟用選項和零值以停用此選項。 如需具有整數資料類型選項，指定適當的值。 <xref:System.Net.Sockets.Socket> 選項會依通訊協定支援的層級。  
  
 以下列出各種<xref:System.Net.Sockets.Socket>可以使用這個多載來設定的選項。 這些選項會依適當<xref:System.Net.Sockets.SocketOptionLevel>。 如果您想要設定任何這些選項，請務必使用適當<xref:System.Net.Sockets.SocketOptionLevel>針對`optionLevel`參數。 若要設定您選擇的選項必須指定`optionName`參數。 如果您想要取得任何所列的選項的目前值，請使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> 您可以使用這個多載設定的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> 您可以使用這個多載設定的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> 您可以使用這個多載設定的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> 您可以使用這個多載設定的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> 您可以使用這個多載設定的選項。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 如需有關這些選項的詳細資訊，請參閱<xref:System.Net.Sockets.SocketOptionName>列舉型別。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">其中一個 <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 值。</param>
        <param name="optionName">其中一個 <see cref="T:System.Net.Sockets.SocketOptionName" /> 值。</param>
        <param name="optionValue"><see cref="T:System.Net.Sockets.LingerOption" /> 或 <see cref="T:System.Net.Sockets.MulticastOption" />，包含選項值。</param>
        <summary>將指定的 <see cref="T:System.Net.Sockets.Socket" /> 選項設定為指定值，表示為物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> 選項會決定目前的行為<xref:System.Net.Sockets.Socket>。 若要設定使用此多載<xref:System.Net.Sockets.SocketOptionName.Linger>， <xref:System.Net.Sockets.SocketOptionName.AddMembership>，並<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>選項。 針對<xref:System.Net.Sockets.SocketOptionName.Linger>選項，請使用<xref:System.Net.Sockets.Socket>如`optionLevel`參數。 針對<xref:System.Net.Sockets.SocketOptionName.AddMembership>並<xref:System.Net.Sockets.SocketOptionName.DropMembership>，使用<xref:System.Net.Sockets.SocketOptionLevel.IP>。 如果您想要取得任何上述選項的目前值，請使用<xref:System.Net.Sockets.Socket.GetSocketOption%2A>方法。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
   
  
## Examples  
 下列程式碼範例會設定<xref:System.Net.Sockets.LingerOption>和<xref:System.Net.Sockets.Socket.Send%2A>逾時值。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">其中一個 <see cref="T:System.Net.Sockets.SocketShutdown" /> 值，指定將不再允許的作業。</param>
        <summary>暫停 <see cref="T:System.Net.Sockets.Socket" /> 上的傳送和接收作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用連線導向<xref:System.Net.Sockets.Socket>，務必呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>方法關閉之前<xref:System.Net.Sockets.Socket>。 這可確保所有資料都傳送及它在關閉之前，連接的通訊端上接收。  
  
 呼叫<xref:System.Net.Sockets.Socket.Close%2A>方法來釋放所有 managed 和 unmanaged 資源相關聯<xref:System.Net.Sockets.Socket>。 請勿嘗試重複使用<xref:System.Net.Sockets.Socket>結尾後面。  
  
 下表顯示<xref:System.Net.Sockets.SocketShutdown>列舉值，適用於`how`參數。  
  
|值|描述|  
|-----------|-----------------|  
|傳送|停用傳送此<xref:System.Net.Sockets.Socket>。|  
|接收|停用此接收<xref:System.Net.Sockets.Socket>。|  
|兩者|停用傳送和接收此<xref:System.Net.Sockets.Socket>。|  
  
 設定`how`要<xref:System.Net.Sockets.SocketShutdown.Send>指定後續的呼叫<xref:System.Net.Sockets.Socket.Send%2A>不允許。 如果您使用無連接<xref:System.Net.Sockets.Socket>，並指定<xref:System.Net.Sockets.SocketShutdown.Send>會有任何作用。  
  
 設定`how`要<xref:System.Net.Sockets.SocketShutdown.Receive>指定後續的呼叫<xref:System.Net.Sockets.Socket.Receive%2A>不允許。 這會有較低的通訊協定層級上沒有作用。 如果您使用連線導向的通訊協定，則連線會終止，如果下列條件存在之後呼叫<xref:System.Net.Sockets.Socket.Shutdown%2A>:  
  
-   資料是在等待接收傳入的網路緩衝區中。  
  
-   更多的資料已送達。  
  
 如果您使用無連接的通訊協定，資料包所接受並排入佇列。 不過，如果沒有緩衝區空間可供其他連入的資料包，都會被捨棄，而且會傳回任何錯誤，寄件者。 使用<xref:System.Net.Sockets.Socket.Shutdown%2A>在無連接<xref:System.Net.Sockets.Socket>不建議使用。  
  
 設定`how`至<xref:System.Net.Sockets.SocketShutdown.Both>停用這兩個傳送和接收上面所述。  
  
> [!NOTE]
>  如果您收到<xref:System.Net.Sockets.SocketException>呼叫時<xref:System.Net.Sockets.Socket.Shutdown%2A>方法，請使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
> [!NOTE]
>  在應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱 < [.NET Framework 中的網路追蹤](~/docs/framework/network-programming/network-tracing.md)。  
  
   
  
## Examples  
 下列程式碼範例會使用<xref:System.Net.Sockets.Socket.Shutdown%2A>若要停用<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Net.Sockets.Socket" /> 的類型。</summary>
        <value>其中一個 <see cref="T:System.Net.Sockets.SocketType" /> 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> 是唯讀的而且會設定當<xref:System.Net.Sockets.Socket>建立。  
  
   
  
## Examples  
 下列程式碼範例會顯示<xref:System.Net.Sockets.AddressFamily>， <xref:System.Net.Sockets.SocketType>，和<xref:System.Net.Sockets.ProtocolType>到主控台。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 IPv4 支援是否可用並在目前的主機上啟用。</summary>
        <value>如果目前的主機支援 IPv4 通訊協定，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作業系統可支援 IPv4 和 IPv6 通訊協定。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出「架構」是否對某些已過時 <see cref="T:System.Net.Dns" /> 成員支援 IPv6。</summary>
        <value>如果「架構」對某些已過時的 <see cref="T:System.Net.Dns" /> 方法支援 IPv6，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作業系統可支援 IPv4 和 IPv6 通訊協定。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Net.Sockets.Socket" /> 所使用的所有資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
當您完成時呼叫 IDisposable.Dispose 使用<xref:System.Net.Sockets.Socket>。 IDisposable.Dispose 方法會使<xref:System.Net.Sockets.Socket>中無法使用的狀態。 在呼叫 IDisposable.Dispose 之後，您必須釋放所有的參考<xref:System.Net.Sockets.Socket>讓記憶體回收行程可以回收記憶體，<xref:System.Net.Sockets.Socket>所佔用。 如需詳細資訊，請參閱 <<c0> [ 清除 Unmanaged 資源向上](~/docs/standard/garbage-collection/unmanaged.md)並[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。

> [!NOTE] 
> 請務必在您釋放最後一個參考之前呼叫 IDisposable.Dispose <xref:System.Net.Sockets.Socket>。 否則工作窗格所使用的資源不會釋放，直到記憶體回收行程呼叫 <xref:System.Net.Sockets.Socket> 物件的 `Finalize` 方法。

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指定 <see cref="T:System.Net.Sockets.Socket" /> 傳送之網際網路通訊協定 (IP) 封包的存留時間 (TTL) 值。</summary>
        <value>TTL 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 值會指示之前，路由器會捨棄封包，以及網際網路控制訊息通訊協定 (ICMP) 已超過的 「 TTL 」，將封包可以周遊的路由器數目上限會傳回錯誤訊息寄件者。  
  
 TTL 值可能設定的值，從 0 到 255。 未設定這個屬性，則通訊端的預設 TTL 值為 32。  
  
 如果已建立成功的連線使用通訊端傳輸控制通訊協定 (TCP) 通訊端上設定這個屬性會忽略的 TCP/IP 堆疊。  
  
 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>屬性，以取得特定的錯誤碼。 取得此程式碼之後，請參閱[Windows Sockets 第 2 版 API 錯誤碼](/windows/desktop/winsock/windows-sockets-error-codes-2)錯誤的詳細描述的文件。  
  
   
  
## Examples  
 下列程式碼範例示範使用<xref:System.Net.Sockets.Socket.Ttl%2A>屬性。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 值不能設定為負數。</exception>
        <exception cref="T:System.NotSupportedException">這個屬性只可為 <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> 或 <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> 家族中的通訊端設定。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">嘗試存取通訊端時發生錯誤。 當嘗試將 TTL 設定為大於 255 的值時，也會傳回這個錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> 已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定通訊端是否只應使用重疊的 I/O 模式。</summary>
        <value>如果 <see cref="T:System.Net.Sockets.Socket" /> 只使用重疊的 I/O，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將此屬性設定為`true`for<xref:System.Net.Sockets.Socket>您想要呼叫<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。 架構，否則可能會將完成通訊埠指派給通訊端，則會禁止使用<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">通訊端已繫結至完成通訊埠。</exception>
      </Docs>
    </Member>
  </Members>
</Type>