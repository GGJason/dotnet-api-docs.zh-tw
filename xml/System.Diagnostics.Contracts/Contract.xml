<Type Name="Contract" FullName="System.Diagnostics.Contracts.Contract">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6c57f0353db36ebb5cdb2d073606dea6ba98b965" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51900443" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Contract" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Contract extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Contracts.Contract" />
  <TypeSignature Language="VB.NET" Value="Public Class Contract" />
  <TypeSignature Language="C++ CLI" Value="public ref class Contract abstract sealed" />
  <TypeSignature Language="F#" Value="type Contract = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="533e0-101">包含表示程式合約的靜態方法，例如前置條件、後置條件及物件非變異。</span>
      <span class="sxs-lookup">
        <span data-stu-id="533e0-101">Contains static methods for representing program contracts such as preconditions, postconditions, and object invariants.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-102">程式碼合約類別可讓您在程式碼中指定前置條件、 後置條件及物件非變異值。</span><span class="sxs-lookup"><span data-stu-id="533e0-102">Code contract classes let you specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="533e0-103">前置條件是輸入方法或屬性時，必須符合的需求。</span><span class="sxs-lookup"><span data-stu-id="533e0-103">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="533e0-104">後置條件描述在方法或屬性程式碼結束時的期望。</span><span class="sxs-lookup"><span data-stu-id="533e0-104">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="533e0-105">物件非變異值描述預期的狀態，沒有任何條件的問題類別。</span><span class="sxs-lookup"><span data-stu-id="533e0-105">Object invariants describe the expected state for a class that has no condition problems.</span></span> <span data-ttu-id="533e0-106">如需有關前置條件、 後置條件及物件非變異值的詳細資訊，請參閱[程式碼合約](~/docs/framework/debug-trace-profile/code-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="533e0-106">For more information about preconditions, postconditions, and object invariants, see [Code Contracts](~/docs/framework/debug-trace-profile/code-contracts.md).</span></span>  
  
 <span data-ttu-id="533e0-107">如需使用程式碼協定的工具和詳細指示，請參閱 MSDN DevLabs 網站上的[程式碼合約](https://go.microsoft.com/fwlink/?LinkId=152461)。</span><span class="sxs-lookup"><span data-stu-id="533e0-107">For tools and detailed instructions for using code contracts, see [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="533e0-108">您必須在要插入的合約的執行階段強制使用二進位重寫器。</span><span class="sxs-lookup"><span data-stu-id="533e0-108">You must use a binary rewriter to insert run-time enforcement of contracts.</span></span> <span data-ttu-id="533e0-109">否則，這類合約<xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType>方法只能以靜態方式測試並不會擲回例外狀況在執行階段期間如果違反合約。</span><span class="sxs-lookup"><span data-stu-id="533e0-109">Otherwise, contracts such as the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A?displayProperty=nameWithType> method can only be tested statically and will not throw exceptions during run time if a contract is violated.</span></span> <span data-ttu-id="533e0-110">您可以下載二進位重寫器 CCRewrite 從[程式碼合約](https://go.microsoft.com/fwlink/?LinkId=152461)MSDN DevLabs 網站上。</span><span class="sxs-lookup"><span data-stu-id="533e0-110">You can download the binary rewriter CCRewrite from [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span> <span data-ttu-id="533e0-111">CCRewrite 隨附於可讓您啟用執行階段合約強制從專案的 Visual Studio 增益集**屬性**頁面。</span><span class="sxs-lookup"><span data-stu-id="533e0-111">CCRewrite comes with a Visual Studio add-in that enables you to activate run-time contract enforcement from the project **Properties** page.</span></span> <span data-ttu-id="533e0-112">二進位重寫器和 Visual Studio 增益集並未隨附[!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]或 Windows SDK。</span><span class="sxs-lookup"><span data-stu-id="533e0-112">The binary rewriter and the Visual Studio add-in do not ship with [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] or the Windows SDK.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Assert">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="533e0-113">在偵錯組建中，為指定的條件進行執行階段測試。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-113">In debug builds, performs a run-time test for a specified condition.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assert : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="533e0-114">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-114">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-115">檢查條件，且如果條件為 <see langword="false" />，則遵循已為分析器設定的擴大原則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-115">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set for the analyzer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-116">預設值擴大原則是以通知有關合約失敗附加偵錯工具，或顯示**Assert**對話方塊中，如果未附加偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="533e0-116">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="533e0-117">（選擇性） 可以指示 「 分析器 」 會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="533e0-117">Optionally, the analyzer can be instructed to throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public static void Assert (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assert(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assert (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assert(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assert : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assert (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="533e0-118">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-118">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="533e0-119">當條件不符合時所顯示的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-119">A message to display if the condition is not met.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-120">檢查條件。如果條件為 <see langword="false" />，則遵循分析器所設定的擴大原則，並顯示指定的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-120">Checks for a condition; if the condition is <see langword="false" />, follows the escalation policy set by the analyzer and displays the specified message.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-121">預設值擴大原則是以通知有關合約失敗附加偵錯工具，或顯示**Assert**對話方塊中，如果未附加偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="533e0-121">The default escalation policy is to notify the attached debugger about a contract failure or to display an **Assert** dialog box if a debugger is not attached.</span></span> <span data-ttu-id="533e0-122">（選擇性） 可以指示 「 分析器 」 會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="533e0-122">Optionally, the analyzer can be instructed to throw an exception.</span></span> <span data-ttu-id="533e0-123">`userMessage`參數傳遞至偵錯工具輸出。</span><span class="sxs-lookup"><span data-stu-id="533e0-123">The `userMessage` parameter is passed to the debugger output.</span></span> <span data-ttu-id="533e0-124">如果`userMessage`不是常數字串常值中，工具可能無法讀取它。</span><span class="sxs-lookup"><span data-stu-id="533e0-124">If `userMessage` is not a constant string literal, tools may not be able to read it.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Assume">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="533e0-125">指示程式碼分析工具假設條件為 <see langword="true" />，即使該條件無法以靜態方式證明永遠是 <see langword="true" /> 亦然。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-125">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition);" />
      <MemberSignature Language="F#" Value="static member Assume : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="533e0-126">要假設 <see langword="true" /> 的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-126">The conditional expression to assume <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-127">指示程式碼分析工具假設指定的條件為 <see langword="true" />，即使該條件無法以靜態方式證明永遠是 <see langword="true" /> 亦然。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-127">Instructs code analysis tools to assume that the specified condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-128">在執行階段，若要使用這個方法就相當於使用<xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29>方法。</span><span class="sxs-lookup"><span data-stu-id="533e0-128">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assume">
      <MemberSignature Language="C#" Value="public static void Assume (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Assume(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Assume (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Assume(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Assume : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Assume (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("DEBUG")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="533e0-129">要假設 <see langword="true" /> 的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-129">The conditional expression to assume <see langword="true" />.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="533e0-130">要在假設失敗時張貼的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-130">The message to post if the assumption fails.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-131">指示程式碼分析工具假設條件為 <see langword="true" />，即使該條件無法以靜態方式證明永遠是 <see langword="true" /> 亦然，同時在假設失敗時顯示訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-131">Instructs code analysis tools to assume that a condition is <see langword="true" />, even if it cannot be statically proven to always be <see langword="true" />, and displays a message if the assumption fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-132">如果`userMessage`不是常數字串常值中，合約可能不了解的工具。</span><span class="sxs-lookup"><span data-stu-id="533e0-132">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 <span data-ttu-id="533e0-133">在執行階段，若要使用這個方法就相當於使用<xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="533e0-133">At run time, using this method is equivalent to using the <xref:System.Diagnostics.Contracts.Contract.Assert%28System.Boolean%2CSystem.String%29> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContractFailed">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Diagnostics.Contracts.ContractFailedEventArgs&gt; ContractFailed" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Contracts.Contract.ContractFailed" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ContractFailed As EventHandler(Of ContractFailedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Diagnostics::Contracts::ContractFailedEventArgs ^&gt; ^ ContractFailed;" />
      <MemberSignature Language="F#" Value="member this.ContractFailed : EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " Usage="member this.ContractFailed : System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Diagnostics.Contracts.ContractFailedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="533e0-134">發生於合約失敗時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-134">Occurs when a contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-135">此事件的事件資訊由提供<xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType>傳遞至事件處理常式的物件。</span><span class="sxs-lookup"><span data-stu-id="533e0-135">The event information for this event is supplied by the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs?displayProperty=nameWithType> object that is passed to the event handler.</span></span> <span data-ttu-id="533e0-136">此事件通知的受管理的應用程式環境，例如互動式解譯器或合約已失敗的 Web 瀏覽器主機。</span><span class="sxs-lookup"><span data-stu-id="533e0-136">This event notifies a managed application environment such as an interactive interpreter or a Web browser host that a contract has failed.</span></span> <span data-ttu-id="533e0-137">再這麼做，就會引發其認為適合應用程式可以處理的事件。</span><span class="sxs-lookup"><span data-stu-id="533e0-137">Before doing so, it will raise an event that an application can handle as it sees fit.</span></span> <span data-ttu-id="533e0-138">比方說，如果程式碼執行的測試架構中，您可以記錄的測試失敗，並再結束測試。</span><span class="sxs-lookup"><span data-stu-id="533e0-138">For example, if code is being run in a testing framework, you can log a test failure and then end the test.</span></span>  
  
 <span data-ttu-id="533e0-139">預設實作<xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A>.NET Framework 類別庫中的方法是呼叫每個已註冊的處理常式<xref:System.Diagnostics.Contracts.Contract.ContractFailed>事件。</span><span class="sxs-lookup"><span data-stu-id="533e0-139">The default implementation of the <xref:System.Diagnostics.Contracts.Internal.ContractHelper.RaiseContractFailedEvent%2A> method in the .NET Framework class library is to call each handler that is registered with the <xref:System.Diagnostics.Contracts.Contract.ContractFailed> event.</span></span> <span data-ttu-id="533e0-140">處理常式所擲回例外狀況會被忽略，但每個處理常式可以指出失敗由呼叫<xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A>事件引數的方法。</span><span class="sxs-lookup"><span data-stu-id="533e0-140">Exceptions thrown by handlers are ignored, but each handler can indicate whether the failure is handled by calling the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled%2A> method for the event arguments.</span></span> <span data-ttu-id="533e0-141">如果任何處理常式會設定為已處理失敗，則方法會傳回`null`，並且在採取任何進一步的動作。</span><span class="sxs-lookup"><span data-stu-id="533e0-141">If any handler sets the failure as handled, the method returns `null` and no further action is taken.</span></span> <span data-ttu-id="533e0-142">或者，可以呼叫處理常式<xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A>方法來指示回溯程式碼。</span><span class="sxs-lookup"><span data-stu-id="533e0-142">Alternatively, handlers can call the <xref:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind%2A> method to instruct the code to unwind.</span></span> <span data-ttu-id="533e0-143">在此情況下，所有處理常式執行完之後，便會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="533e0-143">In that case, an exception is thrown after all handlers have executed.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="533e0-144">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-144">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="533e0-145">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-145">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="EndContractBlock">
      <MemberSignature Language="C#" Value="public static void EndContractBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndContractBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EndContractBlock" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndContractBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndContractBlock();" />
      <MemberSignature Language="F#" Value="static member EndContractBlock : unit -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.EndContractBlock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="533e0-146">當方法的合約僅包含 <see langword="if" />-<see langword="then" />-<see langword="throw" /> 形式的前置條件時，標記合約區段的結尾。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-146">Marks the end of the contract section when a method's contracts contain only preconditions in the <see langword="if" />-<see langword="then" />-<see langword="throw" /> form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-147">大部分的程式碼已包含表單的一些參數驗證`if` - `then` - `throw`程式碼。</span><span class="sxs-lookup"><span data-stu-id="533e0-147">Most code already contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="533e0-148">合約工具辨識`if` - `then` - `throw`為前置條件陳述式出現在方法內，第一個和整組的這類陳述式後面接著明確時的陳述式<xref:System.Diagnostics.Contracts.Contract>方法呼叫，例如<xref:System.Diagnostics.Contracts.Contract.Requires%2A>， <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>， <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>，或<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>。</span><span class="sxs-lookup"><span data-stu-id="533e0-148">The contract tools recognize `if`-`then`-`throw` statements as preconditions when the statements appear first inside a method, and the entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>.</span></span>  
  
 <span data-ttu-id="533e0-149">當`if` - `then` - `throw`陳述式出現在此表單中，合約工具將它們識別為舊版-require 陳述式。</span><span class="sxs-lookup"><span data-stu-id="533e0-149">When `if`-`then`-`throw` statements appear in this form, the contract tools recognize them as legacy-require statements.</span></span> <span data-ttu-id="533e0-150"><xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>只有在後面沒有其他合約，使用表單`if` - `then` - `throw`順序，但它們應該仍會標記為舊版-需要。</span><span class="sxs-lookup"><span data-stu-id="533e0-150">The <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> form is used only if no other contracts follow the `if`-`then`-`throw` sequences, but they should still be tagged as legacy-requires.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ensures">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="533e0-151">指定封入方法或屬性的後置條件合約。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-151">Specifies a postcondition contract for the enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="533e0-152">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-152">The conditional expression to test.</span>
          </span>
          <span data-ttu-id="533e0-153">運算式可以包含 <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />、<see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" /> 及 <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-153">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />, <see cref="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />, and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-154">指定封入方法或屬性的後置條件合約。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-154">Specifies a postcondition contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-155">`condition`參數會指定預期的後置條件`true`封入方法或屬性的正常地傳回時。</span><span class="sxs-lookup"><span data-stu-id="533e0-155">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="533e0-156">這個方法呼叫必須是方法或屬性之前的任何其他程式碼, 的開頭。</span><span class="sxs-lookup"><span data-stu-id="533e0-156">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="533e0-157">您必須使用二進位重寫器 (網址[程式碼合約](https://go.microsoft.com/fwlink/?LinkId=152461)MSDN DevLabs 網站上) 的這個後置條件的執行階段強制。</span><span class="sxs-lookup"><span data-stu-id="533e0-157">You must use the binary rewriter (available at [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="533e0-158">下列範例示範如何使用<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>方法，以確保會傳回預期的值。</span><span class="sxs-lookup"><span data-stu-id="533e0-158">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method to ensure that an expected value is returned.</span></span> <span data-ttu-id="533e0-159">此程式碼範例是針對提供之較大範例的一部分<xref:System.Diagnostics.Contracts.ContractClassAttribute>類別。</span><span class="sxs-lookup"><span data-stu-id="533e0-159">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ensures">
      <MemberSignature Language="C#" Value="public static void Ensures (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ensures(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ensures (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Ensures(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Ensures : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Ensures (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="533e0-160">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-160">The conditional expression to test.</span>
          </span>
          <span data-ttu-id="533e0-161">運算式可以包含 <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> 及 <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> 值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-161">The expression may include <see cref="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" /> and <see cref="M:System.Diagnostics.Contracts.Contract.Result``1" /> values.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="533e0-162">當運算式不是 <see langword="true" /> 時所顯示的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-162">The message to display if the expression is not <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-163">指定提供之結束條件的後置條件合約，以及在條件為 <see langword="false" /> 時所要顯示的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-163">Specifies a postcondition contract for a provided exit condition and a message to display if the condition is <see langword="false" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-164">`condition`參數會指定預期的後置條件`true`封入方法或屬性的正常地傳回時。</span><span class="sxs-lookup"><span data-stu-id="533e0-164">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property returns normally.</span></span>  
  
-   <span data-ttu-id="533e0-165">這個方法呼叫必須是方法或屬性之前的任何其他程式碼, 的開頭。</span><span class="sxs-lookup"><span data-stu-id="533e0-165">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="533e0-166">此合約會公開給用戶端;因此，它必須只參考都至少與封入方法為可見的成員。</span><span class="sxs-lookup"><span data-stu-id="533e0-166">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="533e0-167">您必須使用二進位重寫器 (網址[程式碼合約](https://go.microsoft.com/fwlink/?LinkId=152461)MSDN DevLabs 網站上) 的這個後置條件的執行階段強制。</span><span class="sxs-lookup"><span data-stu-id="533e0-167">You must use the binary rewriter (available at [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site) for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="533e0-168">如果`userMessage`不是常數字串常值中，合約可能不了解的工具。</span><span class="sxs-lookup"><span data-stu-id="533e0-168">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnsuresOnThrow&lt;TException&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="533e0-169">根據所提供的例外狀況和條件，針對封入方法或屬性指定後置條件合約。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-169">Specifies a postcondition contract for the enclosing method or property based on the provided exception and condition.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="533e0-170">例外狀況類型，其會叫用後置條件檢查。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-170">The type of exception that invokes the postcondition check.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="533e0-171">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-171">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-172">根據所提供的例外狀況和條件，針對封入方法或屬性指定後置條件合約。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-172">Specifies a postcondition contract for the enclosing method or property, based on the provided exception and condition.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-173">`condition`參數會指定預期的後置條件`true`封入方法或屬性的異常終止時，類型的例外狀況`TException`就會擲回。</span><span class="sxs-lookup"><span data-stu-id="533e0-173">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span>  
  
-   <span data-ttu-id="533e0-174">這個方法呼叫必須是方法或屬性之前的任何其他程式碼, 的開頭。</span><span class="sxs-lookup"><span data-stu-id="533e0-174">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="533e0-175">此合約會公開給用戶端;因此，它必須只參考都至少與封入方法為可見的成員。</span><span class="sxs-lookup"><span data-stu-id="533e0-175">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="533e0-176">您必須使用這個後置條件的執行階段強制執行二進位重寫器。</span><span class="sxs-lookup"><span data-stu-id="533e0-176">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsuresOnThrow&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void EnsuresOnThrow&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsuresOnThrow&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.EnsuresOnThrow``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsuresOnThrow(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void EnsuresOnThrow(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member EnsuresOnThrow : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.EnsuresOnThrow (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="533e0-177">例外狀況類型，其會叫用後置條件檢查。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-177">The type of exception that invokes the postcondition check.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="533e0-178">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-178">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="533e0-179">當運算式是 <see langword="false" /> 時所顯示的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-179">The message to display if the expression is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-180">針對封入方法或屬性來指定後置條件合約，和當條件是 <see langword="false" /> 時，根據所提供之例外狀況和條件來顯示的訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-180">Specifies a postcondition contract and a message to display if the condition is <see langword="false" /> for the enclosing method or property, based on the provided exception and condition.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-181">`condition`參數會指定預期的後置條件`true`封入方法或屬性的異常終止時，類型的例外狀況`TException`就會擲回。</span><span class="sxs-lookup"><span data-stu-id="533e0-181">The `condition` parameter specifies a postcondition that is expected to be `true` when the enclosing method or property terminates abnormally and an exception of type `TException` is thrown.</span></span> <span data-ttu-id="533e0-182">`message`參數指定要顯示如果條件為`false`。</span><span class="sxs-lookup"><span data-stu-id="533e0-182">The `message` parameter specifies a message to display if the condition is `false`.</span></span>  
  
-   <span data-ttu-id="533e0-183">這個方法呼叫必須是方法或屬性之前的任何其他程式碼, 的開頭。</span><span class="sxs-lookup"><span data-stu-id="533e0-183">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="533e0-184">此合約會公開給用戶端;因此，它必須只參考都至少與封入方法為可見的成員。</span><span class="sxs-lookup"><span data-stu-id="533e0-184">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="533e0-185">您必須使用這個後置條件的執行階段強制執行二進位重寫器。</span><span class="sxs-lookup"><span data-stu-id="533e0-185">You must use the binary rewriter for run-time enforcement of this postcondition.</span></span>  
  
-   <span data-ttu-id="533e0-186">如果`userMessage`不是常數字串常值中，合約可能不了解的工具。</span><span class="sxs-lookup"><span data-stu-id="533e0-186">If `userMessage` is not a constant string literal, the contract may not be understood by tools.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="533e0-187">要傳遞至 <c>predicate</c> 的第一個整數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-187">The first integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="533e0-188">要傳遞至 <c>predicate</c> 的最後一個整數加一。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-188">One more than the last integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="533e0-189">要評估指定範圍內任何整數值的函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-189">The function to evaluate for any value of the integer in the specified range.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-190">判斷整數範圍內是否有任何整數使指定的測試成立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-190">Determines whether a specified test is true for any integer within a range of integers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="533e0-191">如果 <paramref name="predicate" /> 為從 <paramref name="fromInclusive" /> 開始到 <paramref name="toExclusive" /> - 1 的任何整數傳回 <see langword="true" />，則為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-191">
              <see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for any integer starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-192">`toExclusive`參數是一個來加速使用從 0 開始的整數的範圍長度的最後一個整數加一。</span><span class="sxs-lookup"><span data-stu-id="533e0-192">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="533e0-193">比方說，它會設定為 0 到 4 的整數 5。</span><span class="sxs-lookup"><span data-stu-id="533e0-193">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="533e0-194">
            <paramref name="predicate" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-194">
              <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="533e0-195">
            <paramref name="toExclusive" /> 小於 <paramref name="fromInclusive" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-195">
              <paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member Exists : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.Exists (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="533e0-196">中包含的型別<c>集合</c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-196">The type that is contained in <c>collection</c>.</span>
          </span>
        </typeparam>
        <param name="collection">
          <span data-ttu-id="533e0-197">集合，將從其中取出 <c>T</c> 型別的元素以傳遞給 <c>predicate</c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-197">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="533e0-198">要評估 <c>collection</c> 中元素的函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-198">The function to evaluate for an element in <c>collection</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-199">判斷項目集合內的項目是否出現在函式中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-199">Determines whether an element within a collection of elements exists within a function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="533e0-200">只有在 <paramref name="predicate" /> 為 <paramref name="T" /> 中任何 <paramref name="collection" /> 型別之項目傳回 <see langword="true" /> 時，才為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-200">
              <see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for any element of type <paramref name="T" /> in <paramref name="collection" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="533e0-201">
            <paramref name="collection" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-201">
              <paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll">
      <MemberSignature Language="C#" Value="public static bool ForAll (int fromInclusive, int toExclusive, Predicate&lt;int&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll(int32 fromInclusive, int32 toExclusive, class System.Predicate`1&lt;int32&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll (fromInclusive As Integer, toExclusive As Integer, predicate As Predicate(Of Integer)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ForAll(int fromInclusive, int toExclusive, Predicate&lt;int&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : int * int * Predicate&lt;int&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (fromInclusive, toExclusive, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="predicate" Type="System.Predicate&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">
          <span data-ttu-id="533e0-202">要傳遞至 <c>predicate</c> 的第一個整數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-202">The first integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="toExclusive">
          <span data-ttu-id="533e0-203">要傳遞至 <c>predicate</c> 的最後一個整數加一。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-203">One more than the last integer to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="533e0-204">要評估指定範圍中整數是否存在的函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-204">The function to evaluate for the existence of the integers in the specified range.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-205">判斷特定條件對於指定之範圍內的所有整數是否有效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-205">Determines whether a particular condition is valid for all integers in a specified range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="533e0-206">如果 <paramref name="predicate" /> 為從 <paramref name="fromInclusive" /> 開始到 <paramref name="toExclusive" /> - 1 的所有整數傳回 <see langword="true" />，則為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-206">
              <see langword="true" /> if <paramref name="predicate" /> returns <see langword="true" /> for all integers starting from <paramref name="fromInclusive" /> to <paramref name="toExclusive" /> - 1.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-207">`toExclusive`參數是一個來加速使用從 0 開始的整數的範圍長度的最後一個整數加一。</span><span class="sxs-lookup"><span data-stu-id="533e0-207">The `toExclusive` parameter is one more than the last integer to facilitate using the length of a range of integers starting at 0.</span></span> <span data-ttu-id="533e0-208">比方說，它會設定為 0 到 4 的整數 5。</span><span class="sxs-lookup"><span data-stu-id="533e0-208">For example, it would be set to 5 for integers 0 through 4.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="533e0-209">下列範例示範如何使用<xref:System.Diagnostics.Contracts.Contract.ForAll%2A>方法來判斷陣列是否有 null 項目。</span><span class="sxs-lookup"><span data-stu-id="533e0-209">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether an array has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="533e0-210">
            <paramref name="predicate" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-210">
              <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="533e0-211">
            <paramref name="toExclusive" /> 小於 <paramref name="fromInclusive" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-211">
              <paramref name="toExclusive" /> is less than <paramref name="fromInclusive" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; collection, Predicate&lt;T&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ForAll&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; collection, class System.Predicate`1&lt;!!T&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll(Of T) (collection As IEnumerable(Of T), predicate As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool ForAll(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, Predicate&lt;T&gt; ^ predicate);" />
      <MemberSignature Language="F#" Value="static member ForAll : seq&lt;'T&gt; * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Diagnostics.Contracts.Contract.ForAll (collection, predicate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="predicate" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="533e0-212">中包含的型別<c>集合</c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-212">The type that is contained in <c>collection</c>.</span>
          </span>
        </typeparam>
        <param name="collection">
          <span data-ttu-id="533e0-213">集合，將從其中取出 <c>T</c> 型別的元素以傳遞給 <c>predicate</c>。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-213">The collection from which elements of type <c>T</c> will be drawn to pass to <c>predicate</c>.</span>
          </span>
        </param>
        <param name="predicate">
          <span data-ttu-id="533e0-214">要評估 <c>collection</c> 中所有元素是否存在的函式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-214">The function to evaluate for the existence of all the elements in <c>collection</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-215">判斷集合內的所有項目是否都出現在函式中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-215">Determines whether all the elements in a collection exist within a function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="533e0-216">只有在 <paramref name="predicate" /> 為 <paramref name="T" /> 中所有 <paramref name="collection" /> 型別的項目傳回 <see langword="true" /> 時，才為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-216">
              <see langword="true" /> if and only if <paramref name="predicate" /> returns <see langword="true" /> for all elements of type <paramref name="T" /> in <paramref name="collection" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="533e0-217">下列範例示範如何使用<xref:System.Diagnostics.Contracts.Contract.ForAll%2A>方法，以判斷集合是否有 null 項目。</span><span class="sxs-lookup"><span data-stu-id="533e0-217">The following example demonstrates how to use the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> method to determine whether a collection has a null element.</span></span>  
  
 [!code-csharp[Contract.ForAllExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/contract.forallexample/cs/program.cs#1)]
 [!code-vb[Contract.ForAllExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/contract.forallexample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="533e0-218">
            <paramref name="collection" /> 或 <paramref name="predicate" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-218">
              <paramref name="collection" /> or <paramref name="predicate" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invariant">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="533e0-219">指定封入方法或屬性的合約。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-219">Specifies a contract for an enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="533e0-220">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-220">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-221">指定封入方法或屬性的非變異合約。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-221">Specifies an invariant contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> 所識別的方法內所包含的合約<xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute>屬性; 一般而言，方法命名為`ObjectInvariant`。</span><span class="sxs-lookup"><span data-stu-id="533e0-222"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="533e0-223">此合約可以指定只在專用的非變異方法，在類別中宣告。</span><span class="sxs-lookup"><span data-stu-id="533e0-223">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span> <span data-ttu-id="533e0-224">如果此方法不密封格式，它應該只參考受保護的成員，而不是私用成員，以便子類別可以一定要保持不變量。</span><span class="sxs-lookup"><span data-stu-id="533e0-224">If the method is not sealed, it should refer only to protected members, not private members, so that subclasses can be sure to maintain the invariants.</span></span>  
  
-   <span data-ttu-id="533e0-225">此合約不會公開給用戶端;因此，它可能會參考比封入方法較不可見的成員。</span><span class="sxs-lookup"><span data-stu-id="533e0-225">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="533e0-226">您必須使用執行階段強制執行此非變異二進位重寫器。</span><span class="sxs-lookup"><span data-stu-id="533e0-226">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="533e0-227">非變異值有條件地根據所定義的存在`CONTRACTS FULL`符號。</span><span class="sxs-lookup"><span data-stu-id="533e0-227">Invariants are conditionally defined based on the presence of the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="533e0-228">在執行階段檢查期間，會在每個公用方法的結尾檢查非變異值。</span><span class="sxs-lookup"><span data-stu-id="533e0-228">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="533e0-229">如果非變異值提及在相同類別中的公用方法，通常會發生在該公用方法結尾處的非變異檢查已停用，只有該類別最外層的方法呼叫的結束時檢查。</span><span class="sxs-lookup"><span data-stu-id="533e0-229">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="533e0-230">如果因為呼叫另一個類別上的方法而重新輸入此類別，也會進行這項檢查。</span><span class="sxs-lookup"><span data-stu-id="533e0-230">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invariant">
      <MemberSignature Language="C#" Value="public static void Invariant (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invariant(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invariant (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invariant(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Invariant : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Invariant (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="533e0-231">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-231">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="533e0-232">如果條件為 <see langword="false" /> 就會顯示訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-232">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-233">指定封入方法或屬性的非變異合約，並在合約的條件失敗時顯示訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-233">Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> 所識別的方法內所包含的合約<xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute>屬性; 一般而言，方法命名為`ObjectInvariant`。</span><span class="sxs-lookup"><span data-stu-id="533e0-234"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A> contracts are contained within a method that is identified by the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute; typically, the method is named `ObjectInvariant`.</span></span>  
  
-   <span data-ttu-id="533e0-235">此合約可以指定只在專用的非變異方法，在類別中宣告。</span><span class="sxs-lookup"><span data-stu-id="533e0-235">This contract can be specified only in a dedicated invariant method that is declared on a class.</span></span>  
  
-   <span data-ttu-id="533e0-236">此合約不會公開給用戶端;因此，它可能會參考比封入方法較不可見的成員。</span><span class="sxs-lookup"><span data-stu-id="533e0-236">This contract is not exposed to clients; therefore, it may reference members that are less visible than the enclosing method.</span></span>  
  
-   <span data-ttu-id="533e0-237">您必須使用執行階段強制執行此非變異二進位重寫器。</span><span class="sxs-lookup"><span data-stu-id="533e0-237">You must use the binary rewriter for run-time enforcement of this invariant.</span></span>  
  
-   <span data-ttu-id="533e0-238">上有條件地定義非變異值`CONTRACTS FULL`符號。</span><span class="sxs-lookup"><span data-stu-id="533e0-238">Invariants are conditionally defined on the `CONTRACTS FULL` symbol.</span></span> <span data-ttu-id="533e0-239">在執行階段檢查期間，會在每個公用方法的結尾檢查非變異值。</span><span class="sxs-lookup"><span data-stu-id="533e0-239">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="533e0-240">如果非變異值提及在相同類別中的公用方法，通常會發生在該公用方法結尾處的非變異檢查已停用，只有該類別最外層的方法呼叫的結束時檢查。</span><span class="sxs-lookup"><span data-stu-id="533e0-240">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled and checked only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="533e0-241">如果因為呼叫另一個類別上的方法而重新輸入此類別，也會進行這項檢查。</span><span class="sxs-lookup"><span data-stu-id="533e0-241">This also happens if the class is re-entered because of a call to a method on another class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OldValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T OldValue&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T OldValue&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OldValue(Of T) (value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T OldValue(T value);" />
      <MemberSignature Language="F#" Value="static member OldValue : 'T -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.OldValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="533e0-242">值的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-242">The type of value.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="533e0-243">要表示的值 (欄位或參數)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-243">The value to represent (field or parameter).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-244">表示其在方法或屬性開始時的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-244">Represents values as they were at the start of a method or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="533e0-245">在方法或屬性開始時之欄位或參數的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-245">The value of the parameter or field at the start of a method or property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-246">這個方法只能用於條件式運算式<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>合約。</span><span class="sxs-lookup"><span data-stu-id="533e0-246">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="533e0-247">下列範例示範使用<xref:System.Diagnostics.Contracts.Contract.OldValue%2A>方法，以確保已更新計數。</span><span class="sxs-lookup"><span data-stu-id="533e0-247">The following example shows the use of the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method to ensure that a count has been updated.</span></span> <span data-ttu-id="533e0-248">此程式碼範例是針對提供之較大範例的一部分<xref:System.Diagnostics.Contracts.ContractClassAttribute>類別。</span><span class="sxs-lookup"><span data-stu-id="533e0-248">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#5](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#5)]
 [!code-vb[ContractExample#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Requires">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="533e0-249">指定封入方法或屬性的前置條件合約。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-249">Specifies a precondition contract for an enclosing method or property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="533e0-250">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-250">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-251">指定封入方法或屬性的前置條件合約。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-251">Specifies a precondition contract for the enclosing method or property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="533e0-252">這個方法呼叫必須是方法或屬性之前的任何其他程式碼, 的開頭。</span><span class="sxs-lookup"><span data-stu-id="533e0-252">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="533e0-253">此合約會公開給用戶端;因此，它必須只參考都至少與封入方法為可見的成員。</span><span class="sxs-lookup"><span data-stu-id="533e0-253">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="533e0-254">使用這個方法，而不是<xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType>回溯相容性不會強制您擲回特定例外狀況的方法。</span><span class="sxs-lookup"><span data-stu-id="533e0-254">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires">
      <MemberSignature Language="C#" Value="public static void Requires (bool condition, string userMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("CONTRACTS_FULL")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="condition">
          <span data-ttu-id="533e0-255">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-255">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="533e0-256">如果條件為 <see langword="false" /> 就會顯示訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-256">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-257">指定封入方法或屬性的前置條件合約，並在合約的條件失敗時顯示訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-257">Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="533e0-258">這個方法呼叫必須是方法或屬性之前的任何其他程式碼, 的開頭。</span><span class="sxs-lookup"><span data-stu-id="533e0-258">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="533e0-259">此合約會公開給用戶端;因此，它必須只參考都至少與封入方法為可見的成員。</span><span class="sxs-lookup"><span data-stu-id="533e0-259">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="533e0-260">使用這個方法，而不是<xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType>回溯相容性不會強制您擲回特定例外狀況的方法。</span><span class="sxs-lookup"><span data-stu-id="533e0-260">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%60%601%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when backward compatibility does not force you to throw a particular exception.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition);" />
      <MemberSignature Language="F#" Value="static member Requires : bool -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="533e0-261">當條件為 <see langword="false" /> 時所要擲回的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-261">The exception to throw if the condition is <see langword="false" />.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="533e0-262">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-262">The conditional expression to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-263">指定封入方法或屬性的前置條件合約，並在合約的條件失敗時擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-263">Specifies a precondition contract for the enclosing method or property, and throws an exception if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="533e0-264">您必須在執行階段檢查，以使用開啟<xref:System.Diagnostics.Contracts.Contract.Requires%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="533e0-264">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="533e0-265">如果執行階段檢查已關閉，將會終止處理程序。</span><span class="sxs-lookup"><span data-stu-id="533e0-265">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="533e0-266">若要取得適用於執行階段檢查的工具，請參閱[程式碼合約](https://go.microsoft.com/fwlink/?LinkId=152461)MSDN DevLabs 網站上。</span><span class="sxs-lookup"><span data-stu-id="533e0-266">To obtain the tools for runtime checking, see [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
-   <span data-ttu-id="533e0-267">這個方法呼叫必須是方法或屬性之前的任何其他程式碼, 的開頭。</span><span class="sxs-lookup"><span data-stu-id="533e0-267">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="533e0-268">此合約會公開給用戶端;因此，它必須只參考都至少與封入方法為可見的成員。</span><span class="sxs-lookup"><span data-stu-id="533e0-268">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="533e0-269">使用這個方法，而不是<xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType>方法，當您想要的前置條件失敗時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="533e0-269">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Requires&lt;TException&gt;">
      <MemberSignature Language="C#" Value="public static void Requires&lt;TException&gt; (bool condition, string userMessage) where TException : Exception;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Requires&lt;(class System.Exception) TException&gt;(bool condition, string userMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Requires``1(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Requires(Of TException As Exception) (condition As Boolean, userMessage As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TException&gt;&#xA; where TException : Exception static void Requires(bool condition, System::String ^ userMessage);" />
      <MemberSignature Language="F#" Value="static member Requires : bool * string -&gt; unit (requires 'Exception :&gt; Exception)" Usage="System.Diagnostics.Contracts.Contract.Requires (condition, userMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TException">
          <Constraints>
            <BaseTypeName>System.Exception</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="condition" Type="System.Boolean" />
        <Parameter Name="userMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TException">
          <span data-ttu-id="533e0-270">當條件為 <see langword="false" /> 時所要擲回的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-270">The exception to throw if the condition is <see langword="false" />.</span>
          </span>
        </typeparam>
        <param name="condition">
          <span data-ttu-id="533e0-271">要測試的條件運算式。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-271">The conditional expression to test.</span>
          </span>
        </param>
        <param name="userMessage">
          <span data-ttu-id="533e0-272">如果條件為 <see langword="false" /> 就會顯示訊息。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-272">The message to display if the condition is <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-273">指定封入方法或屬性的前置條件合約，並在合約的條件失敗時擲回包含所提供訊息的例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-273">Specifies a precondition contract for the enclosing method or property, and throws an exception with the provided message if the condition for the contract fails.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   > [!IMPORTANT]
    >  <span data-ttu-id="533e0-274">您必須在執行階段檢查，以使用開啟<xref:System.Diagnostics.Contracts.Contract.Requires%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="533e0-274">You must turn on run-time checking to use the <xref:System.Diagnostics.Contracts.Contract.Requires%2A> method.</span></span> <span data-ttu-id="533e0-275">如果執行階段檢查已關閉，將會終止處理程序。</span><span class="sxs-lookup"><span data-stu-id="533e0-275">If run-time checking is turned off, the process will be terminated.</span></span> <span data-ttu-id="533e0-276">若要取得適用於執行階段檢查的工具，請參閱[程式碼合約](https://go.microsoft.com/fwlink/?LinkId=152461)MSDN DevLabs 網站上。</span><span class="sxs-lookup"><span data-stu-id="533e0-276">To obtain the tools for runtime checking, see [Code Contracts](https://go.microsoft.com/fwlink/?LinkId=152461) on the MSDN DevLabs Web site.</span></span>  
  
     <span data-ttu-id="533e0-277">這個方法呼叫必須是方法或屬性之前的任何其他程式碼, 的開頭。</span><span class="sxs-lookup"><span data-stu-id="533e0-277">This method call must be at the beginning of a method or property, before any other code.</span></span>  
  
-   <span data-ttu-id="533e0-278">此合約會公開給用戶端;因此，它必須只參考都至少與封入方法為可見的成員。</span><span class="sxs-lookup"><span data-stu-id="533e0-278">This contract is exposed to clients; therefore, it must only reference members that are at least as visible as the enclosing method.</span></span>  
  
-   <span data-ttu-id="533e0-279">使用這個方法，而不是<xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType>方法，當您想要的前置條件失敗時擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="533e0-279">Use this method instead of the <xref:System.Diagnostics.Contracts.Contract.Requires%28System.Boolean%2CSystem.String%29?displayProperty=nameWithType> method when you want to throw an exception if the precondition fails.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Result&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Result&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.Result``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Result(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Result();" />
      <MemberSignature Language="F#" Value="static member Result : unit -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.Result " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="533e0-280">封入方法或屬性的傳回值類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-280">Type of return value of the enclosing method or property.</span>
          </span>
        </typeparam>
        <summary>
          <span data-ttu-id="533e0-281">表示方法或屬性的傳回值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-281">Represents the return value of a method or property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="533e0-282">封入方法或屬性的傳回值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-282">Return value of the enclosing method or property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-283">這個方法只能用於條件式運算式<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>合約。</span><span class="sxs-lookup"><span data-stu-id="533e0-283">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="533e0-284">下列範例示範如何使用<xref:System.Diagnostics.Contracts.Contract.Result%2A>方法，以指定預期的傳回值。</span><span class="sxs-lookup"><span data-stu-id="533e0-284">The following example shows how to use the <xref:System.Diagnostics.Contracts.Contract.Result%2A> method to specify an expected return value.</span></span> <span data-ttu-id="533e0-285">此程式碼範例是針對提供之較大範例的一部分<xref:System.Diagnostics.Contracts.ContractClassAttribute>類別。</span><span class="sxs-lookup"><span data-stu-id="533e0-285">This code example is part of a larger example provided for the <xref:System.Diagnostics.Contracts.ContractClassAttribute> class.</span></span>  
  
 [!code-csharp[ContractExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#3)]
 [!code-vb[ContractExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueAtReturn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ValueAtReturn&lt;T&gt; (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ValueAtReturn&lt;T&gt;([out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Contracts.Contract.ValueAtReturn``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ValueAtReturn(Of T) (ByRef value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ValueAtReturn([Runtime::InteropServices::Out] T % value);" />
      <MemberSignature Language="F#" Value="static member ValueAtReturn :  -&gt; 'T" Usage="System.Diagnostics.Contracts.Contract.ValueAtReturn value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Contracts</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="533e0-286">
            <see langword="out" /> 參數的類型。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-286">The type of the <see langword="out" /> parameter.</span>
          </span>
        </typeparam>
        <param name="value">
          <span data-ttu-id="533e0-287">
            <see langword="out" /> 參數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-287">The <see langword="out" /> parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="533e0-288">表示從方法傳回時的最後 (輸出) <see langword="out" /> 參數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-288">Represents the final (output) value of an <see langword="out" /> parameter when returning from a method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="533e0-289">
            <see langword="out" /> 參數的輸出值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="533e0-289">The output value of the <see langword="out" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="533e0-290">這個方法只能用於條件式運算式<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>合約。</span><span class="sxs-lookup"><span data-stu-id="533e0-290">This method can be used only in the conditional expression for the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> contract.</span></span> <span data-ttu-id="533e0-291">如同 <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> 方法，只要編譯器能夠推斷其類型，您就可以省略泛型型別引數。</span><span class="sxs-lookup"><span data-stu-id="533e0-291">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="533e0-292">合約重寫器會將方法呼叫取代為 `out` 參數的值。</span><span class="sxs-lookup"><span data-stu-id="533e0-292">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="533e0-293"><xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> 方法只會出現在後置條件中。</span><span class="sxs-lookup"><span data-stu-id="533e0-293">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="533e0-294">方法的引數必須是 `out` 參數，或是結構 `out` 參數的欄位。</span><span class="sxs-lookup"><span data-stu-id="533e0-294">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="533e0-295">參考結構建構函式後置條件中的欄位時，後者也很有用。</span><span class="sxs-lookup"><span data-stu-id="533e0-295">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>