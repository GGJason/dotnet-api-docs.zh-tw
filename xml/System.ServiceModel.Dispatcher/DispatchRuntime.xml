<Type Name="DispatchRuntime" FullName="System.ServiceModel.Dispatcher.DispatchRuntime">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="75c2ddd88e582b7c67fbbb2aa7c800dd3a9a32f6" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39849477" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DispatchRuntime" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DispatchRuntime extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.DispatchRuntime" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DispatchRuntime" />
  <TypeSignature Language="C++ CLI" Value="public ref class DispatchRuntime sealed" />
  <TypeSignature Language="F#" Value="type DispatchRuntime = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>公開屬性，這些屬性可用於修改預設服務行為以及附加自訂物件，而這些物件可以修改將傳入訊息轉換成物件並分派至作業的方式。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.DispatchRuntime> 類別，即可修改服務或個別端點的預設行為，或插入會對下列其中一項或所有服務程序實作自訂修改的物件：  
  
1.  將傳入訊息轉換成物件，並且在針對服務物件叫用方法時釋放這些物件。  
  
2.  將回應叫用服務作業時收到的物件轉換成傳出訊息。  
  
 在 Windows Communication Foundation (WCF) 中，通道和端點發送器是負責接受新通道、 服務元件接收訊息、 方法分派和叫用，以及回應處理。 每個由 <xref:System.ServiceModel.ServiceHost> 物件公開的端點都有一個端點發送器和相關聯的通道發送器；此外，每個參與雙工通訊的用戶端對於每個回呼端點也都有一個端點發送器和通道發送器。  
  
 即使無法辨識訊息，<xref:System.ServiceModel.Dispatcher.DispatchRuntime> 仍可讓您為特定合約上的所有訊息攔截及擴充通道或端點發送器。 當不符合在合約中宣告之任何訊息的訊息到達時，該訊息會被分派至由 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.UnhandledDispatchOperation%2A> 屬性傳回的作業。 若要針對特定作業在所有訊息上進行攔截或擴充，請參閱 <xref:System.ServiceModel.Dispatcher.DispatchOperation> 類別。  
  
 發送器擴充性的四個主要區域是由 <xref:System.ServiceModel.Dispatcher.DispatchRuntime> 類別所公開：  
  
1.  分派元件會使用 <xref:System.ServiceModel.Dispatcher.DispatchRuntime> 的屬性以及相關聯通道發送器的屬性 (由 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.ChannelDispatcher%2A> 屬性傳回)，自訂通道發送器接受及關閉通道的方式。 這個分類包括 <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ChannelInitializers%2A> 和 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InputSessionShutdownHandlers%2A> 屬性。  
  
2.  訊息元件會針對所處理的各個訊息進行自訂。 這個分類包括 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.MessageInspectors%2A>、<xref:System.ServiceModel.Dispatcher.DispatchRuntime.OperationSelector%2A>、<xref:System.ServiceModel.Dispatcher.DispatchRuntime.Operations%2A> 和 <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.ErrorHandlers%2A> 屬性。  
  
3.  執行個體元件會自訂服務類型執行個體的建立、存留期和處置。 如需服務物件存留期的詳細資訊，請參閱 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 屬性。 這個分類包括 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceContextInitializers%2A> 和 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider%2A> 屬性。  
  
4.  安全性相關的元件可以使用下列屬性：  
  
    -   <xref:System.ServiceModel.Dispatcher.DispatchRuntime.SecurityAuditLogLocation%2A> 會指出要將稽核事件寫入何處。  
  
    -   <xref:System.ServiceModel.Dispatcher.DispatchRuntime.ImpersonateCallerForAllOperations%2A> 會控制服務是否會嘗試使用由傳入訊息提供的認證來進行模擬。  
  
    -   <xref:System.ServiceModel.Dispatcher.DispatchRuntime.MessageAuthenticationAuditLevel%2A> 會控制是否要將成功的訊息驗證事件寫入由 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.SecurityAuditLogLocation%2A> 指定的事件記錄檔。  
  
    -   <xref:System.ServiceModel.Dispatcher.DispatchRuntime.PrincipalPermissionMode%2A> 會控制 <xref:System.Threading.Thread.CurrentPrincipal%2A> 屬性的設定方式。  
  
    -   <xref:System.ServiceModel.Dispatcher.DispatchRuntime.ServiceAuthorizationAuditLevel%2A> 會指定稽核授權事件的執行方式。  
  
    -   <xref:System.ServiceModel.Dispatcher.DispatchRuntime.SuppressAuditFailure%2A> 會指定是否要隱藏在記錄處理期間發生的非嚴重例外狀況。  
  
 一般來說，自訂延伸物件會指派給 <xref:System.ServiceModel.Dispatcher.DispatchRuntime> 屬性，或由服務行為 (實作 <xref:System.ServiceModel.Description.IServiceBehavior> 的物件)、合約行為 (實作 <xref:System.ServiceModel.Description.IContractBehavior> 的物件) 或端點行為 (實作 <xref:System.ServiceModel.Description.IEndpointBehavior> 的物件) 插入到集合中。 接著，安裝行為物件會透過程式設計的方式或實作自訂 <xref:System.ServiceModel.Configuration.BehaviorExtensionElement> 物件的方式新增至適當的行為集合，讓該行為可以透過應用程式組態檔插入。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AutomaticInputSessionShutdown">
      <MemberSignature Language="C#" Value="public bool AutomaticInputSessionShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticInputSessionShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.AutomaticInputSessionShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticInputSessionShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutomaticInputSessionShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticInputSessionShutdown : bool with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.AutomaticInputSessionShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定當用戶端關閉輸出工作階段時，服務是否要關閉輸入工作階段。</summary>
        <value>如果服務在用戶端關閉輸出工作階段時關閉輸入工作階段，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您將 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.AutomaticInputSessionShutdown%2A> 屬性設定為 `false`，該通道就必須由另一種機制來關閉。 在這種情況下，您必須將自訂工作階段關機處理常式新增至 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InputSessionShutdownHandlers%2A> 屬性。  
  
 根據預設，當用戶端關閉輸出工作階段，且服務已完成處理任何剩餘的訊息時，伺服器便會關閉工作階段。 將 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.AutomaticInputSessionShutdown%2A> 設定為 `false`，以防止伺服器自動關閉工作階段，並啟用工作階段存留期的自訂控制。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallbackClientRuntime">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.ClientRuntime CallbackClientRuntime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.ClientRuntime CallbackClientRuntime" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.CallbackClientRuntime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CallbackClientRuntime As ClientRuntime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::ClientRuntime ^ CallbackClientRuntime { System::ServiceModel::Dispatcher::ClientRuntime ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CallbackClientRuntime : System.ServiceModel.Dispatcher.ClientRuntime" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.CallbackClientRuntime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.ClientRuntime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.ServiceModel.Dispatcher.ClientRuntime" /> 物件，此物件代表 Windows Communication Foundation (WCF) 延伸模組對雙工回呼端點之傳出呼叫的安裝點。</summary>
        <value>
          <see cref="T:System.ServiceModel.Dispatcher.ClientRuntime" /> 物件，它是透過雙工合約進行之執行階段用戶端自訂的安裝點。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.CallbackClientRuntime%2A> 來新增自訂延伸物件，這些物件可檢視或修改將參數轉換成傳出訊息、以及將回應訊息轉回傳回值。 如需詳細資訊，請參閱 <xref:System.ServiceModel.Dispatcher.ClientRuntime>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChannelDispatcher">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.ChannelDispatcher ChannelDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.ChannelDispatcher ChannelDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.ChannelDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChannelDispatcher As ChannelDispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::ChannelDispatcher ^ ChannelDispatcher { System::ServiceModel::Dispatcher::ChannelDispatcher ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChannelDispatcher : System.ServiceModel.Dispatcher.ChannelDispatcher" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.ChannelDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.ChannelDispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個分派執行階段物件的 <see cref="T:System.ServiceModel.Dispatcher.ChannelDispatcher" />。</summary>
        <value>分派執行階段物件的通道發送器。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcurrencyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ConcurrencyMode ConcurrencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ConcurrencyMode ConcurrencyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.ConcurrencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ConcurrencyMode As ConcurrencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ConcurrencyMode ConcurrencyMode { System::ServiceModel::ConcurrencyMode get(); void set(System::ServiceModel::ConcurrencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.ConcurrencyMode : System.ServiceModel.ConcurrencyMode with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.ConcurrencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定服務的執行個體是循序處理或同時處理訊息。</summary>
        <value>
          <see cref="T:System.ServiceModel.ConcurrencyMode" /> 物件，此物件會控制服務的執行個體是循序處理或同時處理訊息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 服務實作必須是安全執行緒，才能使用 `Multiple` 並行模式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndpointDispatcher">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.EndpointDispatcher EndpointDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.EndpointDispatcher EndpointDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.EndpointDispatcher" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndpointDispatcher As EndpointDispatcher" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::EndpointDispatcher ^ EndpointDispatcher { System::ServiceModel::Dispatcher::EndpointDispatcher ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EndpointDispatcher : System.ServiceModel.Dispatcher.EndpointDispatcher" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.EndpointDispatcher" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.EndpointDispatcher</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個分派執行階段的 <see cref="T:System.ServiceModel.Dispatcher.EndpointDispatcher" />。</summary>
        <value>這個分派執行階段的 <see cref="T:System.ServiceModel.Dispatcher.EndpointDispatcher" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.EndpointDispatcher%2A> 屬性來取得與這個分派執行階段有關聯的端點發送器，即可修改或自訂端點特定的執行。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否依照傳送的順序分派訊息。</summary>
        <value>如果訊息要按照其傳送的順序傳遞，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExternalAuthorizationPolicies">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Policy.IAuthorizationPolicy&gt; ExternalAuthorizationPolicies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.Policy.IAuthorizationPolicy&gt; ExternalAuthorizationPolicies" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.ExternalAuthorizationPolicies" />
      <MemberSignature Language="VB.NET" Value="Public Property ExternalAuthorizationPolicies As ReadOnlyCollection(Of IAuthorizationPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::Policy::IAuthorizationPolicy ^&gt; ^ ExternalAuthorizationPolicies { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::Policy::IAuthorizationPolicy ^&gt; ^ get(); void set(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::Policy::IAuthorizationPolicy ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExternalAuthorizationPolicies : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Policy.IAuthorizationPolicy&gt; with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.ExternalAuthorizationPolicies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Policy.IAuthorizationPolicy&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定外部授權原則，這組原則會定義用於授權使用者、指定宣告集的一組規則。</summary>
        <value>
          <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 物件的 <see cref="T:System.IdentityModel.Policy.IAuthorizationPolicy" />，此集合會定義用於授權使用者、指定宣告集的一組規則。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個屬性來新增 <xref:System.IdentityModel.Policy.IAuthorizationPolicy> 的自訂實作，即可定義用於授權使用者、指定宣告集的一組規則。 這個自訂實作會在每次呼叫服務時使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreTransactionMessageProperty">
      <MemberSignature Language="C#" Value="public bool IgnoreTransactionMessageProperty { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreTransactionMessageProperty" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.IgnoreTransactionMessageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreTransactionMessageProperty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreTransactionMessageProperty { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreTransactionMessageProperty : bool with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.IgnoreTransactionMessageProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定指定是否要忽略 <see cref="T:System.ServiceModel.Channels.TransactionMessageProperty" /> 的值。</summary>
        <value>如果在執行服務方法時忽略 <see cref="T:System.ServiceModel.Channels.TransactionMessageProperty" />，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.TransactionMessageProperty>可讓協力廠商通道開發人員使用專屬的異動流程機制，針對其通道來導入他們的交易到 Windows Communication Foundation (WCF)。 如果這個屬性設定為 `true`，即表示在執行此服務方法時將忽略該交易。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonateCallerForAllOperations">
      <MemberSignature Language="C#" Value="public bool ImpersonateCallerForAllOperations { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ImpersonateCallerForAllOperations" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.ImpersonateCallerForAllOperations" />
      <MemberSignature Language="VB.NET" Value="Public Property ImpersonateCallerForAllOperations As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ImpersonateCallerForAllOperations { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonateCallerForAllOperations : bool with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.ImpersonateCallerForAllOperations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會控制服務是否會使用傳入訊息提供的認證來嘗試模擬。</summary>
        <value>如果服務會在作業的 <see cref="P:System.ServiceModel.Dispatcher.DispatchOperation.Impersonation" /> 屬性值為 <see cref="F:System.ServiceModel.ImpersonationOption.Required" /> 或 <see cref="F:System.ServiceModel.ImpersonationOption.Allowed" /> 時嘗試根據訊息認證進行模擬，則為 <see langword="true" />，如果服務只有在作業的 <see cref="P:System.ServiceModel.Dispatcher.DispatchOperation.Impersonation" /> 屬性值為 <see cref="F:System.ServiceModel.ImpersonationOption.Required" /> 時才嘗試模擬，則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.ImpersonateCallerForAllOperations%2A> 屬性，即可控制是否在作業的 <xref:System.ServiceModel.Dispatcher.DispatchOperation.Impersonation%2A> 屬性值為 <xref:System.ServiceModel.ImpersonationOption.Allowed> 時執行模擬。 如果屬性為 `true` 但作業的 <xref:System.ServiceModel.Dispatcher.DispatchOperation.Impersonation%2A> 屬性值為 <xref:System.ServiceModel.ImpersonationOption.NotAllowed>，便會擲回例外狀況。  
  
 如果作業的 <xref:System.ServiceModel.Dispatcher.DispatchOperation.Impersonation%2A> 屬性值為 <xref:System.ServiceModel.ImpersonationOption.Required>，便一定會嘗試模擬。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonateOnSerializingReply">
      <MemberSignature Language="C#" Value="public bool ImpersonateOnSerializingReply { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ImpersonateOnSerializingReply" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.ImpersonateOnSerializingReply" />
      <MemberSignature Language="VB.NET" Value="Public Property ImpersonateOnSerializingReply As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ImpersonateOnSerializingReply { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonateOnSerializingReply : bool with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.ImpersonateOnSerializingReply" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出是否在序列化回覆動作時使用模擬。</summary>
        <value>如果在序列化回覆作業時使用模擬功能，則為 <see langword="true" />，否則為<see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InputSessionShutdownHandlers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IInputSessionShutdown&gt; InputSessionShutdownHandlers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedCollection`1&lt;class System.ServiceModel.Dispatcher.IInputSessionShutdown&gt; InputSessionShutdownHandlers" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.InputSessionShutdownHandlers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputSessionShutdownHandlers As SynchronizedCollection(Of IInputSessionShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IInputSessionShutdown ^&gt; ^ InputSessionShutdownHandlers { System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IInputSessionShutdown ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputSessionShutdownHandlers : System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IInputSessionShutdown&gt;" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.InputSessionShutdownHandlers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IInputSessionShutdown&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.ServiceModel.Dispatcher.IInputSessionShutdown" /> 物件的集合，該集合可用於新增自訂處理常式來控制輸入工作階段的關閉方式。</summary>
        <value>
          <see cref="T:System.Collections.Generic.SynchronizedCollection`1" />，型別為 <see cref="T:System.ServiceModel.Dispatcher.IInputSessionShutdown" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將 <xref:System.ServiceModel.Dispatcher.IInputSessionShutdown> 物件新增至這個屬性，即可控制輸入工作階段的關閉方式。 如果在 <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A?displayProperty=nameWithType> 上呼叫 <xref:System.ServiceModel.Channels.IDuplexSessionChannel?displayProperty=nameWithType> 方法時是先傳回 `null` (表示該輸入工作階段已關閉)，發送器就會叫用各個 <xref:System.ServiceModel.Dispatcher.IInputSessionShutdown> 物件，並將 <xref:System.ServiceModel.Channels.IDuplexSessionChannel?displayProperty=nameWithType> 物件傳給它。 自訂 <xref:System.ServiceModel.Dispatcher.IInputSessionShutdown> 物件可以使用這個 <xref:System.ServiceModel.Channels.IDuplexSessionChannel> 物件來執行清理各個通道狀態，或在關閉通道之前傳送回應訊息。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextInitializers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IInstanceContextInitializer&gt; InstanceContextInitializers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedCollection`1&lt;class System.ServiceModel.Dispatcher.IInstanceContextInitializer&gt; InstanceContextInitializers" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceContextInitializers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InstanceContextInitializers As SynchronizedCollection(Of IInstanceContextInitializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IInstanceContextInitializer ^&gt; ^ InstanceContextInitializers { System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IInstanceContextInitializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextInitializers : System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IInstanceContextInitializer&gt;" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.InstanceContextInitializers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IInstanceContextInitializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.ServiceModel.Dispatcher.IInstanceContextInitializer" /> 物件的集合，此集合可在初次建立 <see cref="T:System.ServiceModel.InstanceContext" /> 物件時用於檢查或修改該物件。</summary>
        <value>型別 <see cref="T:System.Collections.Generic.SynchronizedCollection`1" /> 的 <see cref="T:System.ServiceModel.Dispatcher.IInstanceContextInitializer" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceContextInitializers%2A> 屬性來新增自訂初始設定式，此初始設定式可在初次建立 <xref:System.ServiceModel.InstanceContext> 物件時用來檢查或修改該物件。 <xref:System.ServiceModel.InstanceContext> 物件的建立頻率是由 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 屬性所控制。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextProvider">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.IInstanceContextProvider InstanceContextProvider { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.IInstanceContextProvider InstanceContextProvider" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceContextProvider" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceContextProvider As IInstanceContextProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::IInstanceContextProvider ^ InstanceContextProvider { System::ServiceModel::Dispatcher::IInstanceContextProvider ^ get(); void set(System::ServiceModel::Dispatcher::IInstanceContextProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextProvider : System.ServiceModel.Dispatcher.IInstanceContextProvider with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.InstanceContextProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.IInstanceContextProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要由 <see cref="T:System.ServiceModel.Dispatcher.IInstanceContextProvider" /> 使用的 <see cref="T:System.ServiceModel.Dispatcher.DispatchRuntime" />。</summary>
        <value>要由 <see cref="T:System.ServiceModel.Dispatcher.IInstanceContextProvider" /> 使用的 <see cref="T:System.ServiceModel.Dispatcher.DispatchRuntime" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceProvider">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.IInstanceProvider InstanceProvider { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.IInstanceProvider InstanceProvider" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceProvider As IInstanceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::IInstanceProvider ^ InstanceProvider { System::ServiceModel::Dispatcher::IInstanceProvider ^ get(); void set(System::ServiceModel::Dispatcher::IInstanceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceProvider : System.ServiceModel.Dispatcher.IInstanceProvider with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.IInstanceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.ServiceModel.Dispatcher.IInstanceProvider" /> 物件，您可以使用該物件來控制服務物件的建立和解構。</summary>
        <value>
          <see cref="T:System.ServiceModel.Dispatcher.IInstanceProvider" /> 物件，此物件會控制與 <see cref="T:System.ServiceModel.InstanceContext" /> 物件關聯之服務物件的建立和解構。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作 <xref:System.ServiceModel.Dispatcher.IInstanceProvider> 介面並將此實作指派給 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.InstanceProvider%2A> 屬性，即可控制使用非預設建構函式之建構函式的服務型別執行個體，例如，實作像是執行個體共用的自訂執行個體模式。  
  
 一般來說，當初次建立 <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%2A> 物件時，便會叫用一次 <xref:System.ServiceModel.InstanceContext> 方法。 當關閉 <xref:System.ServiceModel.Dispatcher.IInstanceProvider.ReleaseInstance%2A> 物件時，也會叫用一次 <xref:System.ServiceModel.InstanceContext> 方法。  
  
 服務也可以設定成在關閉 <xref:System.ServiceModel.InstanceContext> 物件之前釋出執行個體。 這項設定可以使用 <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A> 屬性或呼叫 <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A> 方法來完成。 完成這項設定之後，<xref:System.ServiceModel.InstanceContext> 物件便會呼叫 <xref:System.ServiceModel.Dispatcher.IInstanceProvider.ReleaseInstance%2A> 方法。 如果在執行個體釋放之後有新訊息到達，這時會使用 <xref:System.ServiceModel.Dispatcher.IInstanceProvider.GetInstance%2A> 方法建立新的執行個體。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageAuthenticationAuditLevel">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AuditLevel MessageAuthenticationAuditLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AuditLevel MessageAuthenticationAuditLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.MessageAuthenticationAuditLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageAuthenticationAuditLevel As AuditLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AuditLevel MessageAuthenticationAuditLevel { System::ServiceModel::AuditLevel get(); void set(System::ServiceModel::AuditLevel value); };" />
      <MemberSignature Language="F#" Value="member this.MessageAuthenticationAuditLevel : System.ServiceModel.AuditLevel with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.MessageAuthenticationAuditLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AuditLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定是否要將成功的訊息驗證事件寫入由 <see cref="P:System.ServiceModel.Dispatcher.DispatchRuntime.SecurityAuditLogLocation" /> 指定的事件記錄檔。</summary>
        <value>其中一個 <see cref="T:System.ServiceModel.AuditLevel" /> 值。 預設值為 <see cref="F:System.ServiceModel.AuditLevel.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.MessageAuthenticationAuditLevel%2A> 屬性，即可指定是否要將成功的訊息驗證事件寫入事件記錄檔。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageInspectors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IDispatchMessageInspector&gt; MessageInspectors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedCollection`1&lt;class System.ServiceModel.Dispatcher.IDispatchMessageInspector&gt; MessageInspectors" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.MessageInspectors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageInspectors As SynchronizedCollection(Of IDispatchMessageInspector)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IDispatchMessageInspector ^&gt; ^ MessageInspectors { System::Collections::Generic::SynchronizedCollection&lt;System::ServiceModel::Dispatcher::IDispatchMessageInspector ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageInspectors : System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IDispatchMessageInspector&gt;" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.MessageInspectors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedCollection&lt;System.ServiceModel.Dispatcher.IDispatchMessageInspector&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.ServiceModel.Dispatcher.IDispatchMessageInspector" /> 物件的集合，此集合可用來為整個端點上的所有傳入和傳出訊息附加自訂訊息偵測器。</summary>
        <value>型別 <see cref="T:System.Collections.Generic.SynchronizedCollection`1" /> 的 <see cref="T:System.ServiceModel.Dispatcher.IDispatchMessageInspector" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.MessageInspectors%2A> 屬性來附加自訂 <xref:System.ServiceModel.Dispatcher.IDispatchMessageInspector> 物件，即可檢查或轉換所有經過端點的訊息。 由於 <xref:System.ServiceModel.Dispatcher.IDispatchMessageInspector> 物件會取得訊息的參考，因此您可以緩衝處理它並檢查本文的複本。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Operations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SynchronizedKeyedCollection&lt;string,System.ServiceModel.Dispatcher.DispatchOperation&gt; Operations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SynchronizedKeyedCollection`2&lt;string, class System.ServiceModel.Dispatcher.DispatchOperation&gt; Operations" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.Operations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Operations As SynchronizedKeyedCollection(Of String, DispatchOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SynchronizedKeyedCollection&lt;System::String ^, System::ServiceModel::Dispatcher::DispatchOperation ^&gt; ^ Operations { System::Collections::Generic::SynchronizedKeyedCollection&lt;System::String ^, System::ServiceModel::Dispatcher::DispatchOperation ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Operations : System.Collections.Generic.SynchronizedKeyedCollection&lt;string, System.ServiceModel.Dispatcher.DispatchOperation&gt;" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.Operations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SynchronizedKeyedCollection&lt;System.String,System.ServiceModel.Dispatcher.DispatchOperation&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.ServiceModel.Dispatcher.DispatchOperation" /> 物件的集合，此集合可用於控制特定作業的執行行為。</summary>
        <value>型別 <see cref="T:System.Collections.Generic.SynchronizedKeyedCollection`2" /> 和 <see cref="T:System.String" /> 物件的 <see cref="T:System.ServiceModel.Dispatcher.DispatchOperation" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.Operations%2A> 屬性，即可檢查或修改參數、控制參數和傳回值序列化和還原序列化、控制作業叫用，以及修改單一作業的其他行為。 如需詳細資訊，請參閱 <xref:System.ServiceModel.Dispatcher.DispatchOperation>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OperationSelector">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.IDispatchOperationSelector OperationSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.IDispatchOperationSelector OperationSelector" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.OperationSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property OperationSelector As IDispatchOperationSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::IDispatchOperationSelector ^ OperationSelector { System::ServiceModel::Dispatcher::IDispatchOperationSelector ^ get(); void set(System::ServiceModel::Dispatcher::IDispatchOperationSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OperationSelector : System.ServiceModel.Dispatcher.IDispatchOperationSelector with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.OperationSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.IDispatchOperationSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.ServiceModel.Dispatcher.IDispatchOperationSelector" /> 物件，此物件會控制選取特定訊息的目的地 <see cref="T:System.ServiceModel.Dispatcher.DispatchOperation" />。</summary>
        <value>
          <see cref="T:System.ServiceModel.Dispatcher.IDispatchOperationSelector" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.OperationSelector%2A> 屬性，即可決定哪個作業要接收指定的訊息。 預設的作業選取器會傳回訊息的動作標頭值，該值會用來做為找出正確 <xref:System.ServiceModel.Dispatcher.DispatchOperation> 的索引鍵。 如果找不到相符的作業，該叫用就會分派給 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.UnhandledDispatchOperation%2A> 屬性的傳回值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveMessage">
      <MemberSignature Language="C#" Value="public bool PreserveMessage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveMessage" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.PreserveMessage" />
      <MemberSignature Language="VB.NET" Value="Public Property PreserveMessage As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreserveMessage { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreserveMessage : bool with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.PreserveMessage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定是否保留訊息。</summary>
        <value>如果已保留訊息，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrincipalPermissionMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.PrincipalPermissionMode PrincipalPermissionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.Description.PrincipalPermissionMode PrincipalPermissionMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.PrincipalPermissionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property PrincipalPermissionMode As PrincipalPermissionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Description::PrincipalPermissionMode PrincipalPermissionMode { System::ServiceModel::Description::PrincipalPermissionMode get(); void set(System::ServiceModel::Description::PrincipalPermissionMode value); };" />
      <MemberSignature Language="F#" Value="member this.PrincipalPermissionMode : System.ServiceModel.Description.PrincipalPermissionMode with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.PrincipalPermissionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.PrincipalPermissionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定 <see cref="P:System.Threading.Thread.CurrentPrincipal" /> 屬性的設定方式。</summary>
        <value>其中一個 <see cref="T:System.ServiceModel.Description.PrincipalPermissionMode" /> 值，預設值為 <see cref="F:System.ServiceModel.Description.PrincipalPermissionMode.UseWindowsGroups" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.PrincipalPermissionMode%2A> 為 <xref:System.ServiceModel.Description.PrincipalPermissionMode.None> 時，<xref:System.Threading.Thread.CurrentPrincipal%2A> 屬性便不會設定。  
  
 當值為 <xref:System.ServiceModel.Description.PrincipalPermissionMode.UseWindowsGroups> 時，<xref:System.Threading.Thread.CurrentPrincipal%2A> 屬性會根據傳入訊息的使用者認證填入 <xref:System.Security.Principal.WindowsPrincipal>。  
  
 當值為 <xref:System.ServiceModel.Description.PrincipalPermissionMode.UseAspNetRoles> 時，<xref:System.Threading.Thread.CurrentPrincipal%2A> 屬性會根據 <xref:System.Security.Principal.IPrincipal> 角色資訊填入 [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] 物件。  
  
 當值為 <xref:System.ServiceModel.Description.PrincipalPermissionMode.Custom> 時，<xref:System.Threading.Thread.CurrentPrincipal%2A> 屬性會由自訂 <xref:System.IdentityModel.Policy.IAuthorizationPolicy> 實作填入。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ReleaseServiceInstanceOnTransactionComplete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Property ReleaseServiceInstanceOnTransactionComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReleaseServiceInstanceOnTransactionComplete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReleaseServiceInstanceOnTransactionComplete : bool with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定是否在異動成功完成之後回收服務物件。</summary>
        <value>如果在交易成功完成之後回收服務物件，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> 的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.ReleaseServiceInstanceOnTransactionComplete%2A>，即可指定在交易成功完成時呼叫 <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A> 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RoleProvider">
      <MemberSignature Language="C#" Value="public System.Web.Security.RoleProvider RoleProvider { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Security.RoleProvider RoleProvider" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.RoleProvider" />
      <MemberSignature Language="VB.NET" Value="Public Property RoleProvider As RoleProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Security::RoleProvider ^ RoleProvider { System::Web::Security::RoleProvider ^ get(); void set(System::Web::Security::RoleProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoleProvider : System.Web.Security.RoleProvider with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.RoleProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.RoleProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定由 <see cref="T:System.Web.Security.RoleProvider" /> 使用的自訂 <see cref="T:System.ServiceModel.Dispatcher.DispatchRuntime" />。</summary>
        <value>由 <see cref="T:System.Web.Security.RoleProvider" /> 使用的自訂 <see cref="T:System.ServiceModel.Dispatcher.DispatchRuntime" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityAuditLogLocation">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AuditLogLocation SecurityAuditLogLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AuditLogLocation SecurityAuditLogLocation" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.SecurityAuditLogLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityAuditLogLocation As AuditLogLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AuditLogLocation SecurityAuditLogLocation { System::ServiceModel::AuditLogLocation get(); void set(System::ServiceModel::AuditLogLocation value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityAuditLogLocation : System.ServiceModel.AuditLogLocation with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.SecurityAuditLogLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AuditLogLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定稽核記錄檔的位置。</summary>
        <value>其中一個 <see cref="T:System.ServiceModel.AuditLogLocation" /> 值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceAuthenticationManager">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ServiceAuthenticationManager ServiceAuthenticationManager { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ServiceAuthenticationManager ServiceAuthenticationManager" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.ServiceAuthenticationManager" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceAuthenticationManager As ServiceAuthenticationManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ServiceAuthenticationManager ^ ServiceAuthenticationManager { System::ServiceModel::ServiceAuthenticationManager ^ get(); void set(System::ServiceModel::ServiceAuthenticationManager ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceAuthenticationManager : System.ServiceModel.ServiceAuthenticationManager with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.ServiceAuthenticationManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ServiceAuthenticationManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定物件，該物件會管理服務作業的驗證程序。</summary>
        <value>驗證管理物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 驗證會判斷簽署訊息之實體的識別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceAuthorizationAuditLevel">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AuditLevel ServiceAuthorizationAuditLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AuditLevel ServiceAuthorizationAuditLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.ServiceAuthorizationAuditLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceAuthorizationAuditLevel As AuditLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AuditLevel ServiceAuthorizationAuditLevel { System::ServiceModel::AuditLevel get(); void set(System::ServiceModel::AuditLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceAuthorizationAuditLevel : System.ServiceModel.AuditLevel with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.ServiceAuthorizationAuditLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AuditLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會控制對何種服務授權事件進行稽核。</summary>
        <value>其中一個 <see cref="T:System.ServiceModel.AuditLevel" /> 值。 預設值為 <see cref="F:System.ServiceModel.AuditLevel.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在預設的情況中，不會稽核任何服務授權事件。 如果 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.ServiceAuthorizationAuditLevel%2A> 值為 <xref:System.ServiceModel.AuditLevel.Success>，只有成功的服務授權事件會寫入由 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.SecurityAuditLogLocation%2A> 屬性指定的稽核記錄檔。 如果這個屬性有 <xref:System.ServiceModel.AuditLevel.Failure> 的值，只有不成功的服務授權事件會寫入由 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.SecurityAuditLogLocation%2A> 屬性指定的稽核記錄檔。 如果 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.ServiceAuthorizationAuditLevel%2A> 值為 <xref:System.ServiceModel.AuditLevel.SuccessOrFailure>，成功和失敗的服務授權事件都會寫入稽核記錄檔。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceAuthorizationManager">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ServiceAuthorizationManager ServiceAuthorizationManager { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.ServiceAuthorizationManager ServiceAuthorizationManager" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.ServiceAuthorizationManager" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceAuthorizationManager As ServiceAuthorizationManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ServiceAuthorizationManager ^ ServiceAuthorizationManager { System::ServiceModel::ServiceAuthorizationManager ^ get(); void set(System::ServiceModel::ServiceAuthorizationManager ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceAuthorizationManager : System.ServiceModel.ServiceAuthorizationManager with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.ServiceAuthorizationManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ServiceAuthorizationManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.ServiceModel.ServiceAuthorizationManager" />，它會提供授權檢查 <see cref="T:System.ServiceModel.Dispatcher.DispatchRuntime" />。</summary>
        <value>
          <see cref="T:System.ServiceModel.ServiceAuthorizationManager" />，它會提供授權檢查 <see cref="T:System.ServiceModel.Dispatcher.DispatchRuntime" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SingletonInstanceContext">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContext SingletonInstanceContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.InstanceContext SingletonInstanceContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.SingletonInstanceContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SingletonInstanceContext As InstanceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContext ^ SingletonInstanceContext { System::ServiceModel::InstanceContext ^ get(); void set(System::ServiceModel::InstanceContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SingletonInstanceContext : System.ServiceModel.InstanceContext with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.SingletonInstanceContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要由 <see cref="T:System.ServiceModel.Dispatcher.IInstanceContextProvider" /> 使用的單一 <see cref="T:System.ServiceModel.Dispatcher.DispatchRuntime" />。</summary>
        <value>要由 <see cref="T:System.ServiceModel.Dispatcher.IInstanceContextProvider" /> 使用的單一 <see cref="T:System.ServiceModel.Dispatcher.DispatchRuntime" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressAuditFailure">
      <MemberSignature Language="C#" Value="public bool SuppressAuditFailure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressAuditFailure" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.SuppressAuditFailure" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressAuditFailure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressAuditFailure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressAuditFailure : bool with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.SuppressAuditFailure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定是否隱藏在記錄程序期間發生的非嚴重例外狀況。</summary>
        <value>如果隱藏在記錄處理期間發生的非嚴重例外狀況，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果希望將在寫入稽核記錄檔期間發生的例外狀況重新擲回至應用程式，請將 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.SuppressAuditFailure%2A> 設定為 `false`。 在預設的情況中，只有因嘗試寫入稽核事件所造成的 <xref:System.OutOfMemoryException>、<xref:System.StackOverflowException>、<xref:System.Threading.ThreadAbortException> 和 <xref:System.ArgumentException> 例外狀況會被重新擲回至應用程式，所有的其他例外狀況都會被隱藏。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizationContext">
      <MemberSignature Language="C#" Value="public System.Threading.SynchronizationContext SynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.SynchronizationContext SynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.SynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizationContext As SynchronizationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::SynchronizationContext ^ SynchronizationContext { System::Threading::SynchronizationContext ^ get(); void set(System::Threading::SynchronizationContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizationContext : System.Threading.SynchronizationContext with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.SynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.SynchronizationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定用於叫用服務作業的同步化內容。</summary>
        <value>用於判斷服務作業是叫用哪一個執行緒的 <see cref="T:System.Threading.SynchronizationContext" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回值可以是 `null`。 如果這個值不是 `null`，這個同步化內容就會用於叫用正確執行緒上的服務作業。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool TransactionAutoCompleteOnSessionClose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionAutoCompleteOnSessionClose As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionAutoCompleteOnSessionClose { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionAutoCompleteOnSessionClose : bool with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.TransactionAutoCompleteOnSessionClose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會指定是否要在工作階段關閉時自動完成目前的交易。</summary>
        <value>如果交易會在工作階段關閉時自動完成，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為由 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> 指定的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.TransactionAutoCompleteOnSessionClose%2A> 為 `true`，而此時為作用中的交易，該交易就會在工作階段關閉時完成。 如果 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.TransactionAutoCompleteOnSessionClose%2A> 為 `false`，作用中的交易不會完成，而且最終會中止。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public Type Type { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type Type" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.Type" />
      <MemberSignature Language="VB.NET" Value="Public Property Type As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ Type { Type ^ get(); void set(Type ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Type : Type with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定合約類型。</summary>
        <value>合約的類型。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhandledDispatchOperation">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.DispatchOperation UnhandledDispatchOperation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.DispatchOperation UnhandledDispatchOperation" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.UnhandledDispatchOperation" />
      <MemberSignature Language="VB.NET" Value="Public Property UnhandledDispatchOperation As DispatchOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::DispatchOperation ^ UnhandledDispatchOperation { System::ServiceModel::Dispatcher::DispatchOperation ^ get(); void set(System::ServiceModel::Dispatcher::DispatchOperation ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UnhandledDispatchOperation : System.ServiceModel.Dispatcher.DispatchOperation with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.UnhandledDispatchOperation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.DispatchOperation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定被分派無法辨認之訊息的作業。</summary>
        <value>被分派無法辨認之訊息的 <see cref="T:System.ServiceModel.Dispatcher.DispatchOperation" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由 <xref:System.ServiceModel.Dispatcher.DispatchRuntime.UnhandledDispatchOperation%2A> 傳回的作業是在 <xref:System.ServiceModel.OperationContractAttribute.Action%2A> 屬性中使用 "*" (星號) 指出的作業。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.DispatchRuntime.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.Dispatcher.DispatchRuntime.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" /> 的值。</summary>
        <value>
          <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" /> 的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 判斷未預期的訊息標頭是否會造成錯誤狀況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>