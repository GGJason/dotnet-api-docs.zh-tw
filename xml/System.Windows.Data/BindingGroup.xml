<Type Name="BindingGroup" FullName="System.Windows.Data.BindingGroup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="781bdf7793811cdf3b962966131adbcaaf3a2fe0" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37522070" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BindingGroup : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingGroup extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingGroup" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingGroup&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingGroup : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type BindingGroup = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>內含用來驗證物件之繫結和 <see cref="T:System.Windows.Controls.ValidationRule" /> 物件的集合。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Data.BindingGroup>建立多個繫結，會進行驗證並同時更新之間的關聯性。 例如，假設應用程式會提示使用者輸入的位址。 接著，應用程式填入物件的型別`Address`，其中具有屬性， `Street`， `City`， `ZipCode`，和`Country`，使用者提供的值。 應用程式必須包含四個面板<xref:System.Windows.Controls.TextBox>控制項，每個都是資料繫結至其中一個物件的屬性。 您可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>驗證`Address`物件。 如果繫結參與相同<xref:System.Windows.Data.BindingGroup>，您可以確保 zip 程式碼是有效的地址的國家/地區。  
  
 您設定<xref:System.Windows.FrameworkElement.BindingGroup%2A>上的屬性<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>。 項目子系繼承<xref:System.Windows.Data.BindingGroup>從其父項目，就如同任何其他可繼承的屬性。 繫結的子系的項目新增至<xref:System.Windows.Data.BindingGroup>發生下列情況的其中一個：  
  
-   繫結的來源並<xref:System.Windows.FrameworkElement.DataContext%2A>具有項目的<xref:System.Windows.Data.BindingGroup>是相同的物件和<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>屬性未設定。  
  
-   <xref:System.Windows.Data.BindingBase.BindingGroupName%2A>繫結屬性等於<xref:System.Windows.Data.BindingGroup.Name%2A>的<xref:System.Windows.FrameworkContentElement.BindingGroup%2A>且未明確設定`null`。  
  
 在位址的範例中，假設<xref:System.Windows.FrameworkElement.DataContext%2A>的<xref:System.Windows.Controls.Panel>設定為型別的物件`Address`。 每個繫結<xref:System.Windows.Controls.TextBox>新增至<xref:System.Windows.Data.BindingGroup> 面板。  
  
 您將新增<xref:System.Windows.Controls.ValidationRule>物件至<xref:System.Windows.Data.BindingGroup>。 <xref:System.Windows.Data.BindingGroup>的第一個參數當做傳遞<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法時<xref:System.Windows.Controls.ValidationRule>執行。 您可以使用<xref:System.Windows.Data.BindingGroup.TryGetValue%2A>或<xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29>上的方法<xref:System.Windows.Data.BindingGroup>以取得建議的值的物件，而<xref:System.Windows.Data.BindingGroup.Items%2A>屬性取得繫結來源。  
  
 A<xref:System.Windows.Data.BindingGroup>更新在相同的時間，而不是個別更新每個繫結的繫結的來源。 當您呼叫其中一個方法來驗證資料 (<xref:System.Windows.Data.BindingGroup.ValidateWithoutUpdate%2A>， <xref:System.Windows.Data.BindingGroup.UpdateSources%2A>，或<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>)，每個繫結<xref:System.Windows.Controls.TextBox>在此範例會進行驗證，並可能進行更新。 繫結時的一部分<xref:System.Windows.Data.BindingGroup>，直到您呼叫不會更新繫結來源<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>或是<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>上<xref:System.Windows.Data.BindingGroup>，除非您明確設定<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>屬性。  
  
   
  
## Examples  
 下列範例會建立應用程式會提示使用者輸入的描述和價格項目和供應項目到期的日期。 應用程式會顯示在表單下方的項目目前的資訊。 使用者可以提交，或取消所做的變更。  
  
 應用程式會執行下列命令來達成此行為。  
  
-   會建立<xref:System.Windows.Data.BindingGroup>並將它加入根<xref:System.Windows.Controls.StackPanel>當它建立[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]應用程式。  
  
-   呼叫<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>， <xref:System.Windows.Data.BindingGroup.CommitEdit%2A>，和<xref:System.Windows.Data.BindingGroup.CancelEdit%2A>若要啟用的應用程式的邏輯中回復變更。  
  
-   呼叫<xref:System.Windows.Data.BindingGroup.TryGetValue%2A>在<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法來取得使用者的輸入，然後檢查 透過 100 元的項目可在至少 7 天。  
  
 下列範例會建立[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]應用程式。 根目錄<xref:System.Windows.Controls.StackPanel>已經<xref:System.Windows.Data.BindingGroup>包含<xref:System.Windows.Controls.ValidationRule>來驗證項目，如先前所述。 上的繫結物件`Price`屬性和`OfferExpires`屬性會變成一部分<xref:System.Windows.Data.BindingGroup>每個繫結，且<xref:System.Windows.Controls.ValidationRule>藉此確定價格和日期，分別是有效的值。 之前執行的個別屬性的驗證規則<xref:System.Windows.Controls.ValidationRule>上<xref:System.Windows.Data.BindingGroup>。  
  
 [!code-xaml[BindingGroupSnippets#WindowLayout](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#windowlayout)]  
  
 下列範例會示範應用程式的事件處理常式。 當使用者按一下 [提交] 按鈕時，應用程式會呼叫<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>逐一執行這<xref:System.Windows.Controls.ValidationRule>相關聯<xref:System.Windows.Data.BindingGroup>。 如果每個<xref:System.Windows.Controls.ValidationRule>成功，<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>將值儲存至物件，並結束編輯異動。 如果<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>會成功，應用程式開始另一個編輯異動。 當<xref:System.Windows.Controls.ValidationRule>失敗，請<xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>因為應用程式設定，就會發生事件<xref:System.Windows.Data.BindingGroup.NotifyOnValidationError%2A>要`true`上<xref:System.Windows.Data.BindingGroup>（在上述範例中）。 `ItemError` 控制代碼<xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>事件，並顯示給使用者的驗證錯誤的相關資訊。 此範例也會處理<xref:System.Windows.FrameworkElement.Loaded>事件<xref:System.Windows.Controls.StackPanel>並<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件**取消** 按鈕。  
  
 [!code-csharp[BindingGroupSnippets#WindowLogic](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#windowlogic)]
 [!code-vb[BindingGroupSnippets#WindowLogic](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#windowlogic)]  
  
 下列範例顯示的自訂<xref:System.Windows.Controls.ValidationRule> `ValidateDateAndPrice`，已加入<xref:System.Windows.Data.BindingGroup>中第一個範例。 <xref:System.Windows.Controls.ValidationRule>會使用<xref:System.Windows.Data.BindingGroup>在其<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法來取得使用者輸入表單，並檢查，如果項目超過 $100 元即可，它可在至少 7 天的值。  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingGroup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingGroup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Data.BindingGroup" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginEdit">
      <MemberSignature Language="C#" Value="public void BeginEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.BeginEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginEdit();" />
      <MemberSignature Language="F#" Value="member this.BeginEdit : unit -&gt; unit" Usage="bindingGroup.BeginEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開始對 <see cref="T:System.Windows.Data.BindingGroup" /> 中的來源，進行編輯異動。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果中的來源<xref:System.Windows.Data.BindingGroup>支援捨棄暫止的變更，您可以呼叫<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>若要開始編輯異動，請呼叫<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>若要儲存暫止的變更，請呼叫<xref:System.Windows.Data.BindingGroup.CancelEdit%2A>捨棄暫止的變更。  
  
 中每個物件<xref:System.Windows.Data.BindingGroup.Items%2A>可實<xref:System.ComponentModel.IEditableObject>，<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>呼叫 <xref:System.ComponentModel.IEditableObject.BeginEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>開始編輯異動的視窗載入時。  
  
 [!code-csharp[BindingGroupSnippets#BeginEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#beginedit)]
 [!code-vb[BindingGroupSnippets#BeginEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#beginedit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingExpressions">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt; BindingExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Data.BindingExpressionBase&gt; BindingExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.BindingExpressions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingExpressions As Collection(Of BindingExpressionBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ BindingExpressions { System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingExpressions : System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt;" Usage="System.Windows.Data.BindingGroup.BindingExpressions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Windows.Data.BindingExpression" /> 物件的集合，這類物件包含 <see cref="T:System.Windows.Data.BindingGroup" /> 中各個繫結的資訊。</summary>
        <value>
          <see cref="T:System.Windows.Data.BindingExpression" /> 物件的集合，這類物件包含 <see cref="T:System.Windows.Data.BindingGroup" /> 中各個繫結的資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Data.BindingExpression>屬於<xref:System.Windows.Data.BindingGroup>發生下列情況的其中一個：  
  
-   繫結的來源並<xref:System.Windows.FrameworkElement.DataContext%2A>具有項目的<xref:System.Windows.Data.BindingGroup>是相同的物件和<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>未設定。  
  
-   <xref:System.Windows.Data.BindingBase.BindingGroupName%2A>繫結屬性與<xref:System.Windows.Data.BindingGroup.Name%2A>的<xref:System.Windows.Data.BindingGroup>設定為相同的非 null 值和<xref:System.Windows.Data.BindingGroup>所屬的繫結目標項目的父項目。  
  
-   您將新增<xref:System.Windows.Data.BindingExpression>至<xref:System.Windows.Data.BindingGroup.BindingExpressions%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelEdit">
      <MemberSignature Language="C#" Value="public void CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.CancelEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelEdit();" />
      <MemberSignature Language="F#" Value="member this.CancelEdit : unit -&gt; unit" Usage="bindingGroup.CancelEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>結束編輯異動並捨棄暫止的變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會導致捨棄暫止的變更，如果能夠這樣做的來源物件，並結束編輯異動的來源。 然後此方法會更新目標屬性的已儲存的來源值。  
  
 中每個物件<xref:System.Windows.Data.BindingGroup.Items%2A>可實<xref:System.ComponentModel.IEditableObject>，<xref:System.Windows.Data.BindingGroup.CancelEdit%2A>呼叫 <xref:System.ComponentModel.IEditableObject.CancelEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Windows.Data.BindingGroup.CancelEdit%2A>捨棄暫止的變更，然後呼叫<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>準備要重新編輯的來源。  
  
 [!code-csharp[BindingGroupSnippets#CancelEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#canceledit)]
 [!code-vb[BindingGroupSnippets#CancelEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#canceledit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRestoreValues">
      <MemberSignature Language="C#" Value="public bool CanRestoreValues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRestoreValues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.CanRestoreValues" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRestoreValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRestoreValues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRestoreValues : bool" Usage="System.Windows.Data.BindingGroup.CanRestoreValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示繫結中的每一個來源是否可以捨棄暫止的變更並還原為原始值。</summary>
        <value>如果繫結中的每一個來源都可以捨棄暫止的變更並還原為原始值，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 來源可以捨棄暫止的變更，如果它會實作<xref:System.ComponentModel.IEditableObject>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommitEdit">
      <MemberSignature Language="C#" Value="public bool CommitEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CommitEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.CommitEdit" />
      <MemberSignature Language="VB.NET" Value="Public Function CommitEdit () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CommitEdit();" />
      <MemberSignature Language="F#" Value="member this.CommitEdit : unit -&gt; bool" Usage="bindingGroup.CommitEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果所有驗證規則都成功，這個方法會執行所有的 <see cref="T:System.Windows.Controls.ValidationRule" /> 物件，並更新繫結來源。</summary>
        <returns>如果每一個 <see cref="T:System.Windows.Controls.ValidationRule" /> 都成功，而且這些值都被認可到來源，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果每一個<xref:System.Windows.Controls.ValidationRule>成功，這個方法會導致認可暫止的變更並結束編輯異動，來源的來源物件是否能夠這樣做。  
  
 中每個物件<xref:System.Windows.Data.BindingGroup.Items%2A>可實<xref:System.ComponentModel.IEditableObject>，<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>呼叫 <xref:System.ComponentModel.IEditableObject.EndEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>來儲存暫止的變更，然後呼叫<xref:System.Windows.Data.BindingGroup.BeginEdit%2A>準備要重新編輯的來源。  
  
 [!code-csharp[BindingGroupSnippets#BeginEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#beginedit)]
 [!code-vb[BindingGroupSnippets#BeginEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#beginedit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (object item, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(object item, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.GetValue(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (item As Object, propertyName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Object ^ item, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="member this.GetValue : obj * string -&gt; obj" Usage="bindingGroup.GetValue (item, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">包含指定之屬性的物件。</param>
        <param name="propertyName">要取得其建議值的屬性。</param>
        <summary>傳回指定之屬性與項目的建議值。</summary>
        <returns>建議的屬性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法在<xref:System.Windows.Controls.ValidationRule.Validate%2A?displayProperty=nameWithType>方法來取得要認可至來源的值。 傳回值的類型取決於處的階段<xref:System.Windows.Controls.ValidationRule>，就會發生。 比方說，如果<xref:System.Windows.Controls.TextBox>資料繫結至整數類型的屬性和<xref:System.Windows.Controls.ValidationRule>呼叫<xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29>具有其<xref:System.Windows.Controls.ValidationRule.ValidationStep%2A>設定為<xref:System.Windows.Controls.ValidationStep.RawProposedValue>，方法會傳回字串。 如果<xref:System.Windows.Controls.ValidationRule>有其<xref:System.Windows.Controls.ValidationRule.ValidationStep%2A>設定為<xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue>，此方法會傳回繫結的轉換器會傳回任何類型。 在此範例中，<xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29>通常會傳回一個整數。  
  
   
  
## Examples  
 下列範例是會提示使用者輸入多個客戶，並將銷售人員指派給每位客戶的應用程式的一部分。 應用程式會檢查銷售人員和客戶屬於相同的區域。 此範例將示範<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法，它會使用<xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29>方法，以取得客戶輸入的值。  
  
 [!code-csharp[BindingGroupSnippets#ItemBindGroupValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#itembindgroupvalidationrule)]
 [!code-vb[BindingGroupSnippets#ItemBindGroupValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#itembindgroupvalidationrule)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定之項目和屬性沒有繫結。</exception>
        <exception cref="T:System.Windows.Data.ValueUnavailableException">無法取得指定之屬性的值，因為發生轉換錯誤，或先前的驗證規則失敗。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValidationError">
      <MemberSignature Language="C#" Value="public bool HasValidationError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.HasValidationError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidationError { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidationError : bool" Usage="System.Windows.Data.BindingGroup.HasValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see cref="T:System.Windows.Data.BindingGroup" /> 是否擁有失敗的驗證規則。</summary>
        <value>如果 <see cref="T:System.Windows.Data.BindingGroup" /> 有失敗的驗證規則，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirty : bool" Usage="System.Windows.Data.BindingGroup.IsDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出 <see cref="T:System.Windows.Data.BindingGroup" /> 是否含有尚未寫入至來源的建議值。</summary>
        <value>如果 <see cref="T:System.Windows.Data.BindingGroup" /> 含有尚未寫入至來源的建議值，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IList Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ Items { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IList" Usage="System.Windows.Data.BindingGroup.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Windows.Data.BindingGroup" /> 中之 Binding 物件所使用的來源。</summary>
        <value>
          <see cref="T:System.Windows.Data.BindingGroup" /> 中之 Binding 物件所使用的來源。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用來做為來源新增至每個物件<xref:System.Windows.Data.BindingGroup.Items%2A>屬性的一次，即使物件使用於多個繫結時做為來源。 通常是在只有一個項目<xref:System.Windows.Data.BindingGroup.Items%2A>，這是物件<xref:System.Windows.FrameworkElement.DataContext%2A>使用的項目<xref:System.Windows.Data.BindingGroup>。 可能會<xref:System.Windows.Data.BindingGroup>有多個來源，不過。 例如，如果繫結物件會共用相同<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>但使用不同的來源物件，當做來源使用的每個物件處於<xref:System.Windows.Data.BindingGroup.Items%2A>。  
  
 也可以在多個物件<xref:System.Windows.Data.BindingGroup.Items%2A>如果繫結的路徑會解析至巢狀屬性的來源。 例如，假設<xref:System.Windows.Controls.TextBox>控制項的繫結是一部分<xref:System.Windows.Data.BindingGroup>並將其<xref:System.Windows.FrameworkElement.DataContext%2A>是`Customer`物件，其中包含型別的屬性`Address`。 如果<xref:System.Windows.Data.Binding.Path%2A>的<xref:System.Windows.Data.Binding>是`Address.ZipCode`屬性，`Address`新增至<xref:System.Windows.Data.BindingGroup.Items%2A>屬性。  
  
   
  
## Examples  
 下列範例會是一部分的應用程式，會檢查使用者是否已設定為相同值的兩個物件的屬性。 第一個範例會建立兩個<xref:System.Windows.Controls.TextBox>控制項，其中每一個都是資料繫結至不同的來源。 第一個繫結<xref:System.Windows.Controls.TextBox>取得它的來源`object1`，從<xref:System.Windows.FrameworkElement.DataContext%2A>的<xref:System.Windows.Controls.TextBox>控制項的父項目 ( <xref:System.Windows.Controls.StackPanel>)。 第二個<xref:System.Windows.Controls.TextBox>，繫結來源設為`object2`。 此範例也會建立<xref:System.Windows.Controls.Label>顯示驗證錯誤。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 下列範例所示<xref:System.Windows.Controls.ValidationRule>，先前的範例使用。 在 <xref:System.Windows.Controls.ValidationRule.Validate%2A>方法，此範例會取得每個來源物件<xref:System.Windows.Data.BindingGroup>並檢查物件的屬性是否相等。  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Data.BindingGroup.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定名稱，這個名稱會識別用來包含和排除 <see cref="T:System.Windows.Data.BindingGroup" /> 中 Binding 物件的 <see cref="T:System.Windows.Data.BindingGroup" /> 。</summary>
        <value>可識別 <see cref="T:System.Windows.Data.BindingGroup" /> 的名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.Data.BindingGroup.Name%2A>已`null`，繫結具有的相同物件的來源<xref:System.Windows.FrameworkElement.DataContext%2A>具有項目的<xref:System.Windows.Data.BindingGroup>參與<xref:System.Windows.Data.BindingGroup>。  
  
 您可以包含具有不同來源的繫結<xref:System.Windows.FrameworkElement.DataContext%2A>具有父項目的<xref:System.Windows.Data.BindingGroup>藉由設定<xref:System.Windows.Data.BindingGroup.Name%2A>的<xref:System.Windows.Data.BindingGroup>而<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>屬性繫結至相同的值。 您可以排除具有相同的來源的繫結<xref:System.Windows.FrameworkElement.DataContext%2A>具有父項目的<xref:System.Windows.Data.BindingGroup>藉由設定<xref:System.Windows.Data.BindingGroup.Name%2A>的<xref:System.Windows.Data.BindingGroup>而<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>屬性繫結至不同的值。  
  
   
  
## Examples  
 下列範例會是一部分的應用程式，會檢查使用者是否已設定為相同值的兩個物件的屬性。 第一個範例會建立兩個<xref:System.Windows.Controls.TextBox>控制項，其中每一個都是資料繫結至不同的來源。 第一個繫結<xref:System.Windows.Controls.TextBox>屬於<xref:System.Windows.Data.BindingGroup>因為<xref:System.Windows.Controls.TextBox>繼承<xref:System.Windows.FrameworkElement.DataContext%2A>並<xref:System.Windows.Data.BindingGroup>從其父代<xref:System.Windows.Controls.StackPanel>。  
  
 第二個繫結<xref:System.Windows.Controls.TextBox>屬於<xref:System.Windows.Data.BindingGroup>因為<xref:System.Windows.Data.BindingGroup.Name%2A>的<xref:System.Windows.Data.BindingGroup>並<xref:System.Windows.Data.BindingBase.BindingGroupName%2A>的<xref:System.Windows.Data.Binding>都設定為`bindingGroup`。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 下列範例所示<xref:System.Windows.Controls.ValidationRule>，先前的範例使用。 在 <xref:System.Windows.Controls.ValidationRule.Validate%2A>方法，此範例會取得每個來源物件<xref:System.Windows.Data.BindingGroup>並檢查物件的屬性是否相等。  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnValidationError">
      <MemberSignature Language="C#" Value="public bool NotifyOnValidationError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.NotifyOnValidationError" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnValidationError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnValidationError : bool with get, set" Usage="System.Windows.Data.BindingGroup.NotifyOnValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會表示當 <see cref="E:System.Windows.Controls.Validation.Error" /> 的狀態變更時，是否會發生 <see cref="T:System.Windows.Controls.ValidationRule" /> 事件。</summary>
        <value>當 <see cref="E:System.Windows.Controls.Validation.Error" /> 的狀態變更時，如果發生 <see cref="T:System.Windows.Controls.ValidationRule" /> 事件，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>附加的事件發生在具有的項目上<xref:System.Windows.Data.BindingGroup>。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Windows.Data.BindingGroup>，並設定<xref:System.Windows.Data.BindingGroup.NotifyOnValidationError%2A>要`true`以便讓應用程式能夠處理<xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>事件時<xref:System.Windows.Controls.ValidationRule>失敗。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#bindinggroup)]  
  
 下列範例會處理<xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>事件。  
  
 [!code-csharp[BindingGroupSnippets#ErrorHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#errorhandler)]
 [!code-vb[BindingGroupSnippets#ErrorHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#errorhandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Owner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Owner As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Owner { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.DependencyObject" Usage="System.Windows.Data.BindingGroup.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得被指派這個 <see cref="T:System.Windows.Data.BindingGroup" /> 的物件。</summary>
        <value>被指派這個<see cref="T:System.Windows.Data.BindingGroup" /> 的物件。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SharesProposedValues">
      <MemberSignature Language="C#" Value="public bool SharesProposedValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SharesProposedValues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.SharesProposedValues" />
      <MemberSignature Language="VB.NET" Value="Public Property SharesProposedValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SharesProposedValues { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SharesProposedValues : bool with get, set" Usage="System.Windows.Data.BindingGroup.SharesProposedValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值指出 <see cref="T:System.Windows.Data.BindingGroup" /> 是否重複使用尚未認可至來源的目標值。</summary>
        <value>如果 <see cref="T:System.Windows.Data.BindingGroup" /> 重複使用尚未認可至來源的目標值則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建議的值是值已變更繫結的目標，但不是已認可到來源。 例如，假設在沒有雙向繫結<xref:System.Windows.Controls.TextBox>而<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>屬性設定為<xref:System.Windows.Data.UpdateSourceTrigger.Explicit>。 如果使用者變更的值<xref:System.Windows.Controls.TextBox>，建議的值是在值<xref:System.Windows.Controls.TextBox>認可至來源之前。  
  
 當<xref:System.Windows.Data.BindingGroup.SharesProposedValues%2A>是`true`，則<xref:System.Windows.Data.BindingGroup>當一個繫結離開 BindingGroup 並與相同來源的另一個繫結加入 BindingGroup 使用建議的值。  例如，假設應用程式可讓使用者編輯多個欄位，並按一下按鈕來更新的來源物件。 當欄位不正在編輯時，應用程式會顯示在<xref:System.Windows.Controls.TextBlock>。 當使用者開始編輯欄位時，將會取代應用程式<xref:System.Windows.Controls.TextBlock>與<xref:System.Windows.Controls.TextBox>。 當使用者完成編輯該欄位時，將會取代應用程式<xref:System.Windows.Controls.TextBox>與<xref:System.Windows.Controls.TextBlock>。 因為直到使用者按一下按鈕時，就不會更新來源，必須是讓<xref:System.Windows.Controls.TextBlock>來顯示建議的值。 藉由設定<xref:System.Windows.Data.BindingGroup.SharesProposedValues%2A>至`true`，應用程式就會顯示使用者的變更至欄位即使尚未更新來源。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (object item, string propertyName, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(object item, string propertyName, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.TryGetValue(System.Object,System.String,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (item As Object, propertyName As String, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(System::Object ^ item, System::String ^ propertyName, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : obj * string *  -&gt; bool" Usage="bindingGroup.TryGetValue (item, propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">包含指定之屬性的物件。</param>
        <param name="propertyName">要取得其建議值的屬性。</param>
        <param name="value">當這個方法傳回時，傳回值會包含代表建議之屬性值的物件。 這個參數會以未初始化的狀態傳遞。</param>
        <summary>嘗試取得指定之屬性與項目的建議值。</summary>
        <returns>如果這個值就是指定之屬性的建議值，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> 傳回`false`如果沒有指定的項目和屬性的繫結或指定的屬性值不是可用的因為發生轉換錯誤，或因為先前的驗證規則失敗。  
  
 使用這個方法在<xref:System.Windows.Controls.ValidationRule.Validate%2A?displayProperty=nameWithType>方法來取得要認可至來源的值。 型別`value`處的階段而定<xref:System.Windows.Controls.ValidationRule>，就會發生。 例如，如果<xref:System.Windows.Controls.TextBox>資料繫結至型別整數的屬性`value`是一個字串，如果<xref:System.Windows.Controls.ValidationRule>呼叫<xref:System.Windows.Data.BindingGroup.TryGetValue%2A>具有其<xref:System.Windows.Controls.ValidationRule.ValidationStep%2A>設為<xref:System.Windows.Controls.ValidationStep.RawProposedValue>。 如果<xref:System.Windows.Controls.ValidationRule>有其<xref:System.Windows.Controls.ValidationRule.ValidationStep%2A>設為<xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue>的型別`value`是由繫結的轉換器會傳回任何類型。 在此範例中，`value`通常是整數。  
  
   
  
## Examples  
 下列範例會建立自訂<xref:System.Windows.Controls.ValidationRule>名為`ValidateDateAndPrice`。 在 <xref:System.Windows.Controls.ValidationRule.Validate%2A>方法，此範例會使用<xref:System.Windows.Data.BindingGroup.TryGetValue%2A>方法和<xref:System.Windows.Data.BindingGroup.Items%2A>屬性來取得使用者在表單中輸入的值。 然後此範例會檢查，是否項目超過 $100 元即可，它可在至少 7 天。 這個範例屬於較大範例的上<xref:System.Windows.Data.BindingGroup>類別  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSources">
      <MemberSignature Language="C#" Value="public bool UpdateSources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool UpdateSources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.UpdateSources" />
      <MemberSignature Language="VB.NET" Value="Public Function UpdateSources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool UpdateSources();" />
      <MemberSignature Language="F#" Value="member this.UpdateSources : unit -&gt; bool" Usage="bindingGroup.UpdateSources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果所有驗證規則都成功，則會對此繫結和屬性 <see cref="T:System.Windows.Controls.ValidationRule" /> 設定為 <see cref="P:System.Windows.Controls.ValidationRule.ValidationStep" />、<see cref="F:System.Windows.Controls.ValidationStep.RawProposedValue" /> 或 <see cref="F:System.Windows.Controls.ValidationStep.ConvertedProposedValue" /> 的 <see cref="F:System.Windows.Controls.ValidationStep.UpdatedValue" /> 物件執行該轉換子，並將目標值儲存至來源物件。</summary>
        <returns>如果所有驗證規則成功，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會更新來源，如果每一個<xref:System.Windows.Controls.ValidationRule>成功，但它不會造成要認可暫止的變更並結束編輯異動的來源。 也就是說，如果來源物件實作<xref:System.ComponentModel.IEditableObject>。 呼叫這個方法不會造成<xref:System.ComponentModel.IEditableObject.EndEdit%2A>呼叫。 使用<xref:System.Windows.Data.BindingGroup.CommitEdit%2A>方法具有認可暫止的變更的來源。  
  
   
  
## Examples  
 下列範例是會提示使用者輸入多個客戶，並將銷售人員指派給每位客戶的應用程式的一部分。 應用程式會檢查銷售人員和客戶屬於相同的區域。 此範例會呼叫<xref:System.Windows.Data.BindingGroup.UpdateSources%2A>驗證繫結，並將值儲存至來源，如果所有驗證規則都成功。  
  
 [!code-csharp[BindingGroupSnippets#UpdateSources](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#updatesources)]
 [!code-vb[BindingGroupSnippets#UpdateSources](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#updatesources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnNotifyDataError">
      <MemberSignature Language="C#" Value="public bool ValidatesOnNotifyDataError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnNotifyDataError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnNotifyDataError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnNotifyDataError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnNotifyDataError : bool with get, set" Usage="System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否要包含 <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />。</summary>
        <value>
          <see langword="true" /> 表示包含 <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError%2A>已`true`，會檢查繫結，並報告由實作的資料來源所引發的錯誤<xref:System.ComponentModel.INotifyDataErrorInfo>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateWithoutUpdate">
      <MemberSignature Language="C#" Value="public bool ValidateWithoutUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValidateWithoutUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.ValidateWithoutUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function ValidateWithoutUpdate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValidateWithoutUpdate();" />
      <MemberSignature Language="F#" Value="member this.ValidateWithoutUpdate : unit -&gt; bool" Usage="bindingGroup.ValidateWithoutUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>對此繫結和屬性 <see cref="T:System.Windows.Controls.ValidationRule" /> 設定為 <see cref="P:System.Windows.Controls.ValidationRule.ValidationStep" /> 或 <see cref="F:System.Windows.Controls.ValidationStep.RawProposedValue" /> 的 <see cref="F:System.Windows.Controls.ValidationStep.ConvertedProposedValue" /> 物件執行轉換子。</summary>
        <returns>如果驗證規則成功，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您呼叫這個方法時，不會更新來源。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationErrors">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt; ValidationErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Controls.ValidationError&gt; ValidationErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidationErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationErrors As ReadOnlyCollection(Of ValidationError)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Controls::ValidationError ^&gt; ^ ValidationErrors { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Controls::ValidationError ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationErrors : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt;" Usage="System.Windows.Data.BindingGroup.ValidationErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得導致 <see cref="T:System.Windows.Controls.ValidationError" /> 無效之 <see cref="T:System.Windows.Data.BindingGroup" /> 物件的集合。</summary>
        <value>導致 <see cref="T:System.Windows.Controls.ValidationError" /> 無效之 <see cref="T:System.Windows.Data.BindingGroup" /> 物件的集合。  如果沒有錯誤，這個值為 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationRules">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt; ValidationRules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Controls.ValidationRule&gt; ValidationRules" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationRules As Collection(Of ValidationRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ ValidationRules { System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationRules : System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;" Usage="System.Windows.Data.BindingGroup.ValidationRules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Windows.Controls.ValidationRule" /> 物件的集合，這些物件會驗證 <see cref="T:System.Windows.Data.BindingGroup" /> 中的來源物件。</summary>
        <value>
          <see cref="T:System.Windows.Controls.ValidationRule" /> 物件的集合，這些物件會驗證 <see cref="T:System.Windows.Data.BindingGroup" /> 中的來源物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Controls.ValidationRule>新增至<xref:System.Windows.Data.BindingGroup>，則<xref:System.Windows.Data.BindingGroup>傳入做為第一個參數的<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法。 您可以使用，以取得物件的建議的值<xref:System.Windows.Data.BindingGroup.TryGetValue%2A>或<xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29>方法。 您可以取得物件所來自的繫結的來源<xref:System.Windows.Data.BindingGroup.Items%2A>屬性。  
  
   
  
## Examples  
 下列範例會將自訂<xref:System.Windows.Controls.ValidationRule>，`ValidateDateAndPrice`至<xref:System.Windows.Data.BindingGroup>。  
  
 [!code-xaml[BindingGroupSnippets#BindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#bindinggroup)]  
  
 下列範例顯示 `ValidateDateAndPrice` 類別。 <xref:System.Windows.Controls.ValidationRule.Validate%2A>方法會使用<xref:System.Windows.Data.BindingGroup>以取得使用者輸入表單，並檢查，如果項目超過 $100 元即可，它可在至少 7 天的值。  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>