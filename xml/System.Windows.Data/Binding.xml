<Type Name="Binding" FullName="System.Windows.Data.Binding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f23eed473fec0ff7b1c85691414edaf18650d562" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51878673" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Binding : System.Windows.Data.BindingBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Binding extends System.Windows.Data.BindingBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.Binding" />
  <TypeSignature Language="VB.NET" Value="Public Class Binding&#xA;Inherits BindingBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class Binding : System::Windows::Data::BindingBase" />
  <TypeSignature Language="F#" Value="type Binding = class&#xA;    inherit BindingBase" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Data.BindingBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供繫結定義的高層級存取，連接繫結目標物件的屬性 (通常為 WPF 元素) 和任何資料來源 (例如資料庫、XML 檔案或任何包含資料的物件)。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 資料繫結在資料的展示和互動上，提供應用程式簡單而一致的方式。 資料繫結可讓您同步處理兩個不同的物件屬性的值。  
  
 若要建立繫結，請使用<xref:System.Windows.Data.Binding>類別或其中一個繼承的類別<xref:System.Windows.Data.BindingBase>。 哪些物件不論您要繫結和您的資料來源的本質，每個繫結會遵循下圖所說明的模型。  
  
 ![基本資料繫結圖表](~/add/media/databindingmostbasic.png "基本資料繫結圖表")  
  
 該圖示範下列基本[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]資料繫結概念。  
  
-   每個繫結通常會有四個元件： 繫結目標物件、 目標屬性、 繫結來源，並有<xref:System.Windows.Data.Binding.Path%2A>中要使用的繫結來源的值。 比方說，如果您想要繫結的內容<xref:System.Windows.Controls.TextBox>若要將 Employee 物件的 Name 屬性，您的目標物件是<xref:System.Windows.Controls.TextBox>，目標屬性是<xref:System.Windows.Controls.TextBox.Text%2A>屬性，要使用的值是名稱，且來源物件的員工物件。  
  
-   目標屬性必須是相依性屬性。 這也表示您無法繫結欄位。 大部分屬性<xref:System.Windows.UIElement>物件相依性屬性，而且大部分的相依性屬性，唯讀的除了預設支援資料繫結。 (僅<xref:System.Windows.DependencyObject>類型可以定義相依性屬性以及所有<xref:System.Windows.UIElement>物件都衍生自<xref:System.Windows.DependencyObject>。)  
  
-   雖然圖中未指出，但應該注意的是，繫結來源物件不限於自訂的 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 物件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 資料繫結支援 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 物件和 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] 格式的資料。 若要提供一些範例，可能會繫結來源<xref:System.Windows.UIElement>，任何清單物件、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]相關聯的物件[!INCLUDE[TLA#tla_adonet](~/includes/tlasharptla-adonet-md.md)]資料或 Web 服務或 XmlNode，其中包含您[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]資料。  
  
 使用<xref:System.Windows.Data.Binding.Mode%2A>屬性，以指定資料流程的方向。 若要偵測來源變更單向或雙向繫結中，來源必須實作適合的屬性變更通知機制，例如<xref:System.ComponentModel.INotifyPropertyChanged>。 如需範例，請參閱[如何： 實作屬性變更通知](~/docs/framework/wpf/data/how-to-implement-property-change-notification.md)。 <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>屬性會指定來源更新的時機。 如需詳細資訊，請參閱 「 基本資料繫結概念 」 中[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
<a name="xamlAttributeUsage_PriorityBinding"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object property="{Binding  declaration}"/>  
```  
  
<a name="xamlValues_PriorityBinding"></a>   
## <a name="xaml-values"></a>XAML 值  
 *declaration*  
 零個或多個屬性指派子句，以逗號 （，） 分隔。 如需詳細資訊，請參閱 < [Binding 標記延伸模組](~/docs/framework/wpf/advanced/binding-markup-extension.md)或是[繫結宣告概觀](~/docs/framework/wpf/data/binding-declarations-overview.md)。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Data.MultiBinding" />
    <altmember cref="T:System.Windows.Data.PriorityBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Data.Binding" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Binding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Binding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Data.Binding" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Binding (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Binding(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Windows.Data.Binding : string -&gt; System.Windows.Data.Binding" Usage="new System.Windows.Data.Binding path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">初始 <see cref="P:System.Windows.Data.Binding.Path" /> 來繫結。</param>
        <summary>使用初始路徑，初始化 <see cref="T:System.Windows.Data.Binding" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSourceUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void AddSourceUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddSourceUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.AddSourceUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddSourceUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddSourceUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddSourceUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.AddSourceUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">接聽此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">要加入的處理常式。</param>
        <summary>加入 <see cref="E:System.Windows.Data.Binding.SourceUpdated" /> 附加事件的處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的事件的使用中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddTargetUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void AddTargetUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddTargetUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.AddTargetUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddTargetUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddTargetUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddTargetUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.AddTargetUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">接聽此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">要加入的處理常式。</param>
        <summary>加入 <see cref="E:System.Windows.Data.Binding.TargetUpdated" /> 附加事件的處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的事件的使用中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj with get, set" Usage="System.Windows.Data.Binding.AsyncState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定傳遞至非同步資料發送器的不透明資料。</summary>
        <value>傳遞至非同步資料發送器的資料。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Data.Binding.IsAsync" />
        <altmember cref="P:System.Windows.Data.ObjectDataProvider.IsAsynchronous" />
        <altmember cref="P:System.Windows.Data.XmlDataProvider.IsAsynchronous" />
      </Docs>
    </Member>
    <Member MemberName="BindsDirectlyToSource">
      <MemberSignature Language="C#" Value="public bool BindsDirectlyToSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsDirectlyToSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.BindsDirectlyToSource" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsDirectlyToSource As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsDirectlyToSource { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsDirectlyToSource : bool with get, set" Usage="System.Windows.Data.Binding.BindsDirectlyToSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否評估與資料項目或 <see cref="T:System.Windows.Data.DataSourceProvider" /> 物件相對的 <see cref="P:System.Windows.Data.Binding.Path" />。</summary>
        <value>
          <see langword="false" /> 表示評估與資料項目本身相對的路徑；否則為 <see langword="true" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 正常的行為 (當這個屬性是`false`) 包含特殊待遇的<xref:System.Windows.Data.DataSourceProvider>物件。 在此情況下，繫結引擎會評估<xref:System.Windows.Data.Binding.Path%2A>相對於取自物件<xref:System.Windows.Data.DataSourceProvider.Data%2A>屬性。 此外，繫結會接聽<xref:System.Windows.Data.DataSourceProvider.DataChanged>事件及據以回應。 將此屬性設定為`true`會覆寫這個行為，並提供繫結存取的屬性<xref:System.Windows.Data.DataSourceProvider>物件本身。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.ObjectDataProvider" />
        <altmember cref="T:System.Windows.Data.XmlDataProvider" />
      </Docs>
    </Member>
    <Member MemberName="Converter">
      <MemberSignature Language="C#" Value="public System.Windows.Data.IValueConverter Converter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.IValueConverter Converter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Converter" />
      <MemberSignature Language="VB.NET" Value="Public Property Converter As IValueConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::IValueConverter ^ Converter { System::Windows::Data::IValueConverter ^ get(); void set(System::Windows::Data::IValueConverter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Converter : System.Windows.Data.IValueConverter with get, set" Usage="System.Windows.Data.Binding.Converter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.IValueConverter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要使用的轉換子。</summary>
        <value>型別 <see cref="T:System.Windows.Data.IValueConverter" /> 的值。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 繫結會隱含地使用預設轉換子，會嘗試執行類型轉換的來源值與目標值之間。 如果無法進行轉換，預設轉換器會傳回 `null`。  
  
 如果您想要繫結相關聯的自訂值轉換器，您應該建立類別可實作<xref:System.Windows.Data.IValueConverter>介面，並提供實作<xref:System.Windows.Data.IValueConverter.Convert%2A>和<xref:System.Windows.Data.IValueConverter.ConvertBack%2A>方法。 值轉換器可以將資料從一種類型變更為另一個、 文化特性的詳細資訊，例如字元集之間進行轉換，或修改其呈現方式的其他層面。 一般轉換案例的範例，請參閱 「 資料轉換 」，在[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
<a name="xamlAttributeUsage_Converter"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Converter="myConverter"/>  
```  
  
<a name="xamlValues_Converter"></a>   
## <a name="xaml-values"></a>XAML 值  
 *myConverter*  
 資源參考至類別可實作<xref:System.Windows.Data.IValueConverter>介面，其中包含實作<xref:System.Windows.Data.IValueConverter.Convert%2A>和<xref:System.Windows.Data.IValueConverter.ConvertBack%2A>方法。 若要參考的值轉換器，使用[StaticResource 標記延伸](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConverterCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo ConverterCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo ConverterCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ConverterCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property ConverterCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ ConverterCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConverterCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Data.Binding.ConverterCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.CultureInfoIetfLanguageTagConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定文化特性，藉以評估轉換器。</summary>
        <value>預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未設定這個屬性，繫結引擎會使用`Language`繫結目標物件的屬性。 在 [[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]這預設為"EN-US"，或繼承自] 頁面上，根項目 （或任何項目） 的值，如果已明確設定。  
  
 資料轉換的相關資訊，請參閱中的資料轉換 」 一節[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConverterParameter">
      <MemberSignature Language="C#" Value="public object ConverterParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ConverterParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ConverterParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property ConverterParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ConverterParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConverterParameter : obj with get, set" Usage="System.Windows.Data.Binding.ConverterParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要傳遞至 <see cref="P:System.Windows.Data.Binding.Converter" /> 的參數。</summary>
        <value>要傳遞至 <see cref="P:System.Windows.Data.Binding.Converter" /> 的參數。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Windows.Data.Binding.ConverterParameter%2A>屬性來指定如何轉換物件。  這個屬性會將其他資訊傳遞至您在繫結使用的轉換器。  當您指定<xref:System.Windows.Data.Binding.ConverterParameter%2A>，值會傳遞至<xref:System.Windows.Data.IValueConverter.Convert%2A>並<xref:System.Windows.Data.IValueConverter.ConvertBack%2A>方法為`parameter`參數。  
  
 如需範例，請參閱[如何： 產生值清單中的繫結項目為基礎](~/docs/framework/wpf/data/how-to-produce-a-value-based-on-a-list-of-bound-items.md)。 該範例示範如何實作<xref:System.Windows.Data.IMultiValueConverter>但仍適用於使用方式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoNothing">
      <MemberSignature Language="C#" Value="public static readonly object DoNothing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object DoNothing" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.DoNothing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DoNothing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ DoNothing;" />
      <MemberSignature Language="F#" Value=" staticval mutable DoNothing : obj" Usage="System.Windows.Data.Binding.DoNothing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>作為傳回值，指示繫結引擎不要執行任何動作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 繫結來源屬性或轉換子可以傳回<xref:System.Windows.Data.Binding.DoNothing?displayProperty=nameWithType>指示繫結引擎不要執行任何動作。 例如，若要指示繫結引擎不要將值傳輸到繫結目標，不必移至下一個<xref:System.Windows.Data.Binding>中<xref:System.Windows.Data.PriorityBinding>，或不使用`FallBackValue`或預設值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementName">
      <MemberSignature Language="C#" Value="public string ElementName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ElementName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ElementName" />
      <MemberSignature Language="VB.NET" Value="Public Property ElementName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ElementName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ElementName : string with get, set" Usage="System.Windows.Data.Binding.ElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要作為繫結來源物件的項目名稱。</summary>
        <value>值<see langword="Name" />屬性或[X:name 指示詞](~/docs/framework/xaml-services/x-name-directive.md)感興趣的項目。 僅當程式碼中的項目透過 <see langword="RegisterName" /> 登錄為適當的 <see cref="T:System.Windows.NameScope" />，您才可以對其參考。 如需詳細資訊，請參閱 &lt; [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  
  
預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您想要繫結至您的應用程式中的另一個項目的屬性，此屬性相當實用。 比方說，如果您想要使用<xref:System.Windows.Controls.Slider>控制的應用程式中的另一個控制項的高度或如果您想要繫結<xref:System.Windows.Controls.ContentControl.Content%2A>的控制項<xref:System.Windows.Controls.Primitives.Selector.SelectedValue%2A>屬性您<xref:System.Windows.Controls.ListBox>控制項。  
  
 根據預設，繫結繼承所指定的資料內容`DataContext`如果已設定的屬性。 不過，<xref:System.Windows.Data.Binding.ElementName%2A>屬性是其中一種方式，您可以明確設定的來源<xref:System.Windows.Data.Binding>並覆寫繼承的資料內容。 如需詳細資訊，請參閱 <<c0> [ 如何： 指定繫結來源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。  
  
 <xref:System.Windows.Data.Binding.Source%2A>並<xref:System.Windows.Data.Binding.RelativeSource%2A>的屬性<xref:System.Windows.Data.Binding>類別也可讓您設定的繫結來源明確。 不過，只有三個屬性，其中<xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，和<xref:System.Windows.Data.Binding.RelativeSource%2A>、 應該設定為每個繫結，或可能會發生衝突。 如果繫結來源衝突，則這個屬性會擲回例外狀況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlNamespaceManager">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlNamespaceManager GetXmlNamespaceManager (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlNamespaceManager GetXmlNamespaceManager(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.GetXmlNamespaceManager(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetXmlNamespaceManager (target As DependencyObject) As XmlNamespaceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlNamespaceManager ^ GetXmlNamespaceManager(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetXmlNamespaceManager : System.Windows.DependencyObject -&gt; System.Xml.XmlNamespaceManager" Usage="System.Windows.Data.Binding.GetXmlNamespaceManager target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNamespaceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">要從中取得命名空間資訊的物件。</param>
        <summary>傳回附加至指定物件之繫結所使用的 [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] 命名空間管理員物件。</summary>
        <returns>所傳回的物件，用於檢視與所傳遞物件項目之繫結相關的 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] 命名空間。 這個物件應轉換為 <see cref="T:System.Xml.XmlNamespaceManager" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援的附加的屬性使用方式<xref:System.Windows.Data.Binding.XmlNamespaceManager%2A>附加屬性。  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] 命名空間管理員會繫結中的資料來源時，才適用[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]繫結來源 (<xref:System.Windows.Data.XmlDataProvider>物件)。  
  
 如果命名空間管理員未特別套用原始資料來源建立，或是藉由後續呼叫<xref:System.Windows.Data.Binding.SetXmlNamespaceManager%2A>繫結，則這個方法會傳回`null`。  
  
 這個方法一律會傳回`null`如果繫結背後的資料不是[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> 參數不可為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexerName">
      <MemberSignature Language="C#" Value="public const string IndexerName;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string IndexerName" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.IndexerName" />
      <MemberSignature Language="VB.NET" Value="Public Const IndexerName As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ IndexerName;" />
      <MemberSignature Language="F#" Value="val mutable IndexerName : string" Usage="System.Windows.Data.Binding.IndexerName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>做為 <see cref="P:System.ComponentModel.PropertyChangedEventArgs.PropertyName" /> 的 <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />，表示索引子屬性已變更。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool with get, set" Usage="System.Windows.Data.Binding.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出 <see cref="T:System.Windows.Data.Binding" /> 是否應該以非同步方式取得並設定值。</summary>
        <value>預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.Data.Binding.IsAsync%2A>屬性時`get`您繫結來源屬性的存取子可能需要很長的時間。 其中一個範例是使用的映像屬性`get`從網路下載的存取子。 設定<xref:System.Windows.Data.Binding.IsAsync%2A>要`true`可避免[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]時進行下載。  
  
 等候要送達的值，報告繫結<xref:System.Windows.Data.BindingBase.FallbackValue%2A>，如果有的話，或預設值繫結的目標屬性。  
  
 不過，不應該有許多的情況下，您需要使用<xref:System.Windows.Data.Binding.IsAsync%2A>屬性。 [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]指導方針，建議您不要定義速度較慢的欄位集合會比的屬性。 當您建立您的類別時，請考慮將處理的速度非常慢的作業之外`get`存取子，並快取的結果。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.AsyncState" />
        <altmember cref="P:System.Windows.Data.ObjectDataProvider.IsAsynchronous" />
        <altmember cref="P:System.Windows.Data.XmlDataProvider.IsAsynchronous" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="Mode">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingMode Mode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.BindingMode Mode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Mode" />
      <MemberSignature Language="VB.NET" Value="Public Property Mode As BindingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingMode Mode { System::Windows::Data::BindingMode get(); void set(System::Windows::Data::BindingMode value); };" />
      <MemberSignature Language="F#" Value="member this.Mode : System.Windows.Data.BindingMode with get, set" Usage="System.Windows.Data.Binding.Mode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示繫結中資料流程的方向。</summary>
        <value>其中一個 <see cref="T:System.Windows.Data.BindingMode" /> 值。 預設值為 <see cref="F:System.Windows.Data.BindingMode.Default" />，它會傳回目標相依性屬性的預設繫結模式值。 不過，每個相依性屬性的預設值都會不同。 一般而言，使用者可編輯的控制項屬性 (例如文字方塊和核取方塊的控制項屬性) 預設為雙向繫結，而其他大多數屬性則預設為單向繫結。  
  
判斷相依性屬性預設是否會單向或雙向繫結的程式設計方式是，使用 <see cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" /> 取得屬性的屬性中繼資料，然後檢查 <see cref="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" /> 屬性的布林值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要支援<xref:System.Windows.Data.BindingMode.OneWay>並<xref:System.Windows.Data.BindingMode.TwoWay>繫結，基礎資料必須實作<xref:System.ComponentModel.INotifyPropertyChanged>。 如需詳細資訊，請參閱 <<c0> [ 如何： 實作屬性變更通知](~/docs/framework/wpf/data/how-to-implement-property-change-notification.md)。  
  
 針對<xref:System.Windows.Data.BindingMode.TwoWay>或是<xref:System.Windows.Data.BindingMode.OneWayToSource>繫結，您可以設定來控制目標至來源更新<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>屬性。 如需詳細資訊，請參閱<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>。  
  
 如需有關不同的繫結模式的詳細資訊，請參閱[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnSourceUpdated">
      <MemberSignature Language="C#" Value="public bool NotifyOnSourceUpdated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnSourceUpdated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.NotifyOnSourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnSourceUpdated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnSourceUpdated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnSourceUpdated : bool with get, set" Usage="System.Windows.Data.Binding.NotifyOnSourceUpdated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當值從繫結目標轉送到繫結來源時，取得或設定指出是否引發 <see cref="E:System.Windows.Data.Binding.SourceUpdated" /> 事件的值。</summary>
        <value>如果更新繫結來源值時應該引發 <see cref="E:System.Windows.Data.Binding.SourceUpdated" /> 事件，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.BindingExpression.UpdateSource" />
      </Docs>
    </Member>
    <Member MemberName="NotifyOnTargetUpdated">
      <MemberSignature Language="C#" Value="public bool NotifyOnTargetUpdated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnTargetUpdated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.NotifyOnTargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnTargetUpdated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnTargetUpdated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnTargetUpdated : bool with get, set" Usage="System.Windows.Data.Binding.NotifyOnTargetUpdated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出將值從繫結來源轉送到繫結目標時，是否引發 <see cref="E:System.Windows.Data.Binding.TargetUpdated" /> 事件。</summary>
        <value>如果更新繫結目標值時會引發 <see cref="E:System.Windows.Data.Binding.TargetUpdated" /> 事件，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.BindingExpression.UpdateTarget" />
      </Docs>
    </Member>
    <Member MemberName="NotifyOnValidationError">
      <MemberSignature Language="C#" Value="public bool NotifyOnValidationError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.NotifyOnValidationError" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnValidationError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnValidationError : bool with get, set" Usage="System.Windows.Data.Binding.NotifyOnValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值指出是否要在繫結物件上引發 <see cref="E:System.Windows.Controls.Validation.Error" /> 附加事件。</summary>
        <value>
          <see langword="true" /> 如果<see cref="E:System.Windows.Controls.Validation.Error" />附加的事件應該在來源更新期間驗證錯誤時在繫結物件上引發，否則<see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果繫結具有<xref:System.Windows.Data.Binding.ValidationRules%2A>與它相關聯，則繫結引擎會檢查每個規則，每次將目標屬性值傳輸到 [來源] 屬性。 如果規則導致無效的值，就會建立繫結引擎<xref:System.Windows.Controls.ValidationError>物件，並將它加入至<xref:System.Windows.Controls.Validation>。<xref:System.Windows.Controls.Validation.Errors%2A> 繫結物件的集合。 當<xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType>屬性不是空的<xref:System.Windows.Controls.Validation.HasError%2A?displayProperty=nameWithType>之物件的附加的屬性設定為`true`。 如果<xref:System.Windows.Data.Binding.NotifyOnValidationError%2A>的屬性<xref:System.Windows.Data.Binding>設為`true`，然後繫結引擎會引發<xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>附加物件上的事件。  
  
 如需驗證程序的詳細討論，請參閱中的資料驗證一節[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyPath Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyPath Path" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyPath ^ Path { System::Windows::PropertyPath ^ get(); void set(System::Windows::PropertyPath ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : System.Windows.PropertyPath with get, set" Usage="System.Windows.Data.Binding.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定繫結來源屬性的路徑。</summary>
        <value>繫結來源的路徑。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個繫結通常會有四個元件： 繫結目標物件、 目標屬性、 繫結來源和在要使用的繫結來源值的路徑。 如需有關這些資料繫結概念的詳細資訊，請參閱 <<c0> [ 資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 使用<xref:System.Windows.Data.Binding.Path%2A>屬性來指定您想要繫結來源值：  
  
-   在最簡單的案例中，<xref:System.Windows.Data.Binding.Path%2A>屬性值是使用繫結，例如來源物件的屬性名稱`Path=PropertyName`。  
  
-   類似於 C# 中使用的語法可以指定子屬性的屬性。 例如，子句 `Path=ShoppingCart.Order` 會將繫結設定為物件或屬性 `ShoppingCart` 的子屬性 `Order`。  
  
-   若要繫結至附加屬性，請在附加屬性前後加上括號。 例如，若要繫結至附加屬性<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>，語法是`Path=(DockPanel.Dock)`。  
  
-   屬性的索引子可以在方括弧內指定，接在套用索引子的屬性名稱後面。 例如，子句 `Path=ShoppingCart[0]` 會將繫結設定為索引，而該索引對應於屬性之內部索引處理常值字串 "0" 的方式。 也支援多個索引子。  
  
-   `Path` 子句中可以混合使用索引子和子屬性；例如，`Path=ShoppingCart.ShippingInfo[MailingAddress,Street].`  
  
-   您可以在索引子內加入多個以逗號 (,) 分隔的索引子參數。 各個參數的型別可以使用括號指定。 例如，您可以加入 `Path="[(sys:Int32)42,(sys:Int32)24]"`，其中 `sys` 對應至 `System` 命名空間。  
  
-   當來源為集合檢視時，就可以使用斜線 (/) 指定目前的項目。 例如，子句 `Path=/` 會將繫結設定為檢視中目前的項目。 如果來源為集合，這個語法就會指定預設集合檢視目前的項目。  
  
-   屬性名稱和斜線可以組合用來周遊本身為集合的屬性。 例如，`Path=/Offices/ManagerName` 會指定來源集合目前的項目，其中包含同樣為集合的 `Offices` 屬性。 其目前項目為包含 `ManagerName` 屬性的物件。  
  
-   另外，可以使用句號 (.) 路徑來繫結至目前的來源。 例如，`Text="{Binding}"` 等於 `Text="{Binding Path=.}"`。  
  
 如需路徑語法的詳細資訊，請參閱 <<c0> [ 繫結宣告概觀](~/docs/framework/wpf/data/binding-declarations-overview.md)或是[PropertyPath XAML 語法](~/docs/framework/wpf/advanced/propertypath-xaml-syntax.md)。  
  
 針對[!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)]繫結，請參閱<xref:System.Windows.Data.Binding.XPath%2A>屬性。  
  
 若要繫結至整個物件，您不需要指定<xref:System.Windows.Data.Binding.Path%2A>屬性。 如需詳細資訊，請參閱 「 指定的路徑以值 」 中[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
   
  
## Examples  
 下列範例示範樣式觸發程序建立<xref:System.Windows.Controls.ToolTip>報告驗證錯誤訊息。 Setter 值繫結至目前的錯誤內容<xref:System.Windows.Controls.TextBox>(<xref:System.Windows.Controls.TextBox>使用樣式) 使用<xref:System.Windows.Data.Binding.RelativeSource%2A>屬性。 如需有關此範例的詳細資訊，請參閱[如何： 實作繫結驗證](~/docs/framework/wpf/data/how-to-implement-binding-validation.md)。  
  
 [!code-xaml[BindValidation#5](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RelativeSource">
      <MemberSignature Language="C#" Value="public System.Windows.Data.RelativeSource RelativeSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.RelativeSource RelativeSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.RelativeSource" />
      <MemberSignature Language="VB.NET" Value="Public Property RelativeSource As RelativeSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::RelativeSource ^ RelativeSource { System::Windows::Data::RelativeSource ^ get(); void set(System::Windows::Data::RelativeSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSource : System.Windows.Data.RelativeSource with get, set" Usage="System.Windows.Data.Binding.RelativeSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.RelativeSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>透過指定繫結來源對繫結目標的相對位置，取得或設定繫結來源。</summary>
        <value>
          <see cref="T:System.Windows.Data.RelativeSource" /> 物件，指定要使用的繫結來源相對位置。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性常用的物件的一個屬性繫結至相同的物件，另一個屬性，或在樣式或範本中定義繫結。  
  
 根據預設，繫結繼承所指定的資料內容`DataContext`如果已設定的屬性。 不過，<xref:System.Windows.Data.Binding.RelativeSource%2A>屬性是其中一種方式，您可以明確設定的來源<xref:System.Windows.Data.Binding>並覆寫繼承的資料內容。 如需詳細資訊，請參閱 <<c0> [ 如何： 指定繫結來源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。  
  
 <xref:System.Windows.Data.Binding.ElementName%2A?displayProperty=nameWithType>和<xref:System.Windows.Data.Binding.Source%2A?displayProperty=nameWithType>屬性也可讓您設定的繫結來源明確。 不過，只有三個屬性，其中<xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，和<xref:System.Windows.Data.Binding.RelativeSource%2A>、 應該設定為每個繫結，或可能會發生衝突。 如果繫結來源衝突，則這個屬性會擲回例外狀況。  
  
 針對[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]的詳細資訊，請參閱 < [RelativeSource 標記延伸](~/docs/framework/wpf/advanced/relativesource-markupextension.md)。  
    
## Examples  
 下列範例示範樣式觸發程序建立<xref:System.Windows.Controls.ToolTip>報告驗證錯誤訊息。 Setter 值繫結至目前的錯誤內容<xref:System.Windows.Controls.TextBox>(<xref:System.Windows.Controls.TextBox>使用樣式) 使用<xref:System.Windows.Data.Binding.RelativeSource%2A>屬性。 如需有關此範例的詳細資訊，請參閱[如何： 實作繫結驗證](~/docs/framework/wpf/data/how-to-implement-binding-validation.md)。  
  
 [!code-xaml[BindValidation#5](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml#5)]  
  
 若要查看完整的範例，請參閱[繫結驗證範例](https://go.microsoft.com/fwlink/?LinkID=159972)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.Source" />
      </Docs>
    </Member>
    <Member MemberName="RemoveSourceUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void RemoveSourceUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveSourceUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.RemoveSourceUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveSourceUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveSourceUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveSourceUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.RemoveSourceUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">接聽此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">要移除的處理常式。</param>
        <summary>移除 <see cref="E:System.Windows.Data.Binding.SourceUpdated" /> 附加事件的處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的事件的使用中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveTargetUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void RemoveTargetUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveTargetUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.RemoveTargetUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveTargetUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveTargetUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveTargetUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.RemoveTargetUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">接聽此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">要移除的處理常式。</param>
        <summary>移除 <see cref="E:System.Windows.Data.Binding.TargetUpdated" /> 附加事件的處理常式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的事件的使用中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetXmlNamespaceManager">
      <MemberSignature Language="C#" Value="public static void SetXmlNamespaceManager (System.Windows.DependencyObject target, System.Xml.XmlNamespaceManager value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetXmlNamespaceManager(class System.Windows.DependencyObject target, class System.Xml.XmlNamespaceManager value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.SetXmlNamespaceManager(System.Windows.DependencyObject,System.Xml.XmlNamespaceManager)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetXmlNamespaceManager (target As DependencyObject, value As XmlNamespaceManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetXmlNamespaceManager(System::Windows::DependencyObject ^ target, System::Xml::XmlNamespaceManager ^ value);" />
      <MemberSignature Language="F#" Value="static member SetXmlNamespaceManager : System.Windows.DependencyObject * System.Xml.XmlNamespaceManager -&gt; unit" Usage="System.Windows.Data.Binding.SetXmlNamespaceManager (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Xml.XmlNamespaceManager" />
      </Parameters>
      <Docs>
        <param name="target">要從中取得命名空間資訊的物件。</param>
        <param name="value">用於傳遞之項目中的命名空間評估的 <see cref="T:System.Xml.XmlNamespaceManager" />。</param>
        <summary>設定所提供項目附加的繫結所使用的命名空間管理員物件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援的附加的屬性使用方式<xref:System.Windows.Data.Binding.XmlNamespaceManager%2A>附加屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializePath">
      <MemberSignature Language="C#" Value="public bool ShouldSerializePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.ShouldSerializePath" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializePath () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializePath();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializePath : unit -&gt; bool" Usage="binding.ShouldSerializePath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示是否應該保存 <see cref="P:System.Windows.Data.Binding.Path" /> 屬性。</summary>
        <returns>如果屬性值已經從其預設值變更，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這`ShouldSerialize`提供方法，因為<xref:System.Windows.Data.Binding.Path%2A>屬性並沒有簡單的預設值。 這個方法會指出屬性是否已變更其預設值。 您通常叫用這個方法如果您正在開發的設計工具<xref:System.Windows.Data.Binding>或是開發您自己的控制項併入<xref:System.Windows.Data.Binding>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSource">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.ShouldSerializeSource" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeSource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeSource();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeSource : unit -&gt; bool" Usage="binding.ShouldSerializeSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示是否應該保存 <see cref="P:System.Windows.Data.Binding.Source" /> 屬性。</summary>
        <returns>如果屬性值已經從其預設值變更，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這`ShouldSerialize`提供方法，因為<xref:System.Windows.Data.Binding.Source%2A>屬性並沒有簡單的預設值。 這個方法會指出屬性是否已變更其預設值。 您通常叫用這個方法如果您正在開發的設計工具<xref:System.Windows.Data.Binding>或是開發您自己的控制項併入<xref:System.Windows.Data.Binding>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeValidationRules">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeValidationRules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeValidationRules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.ShouldSerializeValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeValidationRules () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeValidationRules();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeValidationRules : unit -&gt; bool" Usage="binding.ShouldSerializeValidationRules " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指示是否應該保存 <see cref="P:System.Windows.Data.Binding.ValidationRules" /> 屬性。</summary>
        <returns>如果屬性值已經從其預設值變更，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這`ShouldSerialize`提供方法，因為<xref:System.Windows.Data.Binding.ValidationRules%2A>屬性並沒有簡單的預設值。 這個方法會指出屬性是否已變更其預設值。 您通常叫用這個方法如果您正在開發的設計工具<xref:System.Windows.Data.Binding>或是開發您自己的控制項併入<xref:System.Windows.Data.Binding>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.Data.Binding.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要作為繫結來源的物件。</summary>
        <value>要作為繫結來源的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，繫結繼承所指定的資料內容`DataContext`如果已設定的屬性。 不過，<xref:System.Windows.Data.Binding.Source%2A>屬性是其中一種方式，您可以明確設定的來源<xref:System.Windows.Data.Binding>並覆寫繼承的資料內容。 如果您不需要的功能建立的範圍中的數個屬性都繼承相同的資料內容，您可以使用<xref:System.Windows.Data.Binding.Source%2A>屬性而非`DataContext`屬性。  
  
 <xref:System.Windows.Data.Binding.ElementName%2A?displayProperty=nameWithType>和<xref:System.Windows.Data.Binding.RelativeSource%2A?displayProperty=nameWithType>屬性也可讓您設定的繫結來源明確。 不過，只有三個屬性，其中<xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，和<xref:System.Windows.Data.Binding.RelativeSource%2A>、 應該設定為每個繫結，或可能會發生衝突。 如果繫結來源衝突，則這個屬性會擲回例外狀況。  
  
 若要清除此屬性，將它設定為<xref:System.Windows.DependencyProperty.UnsetValue?displayProperty=nameWithType>。  
  
<a name="xamlAttributeUsage_Source"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Source="object"/>  
```  
  
<a name="xamlValues_Source"></a>   
## <a name="xaml-values"></a>XAML 值  
 *object*  
 現有的物件。 若要參考現有的物件，使用[StaticResource 標記延伸](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)  
  
   
  
## Examples  
 下列範例會使用`Person`物件具有名為字串屬性`PersonName`中所定義`SDKSample`命名空間，第一個反白顯示的列所示。 在反白顯示列，其中包含`<src>`項目，它會具現化`Person`物件`PersonName`屬性值為`Joe`。 這在完成`Resources`區段，然後指派`x:Key`。  
  
 [!code-xaml[BindingInstantiation](~/samples/snippets/csharp/VS_Snippets_Wpf/SimpleBinding/CSharp/Page1.xaml?highlight=4,9,37)]  
  
 反白顯示包含的那一行`<TextBlock>`項目示範如何將繫結至`PersonName`屬性。 如此一來，<xref:System.Windows.Controls.TextBlock>控制項是顯示為"Joe"的值。  
  
 在下列範例中，<xref:System.Windows.Data.Binding.Source%2A>的值<xref:System.Windows.Data.Binding>物件都會設為`static`屬性<xref:System.Windows.Application.Current%2A?displayProperty=nameWithType>:  
  
 [!code-xaml[DataBindingLab#ComboBoxMultiBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/DataBindingLab/CSharp/AddProductWindow.xaml#comboboxmultibinding)]  
  
 如需完整範例，請參閱 <<c0> [ 資料繫結示範](https://go.microsoft.com/fwlink/?LinkID=163703)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberSignature Language="ILAsm" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.Binding.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberSignature Language="F#" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" Usage="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>當某個值從繫結目標傳輸至繫結來源，但只在繫結已設定為 <see langword="true" /> 的 <see cref="P:System.Windows.Data.Binding.NotifyOnSourceUpdated" /> 值時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_SourceUpdatedEvent"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Data.Binding.SourceUpdatedEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.EventHandler%601>受限於<xref:System.Windows.Data.DataTransferEventArgs>。|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.BindingExpression.UpdateSource" />
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="SourceUpdatedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SourceUpdatedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SourceUpdatedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.SourceUpdatedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SourceUpdatedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SourceUpdatedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SourceUpdatedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Data.Binding.SourceUpdatedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.Data.Binding.SourceUpdated" /> 附加事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberSignature Language="ILAsm" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.Binding.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberSignature Language="F#" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" Usage="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>發生於值從繫結來源傳送至繫結目標時，但僅針對 <see cref="P:System.Windows.Data.Binding.NotifyOnTargetUpdated" /> 值設為 <see langword="true" /> 的繫結。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TargetUpdatedEvent"></a>   
## <a name="routed-event-information"></a>路由事件資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Data.Binding.TargetUpdatedEvent>|  
|路由策略|事件反昇|  
|Delegate - 委派|<xref:System.EventHandler%601>受限於<xref:System.Windows.Data.DataTransferEventArgs>。|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.BindingExpression.UpdateTarget" />
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TargetUpdatedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TargetUpdatedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TargetUpdatedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.TargetUpdatedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetUpdatedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TargetUpdatedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetUpdatedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Data.Binding.TargetUpdatedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="E:System.Windows.Data.Binding.TargetUpdated" /> 附加事件。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSourceExceptionFilter">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.UpdateSourceExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateSourceExceptionFilter As UpdateSourceExceptionFilterCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceExceptionFilterCallback ^ UpdateSourceExceptionFilter { System::Windows::Data::UpdateSourceExceptionFilterCallback ^ get(); void set(System::Windows::Data::UpdateSourceExceptionFilterCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateSourceExceptionFilter : System.Windows.Data.UpdateSourceExceptionFilterCallback with get, set" Usage="System.Windows.Data.Binding.UpdateSourceExceptionFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceExceptionFilterCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定可用來提供自訂邏輯的處理常式，以處理繫結引擎在更新繫結來源值期間所遇到的例外狀況。 只有您已建立 <see cref="T:System.Windows.Controls.ExceptionValidationRule" /> 與繫結的關聯時才適用。</summary>
        <value>提供自訂邏輯以處理繫結引擎在更新繫結來源值期間所遇到之例外狀況的方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ExceptionValidationRule>是內建驗證規則會檢查繫結來源屬性更新期間擲回例外狀況。 如果您已建立關聯<xref:System.Windows.Controls.ExceptionValidationRule>與您<xref:System.Windows.Data.Binding>物件，您可以使用這個屬性設定來提供自訂邏輯來處理這些例外狀況處理常式。 如果<xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A>中未指定<xref:System.Windows.Data.Binding>，則繫結引擎會建立<xref:System.Windows.Controls.ValidationError>發生例外狀況並將它加入<xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType>繫結元素的集合。  
  
   
  
## Examples  
 <xref:System.Windows.Controls.TextBox.Text%2A>屬性的下列<xref:System.Windows.Controls.TextBox>是資料繫結來源屬性`Age3`型別的`int`。 <xref:System.Windows.Controls.ExceptionValidationRule>檢查 （例如，當使用者輸入的值無法轉換成整數） 的來源屬性更新期間所擲回的例外狀況。  
  
 [!code-xaml[BindValidation#tbExceptionFilter](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml#tbexceptionfilter)]  
  
 您可以提供自訂邏輯以處理這些例外狀況。 下列範例示範如何使用<xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A>屬性來設定<xref:System.Windows.Data.UpdateSourceExceptionFilterCallback>。  
  
 [!code-csharp[BindValidation#filtercallback](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml.cs#filtercallback)]  
  
 以下是範例實作<xref:System.Windows.Data.UpdateSourceExceptionFilterCallback>。  
  
 [!code-csharp[BindValidation#Handler](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml.cs#handler)]  
  
 <xref:System.Windows.Data.UpdateSourceExceptionFilterCallback>也可以傳回`null`，例外狀況本身，或<xref:System.Windows.Controls.ValidationError>。 如需詳細資訊，請參閱<xref:System.Windows.Data.UpdateSourceExceptionFilterCallback>。  
  
 如需完整的範例，請參閱[繫結驗證範例](https://go.microsoft.com/fwlink/?LinkID=159972)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger UpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger UpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.UpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger UpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.Data.Binding.UpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值會判斷繫結來源更新的時機。</summary>
        <value>其中一個 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 值。 預設為 <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />，它會傳回目標相依性屬性的預設 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 值。 不過，大多數相依性屬性的預設值為 <see cref="F:System.Windows.Data.UpdateSourceTrigger.PropertyChanged" />，而 <see cref="P:System.Windows.Controls.TextBox.Text" /> 屬性具有 <see cref="F:System.Windows.Data.UpdateSourceTrigger.LostFocus" /> 的預設值。  
  
一種判斷相依性屬性之預設 <see cref="P:System.Windows.Data.Binding.UpdateSourceTrigger" /> 值的程式設計方式是使用 <see cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" /> 取得屬性的屬性中繼資料，然後再檢查 <see cref="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" /> 屬性的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 繫結<xref:System.Windows.Data.BindingMode.TwoWay>或<xref:System.Windows.Data.BindingMode.OneWayToSource>接聽目標屬性中的變更，並將它們傳播回來源。 這種情況稱為更新來源。 通常，每當目標屬性變更時，就會發生這些更新。 這是正常核取方塊和其他簡單控制項，但它通常不是適用於文字欄位。 之後每個按鍵動作可能會降低效能，並拒絕使用者的一般機會按退格鍵和修正輸入錯誤的新值之後才更新。 因此，預設值<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>的值<xref:System.Windows.Controls.TextBox.Text%2A>屬性是<xref:System.Windows.Data.UpdateSourceTrigger.LostFocus>而非<xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>。  
  
 如果您設定<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>值加入<xref:System.Windows.Data.UpdateSourceTrigger.Explicit>，您必須呼叫<xref:System.Windows.Data.BindingExpression.UpdateSource%2A>方法或所做的變更將不會傳播回來源。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.Mode" />
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnDataErrors">
      <MemberSignature Language="C#" Value="public bool ValidatesOnDataErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnDataErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidatesOnDataErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnDataErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnDataErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnDataErrors : bool with get, set" Usage="System.Windows.Data.Binding.ValidatesOnDataErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否要包含 <see cref="T:System.Windows.Controls.DataErrorValidationRule" />。</summary>
        <value>
          <see langword="true" /> 表示包含 <see cref="T:System.Windows.Controls.DataErrorValidationRule" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性提供替代使用<xref:System.Windows.Controls.DataErrorValidationRule>項目明確。 <xref:System.Windows.Controls.DataErrorValidationRule>是內建驗證規則會檢查所引發的錯誤<xref:System.ComponentModel.IDataErrorInfo>來源物件的實作。 如果會引發錯誤，就會建立繫結引擎<xref:System.Windows.Controls.ValidationError>發生錯誤並將它加入<xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType>繫結元素的集合。 錯誤缺乏會清除這個驗證回應，除非另一個規則就會發出驗證問題。  
  
 <xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱 [.NET Framework 版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下列範例會使用<xref:System.ComponentModel.IDataErrorInfo>並<xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A>來驗證使用者輸入在<xref:System.Windows.Controls.TextBox>。 第一個範例會建立資料型別可實作<xref:System.ComponentModel.IDataErrorInfo>報告驗證錯誤。  
  
 [!code-csharp[BindingValidationAttributesSnippets#IDataErrorInfoData](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/data.cs#idataerrorinfodata)]
 [!code-vb[BindingValidationAttributesSnippets#IDataErrorInfoData](~/samples/snippets/visualbasic/VS_Snippets_Wpf/bindingvalidationattributessnippets/visualbasic/window1.xaml.vb#idataerrorinfodata)]  
  
 下列範例會繫結`Age`屬性，以<xref:System.Windows.Controls.TextBox>並設定<xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A>要`true`上<xref:System.Windows.Data.Binding>。  當使用者輸入無效的值時，在出現的紅色框線<xref:System.Windows.Controls.TextBox>而<xref:System.Windows.Controls.ToolTip>報告的錯誤訊息。  
  
 [!code-xaml[BindingValidationAttributesSnippets#IDataErrorInfoXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/window1.xaml#idataerrorinfoxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.ValidatesOnExceptions" />
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnExceptions">
      <MemberSignature Language="C#" Value="public bool ValidatesOnExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidatesOnExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnExceptions : bool with get, set" Usage="System.Windows.Data.Binding.ValidatesOnExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否要包含 <see cref="T:System.Windows.Controls.ExceptionValidationRule" />。</summary>
        <value>
          <see langword="true" /> 表示包含 <see cref="T:System.Windows.Controls.ExceptionValidationRule" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性提供替代使用<xref:System.Windows.Controls.ExceptionValidationRule>項目明確。 <xref:System.Windows.Controls.ExceptionValidationRule>是內建驗證規則會檢查來源屬性更新期間所擲回的例外狀況。 如果擲回例外狀況，就會建立繫結引擎<xref:System.Windows.Controls.ValidationError>與例外狀況並將它加入<xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType>繫結元素的集合。 錯誤缺乏會清除這個驗證回應，除非另一個規則就會發出驗證問題。  
  
 <xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱 [.NET Framework 版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A>來驗證使用者輸入在<xref:System.Windows.Controls.TextBox>。 第一個範例會建立資料型別會擲回例外狀況時`Age`屬性設定為無效的屬性。  
  
 [!code-csharp[BindingValidationAttributesSnippets#ThrowExceptionData](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/data.cs#throwexceptiondata)]
 [!code-vb[BindingValidationAttributesSnippets#ThrowExceptionData](~/samples/snippets/visualbasic/VS_Snippets_Wpf/bindingvalidationattributessnippets/visualbasic/window1.xaml.vb#throwexceptiondata)]  
  
 下列範例會繫結`Age`屬性，以<xref:System.Windows.Controls.TextBox>並設定<xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A>要`true`上<xref:System.Windows.Data.Binding>。 當使用者輸入無效的值時，在出現的紅色框線<xref:System.Windows.Controls.TextBox>而<xref:System.Windows.Controls.ToolTip>報告的錯誤訊息。  
  
 [!code-xaml[BindingValidationAttributesSnippets#ThrowExceptionXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/window1.xaml#throwexceptionxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.ValidatesOnDataErrors" />
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnNotifyDataErrors">
      <MemberSignature Language="C#" Value="public bool ValidatesOnNotifyDataErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnNotifyDataErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidatesOnNotifyDataErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnNotifyDataErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnNotifyDataErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnNotifyDataErrors : bool with get, set" Usage="System.Windows.Data.Binding.ValidatesOnNotifyDataErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示是否要包含 <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />。</summary>
        <value>
          <see langword="true" /> 表示包含 <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />，否則為 <see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Data.Binding.ValidatesOnNotifyDataErrors%2A>已`true`，會檢查繫結，並報告由實作的資料來源所引發的錯誤<xref:System.ComponentModel.INotifyDataErrorInfo>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationRules">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt; ValidationRules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Controls.ValidationRule&gt; ValidationRules" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationRules As Collection(Of ValidationRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ ValidationRules { System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationRules : System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;" Usage="System.Windows.Data.Binding.ValidationRules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得檢查使用者輸入有效性的規則集合。</summary>
        <value>
          <see cref="T:System.Windows.Controls.ValidationRule" /> 物件的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]資料繫結模型可讓您將建立關聯<xref:System.Windows.Data.Binding.ValidationRules%2A>與您<xref:System.Windows.Data.Binding>或<xref:System.Windows.Data.MultiBinding>物件。 您可以建立自訂規則，藉由衍生自<xref:System.Windows.Controls.ValidationRule>類別，並實作<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法，或者您可以使用內建<xref:System.Windows.Controls.ExceptionValidationRule>，這會使失效值，如果在來源更新期間有例外狀況。  
  
 繫結引擎會檢查每個<xref:System.Windows.Controls.ValidationRule>每次輸入的值 （繫結目標屬性值） 會傳送到繫結來源屬性的繫結相關聯。 如需驗證程序的詳細討論，請參閱中的資料驗證一節[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
> [!NOTE]
>  此屬性可以在設定[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]只能使用集合語法所示，或藉由存取的集合物件，使用的各種方法，例如`Add`。 要存取的集合物件的屬性是唯讀，而該集合本身是讀寫。  
  
<a name="xamlPropertyElementUsage_ValidationRules"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.ValidationRules>  
    oneOrMoreValidationRules  
  </object.ValidationRules>  
</object>  
  
```  
  
<a name="xamlValues_ValidationRules"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreValidationRules*  
 一或多個<xref:System.Windows.Controls.ValidationRule>物件。 您可以使用<xref:System.Windows.Controls.ExceptionValidationRule>類別或子類別化來建立自訂規則<xref:System.Windows.Controls.ValidationRule>類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Validation" />
      </Docs>
    </Member>
    <Member MemberName="XmlNamespaceManager">
      <MemberSignature Language="C#" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberSignature Language="ILAsm" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.XmlNamespaceManager" />
      <MemberSignature Language="VB.NET" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberSignature Language="F#" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" Usage="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Xml.XmlNamespaceManager" />，用於在 XML 繫結中執行命名空間感知 <see langword="XPath" /> 查詢。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個附加的屬性會使用屬性值繼承會重現已存在於的命名空間繼承行為[!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)]。 如需詳細資訊，請參閱[屬性值繼承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
<a name="dependencyPropertyInfo_XmlNamespaceManager"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Data.Binding.XmlNamespaceManagerProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlNamespaceManagerProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty XmlNamespaceManagerProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty XmlNamespaceManagerProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.XmlNamespaceManagerProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly XmlNamespaceManagerProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ XmlNamespaceManagerProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable XmlNamespaceManagerProperty : System.Windows.DependencyProperty" Usage="System.Windows.Data.Binding.XmlNamespaceManagerProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Data.Binding.XmlNamespaceManager" /> 附加屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="XPath">
      <MemberSignature Language="C#" Value="public string XPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.XPath" />
      <MemberSignature Language="VB.NET" Value="Public Property XPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ XPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XPath : string with get, set" Usage="System.Windows.Data.Binding.XPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see langword="XPath" /> 查詢，以傳回 [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] 繫結來源上要使用的值。</summary>
        <value>
          <see langword="XPath" /> 查詢。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當繫結來源時[!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)]資料，而非[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]物件，<xref:System.Windows.Data.Binding.XPath%2A>而不是使用屬性<xref:System.Windows.Data.Binding.Path%2A>屬性，表示要使用的繫結來源值的路徑。  
  
 藉由設定<xref:System.Windows.Data.Binding.XPath%2A>屬性，您會建立`XPath`查詢，以選取的節點的集合 (<xref:System.Xml.XmlElement?displayProperty=nameWithType>並<xref:System.Xml.XmlAttribute?displayProperty=nameWithType>都是衍生自<xref:System.Xml.XmlNode?displayProperty=nameWithType>)。 <xref:System.Xml.XmlNode?displayProperty=nameWithType> 已[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]物件，這表示您可以使用其屬性的繫結<xref:System.Windows.Data.Binding.Path%2A>屬性。  
  
 <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType>方法會處理`XPath`中的運算式<xref:System.Windows.Data.Binding.XPath%2A>屬性。 `XPath` 不支援函式。 針對`XPath`運算式的詳細資訊，請參閱<xref:System.Xml.XmlNode.SelectNodes%2A>文件和範例 > 一節中提供一些範例。  
  
 LINQ to XML 物件<xref:System.Xml.Linq.XDocument>並<xref:System.Xml.Linq.XElement>請勿使用`XPath`。 如需詳細資訊，請參閱 <<c0> [ 如何： 繫結至 XDocument、 XElement 或 LINQ 的 XML 查詢結果](~/docs/framework/wpf/data/how-to-bind-to-xdocument-xelement-or-linq-for-xml-query-results.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>