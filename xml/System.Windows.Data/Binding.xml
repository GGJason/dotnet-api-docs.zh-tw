<Type Name="Binding" FullName="System.Windows.Data.Binding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a39f70f0d554de6fd2dea4e198fa15f050241385" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36365350" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Binding : System.Windows.Data.BindingBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Binding extends System.Windows.Data.BindingBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.Binding" />
  <TypeSignature Language="VB.NET" Value="Public Class Binding&#xA;Inherits BindingBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class Binding : System::Windows::Data::BindingBase" />
  <TypeSignature Language="F#" Value="type Binding = class&#xA;    inherit BindingBase" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Data.BindingBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides high-level access to the definition of a binding, which connects the properties of binding target objects (typically, WPF elements), and any data source (for example, a database, an XML file, or any object that contains data).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 資料繫結在資料的展示和互動上，提供應用程式簡單而一致的方式。 資料繫結可讓您同步處理兩個不同物件的屬性值。  
  
 若要建立的繫結，使用<xref:System.Windows.Data.Binding>類別或其中一個繼承的類別<xref:System.Windows.Data.BindingBase>。 不論什麼物件繫結，您的資料來源的本質，每個繫結會遵循模型，如下圖所示。  
  
 ![基本資料繫結圖表](~/add/media/databindingmostbasic.png "基本資料繫結圖表")  
  
 此圖中會示範下列基本[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]資料繫結的概念。  
  
-   每個繫結通常會有四個元件： 繫結目標物件、 目標屬性、 繫結來源和<xref:System.Windows.Data.Binding.Path%2A>中要使用的繫結來源值。 例如，如果您想要繫結的內容<xref:System.Windows.Controls.TextBox>Employee 物件的 Name 屬性，您的目標物件是<xref:System.Windows.Controls.TextBox>，目標屬性是<xref:System.Windows.Controls.TextBox.Text%2A>屬性，要使用的值是名稱，而來源物件是員工物件。  
  
-   目標屬性必須是相依性屬性。 這也表示您無法繫結欄位。 大部分屬性<xref:System.Windows.UIElement>物件是相依性屬性，大多數相依性屬性，唯讀的除了預設支援資料繫結。 (只有<xref:System.Windows.DependencyObject>類型可以定義相依性屬性以及所有<xref:System.Windows.UIElement>物件衍生自<xref:System.Windows.DependencyObject>。)  
  
-   雖然圖中未指出，但應該注意的是，繫結來源物件不限於自訂的 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 物件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 資料繫結支援 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] 物件和 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] 格式的資料。 若要提供一些範例，可能是繫結來源<xref:System.Windows.UIElement>，任何清單物件，[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]與其相關聯物件[!INCLUDE[TLA#tla_adonet](~/includes/tlasharptla-adonet-md.md)]資料、 Web 服務或 XmlNode，其中包含您[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]資料。  
  
 使用<xref:System.Windows.Data.Binding.Mode%2A>屬性，以指定資料流程的方向。 若要偵測來源變更單向或雙向繫結中，來源必須實作適當的屬性變更通知機制例如<xref:System.ComponentModel.INotifyPropertyChanged>。 如需範例，請參閱[How to： 實作屬性變更告知](~/docs/framework/wpf/data/how-to-implement-property-change-notification.md)。 <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>屬性會指定來源更新的時機。 如需詳細資訊，請參閱 < 基本資料繫結概念 > 中[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
<a name="xamlAttributeUsage_PriorityBinding"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object property="{Binding  declaration}"/>  
```  
  
<a name="xamlValues_PriorityBinding"></a>   
## <a name="xaml-values"></a>XAML 值  
 *declaration*  
 以逗號 （，） 分隔的零或多個屬性指派子句。 如需詳細資訊，請參閱[繫結標記延伸](~/docs/framework/wpf/advanced/binding-markup-extension.md)或[繫結宣告概觀](~/docs/framework/wpf/data/binding-declarations-overview.md)。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Data.MultiBinding" />
    <altmember cref="T:System.Windows.Data.PriorityBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Data.Binding" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Binding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Binding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Data.Binding" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Binding (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Binding(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Windows.Data.Binding : string -&gt; System.Windows.Data.Binding" Usage="new System.Windows.Data.Binding path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The initial <see cref="P:System.Windows.Data.Binding.Path" /> for the binding.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Data.Binding" /> class with an initial path.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSourceUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void AddSourceUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddSourceUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.AddSourceUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddSourceUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddSourceUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddSourceUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.AddSourceUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to the event.</param>
        <param name="handler">The handler to add.</param>
        <summary>Adds a handler for the <see cref="E:System.Windows.Data.Binding.SourceUpdated" /> attached event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的事件的使用中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddTargetUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void AddTargetUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddTargetUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.AddTargetUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddTargetUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddTargetUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddTargetUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.AddTargetUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to the event.</param>
        <param name="handler">The handler to add.</param>
        <summary>Adds a handler for the <see cref="E:System.Windows.Data.Binding.TargetUpdated" /> attached event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的事件的使用中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj with get, set" Usage="System.Windows.Data.Binding.AsyncState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets opaque data passed to the asynchronous data dispatcher.</summary>
        <value>資料傳遞至非同步資料發送器。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Data.Binding.IsAsync" />
        <altmember cref="P:System.Windows.Data.ObjectDataProvider.IsAsynchronous" />
        <altmember cref="P:System.Windows.Data.XmlDataProvider.IsAsynchronous" />
      </Docs>
    </Member>
    <Member MemberName="BindsDirectlyToSource">
      <MemberSignature Language="C#" Value="public bool BindsDirectlyToSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsDirectlyToSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.BindsDirectlyToSource" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsDirectlyToSource As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsDirectlyToSource { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsDirectlyToSource : bool with get, set" Usage="System.Windows.Data.Binding.BindsDirectlyToSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to evaluate the <see cref="P:System.Windows.Data.Binding.Path" /> relative to the data item or the <see cref="T:System.Windows.Data.DataSourceProvider" /> object.</summary>
        <value>
          <see langword="false" /> 表示評估與資料項目本身相對的路徑；否則為 <see langword="true" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 正常行為 (當這個屬性是`false`) 包含特殊處理方式<xref:System.Windows.Data.DataSourceProvider>物件。 在此情況下，繫結引擎會評估<xref:System.Windows.Data.Binding.Path%2A>相對於物件取自<xref:System.Windows.Data.DataSourceProvider.Data%2A>屬性。 此外，繫結會接聽<xref:System.Windows.Data.DataSourceProvider.DataChanged>事件並據以回應。 此屬性設定為`true`會覆寫此行為，並提供繫結存取屬性<xref:System.Windows.Data.DataSourceProvider>物件本身。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.ObjectDataProvider" />
        <altmember cref="T:System.Windows.Data.XmlDataProvider" />
      </Docs>
    </Member>
    <Member MemberName="Converter">
      <MemberSignature Language="C#" Value="public System.Windows.Data.IValueConverter Converter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.IValueConverter Converter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Converter" />
      <MemberSignature Language="VB.NET" Value="Public Property Converter As IValueConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::IValueConverter ^ Converter { System::Windows::Data::IValueConverter ^ get(); void set(System::Windows::Data::IValueConverter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Converter : System.Windows.Data.IValueConverter with get, set" Usage="System.Windows.Data.Binding.Converter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.IValueConverter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the converter to use.</summary>
        <value>型別 <see cref="T:System.Windows.Data.IValueConverter" /> 的值。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 繫結，會隱含地使用嘗試執行類型轉換的來源值與目標值之間的預設轉換子。 如果無法進行轉換，預設轉換器會傳回 `null`。  
  
 如果您想要與繫結產生關聯的自訂值轉換器，您應該建立一個類別，實作<xref:System.Windows.Data.IValueConverter>介面，並提供實作<xref:System.Windows.Data.IValueConverter.Convert%2A>和<xref:System.Windows.Data.IValueConverter.ConvertBack%2A>方法。 值轉換器可以將資料從一個類型變更為另一個、 翻譯文化特性的詳細資料，例如字元集，或修改其簡報的其他層面。 一般轉換案例的範例，請參閱 「 資料轉換 」，在[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
<a name="xamlAttributeUsage_Converter"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Converter="myConverter"/>  
```  
  
<a name="xamlValues_Converter"></a>   
## <a name="xaml-values"></a>XAML 值  
 *myConverter*  
 實作的類別資源參考<xref:System.Windows.Data.IValueConverter>介面，其中包含實作<xref:System.Windows.Data.IValueConverter.Convert%2A>和<xref:System.Windows.Data.IValueConverter.ConvertBack%2A>方法。 若要參考的值轉換器，請使用[StaticResource 標記延伸](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConverterCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo ConverterCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo ConverterCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ConverterCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property ConverterCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ ConverterCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConverterCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Data.Binding.ConverterCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.CultureInfoIetfLanguageTagConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the culture in which to evaluate the converter.</summary>
        <value>預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未設定這個屬性，就會使用繫結引擎`Language`繫結目標物件的屬性。 在[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]這預設為"EN-US"或繼承自 頁面上，根項目 （或任何項目） 的值，如果其中一個已明確設定。  
  
 資料轉換的相關資訊，請參閱中的資料轉換 」 一節[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConverterParameter">
      <MemberSignature Language="C#" Value="public object ConverterParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ConverterParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ConverterParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property ConverterParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ConverterParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConverterParameter : obj with get, set" Usage="System.Windows.Data.Binding.ConverterParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the parameter to pass to the <see cref="P:System.Windows.Data.Binding.Converter" />.</summary>
        <value>要傳遞給參數<see cref="P:System.Windows.Data.Binding.Converter" />。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Windows.Data.Binding.ConverterParameter%2A>屬性來指定物件轉換的方式。  這個屬性會將其他資訊傳遞至您的繫結使用的轉換器。  當您指定<xref:System.Windows.Data.Binding.ConverterParameter%2A>，值會傳遞至<xref:System.Windows.Data.IValueConverter.Convert%2A>和<xref:System.Windows.Data.IValueConverter.ConvertBack%2A>方法`parameter`參數。  
  
 如需範例，請參閱[如何： 產生清單的繫結項目值以](~/docs/framework/wpf/data/how-to-produce-a-value-based-on-a-list-of-bound-items.md)。 該範例會示範實作<xref:System.Windows.Data.IMultiValueConverter>但仍適用於使用方式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoNothing">
      <MemberSignature Language="C#" Value="public static readonly object DoNothing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object DoNothing" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.DoNothing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DoNothing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ DoNothing;" />
      <MemberSignature Language="F#" Value=" staticval mutable DoNothing : obj" Usage="System.Windows.Data.Binding.DoNothing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Used as a returned value to instruct the binding engine not to perform any action.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 繫結來源屬性或轉換子可以傳回<xref:System.Windows.Data.Binding.DoNothing?displayProperty=nameWithType>，指示繫結引擎不要執行任何動作。 例如，若要指示繫結引擎不要傳輸繫結目標時，不將移至下一個值<xref:System.Windows.Data.Binding>中<xref:System.Windows.Data.PriorityBinding>，或不使用`FallBackValue`或預設值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementName">
      <MemberSignature Language="C#" Value="public string ElementName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ElementName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ElementName" />
      <MemberSignature Language="VB.NET" Value="Public Property ElementName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ElementName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ElementName : string with get, set" Usage="System.Windows.Data.Binding.ElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the element to use as the binding source object.</summary>
        <value>值<see langword="Name" />屬性或 [X:name Directive](~/docs/framework/xaml-services/x-name-directive.md) 感興趣的項目。 僅當程式碼中的項目透過 <see langword="RegisterName" /> 登錄為適當的 <see cref="T:System.Windows.NameScope" />，您才可以對其參考。 如需詳細資訊，請參閱 [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)。  預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您想要繫結至應用程式中的另一個項目的屬性，這個屬性是很有用。 例如，如果您想要使用<xref:System.Windows.Controls.Slider>來控制應用程式中的另一個控制項的高度或如果您想要繫結<xref:System.Windows.Controls.ContentControl.Content%2A>至控制項的<xref:System.Windows.Controls.Primitives.Selector.SelectedValue%2A>屬性您<xref:System.Windows.Controls.ListBox>控制項。  
  
 根據預設，繫結繼承所指定的資料內容`DataContext`如果其中一個已設定的屬性。 不過，<xref:System.Windows.Data.Binding.ElementName%2A>屬性是一種方式，您可以明確設定的來源<xref:System.Windows.Data.Binding>並覆寫繼承的資料內容。 如需詳細資訊，請參閱[How to： 指定的繫結來源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。  
  
 <xref:System.Windows.Data.Binding.Source%2A>和<xref:System.Windows.Data.Binding.RelativeSource%2A>屬性<xref:System.Windows.Data.Binding>類別也可讓您設定的繫結來源明確。 不過，只有三個屬性，其中<xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，和<xref:System.Windows.Data.Binding.RelativeSource%2A>、 應該設定為每個繫結，或可能會發生衝突。 如果繫結來源衝突，則這個屬性會擲回例外狀況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlNamespaceManager">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlNamespaceManager GetXmlNamespaceManager (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlNamespaceManager GetXmlNamespaceManager(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.GetXmlNamespaceManager(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetXmlNamespaceManager (target As DependencyObject) As XmlNamespaceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlNamespaceManager ^ GetXmlNamespaceManager(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetXmlNamespaceManager : System.Windows.DependencyObject -&gt; System.Xml.XmlNamespaceManager" Usage="System.Windows.Data.Binding.GetXmlNamespaceManager target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNamespaceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">The object from which to get namespace information.</param>
        <summary>Returns an [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] namespace manager object used by the binding attached to the specified object.</summary>
        <returns>A returned object used for viewing [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] namespaces that relate to the binding on the passed object element. This object should be cast as <see cref="T:System.Xml.XmlNamespaceManager" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的屬性的使用方式的<xref:System.Windows.Data.Binding.XmlNamespaceManager%2A>附加屬性。  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] 命名空間管理員才有意義的資料繫結中來自[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]繫結來源 (<xref:System.Windows.Data.XmlDataProvider>物件)。  
  
 如果命名空間管理員沒有特別套用在原始資料來源建立或由後續呼叫<xref:System.Windows.Data.Binding.SetXmlNamespaceManager%2A>的繫結，則這個方法將傳回`null`。  
  
 這個方法一律會傳回`null`如果繫結背後的資料不是[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="target" /> parameter cannot be <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexerName">
      <MemberSignature Language="C#" Value="public const string IndexerName;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string IndexerName" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.IndexerName" />
      <MemberSignature Language="VB.NET" Value="Public Const IndexerName As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ IndexerName;" />
      <MemberSignature Language="F#" Value="val mutable IndexerName : string" Usage="System.Windows.Data.Binding.IndexerName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Used as the <see cref="P:System.ComponentModel.PropertyChangedEventArgs.PropertyName" /> of <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> to indicate that an indexer property has changed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool with get, set" Usage="System.Windows.Data.Binding.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the <see cref="T:System.Windows.Data.Binding" /> should get and set values asynchronously.</summary>
        <value>預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Windows.Data.Binding.IsAsync%2A>屬性時`get`存取子，您的繫結來源屬性可能需要很長的時間。 其中一個範例是以影像屬性`get`從網路下載的存取子。 設定<xref:System.Windows.Data.Binding.IsAsync%2A>至`true`可避免[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]下載進行時。  
  
 繫結會等待到達的值，報告<xref:System.Windows.Data.BindingBase.FallbackValue%2A>，如果有的話，或預設值繫結的目標屬性。  
  
 不過，不應該有許多案例中您需要使用<xref:System.Windows.Data.Binding.IsAsync%2A>屬性。 [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]指導方針，建議您不要定義速度較慢比欄位集的屬性。 當您建立您的類別時，請考慮將處理的速度非常慢作業之外的`get`存取子和快取結果。 如需詳細資訊，請參閱[NIB： 選擇之間指定屬性和方法](http://msdn.microsoft.com/library/55825e8f-7e2e-448a-9505-7217cc91b1af)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.AsyncState" />
        <altmember cref="P:System.Windows.Data.ObjectDataProvider.IsAsynchronous" />
        <altmember cref="P:System.Windows.Data.XmlDataProvider.IsAsynchronous" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="Mode">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingMode Mode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.BindingMode Mode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Mode" />
      <MemberSignature Language="VB.NET" Value="Public Property Mode As BindingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingMode Mode { System::Windows::Data::BindingMode get(); void set(System::Windows::Data::BindingMode value); };" />
      <MemberSignature Language="F#" Value="member this.Mode : System.Windows.Data.BindingMode with get, set" Usage="System.Windows.Data.Binding.Mode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates the direction of the data flow in the binding.</summary>
        <value>其中一個 <see cref="T:System.Windows.Data.BindingMode" /> 值。 預設值是<see cref="F:System.Windows.Data.BindingMode.Default" />，它會傳回目標相依性屬性的預設繫結模式值。 不過，每個相依性屬性的預設值都會不同。 一般而言，使用者可編輯的控制項屬性 (例如文字方塊和核取方塊的控制項屬性) 預設為雙向繫結，而其他大多數屬性則預設為單向繫結。  判斷相依性屬性預設是否會單向或雙向繫結的程式設計方式是，使用 <see cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" /> 取得屬性的屬性中繼資料，然後檢查 <see cref="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" /> 屬性的布林值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要支援<xref:System.Windows.Data.BindingMode.OneWay>和<xref:System.Windows.Data.BindingMode.TwoWay>基礎資料繫結必須實作<xref:System.ComponentModel.INotifyPropertyChanged>。 如需詳細資訊，請參閱[How to： 實作屬性變更告知](~/docs/framework/wpf/data/how-to-implement-property-change-notification.md)。  
  
 如<xref:System.Windows.Data.BindingMode.TwoWay>或<xref:System.Windows.Data.BindingMode.OneWayToSource>繫結，您可以設定來控制目標到來源更新<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>屬性。 如需詳細資訊，請參閱<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>。  
  
 如需有關不同的繫結模式的詳細資訊，請參閱[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnSourceUpdated">
      <MemberSignature Language="C#" Value="public bool NotifyOnSourceUpdated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnSourceUpdated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.NotifyOnSourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnSourceUpdated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnSourceUpdated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnSourceUpdated : bool with get, set" Usage="System.Windows.Data.Binding.NotifyOnSourceUpdated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to raise the <see cref="E:System.Windows.Data.Binding.SourceUpdated" /> event when a value is transferred from the binding target to the binding source.</summary>
        <value>
          <see langword="true" /> 如果<see cref="E:System.Windows.Data.Binding.SourceUpdated" />更新，否則繫結來源值時，應該引發事件<see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.BindingExpression.UpdateSource" />
      </Docs>
    </Member>
    <Member MemberName="NotifyOnTargetUpdated">
      <MemberSignature Language="C#" Value="public bool NotifyOnTargetUpdated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnTargetUpdated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.NotifyOnTargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnTargetUpdated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnTargetUpdated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnTargetUpdated : bool with get, set" Usage="System.Windows.Data.Binding.NotifyOnTargetUpdated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to raise the <see cref="E:System.Windows.Data.Binding.TargetUpdated" /> event when a value is transferred from the binding source to the binding target.</summary>
        <value>
          <see langword="true" /> 如果<see cref="E:System.Windows.Data.Binding.TargetUpdated" />更新，否則繫結目標值時，應該引發事件<see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.BindingExpression.UpdateTarget" />
      </Docs>
    </Member>
    <Member MemberName="NotifyOnValidationError">
      <MemberSignature Language="C#" Value="public bool NotifyOnValidationError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.NotifyOnValidationError" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnValidationError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnValidationError : bool with get, set" Usage="System.Windows.Data.Binding.NotifyOnValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to raise the <see cref="E:System.Windows.Controls.Validation.Error" /> attached event on the bound object.</summary>
        <value>
          <see langword="true" /> 如果<see cref="E:System.Windows.Controls.Validation.Error" />附加的事件應該在來源更新期間驗證錯誤時在繫結物件上引發，否則<see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果繫結具有<xref:System.Windows.Data.Binding.ValidationRules%2A>與它相關聯，繫結引擎會檢查每個規則，每次傳輸來源屬性的目標屬性值。 如果規則導致無效的值，就會建立繫結引擎<xref:System.Windows.Controls.ValidationError>物件，並將它加入至<xref:System.Windows.Controls.Validation>。<xref:System.Windows.Controls.Validation.Errors%2A> 繫結物件的集合。 當<xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType>屬性不是空的<xref:System.Windows.Controls.Validation.HasError%2A?displayProperty=nameWithType>附加的屬性的物件設定為`true`。 如果<xref:System.Windows.Data.Binding.NotifyOnValidationError%2A>屬性<xref:System.Windows.Data.Binding>設`true`，然後繫結引擎引發<xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType>附加物件上的事件。  
  
 驗證程序的詳細討論，請參閱中的資料驗證一節[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyPath Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyPath Path" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyPath ^ Path { System::Windows::PropertyPath ^ get(); void set(System::Windows::PropertyPath ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : System.Windows.PropertyPath with get, set" Usage="System.Windows.Data.Binding.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the path to the binding source property.</summary>
        <value>繫結來源的路徑。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個繫結通常會有四個元件： 繫結目標物件、 目標屬性、 繫結來源、 和中要使用的繫結來源值的路徑。 如需有關這些資料繫結概念的詳細資訊，請參閱[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
 使用<xref:System.Windows.Data.Binding.Path%2A>屬性來指定您想要繫結來源值：  
  
-   在最簡單的情況下，<xref:System.Windows.Data.Binding.Path%2A>屬性值是使用繫結，例如來源物件的屬性名稱`Path=PropertyName`。  
  
-   子屬性的屬性可以指定類似在 C# 中使用的語法。 例如，子句 `Path=ShoppingCart.Order` 會將繫結設定為物件或屬性 `ShoppingCart` 的子屬性 `Order`。  
  
-   若要繫結至附加屬性，請在附加屬性前後加上括號。 例如，若要附加的屬性繫結<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>，語法是`Path=(DockPanel.Dock)`。  
  
-   屬性的索引子可以在方括弧內指定，接在套用索引子的屬性名稱後面。 例如，子句 `Path=ShoppingCart[0]` 會將繫結設定為索引，而該索引對應於屬性之內部索引處理常值字串 "0" 的方式。 也支援多個索引子。  
  
-   `Path` 子句中可以混合使用索引子和子屬性；例如，`Path=ShoppingCart.ShippingInfo[MailingAddress,Street].`  
  
-   您可以在索引子內加入多個以逗號 (,) 分隔的索引子參數。 各個參數的型別可以使用括號指定。 例如，您可以加入 `Path="[(sys:Int32)42,(sys:Int32)24]"`，其中 `sys` 對應至 `System` 命名空間。  
  
-   當來源為集合檢視時，就可以使用斜線 (/) 指定目前的項目。 例如，子句 `Path=/` 會將繫結設定為檢視中目前的項目。 如果來源為集合，這個語法就會指定預設集合檢視目前的項目。  
  
-   屬性名稱和斜線可以組合用來周遊本身為集合的屬性。 例如，`Path=/Offices/ManagerName` 會指定來源集合目前的項目，其中包含同樣為集合的 `Offices` 屬性。 其目前項目為包含 `ManagerName` 屬性的物件。  
  
-   另外，可以使用句號 (.) 路徑來繫結至目前的來源。 例如，`Text="{Binding}"` 等於 `Text="{Binding Path=.}"`。  
  
 路徑語法的詳細資訊，請參閱[繫結宣告概觀](~/docs/framework/wpf/data/binding-declarations-overview.md)或[PropertyPath XAML 語法](~/docs/framework/wpf/advanced/propertypath-xaml-syntax.md)。  
  
 如[!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)]繫結，請參閱<xref:System.Windows.Data.Binding.XPath%2A>屬性。  
  
 若要繫結至整個物件時，您不需要指定<xref:System.Windows.Data.Binding.Path%2A>屬性。 如需詳細資訊，請參閱 「 指定的路徑以值"中[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
   
  
## Examples  
 下列範例示範建立樣式觸發程序<xref:System.Windows.Controls.ToolTip>，報告驗證錯誤訊息。 Setter 的值會繫結至目前的錯誤內容<xref:System.Windows.Controls.TextBox>(<xref:System.Windows.Controls.TextBox>使用樣式) 使用<xref:System.Windows.Data.Binding.RelativeSource%2A>屬性。 如需有關此範例的詳細資訊，請參閱[How to： 實作繫結驗證](~/docs/framework/wpf/data/how-to-implement-binding-validation.md)。  
  
 [!code-xaml[BindValidation#5](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RelativeSource">
      <MemberSignature Language="C#" Value="public System.Windows.Data.RelativeSource RelativeSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.RelativeSource RelativeSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.RelativeSource" />
      <MemberSignature Language="VB.NET" Value="Public Property RelativeSource As RelativeSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::RelativeSource ^ RelativeSource { System::Windows::Data::RelativeSource ^ get(); void set(System::Windows::Data::RelativeSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSource : System.Windows.Data.RelativeSource with get, set" Usage="System.Windows.Data.Binding.RelativeSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.RelativeSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the binding source by specifying its location relative to the position of the binding target.</summary>
        <value>A<see cref="T:System.Windows.Data.RelativeSource" />物件，指定要使用的繫結來源相對位置。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性常用物件的一個屬性繫結至相同的物件，另一個屬性，或在樣式或範本中定義的繫結。  
  
 根據預設，繫結繼承所指定的資料內容`DataContext`如果其中一個已設定的屬性。 不過，<xref:System.Windows.Data.Binding.RelativeSource%2A>屬性是一種方式，您可以明確設定的來源<xref:System.Windows.Data.Binding>並覆寫繼承的資料內容。 如需詳細資訊，請參閱[How to： 指定的繫結來源](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)。  
  
 <xref:System.Windows.Data.Binding.ElementName%2A?displayProperty=nameWithType>和<xref:System.Windows.Data.Binding.Source%2A?displayProperty=nameWithType>屬性也可讓您設定的繫結來源明確。 不過，只有三個屬性，其中<xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，和<xref:System.Windows.Data.Binding.RelativeSource%2A>、 應該設定為每個繫結，或可能會發生衝突。 如果繫結來源衝突，則這個屬性會擲回例外狀況。  
  
 如[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]的詳細資訊，請參閱[RelativeSource MarkupExtension](~/docs/framework/wpf/advanced/relativesource-markupextension.md)。  
    
## Examples  
 下列範例示範建立樣式觸發程序<xref:System.Windows.Controls.ToolTip>，報告驗證錯誤訊息。 Setter 的值會繫結至目前的錯誤內容<xref:System.Windows.Controls.TextBox>(<xref:System.Windows.Controls.TextBox>使用樣式) 使用<xref:System.Windows.Data.Binding.RelativeSource%2A>屬性。 如需有關此範例的詳細資訊，請參閱[How to： 實作繫結驗證](~/docs/framework/wpf/data/how-to-implement-binding-validation.md)。  
  
 [!code-xaml[BindValidation#5](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml#5)]  
  
 若要查看完整的範例，請參閱[繫結驗證範例](http://go.microsoft.com/fwlink/?LinkID=159972)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.Source" />
      </Docs>
    </Member>
    <Member MemberName="RemoveSourceUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void RemoveSourceUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveSourceUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.RemoveSourceUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveSourceUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveSourceUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveSourceUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.RemoveSourceUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to the event.</param>
        <param name="handler">The handler to remove.</param>
        <summary>Removes a handler for the <see cref="E:System.Windows.Data.Binding.SourceUpdated" /> attached event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的事件的使用中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveTargetUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void RemoveTargetUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveTargetUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.RemoveTargetUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveTargetUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveTargetUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveTargetUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.RemoveTargetUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">The <see cref="T:System.Windows.UIElement" /> or <see cref="T:System.Windows.ContentElement" /> that listens to the event.</param>
        <param name="handler">The handler to remove.</param>
        <summary>Removes a handler for the <see cref="E:System.Windows.Data.Binding.TargetUpdated" /> attached event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的事件的使用中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetXmlNamespaceManager">
      <MemberSignature Language="C#" Value="public static void SetXmlNamespaceManager (System.Windows.DependencyObject target, System.Xml.XmlNamespaceManager value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetXmlNamespaceManager(class System.Windows.DependencyObject target, class System.Xml.XmlNamespaceManager value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.SetXmlNamespaceManager(System.Windows.DependencyObject,System.Xml.XmlNamespaceManager)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetXmlNamespaceManager (target As DependencyObject, value As XmlNamespaceManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetXmlNamespaceManager(System::Windows::DependencyObject ^ target, System::Xml::XmlNamespaceManager ^ value);" />
      <MemberSignature Language="F#" Value="static member SetXmlNamespaceManager : System.Windows.DependencyObject * System.Xml.XmlNamespaceManager -&gt; unit" Usage="System.Windows.Data.Binding.SetXmlNamespaceManager (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Xml.XmlNamespaceManager" />
      </Parameters>
      <Docs>
        <param name="target">The object from which to get namespace information.</param>
        <param name="value">The <see cref="T:System.Xml.XmlNamespaceManager" /> to use for namespace evaluation in the passed element.</param>
        <summary>Sets a namespace manager object used by the binding attached to the provided element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法支援附加的屬性的使用方式的<xref:System.Windows.Data.Binding.XmlNamespaceManager%2A>附加屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializePath">
      <MemberSignature Language="C#" Value="public bool ShouldSerializePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.ShouldSerializePath" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializePath () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializePath();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializePath : unit -&gt; bool" Usage="binding.ShouldSerializePath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates whether the <see cref="P:System.Windows.Data.Binding.Path" /> property should be persisted.</summary>
        <returns>
          <see langword="true" /> if the property value has changed from its default; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這`ShouldSerialize`方法提供，因為<xref:System.Windows.Data.Binding.Path%2A>屬性並沒有簡單的預設值。 這個方法會指出屬性是否已變更其預設值。 如果您開發的設計工具通常呼叫這個方法<xref:System.Windows.Data.Binding>或開發您自己的控制項加入<xref:System.Windows.Data.Binding>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSource">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.ShouldSerializeSource" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeSource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeSource();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeSource : unit -&gt; bool" Usage="binding.ShouldSerializeSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates whether the <see cref="P:System.Windows.Data.Binding.Source" /> property should be persisted.</summary>
        <returns>
          <see langword="true" /> if the property value has changed from its default; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這`ShouldSerialize`方法提供，因為<xref:System.Windows.Data.Binding.Source%2A>屬性並沒有簡單的預設值。 這個方法會指出屬性是否已變更其預設值。 如果您開發的設計工具通常呼叫這個方法<xref:System.Windows.Data.Binding>或開發您自己的控制項加入<xref:System.Windows.Data.Binding>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeValidationRules">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeValidationRules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeValidationRules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.ShouldSerializeValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeValidationRules () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeValidationRules();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeValidationRules : unit -&gt; bool" Usage="binding.ShouldSerializeValidationRules " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates whether the <see cref="P:System.Windows.Data.Binding.ValidationRules" /> property should be persisted.</summary>
        <returns>
          <see langword="true" /> if the property value has changed from its default; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這`ShouldSerialize`方法提供，因為<xref:System.Windows.Data.Binding.ValidationRules%2A>屬性並沒有簡單的預設值。 這個方法會指出屬性是否已變更其預設值。 如果您開發的設計工具通常呼叫這個方法<xref:System.Windows.Data.Binding>或開發您自己的控制項加入<xref:System.Windows.Data.Binding>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.Data.Binding.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object to use as the binding source.</summary>
        <value>要作為繫結來源的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，繫結繼承所指定的資料內容`DataContext`如果其中一個已設定的屬性。 不過，<xref:System.Windows.Data.Binding.Source%2A>屬性是一種方式，您可以明確設定的來源<xref:System.Windows.Data.Binding>並覆寫繼承的資料內容。 如果您不需要的功能建立的執行範圍的數個屬性繼承相同的資料內容，您可以使用<xref:System.Windows.Data.Binding.Source%2A>屬性而非`DataContext`屬性。  
  
 <xref:System.Windows.Data.Binding.ElementName%2A?displayProperty=nameWithType>和<xref:System.Windows.Data.Binding.RelativeSource%2A?displayProperty=nameWithType>屬性也可讓您設定的繫結來源明確。 不過，只有三個屬性，其中<xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，和<xref:System.Windows.Data.Binding.RelativeSource%2A>、 應該設定為每個繫結，或可能會發生衝突。 如果繫結來源衝突，則這個屬性會擲回例外狀況。  
  
 若要清除此屬性，將它設定為<xref:System.Windows.DependencyProperty.UnsetValue?displayProperty=nameWithType>。  
  
<a name="xamlAttributeUsage_Source"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Source="object"/>  
```  
  
<a name="xamlValues_Source"></a>   
## <a name="xaml-values"></a>XAML 值  
 *object*  
 現有的物件。 若要參考現有的物件，使用[StaticResource 標記延伸](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)  
  
   
  
## Examples  
 下列範例會使用`Person`物件具有名為字串屬性`PersonName`集中定義的`SDKSample`命名空間中的，第一個反白顯示的列所示。 在反白顯示列，其中包含`<src>`項目，它會具現化`Person`物件`PersonName`屬性值為`Joe`。 這是`Resources`區段，並指派`x:Key`。  
  
 [!code-xaml[BindingInstantiation](~/samples/snippets/csharp/VS_Snippets_Wpf/SimpleBinding/CSharp/Page1.xaml?highlight=4,9,37)]  
  
 包含反白顯示的列`<TextBlock>`項目示範如何將繫結至`PersonName`屬性。 如此一來，<xref:System.Windows.Controls.TextBlock>控制項就會出現 「 Joe"的值。  
  
 在下列範例中，<xref:System.Windows.Data.Binding.Source%2A>值<xref:System.Windows.Data.Binding>物件都會設為`static`屬性<xref:System.Windows.Application.Current%2A?displayProperty=nameWithType>:  
  
 [!code-xaml[DataBindingLab#ComboBoxMultiBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/DataBindingLab/CSharp/AddProductWindow.xaml#comboboxmultibinding)]  
  
 如需完整範例，請參閱[資料繫結示範](http://go.microsoft.com/fwlink/?LinkID=163703)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberSignature Language="ILAsm" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.Binding.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberSignature Language="F#" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" Usage="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdatedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SourceUpdatedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SourceUpdatedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.SourceUpdatedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SourceUpdatedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SourceUpdatedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SourceUpdatedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Data.Binding.SourceUpdatedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.Data.Binding.SourceUpdated" /> attached event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberSignature Language="ILAsm" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.Binding.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberSignature Language="F#" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" Usage="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdatedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TargetUpdatedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TargetUpdatedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.TargetUpdatedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetUpdatedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TargetUpdatedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetUpdatedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Data.Binding.TargetUpdatedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.Data.Binding.TargetUpdated" /> attached event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSourceExceptionFilter">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.UpdateSourceExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateSourceExceptionFilter As UpdateSourceExceptionFilterCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceExceptionFilterCallback ^ UpdateSourceExceptionFilter { System::Windows::Data::UpdateSourceExceptionFilterCallback ^ get(); void set(System::Windows::Data::UpdateSourceExceptionFilterCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateSourceExceptionFilter : System.Windows.Data.UpdateSourceExceptionFilterCallback with get, set" Usage="System.Windows.Data.Binding.UpdateSourceExceptionFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceExceptionFilterCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a handler you can use to provide custom logic for handling exceptions that the binding engine encounters during the update of the binding source value. This is only applicable if you have associated an <see cref="T:System.Windows.Controls.ExceptionValidationRule" /> with your binding.</summary>
        <value>提供自訂邏輯以處理繫結引擎在更新繫結來源值期間所遇到之例外狀況的方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ExceptionValidationRule>是內建的驗證規則會檢查繫結來源屬性更新期間擲回的例外狀況。 如果您有相關聯<xref:System.Windows.Controls.ExceptionValidationRule>與您<xref:System.Windows.Data.Binding>物件，您可以使用這個屬性設定來提供自訂邏輯以處理這些例外狀況處理常式。 如果<xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A>上未指定<xref:System.Windows.Data.Binding>，建立繫結引擎<xref:System.Windows.Controls.ValidationError>與例外狀況並將它加入<xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType>繫結項目的集合。  
  
   
  
## Examples  
 <xref:System.Windows.Controls.TextBox.Text%2A>的下列屬性<xref:System.Windows.Controls.TextBox>是資料繫結來源屬性`Age3`型別的`int`。 <xref:System.Windows.Controls.ExceptionValidationRule>檢查 （例如，當使用者輸入的值無法轉換為整數） 之來源屬性更新期間所擲回的例外狀況。  
  
 [!code-xaml[BindValidation#tbExceptionFilter](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml#tbexceptionfilter)]  
  
 您可以提供自訂邏輯以處理這些例外狀況。 下列範例示範如何使用<xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A>屬性來設定<xref:System.Windows.Data.UpdateSourceExceptionFilterCallback>。  
  
 [!code-csharp[BindValidation#filtercallback](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml.cs#filtercallback)]  
  
 以下是範例實作<xref:System.Windows.Data.UpdateSourceExceptionFilterCallback>。  
  
 [!code-csharp[BindValidation#Handler](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml.cs#handler)]  
  
 <xref:System.Windows.Data.UpdateSourceExceptionFilterCallback>也可以傳回`null`，本身的例外狀況或<xref:System.Windows.Controls.ValidationError>。 如需詳細資訊，請參閱<xref:System.Windows.Data.UpdateSourceExceptionFilterCallback>。  
  
 如需完整範例，請參閱[繫結驗證範例](http://go.microsoft.com/fwlink/?LinkID=159972)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger UpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger UpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.UpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger UpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.Data.Binding.UpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that determines the timing of binding source updates.</summary>
        <value>其中一個 <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> 值。 預設值是<see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />，它會傳回預設<see cref="T:System.Windows.Data.UpdateSourceTrigger" />目標相依性屬性的值。 不過，大多數相依性屬性的預設值是<see cref="F:System.Windows.Data.UpdateSourceTrigger.PropertyChanged" />，雖然<see cref="P:System.Windows.Controls.TextBox.Text" />屬性具有預設值是<see cref="F:System.Windows.Data.UpdateSourceTrigger.LostFocus" />。  若要判斷預設的程式設計方式<see cref="P:System.Windows.Data.Binding.UpdateSourceTrigger" />相依性屬性的值是要取得的屬性使用的屬性中繼資料<see cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />然後核取的值<see cref="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />屬性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 繫結<xref:System.Windows.Data.BindingMode.TwoWay>或<xref:System.Windows.Data.BindingMode.OneWayToSource>接聽中的目標屬性的變更，並將它們傳播回來源。 這種情況稱為更新來源。 通常，當目標屬性變更時，就可能發生這些更新。 這是正常的核取方塊和其他簡單的控制項，但它通常不是適用於文字欄位。 每個按鍵動作可能會降低效能，並拒絕使用者一般機會退格鍵並認可新的值之前修正輸入錯誤之後更新。 因此，預設值<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>值<xref:System.Windows.Controls.TextBox.Text%2A>屬性是<xref:System.Windows.Data.UpdateSourceTrigger.LostFocus>而非<xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>。  
  
 如果您設定<xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>值設定為<xref:System.Windows.Data.UpdateSourceTrigger.Explicit>，您必須呼叫<xref:System.Windows.Data.BindingExpression.UpdateSource%2A>方法或所做的變更將不會傳播到來源。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.Mode" />
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnDataErrors">
      <MemberSignature Language="C#" Value="public bool ValidatesOnDataErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnDataErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidatesOnDataErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnDataErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnDataErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnDataErrors : bool with get, set" Usage="System.Windows.Data.Binding.ValidatesOnDataErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to include the <see cref="T:System.Windows.Controls.DataErrorValidationRule" />.</summary>
        <value>
          <see langword="true" /> 要包含<see cref="T:System.Windows.Controls.DataErrorValidationRule" />，否則<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性提供替代<xref:System.Windows.Controls.DataErrorValidationRule>元素明確。 <xref:System.Windows.Controls.DataErrorValidationRule>是內建的驗證規則，以檢查所引發的錯誤<xref:System.ComponentModel.IDataErrorInfo>來源物件的實作。 如果會引發錯誤，就會建立繫結引擎<xref:System.Windows.Controls.ValidationError>發生錯誤並將它加入<xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType>繫結項目的集合。 錯誤缺乏清除這個驗證回應，除非另一項規則會引發驗證問題。  
  
 <xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱 [.NET Framework 版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下列範例會使用<xref:System.ComponentModel.IDataErrorInfo>和<xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A>來驗證使用者輸入中的<xref:System.Windows.Controls.TextBox>。 第一個範例會建立資料型別可實作<xref:System.ComponentModel.IDataErrorInfo>報告驗證錯誤。  
  
 [!code-csharp[BindingValidationAttributesSnippets#IDataErrorInfoData](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/data.cs#idataerrorinfodata)]
 [!code-vb[BindingValidationAttributesSnippets#IDataErrorInfoData](~/samples/snippets/visualbasic/VS_Snippets_Wpf/bindingvalidationattributessnippets/visualbasic/window1.xaml.vb#idataerrorinfodata)]  
  
 下列範例會繫結`Age`屬性<xref:System.Windows.Controls.TextBox>並設定<xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A>至`true`上<xref:System.Windows.Data.Binding>。  當使用者輸入無效的值時，在出現紅色框線<xref:System.Windows.Controls.TextBox>和<xref:System.Windows.Controls.ToolTip>報告的錯誤訊息。  
  
 [!code-xaml[BindingValidationAttributesSnippets#IDataErrorInfoXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/window1.xaml#idataerrorinfoxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.ValidatesOnExceptions" />
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnExceptions">
      <MemberSignature Language="C#" Value="public bool ValidatesOnExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidatesOnExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnExceptions : bool with get, set" Usage="System.Windows.Data.Binding.ValidatesOnExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to include the <see cref="T:System.Windows.Controls.ExceptionValidationRule" />.</summary>
        <value>
          <see langword="true" /> 要包含<see cref="T:System.Windows.Controls.ExceptionValidationRule" />，否則<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定這個屬性提供替代<xref:System.Windows.Controls.ExceptionValidationRule>元素明確。 <xref:System.Windows.Controls.ExceptionValidationRule>是內建的驗證規則會檢查來源屬性更新期間所擲回的例外狀況。 如果擲回例外狀況，就會建立繫結引擎<xref:System.Windows.Controls.ValidationError>與例外狀況並將它加入<xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType>繫結項目的集合。 錯誤缺乏清除這個驗證回應，除非另一項規則會引發驗證問題。  
  
 <xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A> .NET Framework 3.5 版中引進。  如需詳細資訊，請參閱 [.NET Framework 版本和相依性](~/docs/framework/migration-guide/versions-and-dependencies.md)。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A>來驗證使用者輸入中的<xref:System.Windows.Controls.TextBox>。 第一個範例會建立資料型別會擲回例外狀況時`Age`屬性設定為無效的屬性。  
  
 [!code-csharp[BindingValidationAttributesSnippets#ThrowExceptionData](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/data.cs#throwexceptiondata)]
 [!code-vb[BindingValidationAttributesSnippets#ThrowExceptionData](~/samples/snippets/visualbasic/VS_Snippets_Wpf/bindingvalidationattributessnippets/visualbasic/window1.xaml.vb#throwexceptiondata)]  
  
 下列範例會繫結`Age`屬性<xref:System.Windows.Controls.TextBox>並設定<xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A>至`true`上<xref:System.Windows.Data.Binding>。 當使用者輸入無效的值時，在出現紅色框線<xref:System.Windows.Controls.TextBox>和<xref:System.Windows.Controls.ToolTip>報告的錯誤訊息。  
  
 [!code-xaml[BindingValidationAttributesSnippets#ThrowExceptionXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/window1.xaml#throwexceptionxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.ValidatesOnDataErrors" />
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnNotifyDataErrors">
      <MemberSignature Language="C#" Value="public bool ValidatesOnNotifyDataErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnNotifyDataErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidatesOnNotifyDataErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnNotifyDataErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnNotifyDataErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnNotifyDataErrors : bool with get, set" Usage="System.Windows.Data.Binding.ValidatesOnNotifyDataErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether to include the <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />.</summary>
        <value>
          <see langword="true" /> 要包含<see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" />，否則<see langword="false" />。 預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Windows.Data.Binding.ValidatesOnNotifyDataErrors%2A>是`true`，繫結檢查，並會報告所實作的資料來源所引發的錯誤<xref:System.ComponentModel.INotifyDataErrorInfo>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationRules">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt; ValidationRules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Controls.ValidationRule&gt; ValidationRules" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationRules As Collection(Of ValidationRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ ValidationRules { System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationRules : System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;" Usage="System.Windows.Data.Binding.ValidationRules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a collection of rules that check the validity of the user input.</summary>
        <value>
          <see cref="T:System.Windows.Controls.ValidationRule" /> 物件的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]資料繫結模型可讓您將<xref:System.Windows.Data.Binding.ValidationRules%2A>與您<xref:System.Windows.Data.Binding>或<xref:System.Windows.Data.MultiBinding>物件。 您可以建立自訂規則衍生自<xref:System.Windows.Controls.ValidationRule>類別，並實作<xref:System.Windows.Controls.ValidationRule.Validate%2A>方法，或者您可以使用內建<xref:System.Windows.Controls.ExceptionValidationRule>，這會導致在來源更新期間的例外狀況是否無效值。  
  
 繫結引擎會檢查每個<xref:System.Windows.Controls.ValidationRule>每次輸入的值 （繫結目標屬性值） 轉送到繫結來源屬性的繫結相關聯。 驗證程序的詳細討論，請參閱中的資料驗證一節[資料繫結概觀](~/docs/framework/wpf/data/data-binding-overview.md)。  
  
> [!NOTE]
>  此屬性可以在設定[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]只能使用集合語法所示，或藉由存取的集合物件，使用的各種方法，例如`Add`。 要存取的集合物件的屬性是唯讀的而集合本身則是讀寫。  
  
<a name="xamlPropertyElementUsage_ValidationRules"></a>   
## <a name="xaml-property-element-usage"></a>XAML 屬性項目用法  
  
```  
<object>  
  <object.ValidationRules>  
    oneOrMoreValidationRules  
  </object.ValidationRules>  
</object>  
  
```  
  
<a name="xamlValues_ValidationRules"></a>   
## <a name="xaml-values"></a>XAML 值  
 *oneOrMoreValidationRules*  
 一或多個<xref:System.Windows.Controls.ValidationRule>物件。 您可以使用<xref:System.Windows.Controls.ExceptionValidationRule>類別或子類別化來建立自訂規則<xref:System.Windows.Controls.ValidationRule>類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Validation" />
      </Docs>
    </Member>
    <Member MemberName="XmlNamespaceManager">
      <MemberSignature Language="C#" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberSignature Language="ILAsm" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.XmlNamespaceManager" />
      <MemberSignature Language="VB.NET" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberSignature Language="F#" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" Usage="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlNamespaceManagerProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty XmlNamespaceManagerProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty XmlNamespaceManagerProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.XmlNamespaceManagerProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly XmlNamespaceManagerProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ XmlNamespaceManagerProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable XmlNamespaceManagerProperty : System.Windows.DependencyProperty" Usage="System.Windows.Data.Binding.XmlNamespaceManagerProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Data.Binding.XmlNamespaceManager" /> attached property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="XPath">
      <MemberSignature Language="C#" Value="public string XPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.XPath" />
      <MemberSignature Language="VB.NET" Value="Public Property XPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ XPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XPath : string with get, set" Usage="System.Windows.Data.Binding.XPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an <see langword="XPath" /> query that returns the value on the [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] binding source to use.</summary>
        <value>
          <see langword="XPath" /> 查詢。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 繫結來源時[!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)]資料，而非[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]物件<xref:System.Windows.Data.Binding.XPath%2A>而不是使用屬性<xref:System.Windows.Data.Binding.Path%2A>屬性，指出要使用的繫結來源上的值的路徑。  
  
 藉由設定<xref:System.Windows.Data.Binding.XPath%2A>屬性，您要建立`XPath`查詢，以選取的節點的集合 (<xref:System.Xml.XmlElement?displayProperty=nameWithType>和<xref:System.Xml.XmlAttribute?displayProperty=nameWithType>兩者都衍生自<xref:System.Xml.XmlNode?displayProperty=nameWithType>)。 <xref:System.Xml.XmlNode?displayProperty=nameWithType> 是[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]物件，這表示您可以使用其屬性的繫結<xref:System.Windows.Data.Binding.Path%2A>屬性。  
  
 <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType>方法會處理`XPath`運算式從<xref:System.Windows.Data.Binding.XPath%2A>屬性。 `XPath` 不支援函式。 如`XPath`運算式的詳細資訊，請參閱<xref:System.Xml.XmlNode.SelectNodes%2A>文件集和範例 > 一節中提供一些範例。  
  
 LINQ to XML 物件<xref:System.Xml.Linq.XDocument>和<xref:System.Xml.Linq.XElement>不要使用`XPath`。 如需詳細資訊，請參閱[How to: for XML 查詢結果繫結至 XDocument、 XElement 或 LINQ](~/docs/framework/wpf/data/how-to-bind-to-xdocument-xelement-or-linq-for-xml-query-results.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>