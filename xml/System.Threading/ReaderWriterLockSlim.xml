<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ff770bb9446d6ebe71649784ebe115f60734cc0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531352" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>代表鎖定，用來管理資源存取，允許多個執行緒的讀取權限或獨佔寫入權限。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.ReaderWriterLockSlim>來保護資源由多個執行緒的讀取及寫入由一個執行緒一次。 <xref:System.Threading.ReaderWriterLockSlim> 可讓多個執行緒處於讀取模式、 讓一個執行緒在寫入模式與獨佔擁有權的鎖定，並允許具有讀取權限可升級的讀取模式，供執行緒來升級至寫入模式，而不必放棄它的一個執行緒s 讀取資源的存取權。  
  
> [!NOTE]
>  <xref:System.Threading.ReaderWriterLockSlim> 類似於 <xref:System.Threading.ReaderWriterLock>，但是它有遞迴以及升級和降級鎖定狀態的簡化規則。 <xref:System.Threading.ReaderWriterLockSlim> 可避免可能發生死結的許多情況。 此外，<xref:System.Threading.ReaderWriterLockSlim> 的效能明顯優於 <xref:System.Threading.ReaderWriterLock>。 建議針對所有新的開發使用 <xref:System.Threading.ReaderWriterLockSlim>。  
  
 根據預設的新執行個體<xref:System.Threading.ReaderWriterLockSlim>以建立<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>旗標，且不允許遞迴。 這項預設原則建議所有新的開發，因為遞迴會引進不必要的複雜性，而讓您的程式碼更容易發生死結。 若要簡化移轉作業從現有的專案使用<xref:System.Threading.Monitor>或<xref:System.Threading.ReaderWriterLock>，您可以使用<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>建立的執行個體的旗標<xref:System.Threading.ReaderWriterLockSlim>，讓遞迴。  
  
 執行緒可以進入三種模式的鎖定： 讀取模式、 寫入模式和可升級的讀取的模式。 (在本主題的其餘部分，「 讀取可升級模式 」 指 「 可升級模式 」，並 「 輸入`x`模式 」 使用代表較長"輸入鎖定`x`模式 」。)  
  
 遞迴原則，不論只有一個執行緒可以在任何時間是在寫入模式中。 當執行緒在寫入模式中時，沒有其他執行緒可以在任何模式下進入鎖定。 只有一個執行緒可以在任何時間是在可升級模式。 任意數目的執行緒可以處於讀取模式，而且可以有一個執行緒在可升級模式中其他的執行緒處於讀取模式。  
  
> [!IMPORTANT]
>  此類型會實作<xref:System.IDisposable>介面。 當您完成使用類型時，您應該會處置它直接或間接。 若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
 <xref:System.Threading.ReaderWriterLockSlim> 具有 managed 執行緒相似性。也就是說，每個<xref:System.Threading.Thread>物件必須讓自己進入或離開鎖定模式的方法呼叫。 任何執行緒可以不變更另一個執行緒的模式。  
  
 如果<xref:System.Threading.ReaderWriterLockSlim>不允許遞迴時，執行緒嘗試進入鎖定狀態可以封鎖有幾個原因：  
  
-   嘗試進入讀取的模式會遭封鎖，等待進入寫入模式，或如果寫入模式中沒有單一執行緒的執行緒時執行緒。  
  
    > [!NOTE]
    >  寫入器會排入佇列時，將封鎖新讀取器是寫入器鎖定公平性原則。 目前的公平性原則公平性讀取器和寫入器，提升產能的最常見的案例之間取得平衡。 未來版本[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]可能會導入新的公平性化原則。  
  
-   嘗試進入可升級模式的區塊，如果已經有執行緒在可升級模式中，如果沒有執行緒等待進入寫入模式，或如果在寫入模式中的單一執行緒的執行緒。  
  
-   嘗試進入寫入模式的區塊，如果沒有任何一種模式中的執行緒的執行緒。  
  
## <a name="upgrading-and-downgrading-locks"></a>升級和降級鎖定  
 可升級模式適用於案例，其中執行緒通常會讀取受保護的資源，但是可能需要寫入其中，如果符合一些條件。 執行緒已進入<xref:System.Threading.ReaderWriterLockSlim>可升級模式具有讀取存取受保護的資源，而且可以升級至寫入模式，藉由呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法。 因為可以有只有一個執行緒在可升級模式下一次，升級至寫入模式不能發生死結時不允許遞迴，這是預設的原則。  
  
> [!IMPORTANT]
>  不論遞迴原則，一開始進入讀取模式不允許升級至可升級模式 」 或 「 寫入模式，因為該模式會建立強式死結的可能性。 例如，如果兩個執行緒同時嘗試進入讀取模式中的寫入模式，它們將會發生死結。 可升級模式被為了避免這類死結。  
  
 如果在讀取模式中，正在升級區塊的執行緒沒有其他執行緒。 當執行緒被封鎖時，其他的執行緒嘗試進入讀取的模式，將會遭到封鎖。 當所有執行緒都結束讀取模式時，封鎖升級的執行緒會進入寫入模式。 如果沒有其他執行緒等待進入寫入模式，它們保持封鎖，因為可升級模式的單一執行緒會防止它們無法獲得獨佔存取的資源。  
  
 當可升級模式中的執行緒結束寫入模式時，其他執行緒等待進入讀取的模式，可以這樣做，除非沒有執行緒等待進入寫入模式。 可升級模式中的執行緒可以升級和降級無限期地，只要它是只寫入受保護資源的執行緒。  
  
> [!IMPORTANT]
>  如果您允許多個執行緒進入寫入模式或可升級模式，您必須允許獨佔可升級模式的單一執行緒。 否則，執行緒嘗試進入寫入模式直接將會遭到封鎖，且已被封鎖，而其他的執行緒將無法進入讀取的模式。  
  
 可升級模式的執行緒可以降級為讀取模式，藉由第一個呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法，然後再呼叫<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法。 即使此降級模式允許所有的鎖定遞迴原則<xref:System.Threading.LockRecursionPolicy.NoRecursion>。  
  
 降級為讀取模式以後, 執行緒無法重新輸入可升級模式，直到結束讀取模式。  
  
## <a name="entering-the-lock-recursively"></a>輸入鎖定以遞迴方式  
 您可以建立<xref:System.Threading.ReaderWriterLockSlim>遞迴鎖定項目支援使用<xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29>建構函式指定鎖定原則，並指定<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>。  
  
> [!NOTE]
>  使用遞迴建議不要進行新開發，因為它會引進不必要的複雜性，並讓您的程式碼更容易發生死結。  
  
 如<xref:System.Threading.ReaderWriterLockSlim>，可讓遞迴，下列可說是有關執行緒可以進入模式：  
  
-   在讀取模式中的執行緒可以輸入讀取的模式遞迴的但是無法進入寫入模式或可升級模式。 如果它嘗試這樣做，請<xref:System.Threading.LockRecursionException>就會擲回。 進入讀取模式，然後進入寫入模式，或可升級模式是一種模式與死結的機率，因此不允許。 如同先前討論，就必須升級鎖定的情況下提供可升級模式。  
  
-   可升級模式的執行緒可以在寫入模式，及/或讀取的模式中，輸入，並可以輸入任何三個模式以遞迴方式。 不過，嘗試進入寫入模式區塊讀取模式中是否有其他的執行緒。  
  
-   寫入模式的執行緒會讀取的模式，及/或可升級模式，可以輸入，並可以輸入任何三個模式以遞迴方式。  
  
-   尚未進入鎖定的執行緒可以進入任何模式。 這項嘗試可能會基於相同原因，因為嘗試輸入非遞迴鎖定封鎖。  
  
 執行緒可以結束它已經進入依任何順序模式，只要它會結束，每一種模式中進入該模式的次數相同。 如果執行緒嘗試次數過多，結束模式或結束尚未進入，模式<xref:System.Threading.SynchronizationLockException>就會擲回。  
  
## <a name="lock-states"></a>鎖定狀態  
 您可能會發現很好的做法鎖定的狀態中。 A<xref:System.Threading.ReaderWriterLockSlim>可以處於四種狀態之一： 不是輸入讀取，升級和寫入。  
  
-   未輸入： 處於此狀態，沒有任何執行緒已進入鎖定 （或所有執行緒都結束鎖定）。  
  
-   請閱讀： 處於此狀態，一或多個執行緒已進入鎖定進行讀取受保護的資源。  
  
    > [!NOTE]
    >  執行緒可以進入讀取模式鎖定使用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法，或從 可升級模式降級。  
  
-   升級： 處於此狀態，一個執行緒已進入鎖定進行讀取與寫入存取所升級選項 （也就是在可升級模式），以及零個或多個執行緒已進入讀取權限的鎖定。 一次只能有一個執行緒可以進入鎖定與升級; 選項嘗試進入可升級模式的其他執行緒會遭到封鎖。  
  
-   寫入： 處於此狀態，一個執行緒已進入鎖定進行寫入存取受保護的資源。 該執行緒擁有獨佔的鎖定。 嘗試進入鎖定，因為任何原因的其他任何執行緒會封鎖。  
  
 下表描述的鎖定狀態，不允許遞迴時，當執行緒的鎖定之間的轉換`t`採取最左邊的資料行中所述的動作。 在階段採取動作，`t`不有任何模式。 (的特殊情況下其中`t`中說明資料表註腳可升級模式。)上方資料列描述鎖定的開始狀態。 資料格描述執行緒，會發生什麼事，並顯示在括號中的鎖定狀態的變更。  
  
||不進入 (N)|Read (R)|升級 (U)|寫入 (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` 進入讀取的模式|`t` 輸入 (R)。|`t` 如果執行緒正在等候寫入模式;，區塊否則，`t`進入。|`t` 如果執行緒正在等候寫入模式;，區塊否則，`t`進入。<sup>1</sup>|`t` 區塊。|  
|`t` 進入可升級模式|`t` 輸入 (U)。|`t` 如果執行緒正在等候的區塊寫入模式或升級模式。否則，`t`進入 (U)。|`t` 區塊。|`t` 區塊。|  
|`t` 進入寫入模式|`t` 輸入 (W)。|`t` 區塊。|`t` 區塊。<sup>2</sup>|`t` 區塊。|  
  
 <sup>1</sup>如果`t`啟動出可升級模式，它進入讀取的模式。 這個動作會永遠不會封鎖。 鎖定狀態不會變更。 （在執行緒然後即可完成以結束可升級模式的方式讀取模式降級）。  
  
 <sup>2</sup>如果`t`開始都處於可升級模式，它會封鎖在讀取模式下執行緒時。 否則，會升級寫入模式。 鎖定狀態 會變更以寫入 (W)。 如果`t`區塊中，因為有執行緒處於讀取模式，因為在最後一個執行緒結束讀取的模式，即會進入寫入模式中，即使有執行緒等待進入寫入模式。  
  
 執行緒結束鎖定，就會發生狀態變更下, 一個執行緒喚醒，當選取時，如下所示：  
  
-   首先，正在等候執行緒寫入模式，且已在可升級模式 （有最多可達一個這類執行緒）。  
  
-   如果失敗，正在等候寫入模式的執行緒。  
  
-   如果失敗，正在等待進入可升級模式的執行緒。  
  
-   如果失敗，正在等候讀取模式的所有執行緒。  
  
 後續狀態一律是鎖定的寫入 (W) 中的第一個兩種情況下與升級 (U) 在第三個案例中，不論鎖定現有執行緒觸發狀態變更時的狀態為何。 在最後一個案例中，鎖定狀態時升級 (U) 執行緒中沒有可升級模式之後的狀態變更和 Read (R) 否則無論之前的狀態。  
  
   
  
## Examples  
 下列範例會示範簡單的同步處理快取保存字串與整數索引鍵。 執行個體<xref:System.Threading.ReaderWriterLockSlim>用來同步處理存取具備<xref:System.Collections.Generic.Dictionary%602>做為內部快取。  
  
 此範例包含簡單的方法加入至快取，刪除從快取，以及讀取快取。 為了示範逾時，此範例也包含它可以這樣做內指定的逾時，才將快取的方法。  
  
 為了示範可升級模式，此範例包含方法，可擷取索引鍵相關聯的值，並比較它與新的值。 如果值為不變，則方法會傳回狀態，表示沒有變更。 它沒有值找不到索引鍵，會插入索引鍵/值組。 如果值已變更，它會更新。 可升級模式可讓執行緒升級從的寫入存取，如有需要而不會發生死結的讀取權限。  
  
 此範例也包含巢狀的列舉，指定方法，示範可升級模式的傳回值。  
  
 此範例會使用預設建構函式，來建立鎖定，因此不允許遞迴。 程式設計<xref:System.Threading.ReaderWriterLockSlim>鎖定不允許遞迴是比較簡單且較不容易發生錯誤。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 下列程式碼再使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。 它會建立三項工作。 第一個寫入蔬菜儲存在陣列中的名稱`SynchronizedCache`執行個體。 第二個和第三個工作顯示蔬菜、 遞增順序 （從低索引最高索引），以遞減順序的第二個中的第一個的名稱。 最後一項工作會搜尋字串"cucumber 」，並在它時，會呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來替代字串 「 綠色 bean"。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>使用預設屬性值，初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Threading.ReaderWriterLockSlim> ，初始化與這個建構函式不允許遞迴。 亦即，<xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> 屬性會傳回 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>。  
  
 如需有關遞迴原則，以及它影響的詳細資訊，請參閱<xref:System.Threading.LockRecursionPolicy>列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
   
  
## Examples  
 下列範例會示範簡單的同步處理快取保存字串與整數索引鍵。 執行個體<xref:System.Threading.ReaderWriterLockSlim>用來同步處理存取具備<xref:System.Collections.Generic.Dictionary%602>做為內部快取。 無參數建構函式用來建立鎖定。  
  
 此範例包含簡單的方法加入至快取，刪除從快取，以及讀取快取。 為了示範逾時，此範例也包含它可以這樣做內指定的逾時，才將快取的方法。  
  
 為了示範可升級模式，此範例包含方法，可擷取索引鍵相關聯的值，並比較它與新的值。 如果值為不變，則方法會傳回狀態，表示沒有變更。 它沒有值找不到索引鍵，會插入索引鍵/值組。 如果值已變更，它會更新。 可升級模式可讓執行緒升級從的寫入存取，如有需要而不會發生死結的讀取權限。  
  
 此範例也包含巢狀的列舉，指定方法，示範可升級模式的傳回值。  
  
 此範例會使用預設建構函式，來建立鎖定，因此不允許遞迴。 程式設計<xref:System.Threading.ReaderWriterLockSlim>鎖定不允許遞迴是比較簡單且較不容易發生錯誤。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 下列程式碼再使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。 它會建立三項工作。 第一個寫入蔬菜儲存在陣列中的名稱`SynchronizedCache`執行個體。 第二個和第三個工作顯示蔬菜、 遞增順序 （從低索引最高索引），以遞減順序的第二個中的第一個的名稱。 最後一項工作會搜尋字串"cucumber 」，並在它時，會呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來替代字串 「 綠色 bean"。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">一個列舉值，指定鎖定遞迴原則。</param>
        <summary>指定鎖定遞迴原則，初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 遞迴原則會決定多次進入鎖定狀態的執行緒上的限制。 例如，如果建立鎖定時使用<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>執行緒已進入讀取模式的鎖定和<xref:System.Threading.LockRecursionException>執行緒會嘗試重新進入讀取模式鎖定便會擲回。 同樣地，如果執行緒已進入寫入模式的鎖定<xref:System.Threading.LockRecursionException>如果執行緒會嘗試重新輸入任何模式中的鎖定，會擲回。  
  
> [!NOTE]
>  可升級模式的執行緒可以寫入模式升級或降級為讀取模式鎖定的遞迴原則設定。  
  
 不論遞迴原則，一開始進入讀取模式不允許升級至可升級模式 」 或 「 寫入模式，因為該模式會建立強式死結的可能性。  
  
 如需有關遞迴原則，以及它影響的詳細資訊，請參閱<xref:System.Threading.LockRecursionPolicy>列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
   
  
## Examples  
 下列範例示範兩個例外狀況，其中一個，取決於<xref:System.Threading.LockRecursionPolicy>設定，另一個則沒有。  
  
 在第一個案例中，執行緒會進入讀取的模式，並再嘗試進入讀取的模式遞迴。 如果<xref:System.Threading.ReaderWriterLockSlim>利用遞迴原則設定為預設建構函式建立<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>，擲回例外狀況。 如果<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>用來建立<xref:System.Threading.ReaderWriterLockSlim>，擲回任何例外狀況。  
  
 在第二個案例中，執行緒會進入讀取的模式，然後嘗試進入寫入模式。 <xref:System.Threading.LockRecursionException> 就會擲回不論鎖定遞迴原則。  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 下列程式碼再使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。 它會建立三項工作。 第一個寫入蔬菜儲存在陣列中的名稱`SynchronizedCache`執行個體。 第二個和第三個工作顯示蔬菜、 遞增順序 （從低索引最高索引），以遞減順序的第二個中的第一個的名稱。 最後一項工作會搜尋字串"cucumber 」，並在它時，會呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來替代字串 「 綠色 bean"。  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得已進入讀取模式鎖定狀態的唯一執行緒總數。</summary>
        <value>已進入讀取模式鎖定狀態的唯一執行緒數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒只計算一次，即使鎖定允許遞迴和執行緒已進入讀取的模式多次。  
  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 計算時，可以變更結果。 因此，它並不安全根據此屬性決定。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A>產生事件記錄檔項目，如果在讀取模式下的執行緒數目超過臨界值的屬性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別目前的執行個體所使用的資源全部釋出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 使用完畢時，請呼叫 <xref:System.Threading.ReaderWriterLockSlim>。 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 方法會將 <xref:System.Threading.ReaderWriterLockSlim> 保留在無法使用的狀態。 在呼叫<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>，您必須釋放所有參考<xref:System.Threading.ReaderWriterLockSlim>讓記憶體回收行程可以回收記憶體的<xref:System.Threading.ReaderWriterLockSlim>所佔用。 如需詳細資訊，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)和[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  請務必呼叫<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>您釋放最後一個參考之前<xref:System.Threading.ReaderWriterLockSlim>物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> 大於零。  
  
 -或-  
  
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> 大於零。  
  
 -或-  
  
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> 大於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試進入讀取模式的鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會封鎖，直到呼叫的執行緒進入鎖定，因此可能永遠不會傳回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法來封鎖指定的間隔，然後再回頭執行如果呼叫執行緒尚未進入讀取模式，在該間隔期間。  
  
 多個執行緒可以進入讀取的模式，在相同的時間。  
  
 如果一個或多個執行緒正在等待進入寫入模式中，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法封鎖，直到這些執行緒具有逾時或已進入寫入模式，然後從它結束。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。  
  
 最多一個執行緒可以在可升級模式，其他的執行緒處於讀取模式。 如果其他的執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法會立即進入讀取的模式，而不會封鎖。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法在讀取模式下進入鎖定。 在範例中所示的方法擷取索引鍵相關聯的值。 如果索引鍵找不到，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。 A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，確保呼叫端結束讀取的模式。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">目前的執行緒無法在保留讀取鎖定的情況下取得寫入鎖定。  
  
 -或-  
  
 <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒嘗試在已經保留讀取鎖定的情況下取得讀取鎖定。  
  
 -或-  
  
 <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒嘗試在已經保留寫入鎖定的情況下取得讀取鎖定。  
  
 -或-  
  
 遞迴的次數會超過計數器的容量。 這項限制非常寬鬆，所以應用程式應該永遠都不會發生這種例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試進入可升級模式的鎖定狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會封鎖，直到呼叫的執行緒進入鎖定，因此可能永遠不會傳回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>來封鎖指定的間隔內，，然後傳回 如果呼叫執行緒尚未進入可升級模式在該間隔期間的方法。  
  
 使用可升級模式下，當執行緒通常存取受保護的資源<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。 可升級模式的執行緒可以降級為讀取模式，或升級至寫入模式。  
  
 只有一個執行緒可以進入可升級模式，在任何指定時間。 如果執行緒是在可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒進入讀取的模式，即使有執行緒等待進入可升級模式。  
  
 如果一個或多個執行緒正在等待進入寫入模式中，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法封鎖，直到這些執行緒具有逾時或已進入寫入模式，然後從它結束。  
  
> [!NOTE]
>  如果鎖定允許遞迴已進入可升級模式鎖定的執行緒可以輸入可升級模式遞迴，即使其他執行緒等待進入寫入模式。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來進入可升級模式的鎖定。 A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，確保呼叫端結束可升級模式。  
  
 在範例中所示的方法擷取索引鍵相關聯的值，並比較它與新的值。 如果值為不變，則方法會傳回狀態，表示沒有變更。 它沒有值找不到索引鍵，會插入索引鍵/值組。 如果值已變更，它會更新。 可升級模式可讓執行緒升級讀取的鎖定，如有需要而不發生死結的風險。  
  
 此範例會使用預設建構函式，來建立鎖定，因此不允許遞迴。 程式設計<xref:System.Threading.ReaderWriterLockSlim>鎖定不允許遞迴是比較簡單且較不容易發生錯誤。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性為 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒已進入任何模式的鎖定狀態。  
  
 -或-  
  
 目前執行緒已進入讀取模式，因此嘗試進入可升級模式可能會造成死結。  
  
 -或-  
  
 遞迴的次數會超過計數器的容量。 限制過大，使應用程式永遠不會發生這個情形。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試進入寫入模式的鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會封鎖，直到呼叫的執行緒進入鎖定，因此可能永遠不會傳回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>來封鎖指定的間隔內，，然後傳回 如果呼叫執行緒尚未進入寫入模式在該間隔期間的方法。  
  
 如果其他的執行緒已進入讀取模式鎖定，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法會封鎖直到那些執行緒都結束讀取模式。 等待進入寫入模式的執行緒時，額外的執行緒嘗試進入讀取的模式或區塊可升級模式，直到所有等待進入寫入模式的執行緒具有逾時已進入寫入模式，或從它然後結束。  
  
> [!NOTE]
>  如果鎖定允許遞迴已進入寫入模式鎖定的執行緒可以輸入遞迴寫入模式，即使其他執行緒等待進入寫入模式。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法，以在寫入模式下進入鎖定狀態。 範例所示的方法會將新的索引鍵/值組加入至同步處理快取。 如果機碼已經快取中，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。 A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端結束寫入模式。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性為 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒已進入任何模式的鎖定狀態。  
  
 -或-  
  
 目前執行緒已進入讀取模式，因此嘗試進入寫入模式鎖定可能會造成死結。  
  
 -或-  
  
 遞迴的次數會超過計數器的容量。 限制過大，使應用程式永遠不會發生這個情形。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>減少讀取模式遞迴的計數，如果得出的計數為 0 (零)，則結束讀取模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是遞迴順序。 例如，如果在執行緒進入可升級模式鎖定，然後在讀取模式下進入鎖定的執行緒結束兩種模式的順序無關。 如果鎖定允許遞迴，執行緒可以進入寫入模式的鎖定，然後輸入它以遞迴方式在以讀取模式。在執行緒結束的順序模式讀寫模式並不重要。  
  
 結束鎖定，可能表示其他的等候中執行緒。  
  
   
  
## Examples  
 下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，確保呼叫端結束讀取的模式。 在範例中所示的方法擷取索引鍵相關聯的值。 如果索引鍵找不到，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法用來進入讀取的模式。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">目前的執行緒尚未進入讀取模式的鎖定狀態。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>減少可升級模式遞迴的計數，如果得出的計數為 0 (零)，則結束可升級模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是遞迴順序。 例如，如果在執行緒進入可升級模式鎖定，然後在寫入模式下進入鎖定的執行緒結束兩種模式的順序無關。 如果鎖定允許遞迴，執行緒可以進入寫入模式的鎖定，然後輸入它以遞迴方式可升級模式。在執行緒結束可升級模式 」 和 「 寫入模式的順序不重要。  
  
 結束鎖定，可能表示其他的等候中執行緒。  
  
   
  
## Examples  
 下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，確保呼叫端結束可升級模式。  
  
 在範例中所示的方法擷取索引鍵相關聯的值，並比較它與新的值。 如果值為不變，則方法會傳回狀態，表示沒有變更。 它沒有值找不到索引鍵，會插入索引鍵/值組。 如果值已變更，它會更新。 可升級模式可讓執行緒升級讀取的鎖定，如有需要而不發生死結的風險。  
  
 此範例會使用預設建構函式，來建立鎖定，因此不允許遞迴。 程式設計<xref:System.Threading.ReaderWriterLockSlim>鎖定不允許遞迴是比較簡單且較不容易發生錯誤。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">目前的執行緒尚未進入可升級模式的鎖定狀態。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>減少寫入模式遞迴的計數，如果得出的計數為 0 (零)，則結束寫入模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是遞迴順序。 例如，如果在執行緒進入可升級模式鎖定，然後在寫入模式下進入鎖定的執行緒結束兩種模式的順序無關。 如果鎖定允許遞迴，執行緒可以進入寫入模式的鎖定，然後輸入它以遞迴方式在以讀取模式。在執行緒結束的順序模式讀寫模式並不重要。  
  
 結束鎖定，可能表示其他的等候中執行緒。  
  
   
  
## Examples  
 下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端結束寫入模式。 範例所示的方法會將新的索引鍵/值組加入至同步處理快取。 如果機碼已經快取中，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法用來在寫入模式下進入鎖定狀態。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">目前的執行緒尚未進入寫入模式的鎖定狀態。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前執行緒是否已進入讀取模式的鎖定。</summary>
        <value>
          如果目前執行緒已進入讀取模式，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性適用於判斷提示或其他偵錯功能。 請勿使用它來控制控制程式執行流程。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A>屬性來產生判斷提示，如果目前執行緒已進入讀取模式意外。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前執行緒是否已進入可升級模式的鎖定。</summary>
        <value>
          如果目前執行緒已進入可升級模式，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性適用於判斷提示或其他偵錯功能。 請勿使用它來控制控制程式執行流程。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A>產生判斷提示，如果目前執行緒已進入可升級模式非預期的屬性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前執行緒是否已進入寫入模式的鎖定。</summary>
        <value>
          如果目前執行緒已進入寫入模式，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性適用於判斷提示或其他偵錯功能。 請勿使用它來控制控制程式執行流程。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A>產生判斷提示，如果目前執行緒已進入寫入模式非預期的屬性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件的遞迴原則。</summary>
        <value>一個列舉值，指定鎖定遞迴原則。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 遞迴原則會決定多次進入鎖定狀態的執行緒上的限制。 例如，如果建立鎖定時使用<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>執行緒已進入讀取模式的鎖定和<xref:System.Threading.LockRecursionException>執行緒會嘗試重新進入讀取模式鎖定便會擲回。  
  
> [!NOTE]
>  可升級模式的執行緒可以寫入模式升級或降級為讀取模式鎖定的遞迴原則設定。  
  
 不論遞迴原則，一開始進入讀取模式不允許升級至可升級模式 」 或 「 寫入模式，因為該模式會建立強式死結的可能性。  
  
 如需有關遞迴原則，以及它影響的詳細資訊，請參閱<xref:System.Threading.LockRecursionPolicy>列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前執行緒已進入讀取模式鎖定的次數，做為遞迴的表示。</summary>
        <value>0 （零），如果目前執行緒尚未進入讀取模式，1，如果執行緒已進入讀取的模式，但是尚未遞迴進入該，或*n*如果執行緒已遞迴進入鎖定*n* -1 次。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 計算時，可以變更結果。 因此，它並不安全根據此屬性決定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前執行緒已進入可升級模式鎖定的次數，做為遞迴的表示。</summary>
        <value>如果目前執行緒尚未進入可升級模式，如果執行緒已進入可升級模式，但已遞迴進入該，1，0 或*n*如果執行緒已進入可升級模式遞迴*n* -1時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 計算時，可以變更結果。 因此，它並不安全根據此屬性決定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前執行緒已進入寫入模式鎖定的次數，做為遞迴的表示。</summary>
        <value>0，表示目前執行緒尚未進入寫入模式，1 如果執行緒已進入寫入模式，但是尚未遞迴進入該，或*n*如果執行緒已遞迴進入寫入模式*n* -1 次。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 計算時，可以變更結果。 因此，它並不安全根據此屬性決定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>嘗試以選用的逾時，在讀取模式下進入鎖定狀態。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數；若要永遠等候，則為 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)。</param>
        <summary>嘗試以選用的整數逾時，進入讀取模式的鎖定狀態。</summary>
        <returns>
          如果呼叫執行緒已進入讀取模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 多個執行緒可以進入讀取的模式，在相同的時間。  
  
 如果一個或多個執行緒正在等待進入寫入模式中，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或呼叫執行緒的自己逾時間隔到期為止。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。  
  
 其他的執行緒處於讀取模式，可升級模式中只能有一個執行緒。 如果其他的執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會立即進入讀取的模式，而不會封鎖。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性為 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒已進入鎖定狀態。  
  
 -或-  
  
 遞迴的次數會超過計數器的容量。 限制過大，使應用程式永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 的值為負，但不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，這是唯一允許的負值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的間隔，或 -1 毫秒無限期等待。</param>
        <summary>嘗試以選用的逾時，在讀取模式下進入鎖定狀態。</summary>
        <returns>
          如果呼叫執行緒已進入讀取模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 多個執行緒可以在讀取模式下進入鎖定在相同的時間。  
  
 如果一個或多個執行緒佇列進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或呼叫執行緒的自己逾時間隔到期為止。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。  
  
 其他的執行緒處於讀取模式，可升級模式中只能有一個執行緒。 如果其他的執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會立即進入讀取的模式，而不會封鎖。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性為 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒已進入鎖定狀態。  
  
 -或-  
  
 遞迴的次數會超過計數器的容量。 限制過大，使應用程式永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值為負，但不等於 -1 毫秒，這是唯一允許的負值。  
  
 -或-  
  
 <paramref name="timeout" /> 的值大於 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>嘗試以選用的逾時，在可升級模式下進入鎖定狀態。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數；若要永遠等候，則為 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)。</param>
        <summary>嘗試以選用的逾時，在可升級模式下進入鎖定狀態。</summary>
        <returns>
          如果呼叫執行緒已進入可升級模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 使用可升級模式下，當執行緒通常存取受保護的資源<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。 可升級模式的執行緒可以寫入模式升級或降級為讀取模式。  
  
 只有一個執行緒可以進入可升級模式鎖定，在任何指定時間。 如果執行緒是在可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒進入讀取的模式，即使有執行緒等待進入可升級模式。  
  
 如果一個或多個執行緒正在等待進入寫入模式中，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或呼叫執行緒的自己逾時間隔到期為止。  
  
> [!NOTE]
>  如果鎖定允許遞迴已進入可升級模式鎖定的執行緒可以輸入可升級模式遞迴，即使其他執行緒等待進入寫入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性為 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒已進入鎖定狀態。  
  
 -或-  
  
 目前執行緒一開始已進入讀取模式的鎖定狀態，因此嘗試進入可升級模式可能會造成死結。  
  
 -或-  
  
 遞迴的次數會超過計數器的容量。 限制過大，使應用程式永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 的值為負，但不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，這是唯一允許的負值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的間隔，或 -1 毫秒無限期等待。</param>
        <summary>嘗試以選用的逾時，在可升級模式下進入鎖定狀態。</summary>
        <returns>
          如果呼叫執行緒已進入可升級模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 當執行緒通常存取受保護的資源時使用可升級模式<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。 可升級模式的執行緒可以寫入模式升級或降級為讀取模式。  
  
 只有一個執行緒可以進入可升級模式鎖定，在任何指定時間。 如果執行緒是在可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒進入讀取的模式，即使有執行緒等待進入可升級模式。  
  
 如果一個或多個執行緒正在等待進入寫入模式中，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或呼叫執行緒的自己逾時間隔到期為止。  
  
> [!NOTE]
>  如果鎖定允許遞迴已進入可升級模式鎖定的執行緒可以輸入可升級模式遞迴，即使其他執行緒等待進入寫入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性為 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒已進入鎖定狀態。  
  
 -或-  
  
 目前執行緒一開始已進入讀取模式的鎖定狀態，因此嘗試進入可升級模式可能會造成死結。  
  
 -或-  
  
 遞迴的次數會超過計數器的容量。 限制過大，使應用程式永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值為負，但不等於 -1 毫秒，這是唯一允許的負值。  
  
 -或-  
  
 <paramref name="timeout" /> 的值大於 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>嘗試以選用的逾時，在寫入模式下進入鎖定狀態。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數；若要永遠等候，則為 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)。</param>
        <summary>嘗試以選用的逾時，在寫入模式下進入鎖定狀態。</summary>
        <returns>
          如果呼叫的執行緒已進入寫入模式，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 如果其他的執行緒已進入讀取模式鎖定，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法會封鎖，直到這些執行緒都結束讀取的模式或經過逾時間隔。 等待進入寫入模式封鎖執行緒，而嘗試進入讀取模式下或可升級模式的其他執行緒會封鎖直到執行緒等待進入寫入模式，其中已逾時或者已進入寫入模式，然後再從它然後結束。  
  
> [!NOTE]
>  如果鎖定允許遞迴已進入寫入模式鎖定的執行緒可以輸入遞迴寫入模式，即使其他執行緒等待進入寫入模式。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法來進入寫入模式，以逾時的鎖定。範例所示的方法會將新的索引鍵/值組加入至同步處理快取。 如果已指定逾時間隔超過在執行緒進入鎖定之前，此方法會傳回`false`。 方法會傳回`true`如果索引鍵/值組已加入。  
  
 如果機碼已經快取中，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。 A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端都結束鎖定。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性為 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒已進入鎖定狀態。  
  
 -或-  
  
 目前執行緒一開始已進入讀取模式的鎖定狀態，因此嘗試進入寫入模式可能會造成死結。  
  
 -或-  
  
 遞迴的次數會超過計數器的容量。 限制過大，使應用程式永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 的值為負，但不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，這是唯一允許的負值。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的間隔，或 -1 毫秒無限期等待。</param>
        <summary>嘗試以選用的逾時，在寫入模式下進入鎖定狀態。</summary>
        <returns>
          如果呼叫的執行緒已進入寫入模式，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 如果其他的執行緒已進入讀取模式鎖定，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法會封鎖，直到這些執行緒都結束讀取的模式或經過逾時間隔。 等待進入寫入模式封鎖執行緒，而嘗試進入讀取模式下或可升級模式的其他執行緒會封鎖直到執行緒等待進入寫入模式，其中已逾時或者已進入寫入模式，然後再從它然後結束。  
  
> [!NOTE]
>  如果鎖定允許遞迴已進入寫入模式鎖定的執行緒可以輸入遞迴寫入模式，即使其他執行緒等待進入寫入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性為 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒已進入鎖定狀態。  
  
 -或-  
  
 目前執行緒一開始已進入讀取模式的鎖定狀態，因此嘗試進入寫入模式可能會造成死結。  
  
 -或-  
  
 遞迴的次數會超過計數器的容量。 限制過大，使應用程式永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值為負，但不等於 -1 毫秒，這是唯一允許的負值。  
  
 -或-  
  
 <paramref name="timeout" /> 的值大於 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得等待進入讀取模式鎖定狀態的執行緒總數。</summary>
        <value>等待進入讀取模式的執行緒總數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 計算時，可以變更結果。 因此，它並不安全根據此屬性決定。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A>產生事件記錄檔項目，如果執行緒被封鎖，等待進入讀取的模式，數目超過臨界值的屬性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得等待進入可升級模式鎖定狀態的執行緒總數。</summary>
        <value>等待進入可升級模式的執行緒總數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 計算時，可以變更結果。 因此，它並不安全根據此屬性決定。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A>產生事件記錄檔項目，如果執行緒被封鎖，等待進入可升級模式，數目超過臨界值的屬性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得等待進入寫入模式鎖定狀態的執行緒總數。</summary>
        <value>等待進入寫入模式的執行緒總數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 計算時，可以變更結果。 因此，它並不安全根據此屬性決定。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A>產生的事件記錄檔項目，就會封鎖，等待進入寫入模式的執行緒數目超過臨界值的屬性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>