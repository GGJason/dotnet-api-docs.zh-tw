<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ba249b86c9e38696438690262b884a5bac97ef6b" /><Meta Name="ms.sourcegitcommit" Value="95e24aee1283af2f120fc5da4b0bdc0712ab698f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65155808" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="a3951-101">代表鎖定，用來管理資源存取，允許多個執行緒的讀取權限或獨佔寫入權限。</span><span class="sxs-lookup"><span data-stu-id="a3951-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-102">使用<xref:System.Threading.ReaderWriterLockSlim>来保護的資源，是由多個執行緒所讀取和寫入至一個執行緒一次。</span><span class="sxs-lookup"><span data-stu-id="a3951-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="a3951-103"><xref:System.Threading.ReaderWriterLockSlim> 可讓多個執行緒處於讀取模式，允許一個執行緒處於寫入模式的鎖定，獨佔擁有權和允許一個執行緒已進入可升級讀取模式，從中執行緒可以升級至寫入模式，而不必放棄它的讀取權限s 讀取資源的存取權。</span><span class="sxs-lookup"><span data-stu-id="a3951-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-104"><xref:System.Threading.ReaderWriterLockSlim> 類似於 <xref:System.Threading.ReaderWriterLock>，但是它有遞迴以及升級和降級鎖定狀態的簡化規則。</span><span class="sxs-lookup"><span data-stu-id="a3951-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="a3951-105"><xref:System.Threading.ReaderWriterLockSlim> 可避免可能發生死結的許多情況。</span><span class="sxs-lookup"><span data-stu-id="a3951-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="a3951-106">此外，<xref:System.Threading.ReaderWriterLockSlim> 的效能明顯優於 <xref:System.Threading.ReaderWriterLock>。</span><span class="sxs-lookup"><span data-stu-id="a3951-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="a3951-107">建議針對所有新的開發使用 <xref:System.Threading.ReaderWriterLockSlim>。</span><span class="sxs-lookup"><span data-stu-id="a3951-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="a3951-108">根據預設的新執行個體<xref:System.Threading.ReaderWriterLockSlim>以建立<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>旗標，並不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="a3951-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="a3951-109">這項預設原則被建議所有新的開發，因為遞迴會引進不必要的複雜性，並讓您的程式碼更容易發生死結。</span><span class="sxs-lookup"><span data-stu-id="a3951-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="a3951-110">若要簡化從現有的移轉專案中使用<xref:System.Threading.Monitor>或是<xref:System.Threading.ReaderWriterLock>，您可以使用<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>建立的執行個體的旗標<xref:System.Threading.ReaderWriterLockSlim>，允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="a3951-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="a3951-111">執行緒可以進入三種模式的鎖定： 讀取模式 」、 「 寫入模式，以及 「 可升級讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="a3951-112">(在本主題的其餘部分，「 讀取可升級模式 」 指 「 進入可升級模式 」 和片語"輸入`x`模式 」 使用順序優先於較長 」 輸入中的鎖定`x`模式 」。)</span><span class="sxs-lookup"><span data-stu-id="a3951-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="a3951-113">遞迴原則，不論只有一個執行緒可以處於寫入模式，在任何時間。</span><span class="sxs-lookup"><span data-stu-id="a3951-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="a3951-114">當執行緒處於寫入模式時，沒有其他執行緒可以進入任何模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="a3951-115">只有一個執行緒可以進入可升級模式是在任何時間。</span><span class="sxs-lookup"><span data-stu-id="a3951-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="a3951-116">任意數目的執行緒可以處於讀取模式，而且可以有一個執行緒進入可升級模式中其他執行緒處於讀取模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a3951-117">此類型會實作<xref:System.IDisposable>介面。</span><span class="sxs-lookup"><span data-stu-id="a3951-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="a3951-118">當您完成使用型別時，您應該處置它直接或間接。</span><span class="sxs-lookup"><span data-stu-id="a3951-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="a3951-119">若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="a3951-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="a3951-120">若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。</span><span class="sxs-lookup"><span data-stu-id="a3951-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="a3951-121">如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。</span><span class="sxs-lookup"><span data-stu-id="a3951-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="a3951-122"><xref:System.Threading.ReaderWriterLockSlim> 具有 managed 執行緒親和性;也就是說，每個<xref:System.Threading.Thread>物件必須讓自己進入或離開鎖定模式的方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="a3951-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="a3951-123">沒有任何執行緒可以變更另一個執行緒的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="a3951-124">如果<xref:System.Threading.ReaderWriterLockSlim>不允許遞迴時，執行緒嘗試進入鎖定可以封鎖原因有幾種：</span><span class="sxs-lookup"><span data-stu-id="a3951-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="a3951-125">嘗試進入讀取的模式的區塊，如果沒有執行緒等待進入寫入模式，或是在寫入模式中有單一執行緒的執行緒。</span><span class="sxs-lookup"><span data-stu-id="a3951-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a3951-126">寫入器會排入佇列時，將封鎖新讀取器是偏重寫入器鎖定的公平性原則。</span><span class="sxs-lookup"><span data-stu-id="a3951-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="a3951-127">目前的公平性原則公平性讀取器和寫入器，來提升產能的最常見的案例之間取得平衡。</span><span class="sxs-lookup"><span data-stu-id="a3951-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="a3951-128">未來的版本[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]可能會導入新的公平性化原則。</span><span class="sxs-lookup"><span data-stu-id="a3951-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="a3951-129">嘗試進入可升級模式的區塊，如果已經有執行緒在進入可升級模式中，如果沒有執行緒等待進入寫入模式，或如果在寫入模式中有單一執行緒的執行緒。</span><span class="sxs-lookup"><span data-stu-id="a3951-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="a3951-130">嘗試進入寫入模式的區塊，如果沒有任何三個模式中的執行緒的執行緒。</span><span class="sxs-lookup"><span data-stu-id="a3951-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="a3951-131">升級和降級鎖定</span><span class="sxs-lookup"><span data-stu-id="a3951-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="a3951-132">可升級模式適用於情況下，執行緒通常會從讀取受保護的資源，但可能要寫入其中，如果符合一些條件。</span><span class="sxs-lookup"><span data-stu-id="a3951-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="a3951-133">執行緒已進入<xref:System.Threading.ReaderWriterLockSlim>可升級模式具有讀取存取權受保護的資源，以及可以升級為寫入模式，藉由呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a3951-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="a3951-134">中可以有只有一個執行緒進入可升級模式一次，因為升級至寫入模式不能發生死結時不允許遞迴，這是預設原則。</span><span class="sxs-lookup"><span data-stu-id="a3951-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a3951-135">不論遞迴原則，一開始進入讀取模式不允許升級進入可升級模式 」 或 「 寫入模式，因為該模式會發生死結的機率。</span><span class="sxs-lookup"><span data-stu-id="a3951-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="a3951-136">例如，如果兩個執行緒同時嘗試進入讀取模式中的寫入模式，它們會鎖死。</span><span class="sxs-lookup"><span data-stu-id="a3951-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="a3951-137">可升級模式的設計可避免發生這類死結。</span><span class="sxs-lookup"><span data-stu-id="a3951-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="a3951-138">如果在讀取模式，正在升級封鎖的執行緒中有其他執行緒。</span><span class="sxs-lookup"><span data-stu-id="a3951-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="a3951-139">執行緒已封鎖，而其他的執行緒嘗試進入讀取的模式，將會遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="a3951-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="a3951-140">當所有執行緒都結束讀取模式中時，已封鎖升級的執行緒會進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="a3951-141">如果有其他執行緒等待進入寫入模式，它們將持續封鎖，因為可升級模式是單一執行緒會讓使用者無法獲得獨佔資源存取權。</span><span class="sxs-lookup"><span data-stu-id="a3951-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="a3951-142">當進入可升級模式中的執行緒結束寫入模式時，其他執行緒等待進入讀取的模式，可以這麼做，除非有執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="a3951-143">可升級模式中的執行緒可以升級並無限期，降級，只要它是唯一的執行緒將寫入至受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="a3951-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a3951-144">如果您允許多個執行緒進入寫入模式或進入可升級模式，您必須允許單一執行緒獨佔進入可升級模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="a3951-145">否則，執行緒嘗試進入寫入模式直接將會永遠被封鎖，且已被封鎖，而其他執行緒將無法進入讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="a3951-146">可升級模式中的執行緒可以降級為讀取模式，第一次呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法，然後呼叫<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="a3951-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="a3951-147">即使允許所有的鎖定遞迴原則，此降級模式<xref:System.Threading.LockRecursionPolicy.NoRecursion>。</span><span class="sxs-lookup"><span data-stu-id="a3951-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="a3951-148">降級為讀取模式之後，執行緒無法重新輸入可升級模式，直到它具有結束讀取模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="a3951-149">輸入鎖定以遞迴方式</span><span class="sxs-lookup"><span data-stu-id="a3951-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="a3951-150">您可以建立<xref:System.Threading.ReaderWriterLockSlim>使用支援遞迴鎖定項目<xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29>建構函式指定鎖定原則，並指定<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a3951-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-151">使用遞迴不會建議新的程式開發，因為它會引進不必要的複雜性，並讓您的程式碼更容易發生死結。</span><span class="sxs-lookup"><span data-stu-id="a3951-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="a3951-152">針對<xref:System.Threading.ReaderWriterLockSlim>可讓遞迴功能，可說是下列相關執行緒可以進入的模式：</span><span class="sxs-lookup"><span data-stu-id="a3951-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="a3951-153">讀取模式中的執行緒可以進入讀取的模式遞迴的但無法進入寫入模式或進入可升級模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="a3951-154">如果它嘗試這樣做，請<xref:System.Threading.LockRecursionException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="a3951-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="a3951-155">進入讀取模式，然後進入寫入模式，或進入可升級模式是死結的機率與模式，因此不允許。</span><span class="sxs-lookup"><span data-stu-id="a3951-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="a3951-156">如前文所述，就必須升級鎖定的情況下提供進入可升級模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="a3951-157">可升級模式中的執行緒可以在寫入模式，及/或讀取的模式中，輸入，並可以輸入任何三種模式以遞迴方式。</span><span class="sxs-lookup"><span data-stu-id="a3951-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="a3951-158">不過，嘗試進入寫入模式區塊讀取模式中是否有其他執行緒。</span><span class="sxs-lookup"><span data-stu-id="a3951-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="a3951-159">寫入模式中的執行緒會讀取的模式，及/或可升級模式，可以輸入，並可以輸入任何三種模式以遞迴方式。</span><span class="sxs-lookup"><span data-stu-id="a3951-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="a3951-160">不進入鎖定的執行緒可以進入任何模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="a3951-161">這項嘗試可能會封鎖嘗試將輸入的是非遞迴鎖定理由相同。</span><span class="sxs-lookup"><span data-stu-id="a3951-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="a3951-162">執行緒可以結束它已經進入依任何順序的模式，只要結束每個進入該模式下的次數相同的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="a3951-163">如果執行緒嘗試次數過多時，結束模式，或結束的模式，它已經不進入<xref:System.Threading.SynchronizationLockException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="a3951-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="a3951-164">鎖定狀態</span><span class="sxs-lookup"><span data-stu-id="a3951-164">Lock States</span></span>  
 <span data-ttu-id="a3951-165">您可能會有用來看待鎖定的狀態中的條款。</span><span class="sxs-lookup"><span data-stu-id="a3951-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="a3951-166">A<xref:System.Threading.ReaderWriterLockSlim>可以處於四種狀態之一： 不是輸入讀取、 升級和寫入。</span><span class="sxs-lookup"><span data-stu-id="a3951-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="a3951-167">未輸入：在此狀態下，沒有任何執行緒已進入鎖定 （或所有執行緒都結束鎖定）。</span><span class="sxs-lookup"><span data-stu-id="a3951-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="a3951-168">讀取：在此狀態下，一或多個執行緒已進入鎖定的讀取權限受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="a3951-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a3951-169">執行緒可以進入讀取模式鎖定使用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法，或從 可升級模式降級。</span><span class="sxs-lookup"><span data-stu-id="a3951-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="a3951-170">升級：在此狀態下，一個執行緒已升級為寫入權限的選項與讀取權限進入鎖定 （也就是在進入可升級模式中），以及零個或多個執行緒已進入鎖定的讀取權限。</span><span class="sxs-lookup"><span data-stu-id="a3951-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="a3951-171">一次不超過一個執行緒可以進入鎖定升級; 的選項嘗試進入可升級模式的其他執行緒會遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="a3951-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="a3951-172">撰寫程式碼：在此狀態下，一個執行緒已進入鎖定進行寫入存取受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="a3951-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="a3951-173">該執行緒已鎖定的獨佔擁有權。</span><span class="sxs-lookup"><span data-stu-id="a3951-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="a3951-174">嘗試進入鎖定，因為任何原因的其他任何執行緒被封鎖。</span><span class="sxs-lookup"><span data-stu-id="a3951-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="a3951-175">下表描述的鎖定狀態，不允許遞迴時，當執行緒的鎖定之間的轉換`t`採取最左邊的資料行中所述。</span><span class="sxs-lookup"><span data-stu-id="a3951-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="a3951-176">當時它採取動作，`t`不有任何模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="a3951-177">(的特殊情況下，`t`處於可升級模式所述的資料表註腳。)上方資料列描述鎖定的開始狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="a3951-178">資料格說明執行緒，會發生什麼事，並顯示在括號中的鎖定狀態的變更。</span><span class="sxs-lookup"><span data-stu-id="a3951-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="a3951-179">不進入 (N)</span><span class="sxs-lookup"><span data-stu-id="a3951-179">Not entered (N)</span></span>|<span data-ttu-id="a3951-180">Read (R)</span><span class="sxs-lookup"><span data-stu-id="a3951-180">Read (R)</span></span>|<span data-ttu-id="a3951-181">升級 (U)</span><span class="sxs-lookup"><span data-stu-id="a3951-181">Upgrade (U)</span></span>|<span data-ttu-id="a3951-182">寫入 (W)</span><span class="sxs-lookup"><span data-stu-id="a3951-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="a3951-183">`t` 進入讀取的模式</span><span class="sxs-lookup"><span data-stu-id="a3951-183">`t` enters read mode</span></span>|<span data-ttu-id="a3951-184">`t` 輸入 (R)。</span><span class="sxs-lookup"><span data-stu-id="a3951-184">`t` enters (R).</span></span>|<span data-ttu-id="a3951-185">`t` 如果執行緒正在等候寫入模式;，區塊否則，`t`進入。</span><span class="sxs-lookup"><span data-stu-id="a3951-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="a3951-186">`t` 如果執行緒正在等候寫入模式;，區塊否則，請`t`進入。<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="a3951-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="a3951-187">`t` 區塊。</span><span class="sxs-lookup"><span data-stu-id="a3951-187">`t` blocks.</span></span>|  
|<span data-ttu-id="a3951-188">`t` 進入可升級模式</span><span class="sxs-lookup"><span data-stu-id="a3951-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="a3951-189">`t` 輸入 (U)。</span><span class="sxs-lookup"><span data-stu-id="a3951-189">`t` enters (U).</span></span>|<span data-ttu-id="a3951-190">`t` 如果執行緒正在等候的區塊寫入模式或升級模式;否則，`t`進入 (U)。</span><span class="sxs-lookup"><span data-stu-id="a3951-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="a3951-191">`t` 區塊。</span><span class="sxs-lookup"><span data-stu-id="a3951-191">`t` blocks.</span></span>|<span data-ttu-id="a3951-192">`t` 區塊。</span><span class="sxs-lookup"><span data-stu-id="a3951-192">`t` blocks.</span></span>|  
|<span data-ttu-id="a3951-193">`t` 進入寫入模式</span><span class="sxs-lookup"><span data-stu-id="a3951-193">`t` enters write mode</span></span>|<span data-ttu-id="a3951-194">`t` 輸入 (W)。</span><span class="sxs-lookup"><span data-stu-id="a3951-194">`t` enters (W).</span></span>|<span data-ttu-id="a3951-195">`t` 區塊。</span><span class="sxs-lookup"><span data-stu-id="a3951-195">`t` blocks.</span></span>|<span data-ttu-id="a3951-196">`t` blocks.<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="a3951-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="a3951-197">`t` 區塊。</span><span class="sxs-lookup"><span data-stu-id="a3951-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="a3951-198"><sup>1</sup>如果`t`啟動出可升級模式，它會進入讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="a3951-199">此動作會永遠不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="a3951-199">This action never blocks.</span></span> <span data-ttu-id="a3951-200">鎖定狀態不會變更。</span><span class="sxs-lookup"><span data-stu-id="a3951-200">The lock state does not change.</span></span> <span data-ttu-id="a3951-201">（執行緒即可完成降級至結束可升級模式，以讀取模式）。</span><span class="sxs-lookup"><span data-stu-id="a3951-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="a3951-202"><sup>2</sup>如果`t`開始都處於可升級模式，它會封鎖有執行緒在讀取模式中。</span><span class="sxs-lookup"><span data-stu-id="a3951-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="a3951-203">否則，會升級寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="a3951-204">鎖定狀態會改變要寫入 (W)。</span><span class="sxs-lookup"><span data-stu-id="a3951-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="a3951-205">如果`t`封鎖有執行緒處於讀取模式，因為它進入寫入模式，只要在最後一個執行緒結束讀取的模式，即使有執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="a3951-206">當執行緒結束鎖定，就會發生狀態變更時下, 一個要喚醒的執行緒則選取路由，如下所示：</span><span class="sxs-lookup"><span data-stu-id="a3951-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="a3951-207">首先，執行緒正在等候寫入模式，並已可升級模式 （可以有最多一個這類執行緒）。</span><span class="sxs-lookup"><span data-stu-id="a3951-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="a3951-208">如果再次失敗，正在等候寫入模式的執行緒。</span><span class="sxs-lookup"><span data-stu-id="a3951-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="a3951-209">如果再次失敗，正在等候進入可升級模式的執行緒。</span><span class="sxs-lookup"><span data-stu-id="a3951-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="a3951-210">如果再次失敗，正在等候讀取模式的所有執行緒。</span><span class="sxs-lookup"><span data-stu-id="a3951-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="a3951-211">後續狀態一律是鎖定的寫入 (W) 在第一個兩個案例和升級 (U) 在第三個案例中，不論現有的執行緒觸發狀態變更時鎖定的狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="a3951-212">在最後一個案例中，鎖定的狀態是升級 (U) 中是否有一個執行緒進入可升級模式之後的狀態變更和 Read (R) 否則不論先前的狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-213">下列範例顯示簡單的同步處理快取保存字串與整數索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a3951-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="a3951-214">執行個體<xref:System.Threading.ReaderWriterLockSlim>用來同步存取<xref:System.Collections.Generic.Dictionary%602>做為內部的快取。</span><span class="sxs-lookup"><span data-stu-id="a3951-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="a3951-215">範例包括簡單的方法，來新增至快取、 從快取中，刪除並從讀取快取。</span><span class="sxs-lookup"><span data-stu-id="a3951-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="a3951-216">為了示範逾時，此範例也包含的方法，則可以這麼內指定的逾時，才加入至快取。</span><span class="sxs-lookup"><span data-stu-id="a3951-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="a3951-217">為了示範可升級模式，此範例包含方法，可擷取索引鍵相關聯的值，並比較它與新的值。</span><span class="sxs-lookup"><span data-stu-id="a3951-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="a3951-218">如果值未變更，則方法會傳回狀態，指出沒有變更。</span><span class="sxs-lookup"><span data-stu-id="a3951-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="a3951-219">如果不找到索引鍵的任何值，則會插入的索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="a3951-219">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="a3951-220">如果值已變更，就會更新。</span><span class="sxs-lookup"><span data-stu-id="a3951-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="a3951-221">可升級模式，可讓執行緒從讀取權限寫入權限，如有需要死結的風險的情況下升級。</span><span class="sxs-lookup"><span data-stu-id="a3951-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="a3951-222">此範例也包含巢狀的列舉，指定將示範可升級模式的方法的傳回值。</span><span class="sxs-lookup"><span data-stu-id="a3951-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="a3951-223">此範例會使用預設建構函式來建立鎖定，因此不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="a3951-223">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="a3951-224">程式設計<xref:System.Threading.ReaderWriterLockSlim>是更簡單且較不容易發生錯誤，當鎖定不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="a3951-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="a3951-225">下列程式碼然後使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。</span><span class="sxs-lookup"><span data-stu-id="a3951-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="a3951-226">它會建立三項工作。</span><span class="sxs-lookup"><span data-stu-id="a3951-226">It creates three tasks.</span></span> <span data-ttu-id="a3951-227">第一個陣列中儲存的蔬菜名稱寫入`SynchronizedCache`執行個體。</span><span class="sxs-lookup"><span data-stu-id="a3951-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="a3951-228">第二個和第三個工作顯示蔬菜、 以遞增順序 （從低索引最高索引），以遞減順序的第二個的第一個的名稱。</span><span class="sxs-lookup"><span data-stu-id="a3951-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="a3951-229">最後一項工作會搜尋字串"cucumber 」，並找到它，當呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來取代字串"綠色 bean"。</span><span class="sxs-lookup"><span data-stu-id="a3951-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="a3951-230">此型別具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="a3951-230">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a3951-231">初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="a3951-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3951-232">使用預設屬性值，初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="a3951-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-233">A<xref:System.Threading.ReaderWriterLockSlim>初始化與這個建構函式不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="a3951-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="a3951-234">亦即，<xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> 屬性會傳回 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a3951-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="a3951-235">如需有關遞迴原則和其效果的詳細資訊，請參閱 <<c0> <xref:System.Threading.LockRecursionPolicy> 列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="a3951-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-236">下列範例顯示簡單的同步處理快取保存字串與整數索引鍵。</span><span class="sxs-lookup"><span data-stu-id="a3951-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="a3951-237">執行個體<xref:System.Threading.ReaderWriterLockSlim>用來同步存取<xref:System.Collections.Generic.Dictionary%602>做為內部的快取。</span><span class="sxs-lookup"><span data-stu-id="a3951-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="a3951-238">無參數建構函式用來建立鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="a3951-239">範例包括簡單的方法，來新增至快取、 從快取中，刪除並從讀取快取。</span><span class="sxs-lookup"><span data-stu-id="a3951-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="a3951-240">為了示範逾時，此範例也包含的方法，則可以這麼內指定的逾時，才加入至快取。</span><span class="sxs-lookup"><span data-stu-id="a3951-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="a3951-241">為了示範可升級模式，此範例包含方法，可擷取索引鍵相關聯的值，並比較它與新的值。</span><span class="sxs-lookup"><span data-stu-id="a3951-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="a3951-242">如果值未變更，則方法會傳回狀態，指出沒有變更。</span><span class="sxs-lookup"><span data-stu-id="a3951-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="a3951-243">如果不找到索引鍵的任何值，則會插入的索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="a3951-243">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="a3951-244">如果值已變更，就會更新。</span><span class="sxs-lookup"><span data-stu-id="a3951-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="a3951-245">可升級模式，可讓執行緒從讀取權限寫入權限，如有需要死結的風險的情況下升級。</span><span class="sxs-lookup"><span data-stu-id="a3951-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="a3951-246">此範例也包含巢狀的列舉，指定將示範可升級模式的方法的傳回值。</span><span class="sxs-lookup"><span data-stu-id="a3951-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="a3951-247">此範例會使用預設建構函式來建立鎖定，因此不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="a3951-247">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="a3951-248">程式設計<xref:System.Threading.ReaderWriterLockSlim>是更簡單且較不容易發生錯誤，當鎖定不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="a3951-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="a3951-249">下列程式碼然後使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。</span><span class="sxs-lookup"><span data-stu-id="a3951-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="a3951-250">它會建立三項工作。</span><span class="sxs-lookup"><span data-stu-id="a3951-250">It creates three tasks.</span></span> <span data-ttu-id="a3951-251">第一個陣列中儲存的蔬菜名稱寫入`SynchronizedCache`執行個體。</span><span class="sxs-lookup"><span data-stu-id="a3951-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="a3951-252">第二個和第三個工作顯示蔬菜、 以遞增順序 （從低索引最高索引），以遞減順序的第二個的第一個的名稱。</span><span class="sxs-lookup"><span data-stu-id="a3951-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="a3951-253">最後一項工作會搜尋字串"cucumber 」，並找到它，當呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來取代字串"綠色 bean"。</span><span class="sxs-lookup"><span data-stu-id="a3951-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy"><span data-ttu-id="a3951-254">一個列舉值，指定鎖定遞迴原則。</span><span class="sxs-lookup"><span data-stu-id="a3951-254">One of the enumeration values that specifies the lock recursion policy.</span></span></param>
        <summary><span data-ttu-id="a3951-255">指定鎖定遞迴原則，初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="a3951-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-256">遞迴原則決定多次進入鎖定的執行緒上的限制。</span><span class="sxs-lookup"><span data-stu-id="a3951-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="a3951-257">例如，如果您建立鎖定時<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>執行緒已進入讀取模式的鎖定和<xref:System.Threading.LockRecursionException>執行緒會嘗試重新輸入中讀取模式鎖定便會擲回。</span><span class="sxs-lookup"><span data-stu-id="a3951-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="a3951-258">同樣地，如果執行緒已進入寫入模式的鎖定<xref:System.Threading.LockRecursionException>如果執行緒嘗試重新輸入在任何模式的鎖定，會擲回。</span><span class="sxs-lookup"><span data-stu-id="a3951-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-259">可升級模式中的執行緒可以升級為寫入模式，或降級為讀取模式，不論鎖定遞迴原則設定。</span><span class="sxs-lookup"><span data-stu-id="a3951-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="a3951-260">不論遞迴原則，一開始進入讀取模式不允許升級進入可升級模式 」 或 「 寫入模式，因為該模式會發生死結的機率。</span><span class="sxs-lookup"><span data-stu-id="a3951-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="a3951-261">如需有關遞迴原則和其效果的詳細資訊，請參閱 <<c0> <xref:System.Threading.LockRecursionPolicy> 列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="a3951-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-262">下列範例顯示兩個例外狀況，其中一個，取決於<xref:System.Threading.LockRecursionPolicy>設定，另一個則否。</span><span class="sxs-lookup"><span data-stu-id="a3951-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="a3951-263">在第一個案例中，執行緒會進入讀取的模式，並嘗試遞迴地進入讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="a3951-264">如果<xref:System.Threading.ReaderWriterLockSlim>遞迴原則設定的預設建構函式會建立<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a3951-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the default constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="a3951-265">如果<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>用以建立<xref:System.Threading.ReaderWriterLockSlim>，會擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a3951-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="a3951-266">在第二個案例中，在執行緒進入讀取的模式，然後嘗試進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="a3951-267"><xref:System.Threading.LockRecursionException> 無論鎖定遞迴原則就會擲回。</span><span class="sxs-lookup"><span data-stu-id="a3951-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="a3951-268">下列程式碼然後使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。</span><span class="sxs-lookup"><span data-stu-id="a3951-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="a3951-269">它會建立三項工作。</span><span class="sxs-lookup"><span data-stu-id="a3951-269">It creates three tasks.</span></span> <span data-ttu-id="a3951-270">第一個陣列中儲存的蔬菜名稱寫入`SynchronizedCache`執行個體。</span><span class="sxs-lookup"><span data-stu-id="a3951-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="a3951-271">第二個和第三個工作顯示蔬菜、 以遞增順序 （從低索引最高索引），以遞減順序的第二個的第一個的名稱。</span><span class="sxs-lookup"><span data-stu-id="a3951-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="a3951-272">最後一項工作會搜尋字串"cucumber 」，並找到它，當呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來取代字串"綠色 bean"。</span><span class="sxs-lookup"><span data-stu-id="a3951-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3951-273">取得已進入讀取模式鎖定狀態的唯一執行緒總數。</span><span class="sxs-lookup"><span data-stu-id="a3951-273">Gets the total number of unique threads that have entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="a3951-274">已進入讀取模式鎖定狀態的唯一執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="a3951-274">The number of unique threads that have entered the lock in read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-275">執行緒只計算一次，即使鎖定允許遞迴和執行緒已進入讀取的模式多次。</span><span class="sxs-lookup"><span data-stu-id="a3951-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="a3951-276">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="a3951-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="a3951-277">一旦已計算出，則可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="a3951-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="a3951-278">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="a3951-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-279">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A>屬性，以產生事件記錄檔項目，如果在讀取模式中的執行緒數目超過臨界值。</span><span class="sxs-lookup"><span data-stu-id="a3951-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3951-280">釋放 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別目前的執行個體所使用的全部資源。</span><span class="sxs-lookup"><span data-stu-id="a3951-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-281"><xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 使用完畢時，請呼叫 <xref:System.Threading.ReaderWriterLockSlim>。</span><span class="sxs-lookup"><span data-stu-id="a3951-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="a3951-282"><xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 方法會將 <xref:System.Threading.ReaderWriterLockSlim> 保留在無法使用的狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="a3951-283">之後呼叫<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>，您必須釋放所有的參考<xref:System.Threading.ReaderWriterLockSlim>讓記憶體回收行程可以回收記憶體，<xref:System.Threading.ReaderWriterLockSlim>所佔用。</span><span class="sxs-lookup"><span data-stu-id="a3951-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="a3951-284">如需詳細資訊，請參閱 <<c0> [ 清除 Unmanaged 資源向上](~/docs/standard/garbage-collection/unmanaged.md)並[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="a3951-284">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-285">請務必呼叫<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>您釋放最後一個參考之前<xref:System.Threading.ReaderWriterLockSlim>物件。</span><span class="sxs-lookup"><span data-stu-id="a3951-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="a3951-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="a3951-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="a3951-287">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-287">-or-</span></span> 
 <span data-ttu-id="a3951-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="a3951-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="a3951-289">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-289">-or-</span></span> 
 <span data-ttu-id="a3951-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> 大於零。</span><span class="sxs-lookup"><span data-stu-id="a3951-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3951-291">嘗試進入讀取模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-291">Tries to enter the lock in read mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-292">這個方法會封鎖，直到呼叫的執行緒進入鎖定，並因此可能永遠不會傳回。</span><span class="sxs-lookup"><span data-stu-id="a3951-292">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="a3951-293">使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法，以封鎖指定的間隔，然後再將 如果呼叫的執行緒尚未進入讀取模式，在該間隔期間。</span><span class="sxs-lookup"><span data-stu-id="a3951-293">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="a3951-294">多個執行緒可以進入讀取的模式，在相同的時間。</span><span class="sxs-lookup"><span data-stu-id="a3951-294">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="a3951-295">如果一或多個執行緒在等待進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法封鎖，直到這些執行緒已逾時或已進入寫入模式，然後結束它。</span><span class="sxs-lookup"><span data-stu-id="a3951-295">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-296">如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-296">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="a3951-297">當其他執行緒處於讀取模式時，最多一個執行緒可以進入可升級模式中。</span><span class="sxs-lookup"><span data-stu-id="a3951-297">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="a3951-298">如果其他執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法立即進入讀取的模式，並不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="a3951-298">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-299">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>進入讀取模式鎖定的方法。</span><span class="sxs-lookup"><span data-stu-id="a3951-299">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="a3951-300">在範例中所示的方法會擷取索引鍵相關聯的值。</span><span class="sxs-lookup"><span data-stu-id="a3951-300">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="a3951-301">如果找不到金鑰，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。</span><span class="sxs-lookup"><span data-stu-id="a3951-301">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="a3951-302">A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，確保呼叫端結束讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-302">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="a3951-303">此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="a3951-303">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="a3951-304"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒嘗試在已經保留讀取鎖定的情況下取得讀取鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-304">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span></span>  
  
<span data-ttu-id="a3951-305">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-305">-or-</span></span> 
<span data-ttu-id="a3951-306"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒嘗試在已經保留寫入鎖定的情況下取得讀取鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-306">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span></span>  
  
<span data-ttu-id="a3951-307">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-307">-or-</span></span> 
<span data-ttu-id="a3951-308">遞迴的次數會超過計數器的容量。</span><span class="sxs-lookup"><span data-stu-id="a3951-308">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="a3951-309">這項限制非常寬鬆，所以應用程式應該永遠都不會發生這種例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a3951-309">This limit is so large that applications should never encounter this exception.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a3951-310"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="a3951-310">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3951-311">嘗試進入可升級模式的鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-311">Tries to enter the lock in upgradeable mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-312">這個方法會封鎖，直到呼叫的執行緒進入鎖定，並因此可能永遠不會傳回。</span><span class="sxs-lookup"><span data-stu-id="a3951-312">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="a3951-313">使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>封鎖指定的間隔，然後再將 如果呼叫的執行緒尚未進入可升級模式在該間隔期間的方法。</span><span class="sxs-lookup"><span data-stu-id="a3951-313">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="a3951-314">當執行緒通常存取受保護的資源，則使用可升級模式<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。</span><span class="sxs-lookup"><span data-stu-id="a3951-314">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="a3951-315">可升級模式中的執行緒可以降級為讀取模式，或升級為寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-315">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="a3951-316">只有一個執行緒可以進入可升級模式，在任何指定時間。</span><span class="sxs-lookup"><span data-stu-id="a3951-316">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="a3951-317">如果執行緒在進入可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒可以在即使有等待進入可升級模式的執行緒進入讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-317">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="a3951-318">如果一或多個執行緒在等待進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法封鎖，直到這些執行緒已逾時或已進入寫入模式，然後結束它。</span><span class="sxs-lookup"><span data-stu-id="a3951-318">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-319">如果鎖定允許遞迴，已進入可升級模式鎖定的執行緒可以進入可升級模式遞迴地進入，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-319">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-320">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來進入可升級模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-320">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="a3951-321">A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，確保呼叫端結束可升級模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-321">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="a3951-322">在範例中所示的方法擷取索引鍵相關聯的值，並比較它與新的值。</span><span class="sxs-lookup"><span data-stu-id="a3951-322">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="a3951-323">如果值未變更，則方法會傳回狀態，指出沒有變更。</span><span class="sxs-lookup"><span data-stu-id="a3951-323">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="a3951-324">沒有值找到索引鍵，會插入索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="a3951-324">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="a3951-325">如果值已變更，就會更新。</span><span class="sxs-lookup"><span data-stu-id="a3951-325">If the value has changed, it is updated.</span></span> <span data-ttu-id="a3951-326">可升級模式，可讓執行緒升級讀取的鎖定，如有需要而死結的風險。</span><span class="sxs-lookup"><span data-stu-id="a3951-326">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="a3951-327">此範例會使用預設建構函式來建立鎖定，因此不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="a3951-327">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="a3951-328">程式設計<xref:System.Threading.ReaderWriterLockSlim>是更簡單且較不容易發生錯誤，當鎖定不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="a3951-328">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="a3951-329">此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="a3951-329">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="a3951-330"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定在任何模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-330">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="a3951-331">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-331">-or-</span></span> 
<span data-ttu-id="a3951-332">目前的執行緒已進入讀取的模式，因此嘗試進入可升級模式，則會造成死結的可能性。</span><span class="sxs-lookup"><span data-stu-id="a3951-332">The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="a3951-333">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-333">-or-</span></span> 
<span data-ttu-id="a3951-334">遞迴的次數會超過計數器的容量。</span><span class="sxs-lookup"><span data-stu-id="a3951-334">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="a3951-335">限制是很大，應用程式應該永遠不會發生這個情形。</span><span class="sxs-lookup"><span data-stu-id="a3951-335">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a3951-336"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="a3951-336">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3951-337">嘗試進入寫入模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-337">Tries to enter the lock in write mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-338">這個方法會封鎖，直到呼叫的執行緒進入鎖定，並因此可能永遠不會傳回。</span><span class="sxs-lookup"><span data-stu-id="a3951-338">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="a3951-339">使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>封鎖指定的間隔，然後再將 如果呼叫的執行緒尚未進入寫入模式在該間隔期間的方法。</span><span class="sxs-lookup"><span data-stu-id="a3951-339">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="a3951-340">如果其他執行緒已進入讀取模式的鎖定，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法封鎖，直到這些執行緒都結束讀取模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-340">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="a3951-341">等待進入寫入模式的執行緒時，額外的執行緒嘗試進入讀取的模式] 或 [可升級模式封鎖，直到等待進入寫入模式的所有執行緒都都是逾時或已進入寫入模式，然後結束它。</span><span class="sxs-lookup"><span data-stu-id="a3951-341">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-342">如果鎖定允許遞迴，已進入寫入模式鎖定的執行緒可以進入寫入模式以遞迴方式，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-342">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-343">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>進入寫入模式鎖定的方法。</span><span class="sxs-lookup"><span data-stu-id="a3951-343">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="a3951-344">範例所示的方法會將新的索引鍵/值組加入至同步處理的快取。</span><span class="sxs-lookup"><span data-stu-id="a3951-344">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="a3951-345">如果快取中，所擲回的內部例外狀況已有索引鍵<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。</span><span class="sxs-lookup"><span data-stu-id="a3951-345">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="a3951-346">A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端結束寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-346">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="a3951-347">此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="a3951-347">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="a3951-348"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定在任何模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-348">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="a3951-349">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-349">-or-</span></span> 
<span data-ttu-id="a3951-350">目前的執行緒已進入真實模式，而且還沒有擁有寫入鎖定，因此嘗試進入寫入模式鎖定可能會造成死結。</span><span class="sxs-lookup"><span data-stu-id="a3951-350">The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="a3951-351">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-351">-or-</span></span> 
<span data-ttu-id="a3951-352">遞迴的次數會超過計數器的容量。</span><span class="sxs-lookup"><span data-stu-id="a3951-352">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="a3951-353">限制是很大，應用程式應該永遠不會發生這個情形。</span><span class="sxs-lookup"><span data-stu-id="a3951-353">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a3951-354"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="a3951-354">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3951-355">減少讀取模式遞迴的計數，如果得出的計數為 0 (零)，則結束讀取模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-355">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-356">這個方法不是遞迴順序。</span><span class="sxs-lookup"><span data-stu-id="a3951-356">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="a3951-357">例如，如果執行緒進入可升級模式的鎖定，然後在讀取模式下進入鎖定的執行緒結束的兩種模式的順序無關緊要。</span><span class="sxs-lookup"><span data-stu-id="a3951-357">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="a3951-358">如果鎖定允許遞迴，執行緒可以進入寫入模式的鎖定，然後輸入它以遞迴方式讀取模式;在執行緒結束的順序模式讀寫模式並不重要。</span><span class="sxs-lookup"><span data-stu-id="a3951-358">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="a3951-359">結束鎖定，可能表示其他等候中執行緒。</span><span class="sxs-lookup"><span data-stu-id="a3951-359">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-360">下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，確保呼叫端結束讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-360">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="a3951-361">在範例中所示的方法會擷取索引鍵相關聯的值。</span><span class="sxs-lookup"><span data-stu-id="a3951-361">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="a3951-362">如果找不到金鑰，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。</span><span class="sxs-lookup"><span data-stu-id="a3951-362">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="a3951-363"><xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法用來進入讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-363">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="a3951-364">此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="a3951-364">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="a3951-365">目前執行緒尚未進入讀取模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-365">The current thread has not entered the lock in read mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3951-366">減少可升級模式遞迴的計數，如果得出的計數為 0 (零)，則結束可升級模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-366">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-367">這個方法不是遞迴順序。</span><span class="sxs-lookup"><span data-stu-id="a3951-367">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="a3951-368">例如，如果執行緒進入可升級模式的鎖定，然後在寫入模式下進入鎖定的執行緒結束的兩種模式的順序無關緊要。</span><span class="sxs-lookup"><span data-stu-id="a3951-368">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="a3951-369">如果鎖定允許遞迴，執行緒可以進入寫入模式鎖定，然後遞迴地進入可升級模式;在執行緒結束可升級模式和寫入模式的順序並不重要。</span><span class="sxs-lookup"><span data-stu-id="a3951-369">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="a3951-370">結束鎖定，可能表示其他等候中執行緒。</span><span class="sxs-lookup"><span data-stu-id="a3951-370">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-371">下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，確保呼叫端結束可升級模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-371">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="a3951-372">在範例中所示的方法擷取索引鍵相關聯的值，並比較它與新的值。</span><span class="sxs-lookup"><span data-stu-id="a3951-372">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="a3951-373">如果值未變更，則方法會傳回狀態，指出沒有變更。</span><span class="sxs-lookup"><span data-stu-id="a3951-373">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="a3951-374">沒有值找到索引鍵，會插入索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="a3951-374">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="a3951-375">如果值已變更，就會更新。</span><span class="sxs-lookup"><span data-stu-id="a3951-375">If the value has changed, it is updated.</span></span> <span data-ttu-id="a3951-376">可升級模式，可讓執行緒升級讀取的鎖定，如有需要而死結的風險。</span><span class="sxs-lookup"><span data-stu-id="a3951-376">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="a3951-377">此範例會使用預設建構函式來建立鎖定，因此不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="a3951-377">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="a3951-378">程式設計<xref:System.Threading.ReaderWriterLockSlim>是更簡單且較不容易發生錯誤，當鎖定不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="a3951-378">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="a3951-379">此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="a3951-379">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="a3951-380">目前執行緒尚未進入可升級模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-380">The current thread has not entered the lock in upgradeable mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a3951-381">減少寫入模式遞迴的計數，如果得出的計數為 0 (零)，則結束寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-381">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-382">這個方法不是遞迴順序。</span><span class="sxs-lookup"><span data-stu-id="a3951-382">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="a3951-383">例如，如果執行緒進入可升級模式的鎖定，然後在寫入模式下進入鎖定的執行緒結束的兩種模式的順序無關緊要。</span><span class="sxs-lookup"><span data-stu-id="a3951-383">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="a3951-384">如果鎖定允許遞迴，執行緒可以進入寫入模式的鎖定，然後輸入它以遞迴方式讀取模式;在執行緒結束的順序模式讀寫模式並不重要。</span><span class="sxs-lookup"><span data-stu-id="a3951-384">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="a3951-385">結束鎖定，可能表示其他等候中執行緒。</span><span class="sxs-lookup"><span data-stu-id="a3951-385">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-386">下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端結束寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-386">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="a3951-387">範例所示的方法會將新的索引鍵/值組加入至同步處理的快取。</span><span class="sxs-lookup"><span data-stu-id="a3951-387">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="a3951-388">如果快取中，所擲回的內部例外狀況已有索引鍵<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。</span><span class="sxs-lookup"><span data-stu-id="a3951-388">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="a3951-389"><xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法用來進入寫入模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-389">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="a3951-390">此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="a3951-390">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="a3951-391">目前執行緒尚未進入寫入模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-391">The current thread has not entered the lock in write mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3951-392">取得值，表示目前執行緒是否已進入讀取模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-392">Gets a value that indicates whether the current thread has entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="a3951-393">如果目前執行緒已進入讀取模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3951-393"><see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-394">這個屬性適用於判斷提示或其他偵錯的目的。</span><span class="sxs-lookup"><span data-stu-id="a3951-394">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="a3951-395">請勿使用它來控制控制程式執行流程。</span><span class="sxs-lookup"><span data-stu-id="a3951-395">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-396">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A>屬性，以產生判斷提示，如果目前執行緒已進入讀取模式的意外。</span><span class="sxs-lookup"><span data-stu-id="a3951-396">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3951-397">取得值，表示目前執行緒是否已進入可升級模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-397">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="a3951-398">如果目前執行緒已進入可升級模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3951-398"><see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-399">這個屬性適用於判斷提示或其他偵錯的目的。</span><span class="sxs-lookup"><span data-stu-id="a3951-399">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="a3951-400">請勿使用它來控制控制程式執行流程。</span><span class="sxs-lookup"><span data-stu-id="a3951-400">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-401">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A>如果目前執行緒已意外地進入可升級模式產生判斷提示的屬性。</span><span class="sxs-lookup"><span data-stu-id="a3951-401">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3951-402">取得值，表示目前執行緒是否已進入寫入模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-402">Gets a value that indicates whether the current thread has entered the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="a3951-403">如果目前執行緒已進入寫入模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3951-403"><see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-404">這個屬性適用於判斷提示或其他偵錯的目的。</span><span class="sxs-lookup"><span data-stu-id="a3951-404">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="a3951-405">請勿使用它來控制控制程式執行流程。</span><span class="sxs-lookup"><span data-stu-id="a3951-405">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-406">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A>如果目前執行緒已意外地進入寫入模式產生判斷提示的屬性。</span><span class="sxs-lookup"><span data-stu-id="a3951-406">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3951-407">取得值，表示目前 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件的遞迴原則。</span><span class="sxs-lookup"><span data-stu-id="a3951-407">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span></span></summary>
        <value><span data-ttu-id="a3951-408">一個列舉值，指定鎖定遞迴原則。</span><span class="sxs-lookup"><span data-stu-id="a3951-408">One of the enumeration values that specifies the lock recursion policy.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-409">遞迴原則決定多次進入鎖定的執行緒上的限制。</span><span class="sxs-lookup"><span data-stu-id="a3951-409">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="a3951-410">例如，如果您建立鎖定時<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>執行緒已進入讀取模式的鎖定和<xref:System.Threading.LockRecursionException>執行緒會嘗試重新輸入中讀取模式鎖定便會擲回。</span><span class="sxs-lookup"><span data-stu-id="a3951-410">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-411">可升級模式中的執行緒可以升級為寫入模式，或降級為讀取模式，不論鎖定遞迴原則設定。</span><span class="sxs-lookup"><span data-stu-id="a3951-411">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="a3951-412">不論遞迴原則，一開始進入讀取模式不允許升級進入可升級模式 」 或 「 寫入模式，因為該模式會發生死結的機率。</span><span class="sxs-lookup"><span data-stu-id="a3951-412">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="a3951-413">如需有關遞迴原則和其效果的詳細資訊，請參閱 <<c0> <xref:System.Threading.LockRecursionPolicy> 列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="a3951-413">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3951-414">取得目前執行緒已進入讀取模式鎖定的次數，做為遞迴的表示。</span><span class="sxs-lookup"><span data-stu-id="a3951-414">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="a3951-415">0 （零），如果目前執行緒尚未進入讀取模式，1，表示執行緒已進入讀取的模式，但是尚未遞迴進入該，或是*n*如果執行緒已遞迴進入鎖定*n* -1 次。</span><span class="sxs-lookup"><span data-stu-id="a3951-415">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-416">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="a3951-416">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="a3951-417">一旦已計算出，則可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="a3951-417">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="a3951-418">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="a3951-418">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3951-419">取得目前執行緒已進入可升級模式鎖定的次數，做為遞迴的表示。</span><span class="sxs-lookup"><span data-stu-id="a3951-419">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="a3951-420">0，表示目前執行緒尚未進入可升級模式，如果執行緒已進入可升級模式，但是已遞迴進入該，則為 1 或*n*如果執行緒已進入可升級模式遞迴*n* -1時間。</span><span class="sxs-lookup"><span data-stu-id="a3951-420">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-421">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="a3951-421">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="a3951-422">一旦已計算出，則可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="a3951-422">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="a3951-423">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="a3951-423">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3951-424">取得目前執行緒已進入寫入模式鎖定的次數，做為遞迴的表示。</span><span class="sxs-lookup"><span data-stu-id="a3951-424">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="a3951-425">0，表示目前執行緒尚未進入寫入模式中，1 如果執行緒已進入寫入模式，但是尚未遞迴進入該，或是*n*如果執行緒已進入寫入模式遞迴*n* -1 次。</span><span class="sxs-lookup"><span data-stu-id="a3951-425">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-426">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="a3951-426">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="a3951-427">一旦已計算出，則可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="a3951-427">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="a3951-428">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="a3951-428">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a3951-429">嘗試以選用的逾時，在讀取模式下進入鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-429">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="a3951-430">要等候的毫秒數；若要永遠等候，則為 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)。</span><span class="sxs-lookup"><span data-stu-id="a3951-430">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="a3951-431">嘗試以選用的整數逾時，進入讀取模式的鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-431">Tries to enter the lock in read mode, with an optional integer time-out.</span></span></summary>
        <returns><span data-ttu-id="a3951-432">如果呼叫執行緒已進入讀取模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3951-432"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-433">如果`millisecondsTimeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="a3951-433">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="a3951-434">多個執行緒可以進入讀取的模式，在相同的時間。</span><span class="sxs-lookup"><span data-stu-id="a3951-434">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="a3951-435">如果一或多個執行緒在等待進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或是呼叫執行緒自己的逾時間隔到期。</span><span class="sxs-lookup"><span data-stu-id="a3951-435">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-436">如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-436">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="a3951-437">當其他執行緒處於讀取模式時，有一個執行緒可以進入可升級模式中。</span><span class="sxs-lookup"><span data-stu-id="a3951-437">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="a3951-438">如果其他執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法立即進入讀取的模式，並不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="a3951-438">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="a3951-439"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-439">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="a3951-440">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-440">-or-</span></span> 
<span data-ttu-id="a3951-441">遞迴的次數會超過計數器的容量。</span><span class="sxs-lookup"><span data-stu-id="a3951-441">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="a3951-442">限制是很大，應用程式應該永遠不會發生這個情形。</span><span class="sxs-lookup"><span data-stu-id="a3951-442">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3951-443">值<paramref name="millisecondsTimeout" />是負數，但不等於<see cref="F:System.Threading.Timeout.Infinite" />(-1)，這是唯一允許的負值。</span><span class="sxs-lookup"><span data-stu-id="a3951-443">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a3951-444"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="a3951-444">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="a3951-445">等待的間隔，或 -1 毫秒無限期等待。</span><span class="sxs-lookup"><span data-stu-id="a3951-445">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="a3951-446">嘗試以選用的逾時，在讀取模式下進入鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-446">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="a3951-447">如果呼叫執行緒已進入讀取模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3951-447"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-448">如果`timeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="a3951-448">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="a3951-449">多個執行緒可以進入讀取模式鎖定，同時。</span><span class="sxs-lookup"><span data-stu-id="a3951-449">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="a3951-450">如果一個或多個執行緒已進入寫入模式中排入佇列，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或是呼叫執行緒自己的逾時間隔到期。</span><span class="sxs-lookup"><span data-stu-id="a3951-450">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-451">如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-451">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="a3951-452">當其他執行緒處於讀取模式時，有一個執行緒可以進入可升級模式中。</span><span class="sxs-lookup"><span data-stu-id="a3951-452">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="a3951-453">如果其他執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法立即進入讀取的模式，並不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="a3951-453">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="a3951-454"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-454">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="a3951-455">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-455">-or-</span></span> 
<span data-ttu-id="a3951-456">遞迴的次數會超過計數器的容量。</span><span class="sxs-lookup"><span data-stu-id="a3951-456">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="a3951-457">限制是很大，應用程式應該永遠不會發生這個情形。</span><span class="sxs-lookup"><span data-stu-id="a3951-457">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3951-458">值<paramref name="timeout" />是負數，但不等於-1 毫秒，這是唯一允許的負值。</span><span class="sxs-lookup"><span data-stu-id="a3951-458">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="a3951-459">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-459">-or-</span></span> 
<span data-ttu-id="a3951-460">值<paramref name="timeout" />大於<see cref="F:System.Int32.MaxValue" />毫秒為單位。</span><span class="sxs-lookup"><span data-stu-id="a3951-460">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a3951-461"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="a3951-461">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a3951-462">嘗試以選用的逾時，在可升級模式下進入鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-462">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="a3951-463">要等候的毫秒數；若要永遠等候，則為 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)。</span><span class="sxs-lookup"><span data-stu-id="a3951-463">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="a3951-464">嘗試以選用的逾時，在可升級模式下進入鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-464">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="a3951-465">如果呼叫執行緒已進入可升級模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3951-465"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-466">如果`millisecondsTimeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="a3951-466">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="a3951-467">當執行緒通常存取受保護的資源，則使用可升級模式<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。</span><span class="sxs-lookup"><span data-stu-id="a3951-467">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="a3951-468">可升級模式中的執行緒可以升級為寫入模式，或降級為讀取模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-468">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="a3951-469">只有一個執行緒可以進入可升級模式鎖定，在任何指定時間。</span><span class="sxs-lookup"><span data-stu-id="a3951-469">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="a3951-470">如果執行緒在進入可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒可以在即使有等待進入可升級模式的執行緒進入讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-470">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="a3951-471">如果一或多個執行緒在等待進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或是呼叫執行緒自己的逾時間隔到期。</span><span class="sxs-lookup"><span data-stu-id="a3951-471">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-472">如果鎖定允許遞迴，已進入可升級模式鎖定的執行緒可以進入可升級模式遞迴地進入，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-472">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="a3951-473"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-473">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="a3951-474">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-474">-or-</span></span> 
<span data-ttu-id="a3951-475">目前執行緒一開始在讀取模式中，進入鎖定，因此嘗試進入可升級模式，則會造成死結的可能性。</span><span class="sxs-lookup"><span data-stu-id="a3951-475">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="a3951-476">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-476">-or-</span></span> 
<span data-ttu-id="a3951-477">遞迴的次數會超過計數器的容量。</span><span class="sxs-lookup"><span data-stu-id="a3951-477">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="a3951-478">限制是很大，應用程式應該永遠不會發生這個情形。</span><span class="sxs-lookup"><span data-stu-id="a3951-478">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3951-479">值<paramref name="millisecondsTimeout" />是負數，但不等於<see cref="F:System.Threading.Timeout.Infinite" />(-1)，這是唯一允許的負值。</span><span class="sxs-lookup"><span data-stu-id="a3951-479">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a3951-480"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="a3951-480">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="a3951-481">等待的間隔，或 -1 毫秒無限期等待。</span><span class="sxs-lookup"><span data-stu-id="a3951-481">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="a3951-482">嘗試以選用的逾時，在可升級模式下進入鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-482">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="a3951-483">如果呼叫執行緒已進入可升級模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3951-483"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-484">如果`timeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="a3951-484">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="a3951-485">當執行緒通常存取受保護的資源，則使用可升級模式<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。</span><span class="sxs-lookup"><span data-stu-id="a3951-485">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="a3951-486">可升級模式中的執行緒可以升級為寫入模式，或降級為讀取模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-486">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="a3951-487">只有一個執行緒可以進入可升級模式鎖定，在任何指定時間。</span><span class="sxs-lookup"><span data-stu-id="a3951-487">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="a3951-488">如果執行緒在進入可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒可以在即使有等待進入可升級模式的執行緒進入讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-488">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="a3951-489">如果一或多個執行緒在等待進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或是呼叫執行緒自己的逾時間隔到期。</span><span class="sxs-lookup"><span data-stu-id="a3951-489">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-490">如果鎖定允許遞迴，已進入可升級模式鎖定的執行緒可以進入可升級模式遞迴地進入，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-490">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="a3951-491"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-491">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="a3951-492">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-492">-or-</span></span> 
<span data-ttu-id="a3951-493">目前執行緒一開始在讀取模式中，進入鎖定，因此嘗試進入可升級模式，則會造成死結的可能性。</span><span class="sxs-lookup"><span data-stu-id="a3951-493">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="a3951-494">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-494">-or-</span></span> 
<span data-ttu-id="a3951-495">遞迴的次數會超過計數器的容量。</span><span class="sxs-lookup"><span data-stu-id="a3951-495">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="a3951-496">限制是很大，應用程式應該永遠不會發生這個情形。</span><span class="sxs-lookup"><span data-stu-id="a3951-496">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3951-497">值<paramref name="timeout" />是負數，但不等於-1 毫秒，這是唯一允許的負值。</span><span class="sxs-lookup"><span data-stu-id="a3951-497">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="a3951-498">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-498">-or-</span></span> 
<span data-ttu-id="a3951-499">值<paramref name="timeout" />大於<see cref="F:System.Int32.MaxValue" />毫秒為單位。</span><span class="sxs-lookup"><span data-stu-id="a3951-499">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a3951-500"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="a3951-500">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a3951-501">嘗試以選用的逾時，在寫入模式下進入鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-501">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="a3951-502">要等候的毫秒數；若要永遠等候，則為 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)。</span><span class="sxs-lookup"><span data-stu-id="a3951-502">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="a3951-503">嘗試以選用的逾時，在寫入模式下進入鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-503">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="a3951-504">如果呼叫執行緒已進入寫入模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3951-504"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-505">如果`millisecondsTimeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="a3951-505">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="a3951-506">如果其他執行緒已進入讀取模式的鎖定，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法會封鎖，直到這些執行緒都結束讀取的模式或經過逾時間隔為止。</span><span class="sxs-lookup"><span data-stu-id="a3951-506">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="a3951-507">等待進入寫入模式，會封鎖執行緒，而嘗試進入讀取的模式或進入可升級模式的其他執行緒會封鎖直到執行緒等待進入寫入模式，有其中一個等候逾時或已進入寫入模式，然後結束它。</span><span class="sxs-lookup"><span data-stu-id="a3951-507">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-508">如果鎖定允許遞迴，已進入寫入模式鎖定的執行緒可以進入寫入模式以遞迴方式，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-508">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-509">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法來進入寫入模式，與逾時的鎖定。範例所示的方法會將新的索引鍵/值組加入至同步處理的快取。</span><span class="sxs-lookup"><span data-stu-id="a3951-509">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="a3951-510">如果超過指定時間的指定逾時間隔，在執行緒進入鎖定之前，此方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="a3951-510">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="a3951-511">此方法會傳回`true`如果加入的索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="a3951-511">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="a3951-512">如果快取中，所擲回的內部例外狀況已有索引鍵<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。</span><span class="sxs-lookup"><span data-stu-id="a3951-512">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="a3951-513">A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端都結束鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-513">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="a3951-514">此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="a3951-514">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="a3951-515"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-515">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="a3951-516">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-516">-or-</span></span> 
<span data-ttu-id="a3951-517">目前執行緒一開始在讀取模式中，進入鎖定，因此嘗試進入寫入模式可能會造成死結。</span><span class="sxs-lookup"><span data-stu-id="a3951-517">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="a3951-518">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-518">-or-</span></span> 
<span data-ttu-id="a3951-519">遞迴的次數會超過計數器的容量。</span><span class="sxs-lookup"><span data-stu-id="a3951-519">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="a3951-520">限制是很大，應用程式應該永遠不會發生這個情形。</span><span class="sxs-lookup"><span data-stu-id="a3951-520">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3951-521">值<paramref name="millisecondsTimeout" />是負數，但不等於<see cref="F:System.Threading.Timeout.Infinite" />(-1)，這是唯一允許的負值。</span><span class="sxs-lookup"><span data-stu-id="a3951-521">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a3951-522"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="a3951-522">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="a3951-523">等待的間隔，或 -1 毫秒無限期等待。</span><span class="sxs-lookup"><span data-stu-id="a3951-523">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="a3951-524">嘗試以選用的逾時，在寫入模式下進入鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="a3951-524">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="a3951-525">如果呼叫執行緒已進入寫入模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="a3951-525"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-526">如果`timeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="a3951-526">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="a3951-527">如果其他執行緒已進入讀取模式的鎖定，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法會封鎖，直到這些執行緒都結束讀取的模式或經過逾時間隔為止。</span><span class="sxs-lookup"><span data-stu-id="a3951-527">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="a3951-528">等待進入寫入模式，會封鎖執行緒，而嘗試進入讀取的模式或進入可升級模式的其他執行緒會封鎖直到執行緒等待進入寫入模式，有其中一個等候逾時或已進入寫入模式，然後結束它。</span><span class="sxs-lookup"><span data-stu-id="a3951-528">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3951-529">如果鎖定允許遞迴，已進入寫入模式鎖定的執行緒可以進入寫入模式以遞迴方式，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="a3951-529">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="a3951-530"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。</span><span class="sxs-lookup"><span data-stu-id="a3951-530">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="a3951-531">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-531">-or-</span></span> 
<span data-ttu-id="a3951-532">目前執行緒一開始在讀取模式中，進入鎖定，因此嘗試進入寫入模式可能會造成死結。</span><span class="sxs-lookup"><span data-stu-id="a3951-532">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="a3951-533">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-533">-or-</span></span> 
<span data-ttu-id="a3951-534">遞迴的次數會超過計數器的容量。</span><span class="sxs-lookup"><span data-stu-id="a3951-534">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="a3951-535">限制是很大，應用程式應該永遠不會發生這個情形。</span><span class="sxs-lookup"><span data-stu-id="a3951-535">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3951-536">值<paramref name="timeout" />是負數，但不等於-1 毫秒，這是唯一允許的負值。</span><span class="sxs-lookup"><span data-stu-id="a3951-536">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="a3951-537">-或-</span><span class="sxs-lookup"><span data-stu-id="a3951-537">-or-</span></span> 
<span data-ttu-id="a3951-538">值<paramref name="timeout" />大於<see cref="F:System.Int32.MaxValue" />毫秒為單位。</span><span class="sxs-lookup"><span data-stu-id="a3951-538">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="a3951-539"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="a3951-539">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3951-540">取得等待進入讀取模式鎖定狀態的執行緒總數。</span><span class="sxs-lookup"><span data-stu-id="a3951-540">Gets the total number of threads that are waiting to enter the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="a3951-541">等待進入讀取模式的執行緒總數。</span><span class="sxs-lookup"><span data-stu-id="a3951-541">The total number of threads that are waiting to enter read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-542">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="a3951-542">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="a3951-543">一旦已計算出，則可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="a3951-543">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="a3951-544">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="a3951-544">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-545">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A>屬性，以產生事件記錄檔項目，如果封鎖，等待進入讀取的模式，執行緒的數目超過臨界值。</span><span class="sxs-lookup"><span data-stu-id="a3951-545">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3951-546">取得等待進入可升級模式鎖定狀態的執行緒總數。</span><span class="sxs-lookup"><span data-stu-id="a3951-546">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="a3951-547">等待進入可升級模式的執行緒總數。</span><span class="sxs-lookup"><span data-stu-id="a3951-547">The total number of threads that are waiting to enter upgradeable mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-548">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="a3951-548">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="a3951-549">一旦已計算出，則可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="a3951-549">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="a3951-550">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="a3951-550">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-551">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A>屬性，以產生事件記錄檔項目，如果封鎖，等待進入可升級模式，執行緒的數目超過臨界值。</span><span class="sxs-lookup"><span data-stu-id="a3951-551">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a3951-552">取得等待進入寫入模式鎖定狀態的執行緒總數。</span><span class="sxs-lookup"><span data-stu-id="a3951-552">Gets the total number of threads that are waiting to enter the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="a3951-553">等待進入寫入模式的執行緒總數。</span><span class="sxs-lookup"><span data-stu-id="a3951-553">The total number of threads that are waiting to enter write mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a3951-554">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="a3951-554">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="a3951-555">一旦已計算出，則可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="a3951-555">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="a3951-556">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="a3951-556">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a3951-557">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A>屬性，以產生事件記錄檔項目，如果遭到封鎖，等待進入寫入模式的執行緒數目超過臨界值。</span><span class="sxs-lookup"><span data-stu-id="a3951-557">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
