<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c054992aa5b458c405c83dbc79a506889a9ffc87" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407184" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="44960-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span>
      <span class="sxs-lookup">
        <span data-stu-id="44960-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-102">使用<xref:System.Threading.ReaderWriterLockSlim>來保護資源由多個執行緒的讀取及寫入由一個執行緒一次。</span><span class="sxs-lookup"><span data-stu-id="44960-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="44960-103"><xref:System.Threading.ReaderWriterLockSlim> 可讓多個執行緒處於讀取模式、 讓一個執行緒在寫入模式與獨佔擁有權的鎖定，並允許具有讀取權限可升級的讀取模式，供執行緒來升級至寫入模式，而不必放棄它的一個執行緒s 讀取資源的存取權。</span><span class="sxs-lookup"><span data-stu-id="44960-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-104"><xref:System.Threading.ReaderWriterLockSlim> 類似於 <xref:System.Threading.ReaderWriterLock>，但是它有遞迴以及升級和降級鎖定狀態的簡化規則。</span><span class="sxs-lookup"><span data-stu-id="44960-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="44960-105"><xref:System.Threading.ReaderWriterLockSlim> 可避免可能發生死結的許多情況。</span><span class="sxs-lookup"><span data-stu-id="44960-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="44960-106">此外，<xref:System.Threading.ReaderWriterLockSlim> 的效能明顯優於 <xref:System.Threading.ReaderWriterLock>。</span><span class="sxs-lookup"><span data-stu-id="44960-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="44960-107">建議針對所有新的開發使用 <xref:System.Threading.ReaderWriterLockSlim>。</span><span class="sxs-lookup"><span data-stu-id="44960-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="44960-108">根據預設的新執行個體<xref:System.Threading.ReaderWriterLockSlim>以建立<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>旗標，且不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="44960-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="44960-109">這項預設原則建議所有新的開發，因為遞迴會引進不必要的複雜性，而讓您的程式碼更容易發生死結。</span><span class="sxs-lookup"><span data-stu-id="44960-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="44960-110">若要簡化移轉作業從現有的專案使用<xref:System.Threading.Monitor>或<xref:System.Threading.ReaderWriterLock>，您可以使用<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>建立的執行個體的旗標<xref:System.Threading.ReaderWriterLockSlim>，讓遞迴。</span><span class="sxs-lookup"><span data-stu-id="44960-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="44960-111">執行緒可以進入三種模式的鎖定： 讀取模式、 寫入模式和可升級的讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="44960-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="44960-112">(在本主題的其餘部分，「 讀取可升級模式 」 指 「 可升級模式 」，並 「 輸入`x`模式 」 使用代表較長"輸入鎖定`x`模式 」。)</span><span class="sxs-lookup"><span data-stu-id="44960-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="44960-113">遞迴原則，不論只有一個執行緒可以在任何時間是在寫入模式中。</span><span class="sxs-lookup"><span data-stu-id="44960-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="44960-114">當執行緒在寫入模式中時，沒有其他執行緒可以在任何模式下進入鎖定。</span><span class="sxs-lookup"><span data-stu-id="44960-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="44960-115">只有一個執行緒可以在任何時間是在可升級模式。</span><span class="sxs-lookup"><span data-stu-id="44960-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="44960-116">任意數目的執行緒可以處於讀取模式，而且可以有一個執行緒在可升級模式中其他的執行緒處於讀取模式。</span><span class="sxs-lookup"><span data-stu-id="44960-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="44960-117">此類型會實作<xref:System.IDisposable>介面。</span><span class="sxs-lookup"><span data-stu-id="44960-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="44960-118">當您完成使用類型時，您應該會處置它直接或間接。</span><span class="sxs-lookup"><span data-stu-id="44960-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="44960-119">若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="44960-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="44960-120">若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。</span><span class="sxs-lookup"><span data-stu-id="44960-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="44960-121">如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。</span><span class="sxs-lookup"><span data-stu-id="44960-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="44960-122"><xref:System.Threading.ReaderWriterLockSlim> 具有 managed 執行緒相似性。也就是說，每個<xref:System.Threading.Thread>物件必須讓自己進入或離開鎖定模式的方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="44960-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="44960-123">任何執行緒可以不變更另一個執行緒的模式。</span><span class="sxs-lookup"><span data-stu-id="44960-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="44960-124">如果<xref:System.Threading.ReaderWriterLockSlim>不允許遞迴時，執行緒嘗試進入鎖定狀態可以封鎖有幾個原因：</span><span class="sxs-lookup"><span data-stu-id="44960-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="44960-125">嘗試進入讀取的模式會遭封鎖，等待進入寫入模式，或如果寫入模式中沒有單一執行緒的執行緒時執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="44960-126">寫入器會排入佇列時，將封鎖新讀取器是寫入器鎖定公平性原則。</span><span class="sxs-lookup"><span data-stu-id="44960-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="44960-127">目前的公平性原則公平性讀取器和寫入器，提升產能的最常見的案例之間取得平衡。</span><span class="sxs-lookup"><span data-stu-id="44960-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="44960-128">未來版本[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]可能會導入新的公平性化原則。</span><span class="sxs-lookup"><span data-stu-id="44960-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="44960-129">嘗試進入可升級模式的區塊，如果已經有執行緒在可升級模式中，如果沒有執行緒等待進入寫入模式，或如果在寫入模式中的單一執行緒的執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="44960-130">嘗試進入寫入模式的區塊，如果沒有任何一種模式中的執行緒的執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="44960-131">升級和降級鎖定</span><span class="sxs-lookup"><span data-stu-id="44960-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="44960-132">可升級模式適用於案例，其中執行緒通常會讀取受保護的資源，但是可能需要寫入其中，如果符合一些條件。</span><span class="sxs-lookup"><span data-stu-id="44960-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="44960-133">執行緒已進入<xref:System.Threading.ReaderWriterLockSlim>可升級模式具有讀取存取受保護的資源，而且可以升級至寫入模式，藉由呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="44960-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="44960-134">因為可以有只有一個執行緒在可升級模式下一次，升級至寫入模式不能發生死結時不允許遞迴，這是預設的原則。</span><span class="sxs-lookup"><span data-stu-id="44960-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="44960-135">不論遞迴原則，一開始進入讀取模式不允許升級至可升級模式 」 或 「 寫入模式，因為該模式會建立強式死結的可能性。</span><span class="sxs-lookup"><span data-stu-id="44960-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="44960-136">例如，如果兩個執行緒同時嘗試進入讀取模式中的寫入模式，它們將會發生死結。</span><span class="sxs-lookup"><span data-stu-id="44960-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="44960-137">可升級模式被為了避免這類死結。</span><span class="sxs-lookup"><span data-stu-id="44960-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="44960-138">如果在讀取模式中，正在升級區塊的執行緒沒有其他執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="44960-139">當執行緒被封鎖時，其他的執行緒嘗試進入讀取的模式，將會遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="44960-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="44960-140">當所有執行緒都結束讀取模式時，封鎖升級的執行緒會進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="44960-141">如果沒有其他執行緒等待進入寫入模式，它們保持封鎖，因為可升級模式的單一執行緒會防止它們無法獲得獨佔存取的資源。</span><span class="sxs-lookup"><span data-stu-id="44960-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="44960-142">當可升級模式中的執行緒結束寫入模式時，其他執行緒等待進入讀取的模式，可以這樣做，除非沒有執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="44960-143">可升級模式中的執行緒可以升級和降級無限期地，只要它是只寫入受保護資源的執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="44960-144">如果您允許多個執行緒進入寫入模式或可升級模式，您必須允許獨佔可升級模式的單一執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="44960-145">否則，執行緒嘗試進入寫入模式直接將會遭到封鎖，且已被封鎖，而其他的執行緒將無法進入讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="44960-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="44960-146">可升級模式的執行緒可以降級為讀取模式，藉由第一個呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法，然後再呼叫<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="44960-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="44960-147">即使此降級模式允許所有的鎖定遞迴原則<xref:System.Threading.LockRecursionPolicy.NoRecursion>。</span><span class="sxs-lookup"><span data-stu-id="44960-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="44960-148">降級為讀取模式以後, 執行緒無法重新輸入可升級模式，直到結束讀取模式。</span><span class="sxs-lookup"><span data-stu-id="44960-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="44960-149">輸入鎖定以遞迴方式</span><span class="sxs-lookup"><span data-stu-id="44960-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="44960-150">您可以建立<xref:System.Threading.ReaderWriterLockSlim>遞迴鎖定項目支援使用<xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29>建構函式指定鎖定原則，並指定<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="44960-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-151">使用遞迴建議不要進行新開發，因為它會引進不必要的複雜性，並讓您的程式碼更容易發生死結。</span><span class="sxs-lookup"><span data-stu-id="44960-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="44960-152">如<xref:System.Threading.ReaderWriterLockSlim>，可讓遞迴，下列可說是有關執行緒可以進入模式：</span><span class="sxs-lookup"><span data-stu-id="44960-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="44960-153">在讀取模式中的執行緒可以輸入讀取的模式遞迴的但是無法進入寫入模式或可升級模式。</span><span class="sxs-lookup"><span data-stu-id="44960-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="44960-154">如果它嘗試這樣做，請<xref:System.Threading.LockRecursionException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="44960-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="44960-155">進入讀取模式，然後進入寫入模式，或可升級模式是一種模式與死結的機率，因此不允許。</span><span class="sxs-lookup"><span data-stu-id="44960-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="44960-156">如同先前討論，就必須升級鎖定的情況下提供可升級模式。</span><span class="sxs-lookup"><span data-stu-id="44960-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="44960-157">可升級模式的執行緒可以在寫入模式，及/或讀取的模式中，輸入，並可以輸入任何三個模式以遞迴方式。</span><span class="sxs-lookup"><span data-stu-id="44960-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="44960-158">不過，嘗試進入寫入模式區塊讀取模式中是否有其他的執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="44960-159">寫入模式的執行緒會讀取的模式，及/或可升級模式，可以輸入，並可以輸入任何三個模式以遞迴方式。</span><span class="sxs-lookup"><span data-stu-id="44960-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="44960-160">尚未進入鎖定的執行緒可以進入任何模式。</span><span class="sxs-lookup"><span data-stu-id="44960-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="44960-161">這項嘗試可能會基於相同原因，因為嘗試輸入非遞迴鎖定封鎖。</span><span class="sxs-lookup"><span data-stu-id="44960-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="44960-162">執行緒可以結束它已經進入依任何順序模式，只要它會結束，每一種模式中進入該模式的次數相同。</span><span class="sxs-lookup"><span data-stu-id="44960-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="44960-163">如果執行緒嘗試次數過多，結束模式或結束尚未進入，模式<xref:System.Threading.SynchronizationLockException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="44960-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="44960-164">鎖定狀態</span><span class="sxs-lookup"><span data-stu-id="44960-164">Lock States</span></span>  
 <span data-ttu-id="44960-165">您可能會發現很好的做法鎖定的狀態中。</span><span class="sxs-lookup"><span data-stu-id="44960-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="44960-166">A<xref:System.Threading.ReaderWriterLockSlim>可以處於四種狀態之一： 不是輸入讀取，升級和寫入。</span><span class="sxs-lookup"><span data-stu-id="44960-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="44960-167">未輸入： 處於此狀態，沒有任何執行緒已進入鎖定 （或所有執行緒都結束鎖定）。</span><span class="sxs-lookup"><span data-stu-id="44960-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="44960-168">請閱讀： 處於此狀態，一或多個執行緒已進入鎖定進行讀取受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="44960-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="44960-169">執行緒可以進入讀取模式鎖定使用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法，或從 可升級模式降級。</span><span class="sxs-lookup"><span data-stu-id="44960-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="44960-170">升級： 處於此狀態，一個執行緒已進入鎖定進行讀取與寫入存取所升級選項 （也就是在可升級模式），以及零個或多個執行緒已進入讀取權限的鎖定。</span><span class="sxs-lookup"><span data-stu-id="44960-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="44960-171">一次只能有一個執行緒可以進入鎖定與升級; 選項嘗試進入可升級模式的其他執行緒會遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="44960-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="44960-172">寫入： 處於此狀態，一個執行緒已進入鎖定進行寫入存取受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="44960-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="44960-173">該執行緒擁有獨佔的鎖定。</span><span class="sxs-lookup"><span data-stu-id="44960-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="44960-174">嘗試進入鎖定，因為任何原因的其他任何執行緒會封鎖。</span><span class="sxs-lookup"><span data-stu-id="44960-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="44960-175">下表描述的鎖定狀態，不允許遞迴時，當執行緒的鎖定之間的轉換`t`採取最左邊的資料行中所述的動作。</span><span class="sxs-lookup"><span data-stu-id="44960-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="44960-176">在階段採取動作，`t`不有任何模式。</span><span class="sxs-lookup"><span data-stu-id="44960-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="44960-177">(的特殊情況下其中`t`中說明資料表註腳可升級模式。)上方資料列描述鎖定的開始狀態。</span><span class="sxs-lookup"><span data-stu-id="44960-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="44960-178">資料格描述執行緒，會發生什麼事，並顯示在括號中的鎖定狀態的變更。</span><span class="sxs-lookup"><span data-stu-id="44960-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="44960-179">不進入 (N)</span><span class="sxs-lookup"><span data-stu-id="44960-179">Not entered (N)</span></span>|<span data-ttu-id="44960-180">Read (R)</span><span class="sxs-lookup"><span data-stu-id="44960-180">Read (R)</span></span>|<span data-ttu-id="44960-181">升級 (U)</span><span class="sxs-lookup"><span data-stu-id="44960-181">Upgrade (U)</span></span>|<span data-ttu-id="44960-182">寫入 (W)</span><span class="sxs-lookup"><span data-stu-id="44960-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="44960-183">`t` 進入讀取的模式</span><span class="sxs-lookup"><span data-stu-id="44960-183">`t` enters read mode</span></span>|<span data-ttu-id="44960-184">`t` 輸入 (R)。</span><span class="sxs-lookup"><span data-stu-id="44960-184">`t` enters (R).</span></span>|<span data-ttu-id="44960-185">`t` 如果執行緒正在等候寫入模式;，區塊否則，`t`進入。</span><span class="sxs-lookup"><span data-stu-id="44960-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="44960-186">`t` 如果執行緒正在等候寫入模式;，區塊否則，`t`進入。<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="44960-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="44960-187">`t` 區塊。</span><span class="sxs-lookup"><span data-stu-id="44960-187">`t` blocks.</span></span>|  
|<span data-ttu-id="44960-188">`t` 進入可升級模式</span><span class="sxs-lookup"><span data-stu-id="44960-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="44960-189">`t` 輸入 (U)。</span><span class="sxs-lookup"><span data-stu-id="44960-189">`t` enters (U).</span></span>|<span data-ttu-id="44960-190">`t` 如果執行緒正在等候的區塊寫入模式或升級模式。否則，`t`進入 (U)。</span><span class="sxs-lookup"><span data-stu-id="44960-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="44960-191">`t` 區塊。</span><span class="sxs-lookup"><span data-stu-id="44960-191">`t` blocks.</span></span>|<span data-ttu-id="44960-192">`t` 區塊。</span><span class="sxs-lookup"><span data-stu-id="44960-192">`t` blocks.</span></span>|  
|<span data-ttu-id="44960-193">`t` 進入寫入模式</span><span class="sxs-lookup"><span data-stu-id="44960-193">`t` enters write mode</span></span>|<span data-ttu-id="44960-194">`t` 輸入 (W)。</span><span class="sxs-lookup"><span data-stu-id="44960-194">`t` enters (W).</span></span>|<span data-ttu-id="44960-195">`t` 區塊。</span><span class="sxs-lookup"><span data-stu-id="44960-195">`t` blocks.</span></span>|<span data-ttu-id="44960-196">`t` 區塊。<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="44960-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="44960-197">`t` 區塊。</span><span class="sxs-lookup"><span data-stu-id="44960-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="44960-198"><sup>1</sup>如果`t`啟動出可升級模式，它進入讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="44960-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="44960-199">這個動作會永遠不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="44960-199">This action never blocks.</span></span> <span data-ttu-id="44960-200">鎖定狀態不會變更。</span><span class="sxs-lookup"><span data-stu-id="44960-200">The lock state does not change.</span></span> <span data-ttu-id="44960-201">（在執行緒然後即可完成以結束可升級模式的方式讀取模式降級）。</span><span class="sxs-lookup"><span data-stu-id="44960-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="44960-202"><sup>2</sup>如果`t`開始都處於可升級模式，它會封鎖在讀取模式下執行緒時。</span><span class="sxs-lookup"><span data-stu-id="44960-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="44960-203">否則，會升級寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="44960-204">鎖定狀態 會變更以寫入 (W)。</span><span class="sxs-lookup"><span data-stu-id="44960-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="44960-205">如果`t`區塊中，因為有執行緒處於讀取模式，因為在最後一個執行緒結束讀取的模式，即會進入寫入模式中，即使有執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="44960-206">執行緒結束鎖定，就會發生狀態變更下, 一個執行緒喚醒，當選取時，如下所示：</span><span class="sxs-lookup"><span data-stu-id="44960-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="44960-207">首先，正在等候執行緒寫入模式，且已在可升級模式 （有最多可達一個這類執行緒）。</span><span class="sxs-lookup"><span data-stu-id="44960-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="44960-208">如果失敗，正在等候寫入模式的執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="44960-209">如果失敗，正在等待進入可升級模式的執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="44960-210">如果失敗，正在等候讀取模式的所有執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="44960-211">後續狀態一律是鎖定的寫入 (W) 中的第一個兩種情況下與升級 (U) 在第三個案例中，不論鎖定現有執行緒觸發狀態變更時的狀態為何。</span><span class="sxs-lookup"><span data-stu-id="44960-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="44960-212">在最後一個案例中，鎖定狀態時升級 (U) 執行緒中沒有可升級模式之後的狀態變更和 Read (R) 否則無論之前的狀態。</span><span class="sxs-lookup"><span data-stu-id="44960-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-213">下列範例會示範簡單的同步處理快取保存字串與整數索引鍵。</span><span class="sxs-lookup"><span data-stu-id="44960-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="44960-214">執行個體<xref:System.Threading.ReaderWriterLockSlim>用來同步處理存取具備<xref:System.Collections.Generic.Dictionary%602>做為內部快取。</span><span class="sxs-lookup"><span data-stu-id="44960-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="44960-215">此範例包含簡單的方法加入至快取，刪除從快取，以及讀取快取。</span><span class="sxs-lookup"><span data-stu-id="44960-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="44960-216">為了示範逾時，此範例也包含它可以這樣做內指定的逾時，才將快取的方法。</span><span class="sxs-lookup"><span data-stu-id="44960-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="44960-217">為了示範可升級模式，此範例包含方法，可擷取索引鍵相關聯的值，並比較它與新的值。</span><span class="sxs-lookup"><span data-stu-id="44960-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="44960-218">如果值為不變，則方法會傳回狀態，表示沒有變更。</span><span class="sxs-lookup"><span data-stu-id="44960-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="44960-219">它沒有值找不到索引鍵，會插入索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="44960-219">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="44960-220">如果值已變更，它會更新。</span><span class="sxs-lookup"><span data-stu-id="44960-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="44960-221">可升級模式可讓執行緒升級從的寫入存取，如有需要而不會發生死結的讀取權限。</span><span class="sxs-lookup"><span data-stu-id="44960-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="44960-222">此範例也包含巢狀的列舉，指定方法，示範可升級模式的傳回值。</span><span class="sxs-lookup"><span data-stu-id="44960-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="44960-223">此範例會使用預設建構函式，來建立鎖定，因此不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="44960-223">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="44960-224">程式設計<xref:System.Threading.ReaderWriterLockSlim>鎖定不允許遞迴是比較簡單且較不容易發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="44960-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="44960-225">下列程式碼再使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。</span><span class="sxs-lookup"><span data-stu-id="44960-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="44960-226">它會建立三項工作。</span><span class="sxs-lookup"><span data-stu-id="44960-226">It creates three tasks.</span></span> <span data-ttu-id="44960-227">第一個寫入蔬菜儲存在陣列中的名稱`SynchronizedCache`執行個體。</span><span class="sxs-lookup"><span data-stu-id="44960-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="44960-228">第二個和第三個工作顯示蔬菜、 遞增順序 （從低索引最高索引），以遞減順序的第二個中的第一個的名稱。</span><span class="sxs-lookup"><span data-stu-id="44960-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="44960-229">最後一項工作會搜尋字串"cucumber 」，並在它時，會呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來替代字串 「 綠色 bean"。</span><span class="sxs-lookup"><span data-stu-id="44960-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="44960-230">此型別具備執行緒安全。</span>
      <span class="sxs-lookup">
        <span data-stu-id="44960-230">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="44960-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="44960-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-233">A <xref:System.Threading.ReaderWriterLockSlim> ，初始化與這個建構函式不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="44960-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="44960-234">亦即，<xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> 屬性會傳回 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="44960-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="44960-235">如需有關遞迴原則，以及它影響的詳細資訊，請參閱<xref:System.Threading.LockRecursionPolicy>列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="44960-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-236">下列範例會示範簡單的同步處理快取保存字串與整數索引鍵。</span><span class="sxs-lookup"><span data-stu-id="44960-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="44960-237">執行個體<xref:System.Threading.ReaderWriterLockSlim>用來同步處理存取具備<xref:System.Collections.Generic.Dictionary%602>做為內部快取。</span><span class="sxs-lookup"><span data-stu-id="44960-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="44960-238">無參數建構函式用來建立鎖定。</span><span class="sxs-lookup"><span data-stu-id="44960-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="44960-239">此範例包含簡單的方法加入至快取，刪除從快取，以及讀取快取。</span><span class="sxs-lookup"><span data-stu-id="44960-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="44960-240">為了示範逾時，此範例也包含它可以這樣做內指定的逾時，才將快取的方法。</span><span class="sxs-lookup"><span data-stu-id="44960-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="44960-241">為了示範可升級模式，此範例包含方法，可擷取索引鍵相關聯的值，並比較它與新的值。</span><span class="sxs-lookup"><span data-stu-id="44960-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="44960-242">如果值為不變，則方法會傳回狀態，表示沒有變更。</span><span class="sxs-lookup"><span data-stu-id="44960-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="44960-243">它沒有值找不到索引鍵，會插入索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="44960-243">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="44960-244">如果值已變更，它會更新。</span><span class="sxs-lookup"><span data-stu-id="44960-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="44960-245">可升級模式可讓執行緒升級從的寫入存取，如有需要而不會發生死結的讀取權限。</span><span class="sxs-lookup"><span data-stu-id="44960-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="44960-246">此範例也包含巢狀的列舉，指定方法，示範可升級模式的傳回值。</span><span class="sxs-lookup"><span data-stu-id="44960-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="44960-247">此範例會使用預設建構函式，來建立鎖定，因此不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="44960-247">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="44960-248">程式設計<xref:System.Threading.ReaderWriterLockSlim>鎖定不允許遞迴是比較簡單且較不容易發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="44960-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="44960-249">下列程式碼再使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。</span><span class="sxs-lookup"><span data-stu-id="44960-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="44960-250">它會建立三項工作。</span><span class="sxs-lookup"><span data-stu-id="44960-250">It creates three tasks.</span></span> <span data-ttu-id="44960-251">第一個寫入蔬菜儲存在陣列中的名稱`SynchronizedCache`執行個體。</span><span class="sxs-lookup"><span data-stu-id="44960-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="44960-252">第二個和第三個工作顯示蔬菜、 遞增順序 （從低索引最高索引），以遞減順序的第二個中的第一個的名稱。</span><span class="sxs-lookup"><span data-stu-id="44960-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="44960-253">最後一項工作會搜尋字串"cucumber 」，並在它時，會呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來替代字串 「 綠色 bean"。</span><span class="sxs-lookup"><span data-stu-id="44960-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">
          <span data-ttu-id="44960-254">One of the enumeration values that specifies the lock recursion policy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-254">One of the enumeration values that specifies the lock recursion policy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44960-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-256">遞迴原則會決定多次進入鎖定狀態的執行緒上的限制。</span><span class="sxs-lookup"><span data-stu-id="44960-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="44960-257">例如，如果建立鎖定時使用<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>執行緒已進入讀取模式的鎖定和<xref:System.Threading.LockRecursionException>執行緒會嘗試重新進入讀取模式鎖定便會擲回。</span><span class="sxs-lookup"><span data-stu-id="44960-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="44960-258">同樣地，如果執行緒已進入寫入模式的鎖定<xref:System.Threading.LockRecursionException>如果執行緒會嘗試重新輸入任何模式中的鎖定，會擲回。</span><span class="sxs-lookup"><span data-stu-id="44960-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-259">可升級模式的執行緒可以寫入模式升級或降級為讀取模式鎖定的遞迴原則設定。</span><span class="sxs-lookup"><span data-stu-id="44960-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="44960-260">不論遞迴原則，一開始進入讀取模式不允許升級至可升級模式 」 或 「 寫入模式，因為該模式會建立強式死結的可能性。</span><span class="sxs-lookup"><span data-stu-id="44960-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="44960-261">如需有關遞迴原則，以及它影響的詳細資訊，請參閱<xref:System.Threading.LockRecursionPolicy>列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="44960-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-262">下列範例示範兩個例外狀況，其中一個，取決於<xref:System.Threading.LockRecursionPolicy>設定，另一個則沒有。</span><span class="sxs-lookup"><span data-stu-id="44960-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="44960-263">在第一個案例中，執行緒會進入讀取的模式，並再嘗試進入讀取的模式遞迴。</span><span class="sxs-lookup"><span data-stu-id="44960-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="44960-264">如果<xref:System.Threading.ReaderWriterLockSlim>利用遞迴原則設定為預設建構函式建立<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>，擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="44960-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the default constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="44960-265">如果<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>用來建立<xref:System.Threading.ReaderWriterLockSlim>，擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="44960-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="44960-266">在第二個案例中，執行緒會進入讀取的模式，然後嘗試進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="44960-267"><xref:System.Threading.LockRecursionException> 就會擲回不論鎖定遞迴原則。</span><span class="sxs-lookup"><span data-stu-id="44960-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="44960-268">下列程式碼再使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。</span><span class="sxs-lookup"><span data-stu-id="44960-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="44960-269">它會建立三項工作。</span><span class="sxs-lookup"><span data-stu-id="44960-269">It creates three tasks.</span></span> <span data-ttu-id="44960-270">第一個寫入蔬菜儲存在陣列中的名稱`SynchronizedCache`執行個體。</span><span class="sxs-lookup"><span data-stu-id="44960-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="44960-271">第二個和第三個工作顯示蔬菜、 遞增順序 （從低索引最高索引），以遞減順序的第二個中的第一個的名稱。</span><span class="sxs-lookup"><span data-stu-id="44960-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="44960-272">最後一項工作會搜尋字串"cucumber 」，並在它時，會呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來替代字串 「 綠色 bean"。</span><span class="sxs-lookup"><span data-stu-id="44960-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44960-273">Gets the total number of unique threads that have entered the lock in read mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-273">Gets the total number of unique threads that have entered the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44960-274">已進入讀取模式鎖定狀態的唯一執行緒數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-274">The number of unique threads that have entered the lock in read mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-275">執行緒只計算一次，即使鎖定允許遞迴和執行緒已進入讀取的模式多次。</span><span class="sxs-lookup"><span data-stu-id="44960-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="44960-276">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="44960-277">計算時，可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="44960-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="44960-278">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="44960-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-279">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A>產生事件記錄檔項目，如果在讀取模式下的執行緒數目超過臨界值的屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="44960-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-281"><xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 使用完畢時，請呼叫 <xref:System.Threading.ReaderWriterLockSlim>。</span><span class="sxs-lookup"><span data-stu-id="44960-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="44960-282"><xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 方法會將 <xref:System.Threading.ReaderWriterLockSlim> 保留在無法使用的狀態。</span><span class="sxs-lookup"><span data-stu-id="44960-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="44960-283">在呼叫<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>，您必須釋放所有參考<xref:System.Threading.ReaderWriterLockSlim>讓記憶體回收行程可以回收記憶體的<xref:System.Threading.ReaderWriterLockSlim>所佔用。</span><span class="sxs-lookup"><span data-stu-id="44960-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="44960-284">如需詳細資訊，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)和[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="44960-284">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-285">請務必呼叫<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>您釋放最後一個參考之前<xref:System.Threading.ReaderWriterLockSlim>物件。</span><span class="sxs-lookup"><span data-stu-id="44960-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="44960-286">
            <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-286">
              <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span>
          </span>
          <span data-ttu-id="44960-287">-or-  <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-287">-or-  <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span>
          </span>
          <span data-ttu-id="44960-288">-or-  <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-288">-or-  <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="44960-289">Tries to enter the lock in read mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-289">Tries to enter the lock in read mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-290">這個方法會封鎖，直到呼叫的執行緒進入鎖定，因此可能永遠不會傳回。</span><span class="sxs-lookup"><span data-stu-id="44960-290">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="44960-291">使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法來封鎖指定的間隔，然後再回頭執行如果呼叫執行緒尚未進入讀取模式，在該間隔期間。</span><span class="sxs-lookup"><span data-stu-id="44960-291">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="44960-292">多個執行緒可以進入讀取的模式，在相同的時間。</span><span class="sxs-lookup"><span data-stu-id="44960-292">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="44960-293">如果一個或多個執行緒正在等待進入寫入模式中，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法封鎖，直到這些執行緒具有逾時或已進入寫入模式，然後從它結束。</span><span class="sxs-lookup"><span data-stu-id="44960-293">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-294">如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-294">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="44960-295">最多一個執行緒可以在可升級模式，其他的執行緒處於讀取模式。</span><span class="sxs-lookup"><span data-stu-id="44960-295">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="44960-296">如果其他的執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法會立即進入讀取的模式，而不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="44960-296">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-297">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法在讀取模式下進入鎖定。</span><span class="sxs-lookup"><span data-stu-id="44960-297">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="44960-298">在範例中所示的方法擷取索引鍵相關聯的值。</span><span class="sxs-lookup"><span data-stu-id="44960-298">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="44960-299">如果索引鍵找不到，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。</span><span class="sxs-lookup"><span data-stu-id="44960-299">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="44960-300">A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，確保呼叫端結束讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="44960-300">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="44960-301">這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="44960-301">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="44960-302">The current thread cannot acquire the write lock when it holds the read lock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-302">The current thread cannot acquire the write lock when it holds the read lock.</span>
          </span>
          <span data-ttu-id="44960-303">-or-  The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-303">-or-  The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span>
          </span>
          <span data-ttu-id="44960-304">-or-  The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-304">-or-  The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span>
          </span>
          <span data-ttu-id="44960-305">-or-  The recursion number would exceed the capacity of the counter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-305">-or-  The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="44960-306">This limit is so large that applications should never encounter this exception.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-306">This limit is so large that applications should never encounter this exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="44960-307">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-307">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="44960-308">Tries to enter the lock in upgradeable mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-308">Tries to enter the lock in upgradeable mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-309">這個方法會封鎖，直到呼叫的執行緒進入鎖定，因此可能永遠不會傳回。</span><span class="sxs-lookup"><span data-stu-id="44960-309">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="44960-310">使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>來封鎖指定的間隔內，，然後傳回 如果呼叫執行緒尚未進入可升級模式在該間隔期間的方法。</span><span class="sxs-lookup"><span data-stu-id="44960-310">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="44960-311">使用可升級模式下，當執行緒通常存取受保護的資源<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。</span><span class="sxs-lookup"><span data-stu-id="44960-311">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="44960-312">可升級模式的執行緒可以降級為讀取模式，或升級至寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-312">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="44960-313">只有一個執行緒可以進入可升級模式，在任何指定時間。</span><span class="sxs-lookup"><span data-stu-id="44960-313">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="44960-314">如果執行緒是在可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒進入讀取的模式，即使有執行緒等待進入可升級模式。</span><span class="sxs-lookup"><span data-stu-id="44960-314">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="44960-315">如果一個或多個執行緒正在等待進入寫入模式中，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法封鎖，直到這些執行緒具有逾時或已進入寫入模式，然後從它結束。</span><span class="sxs-lookup"><span data-stu-id="44960-315">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-316">如果鎖定允許遞迴已進入可升級模式鎖定的執行緒可以輸入可升級模式遞迴，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-316">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-317">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來進入可升級模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="44960-317">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="44960-318">A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，確保呼叫端結束可升級模式。</span><span class="sxs-lookup"><span data-stu-id="44960-318">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="44960-319">在範例中所示的方法擷取索引鍵相關聯的值，並比較它與新的值。</span><span class="sxs-lookup"><span data-stu-id="44960-319">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="44960-320">如果值為不變，則方法會傳回狀態，表示沒有變更。</span><span class="sxs-lookup"><span data-stu-id="44960-320">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="44960-321">它沒有值找不到索引鍵，會插入索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="44960-321">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="44960-322">如果值已變更，它會更新。</span><span class="sxs-lookup"><span data-stu-id="44960-322">If the value has changed, it is updated.</span></span> <span data-ttu-id="44960-323">可升級模式可讓執行緒升級讀取的鎖定，如有需要而不發生死結的風險。</span><span class="sxs-lookup"><span data-stu-id="44960-323">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="44960-324">此範例會使用預設建構函式，來建立鎖定，因此不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="44960-324">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="44960-325">程式設計<xref:System.Threading.ReaderWriterLockSlim>鎖定不允許遞迴是比較簡單且較不容易發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="44960-325">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="44960-326">這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="44960-326">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="44960-327">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-327">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span>
          </span>
          <span data-ttu-id="44960-328">-or-  The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-328">-or-  The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="44960-329">-or-  The recursion number would exceed the capacity of the counter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-329">-or-  The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="44960-330">The limit is so large that applications should never encounter it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-330">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="44960-331">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-331">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="44960-332">Tries to enter the lock in write mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-332">Tries to enter the lock in write mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-333">這個方法會封鎖，直到呼叫的執行緒進入鎖定，因此可能永遠不會傳回。</span><span class="sxs-lookup"><span data-stu-id="44960-333">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="44960-334">使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>來封鎖指定的間隔內，，然後傳回 如果呼叫執行緒尚未進入寫入模式在該間隔期間的方法。</span><span class="sxs-lookup"><span data-stu-id="44960-334">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="44960-335">如果其他的執行緒已進入讀取模式鎖定，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法會封鎖直到那些執行緒都結束讀取模式。</span><span class="sxs-lookup"><span data-stu-id="44960-335">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="44960-336">等待進入寫入模式的執行緒時，額外的執行緒嘗試進入讀取的模式或區塊可升級模式，直到所有等待進入寫入模式的執行緒具有逾時已進入寫入模式，或從它然後結束。</span><span class="sxs-lookup"><span data-stu-id="44960-336">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-337">如果鎖定允許遞迴已進入寫入模式鎖定的執行緒可以輸入遞迴寫入模式，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-337">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-338">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法，以在寫入模式下進入鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="44960-338">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="44960-339">範例所示的方法會將新的索引鍵/值組加入至同步處理快取。</span><span class="sxs-lookup"><span data-stu-id="44960-339">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="44960-340">如果機碼已經快取中，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。</span><span class="sxs-lookup"><span data-stu-id="44960-340">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="44960-341">A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端結束寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-341">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="44960-342">這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="44960-342">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="44960-343">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-343">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span>
          </span>
          <span data-ttu-id="44960-344">-or-  The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-344">-or-  The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="44960-345">-or-  The recursion number would exceed the capacity of the counter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-345">-or-  The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="44960-346">The limit is so large that applications should never encounter it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-346">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="44960-347">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-347">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="44960-348">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-348">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-349">這個方法不是遞迴順序。</span><span class="sxs-lookup"><span data-stu-id="44960-349">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="44960-350">例如，如果在執行緒進入可升級模式鎖定，然後在讀取模式下進入鎖定的執行緒結束兩種模式的順序無關。</span><span class="sxs-lookup"><span data-stu-id="44960-350">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="44960-351">如果鎖定允許遞迴，執行緒可以進入寫入模式的鎖定，然後輸入它以遞迴方式在以讀取模式。在執行緒結束的順序模式讀寫模式並不重要。</span><span class="sxs-lookup"><span data-stu-id="44960-351">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="44960-352">結束鎖定，可能表示其他的等候中執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-352">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-353">下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，確保呼叫端結束讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="44960-353">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="44960-354">在範例中所示的方法擷取索引鍵相關聯的值。</span><span class="sxs-lookup"><span data-stu-id="44960-354">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="44960-355">如果索引鍵找不到，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。</span><span class="sxs-lookup"><span data-stu-id="44960-355">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="44960-356"><xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法用來進入讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="44960-356">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="44960-357">這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="44960-357">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="44960-358">The current thread has not entered the lock in read mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-358">The current thread has not entered the lock in read mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="44960-359">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-359">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-360">這個方法不是遞迴順序。</span><span class="sxs-lookup"><span data-stu-id="44960-360">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="44960-361">例如，如果在執行緒進入可升級模式鎖定，然後在寫入模式下進入鎖定的執行緒結束兩種模式的順序無關。</span><span class="sxs-lookup"><span data-stu-id="44960-361">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="44960-362">如果鎖定允許遞迴，執行緒可以進入寫入模式的鎖定，然後輸入它以遞迴方式可升級模式。在執行緒結束可升級模式 」 和 「 寫入模式的順序不重要。</span><span class="sxs-lookup"><span data-stu-id="44960-362">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="44960-363">結束鎖定，可能表示其他的等候中執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-363">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-364">下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，確保呼叫端結束可升級模式。</span><span class="sxs-lookup"><span data-stu-id="44960-364">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="44960-365">在範例中所示的方法擷取索引鍵相關聯的值，並比較它與新的值。</span><span class="sxs-lookup"><span data-stu-id="44960-365">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="44960-366">如果值為不變，則方法會傳回狀態，表示沒有變更。</span><span class="sxs-lookup"><span data-stu-id="44960-366">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="44960-367">它沒有值找不到索引鍵，會插入索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="44960-367">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="44960-368">如果值已變更，它會更新。</span><span class="sxs-lookup"><span data-stu-id="44960-368">If the value has changed, it is updated.</span></span> <span data-ttu-id="44960-369">可升級模式可讓執行緒升級讀取的鎖定，如有需要而不發生死結的風險。</span><span class="sxs-lookup"><span data-stu-id="44960-369">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="44960-370">此範例會使用預設建構函式，來建立鎖定，因此不允許遞迴。</span><span class="sxs-lookup"><span data-stu-id="44960-370">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="44960-371">程式設計<xref:System.Threading.ReaderWriterLockSlim>鎖定不允許遞迴是比較簡單且較不容易發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="44960-371">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="44960-372">這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="44960-372">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="44960-373">The current thread has not entered the lock in upgradeable mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-373">The current thread has not entered the lock in upgradeable mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="44960-374">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-374">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-375">這個方法不是遞迴順序。</span><span class="sxs-lookup"><span data-stu-id="44960-375">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="44960-376">例如，如果在執行緒進入可升級模式鎖定，然後在寫入模式下進入鎖定的執行緒結束兩種模式的順序無關。</span><span class="sxs-lookup"><span data-stu-id="44960-376">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="44960-377">如果鎖定允許遞迴，執行緒可以進入寫入模式的鎖定，然後輸入它以遞迴方式在以讀取模式。在執行緒結束的順序模式讀寫模式並不重要。</span><span class="sxs-lookup"><span data-stu-id="44960-377">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="44960-378">結束鎖定，可能表示其他的等候中執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-378">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-379">下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端結束寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-379">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="44960-380">範例所示的方法會將新的索引鍵/值組加入至同步處理快取。</span><span class="sxs-lookup"><span data-stu-id="44960-380">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="44960-381">如果機碼已經快取中，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。</span><span class="sxs-lookup"><span data-stu-id="44960-381">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="44960-382"><xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法用來在寫入模式下進入鎖定狀態。</span><span class="sxs-lookup"><span data-stu-id="44960-382">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="44960-383">這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="44960-383">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="44960-384">The current thread has not entered the lock in write mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-384">The current thread has not entered the lock in write mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44960-385">Gets a value that indicates whether the current thread has entered the lock in read mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-385">Gets a value that indicates whether the current thread has entered the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44960-386">如果目前執行緒已進入讀取模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-386">
              <see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-387">這個屬性適用於判斷提示或其他偵錯功能。</span><span class="sxs-lookup"><span data-stu-id="44960-387">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="44960-388">請勿使用它來控制控制程式執行流程。</span><span class="sxs-lookup"><span data-stu-id="44960-388">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-389">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A>屬性來產生判斷提示，如果目前執行緒已進入讀取模式意外。</span><span class="sxs-lookup"><span data-stu-id="44960-389">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44960-390">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-390">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44960-391">如果目前執行緒已進入可升級模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-391">
              <see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-392">這個屬性適用於判斷提示或其他偵錯功能。</span><span class="sxs-lookup"><span data-stu-id="44960-392">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="44960-393">請勿使用它來控制控制程式執行流程。</span><span class="sxs-lookup"><span data-stu-id="44960-393">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-394">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A>產生判斷提示，如果目前執行緒已進入可升級模式非預期的屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-394">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44960-395">Gets a value that indicates whether the current thread has entered the lock in write mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-395">Gets a value that indicates whether the current thread has entered the lock in write mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44960-396">如果目前執行緒已進入寫入模式，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-396">
              <see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-397">這個屬性適用於判斷提示或其他偵錯功能。</span><span class="sxs-lookup"><span data-stu-id="44960-397">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="44960-398">請勿使用它來控制控制程式執行流程。</span><span class="sxs-lookup"><span data-stu-id="44960-398">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-399">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A>產生判斷提示，如果目前執行緒已進入寫入模式非預期的屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-399">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44960-400">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-400">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44960-401">一個列舉值，指定鎖定遞迴原則。</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-401">One of the enumeration values that specifies the lock recursion policy.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-402">遞迴原則會決定多次進入鎖定狀態的執行緒上的限制。</span><span class="sxs-lookup"><span data-stu-id="44960-402">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="44960-403">例如，如果建立鎖定時使用<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>執行緒已進入讀取模式的鎖定和<xref:System.Threading.LockRecursionException>執行緒會嘗試重新進入讀取模式鎖定便會擲回。</span><span class="sxs-lookup"><span data-stu-id="44960-403">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-404">可升級模式的執行緒可以寫入模式升級或降級為讀取模式鎖定的遞迴原則設定。</span><span class="sxs-lookup"><span data-stu-id="44960-404">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="44960-405">不論遞迴原則，一開始進入讀取模式不允許升級至可升級模式 」 或 「 寫入模式，因為該模式會建立強式死結的可能性。</span><span class="sxs-lookup"><span data-stu-id="44960-405">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="44960-406">如需有關遞迴原則，以及它影響的詳細資訊，請參閱<xref:System.Threading.LockRecursionPolicy>列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="44960-406">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44960-407">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-407">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44960-408">0 （零），如果目前執行緒尚未進入讀取模式，1，如果執行緒已進入讀取的模式，但是尚未遞迴進入該，或 * n * 如果執行緒已遞迴進入鎖定 * n *-1 次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-408">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-409">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-409">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="44960-410">計算時，可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="44960-410">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="44960-411">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="44960-411">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44960-412">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-412">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44960-413">如果目前執行緒尚未進入可升級模式，如果執行緒已進入可升級模式，但已遞迴進入該，1，0 或 * n * 如果執行緒已進入可升級模式遞迴 * n *-1 次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-413">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-414">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-414">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="44960-415">計算時，可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="44960-415">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="44960-416">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="44960-416">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44960-417">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-417">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44960-418">0，表示目前執行緒尚未進入寫入模式，1 如果執行緒已進入寫入模式，但是尚未遞迴進入該，或 * n * 如果執行緒已遞迴進入寫入模式 * n *-1 次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-418">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-419">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-419">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="44960-420">計算時，可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="44960-420">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="44960-421">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="44960-421">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="44960-422">Tries to enter the lock in read mode, with an optional time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-422">Tries to enter the lock in read mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="44960-423">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-423">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44960-424">Tries to enter the lock in read mode, with an optional integer time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-424">Tries to enter the lock in read mode, with an optional integer time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44960-425">
            <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-425">
              <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-426">如果`millisecondsTimeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="44960-426">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="44960-427">多個執行緒可以進入讀取的模式，在相同的時間。</span><span class="sxs-lookup"><span data-stu-id="44960-427">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="44960-428">如果一個或多個執行緒正在等待進入寫入模式中，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或呼叫執行緒的自己逾時間隔到期為止。</span><span class="sxs-lookup"><span data-stu-id="44960-428">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-429">如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-429">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="44960-430">其他的執行緒處於讀取模式，可升級模式中只能有一個執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-430">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="44960-431">如果其他的執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會立即進入讀取的模式，而不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="44960-431">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="44960-432">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-432">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="44960-433">-or-  The recursion number would exceed the capacity of the counter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-433">-or-  The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="44960-434">The limit is so large that applications should never encounter it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-434">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="44960-435">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-435">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="44960-436">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-436">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="44960-437">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-437">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44960-438">Tries to enter the lock in read mode, with an optional time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-438">Tries to enter the lock in read mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44960-439">
            <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-439">
              <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-440">如果`timeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="44960-440">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="44960-441">多個執行緒可以在讀取模式下進入鎖定在相同的時間。</span><span class="sxs-lookup"><span data-stu-id="44960-441">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="44960-442">如果一個或多個執行緒佇列進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或呼叫執行緒的自己逾時間隔到期為止。</span><span class="sxs-lookup"><span data-stu-id="44960-442">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-443">如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-443">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="44960-444">其他的執行緒處於讀取模式，可升級模式中只能有一個執行緒。</span><span class="sxs-lookup"><span data-stu-id="44960-444">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="44960-445">如果其他的執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會立即進入讀取的模式，而不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="44960-445">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="44960-446">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-446">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="44960-447">-or-  The recursion number would exceed the capacity of the counter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-447">-or-  The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="44960-448">The limit is so large that applications should never encounter it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-448">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="44960-449">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-449">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="44960-450">-or-  The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-450">-or-  The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="44960-451">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-451">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="44960-452">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-452">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="44960-453">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-453">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44960-454">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-454">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44960-455">
            <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-455">
              <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-456">如果`millisecondsTimeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="44960-456">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="44960-457">使用可升級模式下，當執行緒通常存取受保護的資源<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。</span><span class="sxs-lookup"><span data-stu-id="44960-457">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="44960-458">可升級模式的執行緒可以寫入模式升級或降級為讀取模式。</span><span class="sxs-lookup"><span data-stu-id="44960-458">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="44960-459">只有一個執行緒可以進入可升級模式鎖定，在任何指定時間。</span><span class="sxs-lookup"><span data-stu-id="44960-459">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="44960-460">如果執行緒是在可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒進入讀取的模式，即使有執行緒等待進入可升級模式。</span><span class="sxs-lookup"><span data-stu-id="44960-460">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="44960-461">如果一個或多個執行緒正在等待進入寫入模式中，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或呼叫執行緒的自己逾時間隔到期為止。</span><span class="sxs-lookup"><span data-stu-id="44960-461">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-462">如果鎖定允許遞迴已進入可升級模式鎖定的執行緒可以輸入可升級模式遞迴，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-462">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="44960-463">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-463">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="44960-464">-or-  The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-464">-or-  The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="44960-465">-or-  The recursion number would exceed the capacity of the counter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-465">-or-  The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="44960-466">The limit is so large that applications should never encounter it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-466">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="44960-467">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-467">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="44960-468">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-468">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="44960-469">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-469">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44960-470">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-470">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44960-471">
            <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-471">
              <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-472">如果`timeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="44960-472">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="44960-473">當執行緒通常存取受保護的資源時使用可升級模式<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。</span><span class="sxs-lookup"><span data-stu-id="44960-473">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="44960-474">可升級模式的執行緒可以寫入模式升級或降級為讀取模式。</span><span class="sxs-lookup"><span data-stu-id="44960-474">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="44960-475">只有一個執行緒可以進入可升級模式鎖定，在任何指定時間。</span><span class="sxs-lookup"><span data-stu-id="44960-475">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="44960-476">如果執行緒是在可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒進入讀取的模式，即使有執行緒等待進入可升級模式。</span><span class="sxs-lookup"><span data-stu-id="44960-476">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="44960-477">如果一個或多個執行緒正在等待進入寫入模式中，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或呼叫執行緒的自己逾時間隔到期為止。</span><span class="sxs-lookup"><span data-stu-id="44960-477">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-478">如果鎖定允許遞迴已進入可升級模式鎖定的執行緒可以輸入可升級模式遞迴，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-478">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="44960-479">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-479">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="44960-480">-or-  The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-480">-or-  The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="44960-481">-or-  The recursion number would exceed the capacity of the counter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-481">-or-  The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="44960-482">The limit is so large that applications should never encounter it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-482">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="44960-483">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-483">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="44960-484">-or-  The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-484">-or-  The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="44960-485">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-485">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="44960-486">Tries to enter the lock in write mode, with an optional time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-486">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="44960-487">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-487">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44960-488">Tries to enter the lock in write mode, with an optional time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-488">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44960-489">
            <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-489">
              <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-490">如果`millisecondsTimeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="44960-490">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="44960-491">如果其他的執行緒已進入讀取模式鎖定，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法會封鎖，直到這些執行緒都結束讀取的模式或經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="44960-491">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="44960-492">等待進入寫入模式封鎖執行緒，而嘗試進入讀取模式下或可升級模式的其他執行緒會封鎖直到執行緒等待進入寫入模式，其中已逾時或者已進入寫入模式，然後再從它然後結束。</span><span class="sxs-lookup"><span data-stu-id="44960-492">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-493">如果鎖定允許遞迴已進入寫入模式鎖定的執行緒可以輸入遞迴寫入模式，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-493">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-494">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法來進入寫入模式，以逾時的鎖定。範例所示的方法會將新的索引鍵/值組加入至同步處理快取。</span><span class="sxs-lookup"><span data-stu-id="44960-494">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="44960-495">如果已指定逾時間隔超過在執行緒進入鎖定之前，此方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="44960-495">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="44960-496">方法會傳回`true`如果索引鍵/值組已加入。</span><span class="sxs-lookup"><span data-stu-id="44960-496">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="44960-497">如果機碼已經快取中，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。</span><span class="sxs-lookup"><span data-stu-id="44960-497">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="44960-498">A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端都結束鎖定。</span><span class="sxs-lookup"><span data-stu-id="44960-498">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="44960-499">這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。</span><span class="sxs-lookup"><span data-stu-id="44960-499">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="44960-500">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-500">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="44960-501">-or-  The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-501">-or-  The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="44960-502">-or-  The recursion number would exceed the capacity of the counter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-502">-or-  The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="44960-503">The limit is so large that applications should never encounter it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-503">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="44960-504">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-504">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="44960-505">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-505">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="44960-506">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-506">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="44960-507">Tries to enter the lock in write mode, with an optional time-out.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-507">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="44960-508">
            <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-508">
              <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-509">如果`timeout`是 0 （零），則這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。</span><span class="sxs-lookup"><span data-stu-id="44960-509">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="44960-510">如果其他的執行緒已進入讀取模式鎖定，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法會封鎖，直到這些執行緒都結束讀取的模式或經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="44960-510">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="44960-511">等待進入寫入模式封鎖執行緒，而嘗試進入讀取模式下或可升級模式的其他執行緒會封鎖直到執行緒等待進入寫入模式，其中已逾時或者已進入寫入模式，然後再從它然後結束。</span><span class="sxs-lookup"><span data-stu-id="44960-511">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="44960-512">如果鎖定允許遞迴已進入寫入模式鎖定的執行緒可以輸入遞迴寫入模式，即使其他執行緒等待進入寫入模式。</span><span class="sxs-lookup"><span data-stu-id="44960-512">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="44960-513">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-513">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="44960-514">-or-  The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-514">-or-  The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="44960-515">-or-  The recursion number would exceed the capacity of the counter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-515">-or-  The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="44960-516">The limit is so large that applications should never encounter it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-516">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="44960-517">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-517">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="44960-518">-or-  The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-518">-or-  The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="44960-519">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-519">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44960-520">Gets the total number of threads that are waiting to enter the lock in read mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-520">Gets the total number of threads that are waiting to enter the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44960-521">等待進入讀取模式的執行緒總數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-521">The total number of threads that are waiting to enter read mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-522">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-522">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="44960-523">計算時，可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="44960-523">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="44960-524">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="44960-524">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-525">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A>產生事件記錄檔項目，如果執行緒被封鎖，等待進入讀取的模式，數目超過臨界值的屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-525">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44960-526">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-526">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44960-527">等待進入可升級模式的執行緒總數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-527">The total number of threads that are waiting to enter upgradeable mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-528">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-528">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="44960-529">計算時，可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="44960-529">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="44960-530">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="44960-530">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-531">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A>產生事件記錄檔項目，如果執行緒被封鎖，等待進入可升級模式，數目超過臨界值的屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-531">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="44960-532">Gets the total number of threads that are waiting to enter the lock in write mode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-532">Gets the total number of threads that are waiting to enter the lock in write mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="44960-533">等待進入寫入模式的執行緒總數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="44960-533">The total number of threads that are waiting to enter write mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="44960-534">僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-534">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="44960-535">計算時，可以變更結果。</span><span class="sxs-lookup"><span data-stu-id="44960-535">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="44960-536">因此，它並不安全根據此屬性決定。</span><span class="sxs-lookup"><span data-stu-id="44960-536">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="44960-537">下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A>產生的事件記錄檔項目，就會封鎖，等待進入寫入模式的執行緒數目超過臨界值的屬性。</span><span class="sxs-lookup"><span data-stu-id="44960-537">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>