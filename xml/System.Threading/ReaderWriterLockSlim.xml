<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ba249b86c9e38696438690262b884a5bac97ef6b" /><Meta Name="ms.sourcegitcommit" Value="95e24aee1283af2f120fc5da4b0bdc0712ab698f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65155808" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>代表鎖定，用來管理資源存取，允許多個執行緒的讀取權限或獨佔寫入權限。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.ReaderWriterLockSlim>来保護的資源，是由多個執行緒所讀取和寫入至一個執行緒一次。 <xref:System.Threading.ReaderWriterLockSlim> 可讓多個執行緒處於讀取模式，允許一個執行緒處於寫入模式的鎖定，獨佔擁有權和允許一個執行緒已進入可升級讀取模式，從中執行緒可以升級至寫入模式，而不必放棄它的讀取權限s 讀取資源的存取權。  
  
> [!NOTE]
>  <xref:System.Threading.ReaderWriterLockSlim> 類似於 <xref:System.Threading.ReaderWriterLock>，但是它有遞迴以及升級和降級鎖定狀態的簡化規則。 <xref:System.Threading.ReaderWriterLockSlim> 可避免可能發生死結的許多情況。 此外，<xref:System.Threading.ReaderWriterLockSlim> 的效能明顯優於 <xref:System.Threading.ReaderWriterLock>。 建議針對所有新的開發使用 <xref:System.Threading.ReaderWriterLockSlim>。  
  
 根據預設的新執行個體<xref:System.Threading.ReaderWriterLockSlim>以建立<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>旗標，並不允許遞迴。 這項預設原則被建議所有新的開發，因為遞迴會引進不必要的複雜性，並讓您的程式碼更容易發生死結。 若要簡化從現有的移轉專案中使用<xref:System.Threading.Monitor>或是<xref:System.Threading.ReaderWriterLock>，您可以使用<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>建立的執行個體的旗標<xref:System.Threading.ReaderWriterLockSlim>，允許遞迴。  
  
 執行緒可以進入三種模式的鎖定： 讀取模式 」、 「 寫入模式，以及 「 可升級讀取的模式。 (在本主題的其餘部分，「 讀取可升級模式 」 指 「 進入可升級模式 」 和片語"輸入`x`模式 」 使用順序優先於較長 」 輸入中的鎖定`x`模式 」。)  
  
 遞迴原則，不論只有一個執行緒可以處於寫入模式，在任何時間。 當執行緒處於寫入模式時，沒有其他執行緒可以進入任何模式的鎖定。 只有一個執行緒可以進入可升級模式是在任何時間。 任意數目的執行緒可以處於讀取模式，而且可以有一個執行緒進入可升級模式中其他執行緒處於讀取模式。  
  
> [!IMPORTANT]
>  此類型會實作<xref:System.IDisposable>介面。 當您完成使用型別時，您應該處置它直接或間接。 若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
 <xref:System.Threading.ReaderWriterLockSlim> 具有 managed 執行緒親和性;也就是說，每個<xref:System.Threading.Thread>物件必須讓自己進入或離開鎖定模式的方法呼叫。 沒有任何執行緒可以變更另一個執行緒的模式。  
  
 如果<xref:System.Threading.ReaderWriterLockSlim>不允許遞迴時，執行緒嘗試進入鎖定可以封鎖原因有幾種：  
  
-   嘗試進入讀取的模式的區塊，如果沒有執行緒等待進入寫入模式，或是在寫入模式中有單一執行緒的執行緒。  
  
    > [!NOTE]
    >  寫入器會排入佇列時，將封鎖新讀取器是偏重寫入器鎖定的公平性原則。 目前的公平性原則公平性讀取器和寫入器，來提升產能的最常見的案例之間取得平衡。 未來的版本[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]可能會導入新的公平性化原則。  
  
-   嘗試進入可升級模式的區塊，如果已經有執行緒在進入可升級模式中，如果沒有執行緒等待進入寫入模式，或如果在寫入模式中有單一執行緒的執行緒。  
  
-   嘗試進入寫入模式的區塊，如果沒有任何三個模式中的執行緒的執行緒。  
  
## <a name="upgrading-and-downgrading-locks"></a>升級和降級鎖定  
 可升級模式適用於情況下，執行緒通常會從讀取受保護的資源，但可能要寫入其中，如果符合一些條件。 執行緒已進入<xref:System.Threading.ReaderWriterLockSlim>可升級模式具有讀取存取權受保護的資源，以及可以升級為寫入模式，藉由呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法。 中可以有只有一個執行緒進入可升級模式一次，因為升級至寫入模式不能發生死結時不允許遞迴，這是預設原則。  
  
> [!IMPORTANT]
>  不論遞迴原則，一開始進入讀取模式不允許升級進入可升級模式 」 或 「 寫入模式，因為該模式會發生死結的機率。 例如，如果兩個執行緒同時嘗試進入讀取模式中的寫入模式，它們會鎖死。 可升級模式的設計可避免發生這類死結。  
  
 如果在讀取模式，正在升級封鎖的執行緒中有其他執行緒。 執行緒已封鎖，而其他的執行緒嘗試進入讀取的模式，將會遭到封鎖。 當所有執行緒都結束讀取模式中時，已封鎖升級的執行緒會進入寫入模式。 如果有其他執行緒等待進入寫入模式，它們將持續封鎖，因為可升級模式是單一執行緒會讓使用者無法獲得獨佔資源存取權。  
  
 當進入可升級模式中的執行緒結束寫入模式時，其他執行緒等待進入讀取的模式，可以這麼做，除非有執行緒等待進入寫入模式。 可升級模式中的執行緒可以升級並無限期，降級，只要它是唯一的執行緒將寫入至受保護的資源。  
  
> [!IMPORTANT]
>  如果您允許多個執行緒進入寫入模式或進入可升級模式，您必須允許單一執行緒獨佔進入可升級模式。 否則，執行緒嘗試進入寫入模式直接將會永遠被封鎖，且已被封鎖，而其他執行緒將無法進入讀取的模式。  
  
 可升級模式中的執行緒可以降級為讀取模式，第一次呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法，然後呼叫<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法。 即使允許所有的鎖定遞迴原則，此降級模式<xref:System.Threading.LockRecursionPolicy.NoRecursion>。  
  
 降級為讀取模式之後，執行緒無法重新輸入可升級模式，直到它具有結束讀取模式。  
  
## <a name="entering-the-lock-recursively"></a>輸入鎖定以遞迴方式  
 您可以建立<xref:System.Threading.ReaderWriterLockSlim>使用支援遞迴鎖定項目<xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29>建構函式指定鎖定原則，並指定<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>。  
  
> [!NOTE]
>  使用遞迴不會建議新的程式開發，因為它會引進不必要的複雜性，並讓您的程式碼更容易發生死結。  
  
 針對<xref:System.Threading.ReaderWriterLockSlim>可讓遞迴功能，可說是下列相關執行緒可以進入的模式：  
  
-   讀取模式中的執行緒可以進入讀取的模式遞迴的但無法進入寫入模式或進入可升級模式。 如果它嘗試這樣做，請<xref:System.Threading.LockRecursionException>就會擲回。 進入讀取模式，然後進入寫入模式，或進入可升級模式是死結的機率與模式，因此不允許。 如前文所述，就必須升級鎖定的情況下提供進入可升級模式。  
  
-   可升級模式中的執行緒可以在寫入模式，及/或讀取的模式中，輸入，並可以輸入任何三種模式以遞迴方式。 不過，嘗試進入寫入模式區塊讀取模式中是否有其他執行緒。  
  
-   寫入模式中的執行緒會讀取的模式，及/或可升級模式，可以輸入，並可以輸入任何三種模式以遞迴方式。  
  
-   不進入鎖定的執行緒可以進入任何模式。 這項嘗試可能會封鎖嘗試將輸入的是非遞迴鎖定理由相同。  
  
 執行緒可以結束它已經進入依任何順序的模式，只要結束每個進入該模式下的次數相同的模式。 如果執行緒嘗試次數過多時，結束模式，或結束的模式，它已經不進入<xref:System.Threading.SynchronizationLockException>就會擲回。  
  
## <a name="lock-states"></a>鎖定狀態  
 您可能會有用來看待鎖定的狀態中的條款。 A<xref:System.Threading.ReaderWriterLockSlim>可以處於四種狀態之一： 不是輸入讀取、 升級和寫入。  
  
-   未輸入：在此狀態下，沒有任何執行緒已進入鎖定 （或所有執行緒都結束鎖定）。  
  
-   讀取：在此狀態下，一或多個執行緒已進入鎖定的讀取權限受保護的資源。  
  
    > [!NOTE]
    >  執行緒可以進入讀取模式鎖定使用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>或<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法，或從 可升級模式降級。  
  
-   升級：在此狀態下，一個執行緒已升級為寫入權限的選項與讀取權限進入鎖定 （也就是在進入可升級模式中），以及零個或多個執行緒已進入鎖定的讀取權限。 一次不超過一個執行緒可以進入鎖定升級; 的選項嘗試進入可升級模式的其他執行緒會遭到封鎖。  
  
-   撰寫程式碼：在此狀態下，一個執行緒已進入鎖定進行寫入存取受保護的資源。 該執行緒已鎖定的獨佔擁有權。 嘗試進入鎖定，因為任何原因的其他任何執行緒被封鎖。  
  
 下表描述的鎖定狀態，不允許遞迴時，當執行緒的鎖定之間的轉換`t`採取最左邊的資料行中所述。 當時它採取動作，`t`不有任何模式。 (的特殊情況下，`t`處於可升級模式所述的資料表註腳。)上方資料列描述鎖定的開始狀態。 資料格說明執行緒，會發生什麼事，並顯示在括號中的鎖定狀態的變更。  
  
||不進入 (N)|Read (R)|升級 (U)|寫入 (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` 進入讀取的模式|`t` 輸入 (R)。|`t` 如果執行緒正在等候寫入模式;，區塊否則，`t`進入。|`t` 如果執行緒正在等候寫入模式;，區塊否則，請`t`進入。<sup>1</sup>|`t` 區塊。|  
|`t` 進入可升級模式|`t` 輸入 (U)。|`t` 如果執行緒正在等候的區塊寫入模式或升級模式;否則，`t`進入 (U)。|`t` 區塊。|`t` 區塊。|  
|`t` 進入寫入模式|`t` 輸入 (W)。|`t` 區塊。|`t` blocks.<sup>2</sup>|`t` 區塊。|  
  
 <sup>1</sup>如果`t`啟動出可升級模式，它會進入讀取的模式。 此動作會永遠不會封鎖。 鎖定狀態不會變更。 （執行緒即可完成降級至結束可升級模式，以讀取模式）。  
  
 <sup>2</sup>如果`t`開始都處於可升級模式，它會封鎖有執行緒在讀取模式中。 否則，會升級寫入模式。 鎖定狀態會改變要寫入 (W)。 如果`t`封鎖有執行緒處於讀取模式，因為它進入寫入模式，只要在最後一個執行緒結束讀取的模式，即使有執行緒等待進入寫入模式。  
  
 當執行緒結束鎖定，就會發生狀態變更時下, 一個要喚醒的執行緒則選取路由，如下所示：  
  
-   首先，執行緒正在等候寫入模式，並已可升級模式 （可以有最多一個這類執行緒）。  
  
-   如果再次失敗，正在等候寫入模式的執行緒。  
  
-   如果再次失敗，正在等候進入可升級模式的執行緒。  
  
-   如果再次失敗，正在等候讀取模式的所有執行緒。  
  
 後續狀態一律是鎖定的寫入 (W) 在第一個兩個案例和升級 (U) 在第三個案例中，不論現有的執行緒觸發狀態變更時鎖定的狀態。 在最後一個案例中，鎖定的狀態是升級 (U) 中是否有一個執行緒進入可升級模式之後的狀態變更和 Read (R) 否則不論先前的狀態。  
  
   
  
## Examples  
 下列範例顯示簡單的同步處理快取保存字串與整數索引鍵。 執行個體<xref:System.Threading.ReaderWriterLockSlim>用來同步存取<xref:System.Collections.Generic.Dictionary%602>做為內部的快取。  
  
 範例包括簡單的方法，來新增至快取、 從快取中，刪除並從讀取快取。 為了示範逾時，此範例也包含的方法，則可以這麼內指定的逾時，才加入至快取。  
  
 為了示範可升級模式，此範例包含方法，可擷取索引鍵相關聯的值，並比較它與新的值。 如果值未變更，則方法會傳回狀態，指出沒有變更。 如果不找到索引鍵的任何值，則會插入的索引鍵/值組。 如果值已變更，就會更新。 可升級模式，可讓執行緒從讀取權限寫入權限，如有需要死結的風險的情況下升級。  
  
 此範例也包含巢狀的列舉，指定將示範可升級模式的方法的傳回值。  
  
 此範例會使用預設建構函式來建立鎖定，因此不允許遞迴。 程式設計<xref:System.Threading.ReaderWriterLockSlim>是更簡單且較不容易發生錯誤，當鎖定不允許遞迴。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 下列程式碼然後使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。 它會建立三項工作。 第一個陣列中儲存的蔬菜名稱寫入`SynchronizedCache`執行個體。 第二個和第三個工作顯示蔬菜、 以遞增順序 （從低索引最高索引），以遞減順序的第二個的第一個的名稱。 最後一項工作會搜尋字串"cucumber 」，並找到它，當呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來取代字串"綠色 bean"。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>使用預設屬性值，初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Threading.ReaderWriterLockSlim>初始化與這個建構函式不允許遞迴。 亦即，<xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> 屬性會傳回 <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>。  
  
 如需有關遞迴原則和其效果的詳細資訊，請參閱 <<c0> <xref:System.Threading.LockRecursionPolicy> 列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
   
  
## Examples  
 下列範例顯示簡單的同步處理快取保存字串與整數索引鍵。 執行個體<xref:System.Threading.ReaderWriterLockSlim>用來同步存取<xref:System.Collections.Generic.Dictionary%602>做為內部的快取。 無參數建構函式用來建立鎖定。  
  
 範例包括簡單的方法，來新增至快取、 從快取中，刪除並從讀取快取。 為了示範逾時，此範例也包含的方法，則可以這麼內指定的逾時，才加入至快取。  
  
 為了示範可升級模式，此範例包含方法，可擷取索引鍵相關聯的值，並比較它與新的值。 如果值未變更，則方法會傳回狀態，指出沒有變更。 如果不找到索引鍵的任何值，則會插入的索引鍵/值組。 如果值已變更，就會更新。 可升級模式，可讓執行緒從讀取權限寫入權限，如有需要死結的風險的情況下升級。  
  
 此範例也包含巢狀的列舉，指定將示範可升級模式的方法的傳回值。  
  
 此範例會使用預設建構函式來建立鎖定，因此不允許遞迴。 程式設計<xref:System.Threading.ReaderWriterLockSlim>是更簡單且較不容易發生錯誤，當鎖定不允許遞迴。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 下列程式碼然後使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。 它會建立三項工作。 第一個陣列中儲存的蔬菜名稱寫入`SynchronizedCache`執行個體。 第二個和第三個工作顯示蔬菜、 以遞增順序 （從低索引最高索引），以遞減順序的第二個的第一個的名稱。 最後一項工作會搜尋字串"cucumber 」，並找到它，當呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來取代字串"綠色 bean"。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">一個列舉值，指定鎖定遞迴原則。</param>
        <summary>指定鎖定遞迴原則，初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 遞迴原則決定多次進入鎖定的執行緒上的限制。 例如，如果您建立鎖定時<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>執行緒已進入讀取模式的鎖定和<xref:System.Threading.LockRecursionException>執行緒會嘗試重新輸入中讀取模式鎖定便會擲回。 同樣地，如果執行緒已進入寫入模式的鎖定<xref:System.Threading.LockRecursionException>如果執行緒嘗試重新輸入在任何模式的鎖定，會擲回。  
  
> [!NOTE]
>  可升級模式中的執行緒可以升級為寫入模式，或降級為讀取模式，不論鎖定遞迴原則設定。  
  
 不論遞迴原則，一開始進入讀取模式不允許升級進入可升級模式 」 或 「 寫入模式，因為該模式會發生死結的機率。  
  
 如需有關遞迴原則和其效果的詳細資訊，請參閱 <<c0> <xref:System.Threading.LockRecursionPolicy> 列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
   
  
## Examples  
 下列範例顯示兩個例外狀況，其中一個，取決於<xref:System.Threading.LockRecursionPolicy>設定，另一個則否。  
  
 在第一個案例中，執行緒會進入讀取的模式，並嘗試遞迴地進入讀取的模式。 如果<xref:System.Threading.ReaderWriterLockSlim>遞迴原則設定的預設建構函式會建立<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>，會擲回例外狀況。 如果<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>用以建立<xref:System.Threading.ReaderWriterLockSlim>，會擲回任何例外狀況。  
  
 在第二個案例中，在執行緒進入讀取的模式，然後嘗試進入寫入模式。 <xref:System.Threading.LockRecursionException> 無論鎖定遞迴原則就會擲回。  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 下列程式碼然後使用`SynchronizedCache`儲存 vegetable 名稱的字典物件。 它會建立三項工作。 第一個陣列中儲存的蔬菜名稱寫入`SynchronizedCache`執行個體。 第二個和第三個工作顯示蔬菜、 以遞增順序 （從低索引最高索引），以遞減順序的第二個的第一個的名稱。 最後一項工作會搜尋字串"cucumber 」，並找到它，當呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來取代字串"綠色 bean"。  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得已進入讀取模式鎖定狀態的唯一執行緒總數。</summary>
        <value>已進入讀取模式鎖定狀態的唯一執行緒數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒只計算一次，即使鎖定允許遞迴和執行緒已進入讀取的模式多次。  
  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 一旦已計算出，則可以變更結果。 因此，它並不安全根據此屬性決定。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A>屬性，以產生事件記錄檔項目，如果在讀取模式中的執行緒數目超過臨界值。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 類別目前的執行個體所使用的全部資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 使用完畢時，請呼叫 <xref:System.Threading.ReaderWriterLockSlim>。 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> 方法會將 <xref:System.Threading.ReaderWriterLockSlim> 保留在無法使用的狀態。 之後呼叫<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>，您必須釋放所有的參考<xref:System.Threading.ReaderWriterLockSlim>讓記憶體回收行程可以回收記憶體，<xref:System.Threading.ReaderWriterLockSlim>所佔用。 如需詳細資訊，請參閱 <<c0> [ 清除 Unmanaged 資源向上](~/docs/standard/garbage-collection/unmanaged.md)並[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  請務必呼叫<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>您釋放最後一個參考之前<xref:System.Threading.ReaderWriterLockSlim>物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> 大於零。  
  
-或- 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> 大於零。  
  
-或- 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> 大於零。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試進入讀取模式的鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會封鎖，直到呼叫的執行緒進入鎖定，並因此可能永遠不會傳回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法，以封鎖指定的間隔，然後再將 如果呼叫的執行緒尚未進入讀取模式，在該間隔期間。  
  
 多個執行緒可以進入讀取的模式，在相同的時間。  
  
 如果一或多個執行緒在等待進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法封鎖，直到這些執行緒已逾時或已進入寫入模式，然後結束它。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。  
  
 當其他執行緒處於讀取模式時，最多一個執行緒可以進入可升級模式中。 如果其他執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法立即進入讀取的模式，並不會封鎖。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>進入讀取模式鎖定的方法。 在範例中所示的方法會擷取索引鍵相關聯的值。 如果找不到金鑰，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。 A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，確保呼叫端結束讀取的模式。  
  
 此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒嘗試在已經保留讀取鎖定的情況下取得讀取鎖定。  
  
-或- 
<see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 屬性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，且目前的執行緒嘗試在已經保留寫入鎖定的情況下取得讀取鎖定。  
  
-或- 
遞迴的次數會超過計數器的容量。 這項限制非常寬鬆，所以應用程式應該永遠都不會發生這種例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試進入可升級模式的鎖定狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會封鎖，直到呼叫的執行緒進入鎖定，並因此可能永遠不會傳回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>封鎖指定的間隔，然後再將 如果呼叫的執行緒尚未進入可升級模式在該間隔期間的方法。  
  
 當執行緒通常存取受保護的資源，則使用可升級模式<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。 可升級模式中的執行緒可以降級為讀取模式，或升級為寫入模式。  
  
 只有一個執行緒可以進入可升級模式，在任何指定時間。 如果執行緒在進入可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒可以在即使有等待進入可升級模式的執行緒進入讀取的模式。  
  
 如果一或多個執行緒在等待進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法封鎖，直到這些執行緒已逾時或已進入寫入模式，然後結束它。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入可升級模式鎖定的執行緒可以進入可升級模式遞迴地進入，即使其他執行緒等待進入寫入模式。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>方法來進入可升級模式的鎖定。 A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，確保呼叫端結束可升級模式。  
  
 在範例中所示的方法擷取索引鍵相關聯的值，並比較它與新的值。 如果值未變更，則方法會傳回狀態，指出沒有變更。 沒有值找到索引鍵，會插入索引鍵/值組。 如果值已變更，就會更新。 可升級模式，可讓執行緒升級讀取的鎖定，如有需要而死結的風險。  
  
 此範例會使用預設建構函式來建立鎖定，因此不允許遞迴。 程式設計<xref:System.Threading.ReaderWriterLockSlim>是更簡單且較不容易發生錯誤，當鎖定不允許遞迴。  
  
 此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定在任何模式。  
  
-或- 
目前的執行緒已進入讀取的模式，因此嘗試進入可升級模式，則會造成死結的可能性。  
  
-或- 
遞迴的次數會超過計數器的容量。 限制是很大，應用程式應該永遠不會發生這個情形。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>嘗試進入寫入模式的鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會封鎖，直到呼叫的執行緒進入鎖定，並因此可能永遠不會傳回。 使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>封鎖指定的間隔，然後再將 如果呼叫的執行緒尚未進入寫入模式在該間隔期間的方法。  
  
 如果其他執行緒已進入讀取模式的鎖定，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法封鎖，直到這些執行緒都結束讀取模式。 等待進入寫入模式的執行緒時，額外的執行緒嘗試進入讀取的模式] 或 [可升級模式封鎖，直到等待進入寫入模式的所有執行緒都都是逾時或已進入寫入模式，然後結束它。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入寫入模式鎖定的執行緒可以進入寫入模式以遞迴方式，即使其他執行緒等待進入寫入模式。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>進入寫入模式鎖定的方法。 範例所示的方法會將新的索引鍵/值組加入至同步處理的快取。 如果快取中，所擲回的內部例外狀況已有索引鍵<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。 A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端結束寫入模式。  
  
 此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定在任何模式。  
  
-或- 
目前的執行緒已進入真實模式，而且還沒有擁有寫入鎖定，因此嘗試進入寫入模式鎖定可能會造成死結。  
  
-或- 
遞迴的次數會超過計數器的容量。 限制是很大，應用程式應該永遠不會發生這個情形。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>減少讀取模式遞迴的計數，如果得出的計數為 0 (零)，則結束讀取模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是遞迴順序。 例如，如果執行緒進入可升級模式的鎖定，然後在讀取模式下進入鎖定的執行緒結束的兩種模式的順序無關緊要。 如果鎖定允許遞迴，執行緒可以進入寫入模式的鎖定，然後輸入它以遞迴方式讀取模式;在執行緒結束的順序模式讀寫模式並不重要。  
  
 結束鎖定，可能表示其他等候中執行緒。  
  
   
  
## Examples  
 下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>方法，確保呼叫端結束讀取的模式。 在範例中所示的方法會擷取索引鍵相關聯的值。 如果找不到金鑰，由內部擲回的例外狀況<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>方法用來進入讀取的模式。  
  
 此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">目前執行緒尚未進入讀取模式的鎖定。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>減少可升級模式遞迴的計數，如果得出的計數為 0 (零)，則結束可升級模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是遞迴順序。 例如，如果執行緒進入可升級模式的鎖定，然後在寫入模式下進入鎖定的執行緒結束的兩種模式的順序無關緊要。 如果鎖定允許遞迴，執行緒可以進入寫入模式鎖定，然後遞迴地進入可升級模式;在執行緒結束可升級模式和寫入模式的順序並不重要。  
  
 結束鎖定，可能表示其他等候中執行緒。  
  
   
  
## Examples  
 下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>方法，確保呼叫端結束可升級模式。  
  
 在範例中所示的方法擷取索引鍵相關聯的值，並比較它與新的值。 如果值未變更，則方法會傳回狀態，指出沒有變更。 沒有值找到索引鍵，會插入索引鍵/值組。 如果值已變更，就會更新。 可升級模式，可讓執行緒升級讀取的鎖定，如有需要而死結的風險。  
  
 此範例會使用預設建構函式來建立鎖定，因此不允許遞迴。 程式設計<xref:System.Threading.ReaderWriterLockSlim>是更簡單且較不容易發生錯誤，當鎖定不允許遞迴。  
  
 此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">目前執行緒尚未進入可升級模式的鎖定。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>減少寫入模式遞迴的計數，如果得出的計數為 0 (零)，則結束寫入模式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不是遞迴順序。 例如，如果執行緒進入可升級模式的鎖定，然後在寫入模式下進入鎖定的執行緒結束的兩種模式的順序無關緊要。 如果鎖定允許遞迴，執行緒可以進入寫入模式的鎖定，然後輸入它以遞迴方式讀取模式;在執行緒結束的順序模式讀寫模式並不重要。  
  
 結束鎖定，可能表示其他等候中執行緒。  
  
   
  
## Examples  
 下列範例示範如何使用`finally`區塊執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端結束寫入模式。 範例所示的方法會將新的索引鍵/值組加入至同步處理的快取。 如果快取中，所擲回的內部例外狀況已有索引鍵<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>方法用來進入寫入模式的鎖定。  
  
 此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">目前執行緒尚未進入寫入模式的鎖定。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前執行緒是否已進入讀取模式的鎖定。</summary>
        <value>如果目前執行緒已進入讀取模式，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性適用於判斷提示或其他偵錯的目的。 請勿使用它來控制控制程式執行流程。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A>屬性，以產生判斷提示，如果目前執行緒已進入讀取模式的意外。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前執行緒是否已進入可升級模式的鎖定。</summary>
        <value>如果目前執行緒已進入可升級模式，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性適用於判斷提示或其他偵錯的目的。 請勿使用它來控制控制程式執行流程。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A>如果目前執行緒已意外地進入可升級模式產生判斷提示的屬性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前執行緒是否已進入寫入模式的鎖定。</summary>
        <value>如果目前執行緒已進入寫入模式，則為 <see langword="true" />；否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性適用於判斷提示或其他偵錯的目的。 請勿使用它來控制控制程式執行流程。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A>如果目前執行緒已意外地進入寫入模式產生判斷提示的屬性。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，表示目前 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件的遞迴原則。</summary>
        <value>一個列舉值，指定鎖定遞迴原則。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 遞迴原則決定多次進入鎖定的執行緒上的限制。 例如，如果您建立鎖定時<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>執行緒已進入讀取模式的鎖定和<xref:System.Threading.LockRecursionException>執行緒會嘗試重新輸入中讀取模式鎖定便會擲回。  
  
> [!NOTE]
>  可升級模式中的執行緒可以升級為寫入模式，或降級為讀取模式，不論鎖定遞迴原則設定。  
  
 不論遞迴原則，一開始進入讀取模式不允許升級進入可升級模式 」 或 「 寫入模式，因為該模式會發生死結的機率。  
  
 如需有關遞迴原則和其效果的詳細資訊，請參閱 <<c0> <xref:System.Threading.LockRecursionPolicy> 列舉型別和<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前執行緒已進入讀取模式鎖定的次數，做為遞迴的表示。</summary>
        <value>0 （零），如果目前執行緒尚未進入讀取模式，1，表示執行緒已進入讀取的模式，但是尚未遞迴進入該，或是*n*如果執行緒已遞迴進入鎖定*n* -1 次。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 一旦已計算出，則可以變更結果。 因此，它並不安全根據此屬性決定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前執行緒已進入可升級模式鎖定的次數，做為遞迴的表示。</summary>
        <value>0，表示目前執行緒尚未進入可升級模式，如果執行緒已進入可升級模式，但是已遞迴進入該，則為 1 或*n*如果執行緒已進入可升級模式遞迴*n* -1時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 一旦已計算出，則可以變更結果。 因此，它並不安全根據此屬性決定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前執行緒已進入寫入模式鎖定的次數，做為遞迴的表示。</summary>
        <value>0，表示目前執行緒尚未進入寫入模式中，1 如果執行緒已進入寫入模式，但是尚未遞迴進入該，或是*n*如果執行緒已進入寫入模式遞迴*n* -1 次。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 一旦已計算出，則可以變更結果。 因此，它並不安全根據此屬性決定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>嘗試以選用的逾時，在讀取模式下進入鎖定狀態。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數；若要永遠等候，則為 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)。</param>
        <summary>嘗試以選用的整數逾時，進入讀取模式的鎖定狀態。</summary>
        <returns>如果呼叫執行緒已進入讀取模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 多個執行緒可以進入讀取的模式，在相同的時間。  
  
 如果一或多個執行緒在等待進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或是呼叫執行緒自己的逾時間隔到期。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。  
  
 當其他執行緒處於讀取模式時，有一個執行緒可以進入可升級模式中。 如果其他執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法立即進入讀取的模式，並不會封鎖。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。  
  
-或- 
遞迴的次數會超過計數器的容量。 限制是很大，應用程式應該永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">值<paramref name="millisecondsTimeout" />是負數，但不等於<see cref="F:System.Threading.Timeout.Infinite" />(-1)，這是唯一允許的負值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的間隔，或 -1 毫秒無限期等待。</param>
        <summary>嘗試以選用的逾時，在讀取模式下進入鎖定狀態。</summary>
        <returns>如果呼叫執行緒已進入讀取模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 多個執行緒可以進入讀取模式鎖定，同時。  
  
 如果一個或多個執行緒已進入寫入模式中排入佇列，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或是呼叫執行緒自己的逾時間隔到期。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入讀取模式鎖定的執行緒可以進入讀取的模式遞迴，即使其他執行緒等待進入寫入模式。  
  
 當其他執行緒處於讀取模式時，有一個執行緒可以進入可升級模式中。 如果其他執行緒等待進入可升級模式，且沒有執行緒等待進入寫入模式，執行緒呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>方法立即進入讀取的模式，並不會封鎖。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。  
  
-或- 
遞迴的次數會超過計數器的容量。 限制是很大，應用程式應該永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">值<paramref name="timeout" />是負數，但不等於-1 毫秒，這是唯一允許的負值。  
  
-或- 
值<paramref name="timeout" />大於<see cref="F:System.Int32.MaxValue" />毫秒為單位。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>嘗試以選用的逾時，在可升級模式下進入鎖定狀態。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數；若要永遠等候，則為 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)。</param>
        <summary>嘗試以選用的逾時，在可升級模式下進入鎖定狀態。</summary>
        <returns>如果呼叫執行緒已進入可升級模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 當執行緒通常存取受保護的資源，則使用可升級模式<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。 可升級模式中的執行緒可以升級為寫入模式，或降級為讀取模式。  
  
 只有一個執行緒可以進入可升級模式鎖定，在任何指定時間。 如果執行緒在進入可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒可以在即使有等待進入可升級模式的執行緒進入讀取的模式。  
  
 如果一或多個執行緒在等待進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或是呼叫執行緒自己的逾時間隔到期。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入可升級模式鎖定的執行緒可以進入可升級模式遞迴地進入，即使其他執行緒等待進入寫入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。  
  
-或- 
目前執行緒一開始在讀取模式中，進入鎖定，因此嘗試進入可升級模式，則會造成死結的可能性。  
  
-或- 
遞迴的次數會超過計數器的容量。 限制是很大，應用程式應該永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">值<paramref name="millisecondsTimeout" />是負數，但不等於<see cref="F:System.Threading.Timeout.Infinite" />(-1)，這是唯一允許的負值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的間隔，或 -1 毫秒無限期等待。</param>
        <summary>嘗試以選用的逾時，在可升級模式下進入鎖定狀態。</summary>
        <returns>如果呼叫執行緒已進入可升級模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 當執行緒通常存取受保護的資源，則使用可升級模式<xref:System.Threading.ReaderWriterLockSlim>在讀取模式，但可能需要進入寫入模式，如果符合特定條件。 可升級模式中的執行緒可以升級為寫入模式，或降級為讀取模式。  
  
 只有一個執行緒可以進入可升級模式鎖定，在任何指定時間。 如果執行緒在進入可升級模式，且沒有執行緒等待進入寫入模式，任意數目的其他執行緒可以在即使有等待進入可升級模式的執行緒進入讀取的模式。  
  
 如果一或多個執行緒在等待進入寫入模式中，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>方法會封鎖，直到這些執行緒有可能是等候逾時或已進入寫入模式，然後結束，或是呼叫執行緒自己的逾時間隔到期。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入可升級模式鎖定的執行緒可以進入可升級模式遞迴地進入，即使其他執行緒等待進入寫入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。  
  
-或- 
目前執行緒一開始在讀取模式中，進入鎖定，因此嘗試進入可升級模式，則會造成死結的可能性。  
  
-或- 
遞迴的次數會超過計數器的容量。 限制是很大，應用程式應該永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">值<paramref name="timeout" />是負數，但不等於-1 毫秒，這是唯一允許的負值。  
  
-或- 
值<paramref name="timeout" />大於<see cref="F:System.Int32.MaxValue" />毫秒為單位。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>嘗試以選用的逾時，在寫入模式下進入鎖定狀態。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數；若要永遠等候，則為 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)。</param>
        <summary>嘗試以選用的逾時，在寫入模式下進入鎖定狀態。</summary>
        <returns>如果呼叫執行緒已進入寫入模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 如果其他執行緒已進入讀取模式的鎖定，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法會封鎖，直到這些執行緒都結束讀取的模式或經過逾時間隔為止。 等待進入寫入模式，會封鎖執行緒，而嘗試進入讀取的模式或進入可升級模式的其他執行緒會封鎖直到執行緒等待進入寫入模式，有其中一個等候逾時或已進入寫入模式，然後結束它。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入寫入模式鎖定的執行緒可以進入寫入模式以遞迴方式，即使其他執行緒等待進入寫入模式。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法來進入寫入模式，與逾時的鎖定。範例所示的方法會將新的索引鍵/值組加入至同步處理的快取。 如果超過指定時間的指定逾時間隔，在執行緒進入鎖定之前，此方法會傳回`false`。 此方法會傳回`true`如果加入的索引鍵/值組。  
  
 如果快取中，所擲回的內部例外狀況已有索引鍵<xref:System.Collections.Generic.Dictionary%602>允許 terminate 方法。 A`finally`區塊用來執行<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>方法，確保呼叫端都結束鎖定。  
  
 此程式碼是針對提供之較大範例的一部分<xref:System.Threading.ReaderWriterLockSlim>類別。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。  
  
-或- 
目前執行緒一開始在讀取模式中，進入鎖定，因此嘗試進入寫入模式可能會造成死結。  
  
-或- 
遞迴的次數會超過計數器的容量。 限制是很大，應用程式應該永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">值<paramref name="millisecondsTimeout" />是負數，但不等於<see cref="F:System.Threading.Timeout.Infinite" />(-1)，這是唯一允許的負值。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">等待的間隔，或 -1 毫秒無限期等待。</param>
        <summary>嘗試以選用的逾時，在寫入模式下進入鎖定狀態。</summary>
        <returns>如果呼叫執行緒已進入寫入模式，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`為 0 （零），這個方法會檢查鎖定狀態，並傳回`false`立即如果所需的狀態無法使用。  
  
 如果其他執行緒已進入讀取模式的鎖定，執行緒的呼叫<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>方法會封鎖，直到這些執行緒都結束讀取的模式或經過逾時間隔為止。 等待進入寫入模式，會封鎖執行緒，而嘗試進入讀取的模式或進入可升級模式的其他執行緒會封鎖直到執行緒等待進入寫入模式，有其中一個等候逾時或已進入寫入模式，然後結束它。  
  
> [!NOTE]
>  如果鎖定允許遞迴，已進入寫入模式鎖定的執行緒可以進入寫入模式以遞迴方式，即使其他執行緒等待進入寫入模式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />屬性是<see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />且目前的執行緒已進入鎖定。  
  
-或- 
目前執行緒一開始在讀取模式中，進入鎖定，因此嘗試進入寫入模式可能會造成死結。  
  
-或- 
遞迴的次數會超過計數器的容量。 限制是很大，應用程式應該永遠不會發生這個情形。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">值<paramref name="timeout" />是負數，但不等於-1 毫秒，這是唯一允許的負值。  
  
-或- 
值<paramref name="timeout" />大於<see cref="F:System.Int32.MaxValue" />毫秒為單位。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.ReaderWriterLockSlim" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得等待進入讀取模式鎖定狀態的執行緒總數。</summary>
        <value>等待進入讀取模式的執行緒總數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 一旦已計算出，則可以變更結果。 因此，它並不安全根據此屬性決定。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A>屬性，以產生事件記錄檔項目，如果封鎖，等待進入讀取的模式，執行緒的數目超過臨界值。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得等待進入可升級模式鎖定狀態的執行緒總數。</summary>
        <value>等待進入可升級模式的執行緒總數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 一旦已計算出，則可以變更結果。 因此，它並不安全根據此屬性決定。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A>屬性，以產生事件記錄檔項目，如果封鎖，等待進入可升級模式，執行緒的數目超過臨界值。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得等待進入寫入模式鎖定狀態的執行緒總數。</summary>
        <value>等待進入寫入模式的執行緒總數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 僅適用於偵錯、 分析和記錄功能，而非控制演算法的行為，請使用這個屬性。 一旦已計算出，則可以變更結果。 因此，它並不安全根據此屬性決定。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A>屬性，以產生事件記錄檔項目，如果遭到封鎖，等待進入寫入模式的執行緒數目超過臨界值。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
