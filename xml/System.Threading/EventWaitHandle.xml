<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="61c510c2657756b5dda575c7964f17954eef85a4" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407161" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a thread synchronization event.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle>類別可讓執行緒信號與對方進行通訊。 一般而言，一個或多個執行緒封鎖<xref:System.Threading.EventWaitHandle>之前解除封鎖的執行緒呼叫<xref:System.Threading.EventWaitHandle.Set%2A>方法，釋出一或多個已封鎖的執行緒。 執行緒可以發出信號<xref:System.Threading.EventWaitHandle>再封鎖它，藉由呼叫`static`(`Shared`在 Visual Basic 中)<xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  <xref:System.Threading.EventWaitHandle>類別會提供存取具名的系統同步處理事件。  
  
 行為<xref:System.Threading.EventWaitHandle>，已收到信號其重設模式而定。 <xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標會自動重設時收到信號之後釋出單一的等候執行緒。 <xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標會保留已收到信號，直到其<xref:System.Threading.EventWaitHandle.Reset%2A>方法呼叫。  
  
 自動重設事件提供給資源的獨佔存取權。 如果自動重設事件在沒有任何執行緒處於等候狀態時收到訊號，它會維持收到訊號的狀態，直到有執行緒嘗試等候它為止。 此事件會釋出執行緒並立即重設，以阻斷後續的執行緒。  
  
 手動重設事件就像是大門。 當事件不會收到信號時，將會封鎖在其等候的執行緒。 當事件發出信號、 釋放所有等候中執行緒，以及事件保留已收到信號時 （亦即，就不會封鎖後續的等候） 直到其<xref:System.Threading.EventWaitHandle.Reset%2A>方法呼叫。 手動重設事件當一個執行緒必須完成的活動，然後才可以繼續執行其他執行緒會很有用。  
  
 <xref:System.Threading.EventWaitHandle> 物件可以用與`static`(`Shared`在 Visual Basic 中)<xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>和<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>方法。  
  
 如需執行緒的同步處理機制的詳細資訊，請參閱[EventWaitHandle、 AutoResetEvent、 CountdownEvent、 ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法多載來允許主執行緒發出信號封鎖的執行緒，以及執行緒完成工作，然後等候。  
  
 範例啟動五個執行緒，並讓他們封鎖<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標，然後再發行每一個執行緒時間，使用者按下 ENTER 鍵。 此範例會排入佇列，另一個的五個執行緒，並釋放所有使用<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未收到信號的事件初始狀態，該事件的執行緒會封鎖。 如果收到信號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，該事件的執行緒不會封鎖。 如果收到信號的初始狀態，和`mode`是<xref:System.Threading.EventResetMode.AutoReset>、 等候事件的第一個執行緒就會發行立即之後, 會重設事件，並將會封鎖後續的執行緒。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法多載來允許主執行緒發出信號封鎖的執行緒，以及執行緒完成工作，然後等候。  
  
 範例啟動五個執行緒，並讓他們封鎖<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標，然後再發行每一個執行緒時間，使用者按下 ENTER 鍵。 此範例會排入佇列，另一個的五個執行緒，並釋放所有使用<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <param name="name">The name of a system-wide synchronization event.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`name`是`null`或空字串時，本機<xref:System.Threading.EventWaitHandle>建立。  
  
 如果指定的名稱與系統事件`name`參數已經存在，`initialState`參數已忽略。  
  
> [!IMPORTANT]
>  當使用這個建構函式的具名的系統事件時，指定`false`如`initialState`。 這個建構函式會提供任何方法來判斷是否已建立具名的系統事件，因此您不能提出任何假設具名事件的狀態。 若要判斷是否已建立的具名的事件，請使用<xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29>建構函式或<xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29>建構函式。  
  
 如果未收到信號的事件初始狀態，該事件的執行緒會封鎖。 如果收到信號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，該事件的執行緒不會封鎖。 如果收到信號的初始狀態，和`mode`是<xref:System.Threading.EventResetMode.AutoReset>、 等候事件的第一個執行緒就會發行立即之後, 會重設事件，並將會封鎖後續的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <param name="name">The name of a system-wide synchronization event.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed. This parameter is passed uninitialized.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的名稱與系統事件`name`參數已經存在，`initialState`參數已忽略。 之後呼叫這個建構函式，使用中針對指定的變數值`ref`參數 (`ByRef`在 Visual Basic 中)`createdNew`來判斷是否具名的系統事件已經存在，或已建立。  
  
 如果未收到信號的事件初始狀態，該事件的執行緒會封鎖。 如果收到信號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，該事件的執行緒不會封鎖。 如果收到信號的初始狀態，和`mode`是<xref:System.Threading.EventResetMode.AutoReset>、 等候事件的第一個執行緒就會發行立即之後, 會重設事件，並將會封鎖後續的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <param name="name">The name of a system-wide synchronization event.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed. This parameter is passed uninitialized.</param>
        <param name="eventSecurity">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個建構函式套用到具名的系統事件建立時，避免其他程式碼取得事件的控制項的存取控制安全性。  
  
 這個建構函式初始化<xref:System.Threading.EventWaitHandle>物件，代表系統事件。 您可以建立多個<xref:System.Threading.EventWaitHandle>代表相同的系統事件的物件。  
  
 如果系統事件不存在，則會建立具有指定的存取控制安全性。 如果此事件存在，則會忽略指定的存取控制安全性。  
  
> [!NOTE]
>  呼叫端具有對於新建立的完整控制權<xref:System.Threading.EventWaitHandle>物件，即使`eventSecurity`拒絕，或將某些存取權授與目前的使用者就會失敗。 不過，如果目前的使用者試圖取得另一個<xref:System.Threading.EventWaitHandle>物件代表相同具名事件時，使用建構函式或<xref:System.Threading.EventWaitHandle.OpenExisting%2A>方法時，Windows 會套用存取控制安全性。  
  
 如果指定的名稱與系統事件`name`參數已經存在，`initialState`參數已忽略。 之後呼叫這個建構函式，使用中針對指定的變數值`ref`參數 (`ByRef`在 Visual Basic 中)`createdNew`來判斷是否具名的系統事件已經存在，或已建立。  
  
 如果未收到信號的事件初始狀態，該事件的執行緒會封鎖。 如果收到信號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，該事件的執行緒不會封鎖。 如果收到信號的初始狀態，和`mode`是<xref:System.Threading.EventResetMode.AutoReset>、 等候事件的第一個執行緒就會發行立即之後, 會重設事件，並將會封鎖後續的執行緒。  
  
   
  
## Examples  
 下列程式碼範例示範具名的系統事件的跨處理序行為與存取控制安全性。 此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。  
  
 如果事件不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限，請使用事件，但讀取和變更的權限事件的權限會授與存取控制安全性。  
  
 如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。 例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來讀取和變更的權限所需的權限以等候事件。  
  
 變更權限之後，事件會開啟在其上等候，並表示它所需的權限。 如果您是從第三個命令視窗執行編譯的範例，此範例會使用執行新的權限。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</summary>
        <returns>An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.GetAccessControl%2A>方法會使用下列旗標 （使用位元 OR 運算結合） 的組合來搜尋權限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。  
  
 使用者必須擁有<xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType>呼叫這個方法和事件的權限必須是與開啟<xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType>旗標。  
  
   
  
## Examples  
 下列程式碼範例示範具名的系統事件的跨處理序行為與存取控制安全性。 此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。  
  
 如果事件不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限，請使用事件，但讀取和變更的權限事件的權限會授與存取控制安全性。  
  
 如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。 例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來讀取和變更的權限所需的權限以等候事件。  
  
 權限已閱讀、 使用之後<xref:System.Threading.EventWaitHandle.GetAccessControl%2A>方法，而且變更，事件會開啟在其上等候，並表示它所需的權限。 如果您是從第三個命令視窗執行編譯的範例，此範例會使用執行新的權限。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  -or-  The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Not supported for Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named synchronization event, if it already exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <summary>Opens the specified named synchronization event, if it already exists.</summary>
        <returns>An  object that represents the named system event.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A>方法嘗試開啟指定的具名的系統事件。 如果系統事件不存在，這個方法會擲回的例外狀況，而不是建立的系統事件。 若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。  
  
 這個方法多載就相當於呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。  
  
 指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒等候該具名的系統事件，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範具名的系統事件的跨處理序行為與存取控制安全性。 此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。  
  
 如果事件不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限，請使用事件，但讀取和變更的權限事件的權限會授與存取控制安全性。  
  
 如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。 例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來讀取和變更的權限所需的權限以等候事件。  
  
 變更權限之後，事件會開啟在其上等候，並表示它所需的權限。 如果您是從第三個命令視窗執行編譯的範例，此範例會使用執行新的權限。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named system event does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <summary>Opens the specified named synchronization event, if it already exists, with the desired security access.</summary>
        <returns>An object that represents the named system event.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights`參數必須包含<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標以允許的執行緒等待事件，而<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。  
  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A>方法嘗試開啟現有的具名的系統事件。 如果系統事件不存在，這個方法會擲回的例外狀況，而不是建立的系統事件。 若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。  
  
   
  
## Examples  
 下列程式碼範例示範具名的系統事件的跨處理序行為與存取控制安全性。 此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。  
  
 如果事件不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限，請使用事件，但讀取和變更的權限事件的權限會授與存取控制安全性。  
  
 如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。 例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來讀取和變更的權限所需的權限以等候事件。  
  
 變更權限之後，事件會開啟在其上等候，並表示它所需的權限。 如果您是從第三個命令視窗執行編譯的範例，此範例會使用執行新的權限。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named system event does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the state of the event to nonsignaled, causing threads to block.</summary>
        <returns>
          <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</summary>
        <returns>
          <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如<xref:System.Threading.EventWaitHandle>與<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>(包括<xref:System.Threading.AutoResetEvent>)、<xref:System.Threading.EventWaitHandle.Set%2A>方法會釋放單一執行緒。 如果有任何的等候中執行緒，等候控制代碼維持信號，直到執行緒嘗試等候，或直到它<xref:System.Threading.EventWaitHandle.Reset%2A>方法呼叫。  
  
> [!IMPORTANT]
>  不保證，每次呼叫<xref:System.Threading.EventWaitHandle.Set%2A>方法會釋放執行緒<xref:System.Threading.EventWaitHandle>其重設模式是<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>。 如果兩個呼叫太接近，使第二次呼叫發生於之前已釋放執行緒，只有一個執行緒在釋出。 就如同第二個呼叫並未發生。 此外，如果<xref:System.Threading.EventWaitHandle.Set%2A>沒有等候的執行緒時，會呼叫和<xref:System.Threading.EventWaitHandle>已經發出信號，呼叫沒有任何作用。  
  
 如<xref:System.Threading.EventWaitHandle>與<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>(包括<xref:System.Threading.ManualResetEvent>)，則呼叫<xref:System.Threading.EventWaitHandle.Set%2A>方法會等候控制代碼保留在收到信號的狀態，直到其<xref:System.Threading.EventWaitHandle.Reset%2A>方法呼叫。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法多載來允許主執行緒發出信號封鎖的執行緒，以及執行緒完成工作，然後等候。  
  
 範例啟動五個執行緒，並讓他們封鎖<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標，然後再發行每一個執行緒時間，使用者按下 ENTER 鍵。 此範例會排入佇列，另一個的五個執行緒，並釋放所有使用<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</param>
        <summary>Sets the access control security for a named system event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用者必須擁有<xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType>呼叫這個方法和事件的權限必須是與開啟<xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType>旗標。  
  
   
  
## Examples  
 下列程式碼範例示範具名的系統事件的跨處理序行為與存取控制安全性。 此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。  
  
 如果事件不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限，請使用事件，但讀取和變更的權限事件的權限會授與存取控制安全性。  
  
 如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。 例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來讀取和變更的權限所需的權限以等候事件。  
  
 變更的權限，使用後<xref:System.Threading.EventWaitHandle.SetAccessControl%2A>開啟事件的方法，在其上等候，並表示它所需的權限。 如果您是從第三個命令視窗執行編譯的範例，此範例會使用執行新的權限。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  -or-  The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果具名同步處理事件不存在，這個方法不會建立它。 若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。  
  
 如果您不確定具名同步處理事件是否存在，請使用這個方法多載，而不是<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載，如果同步處理事件不存在，擲回例外狀況。  
  
 這個方法多載就相當於呼叫<xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29>方法多載，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。 指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒等候該具名的系統事件，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果具名同步處理事件不存在，這個方法不會建立它。 若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。  
  
 如果您不確定具名同步處理事件是否存在，請使用這個方法多載，而不是<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載，如果同步處理事件不存在，擲回例外狀況。  
  
 `rights`參數必須包含<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標以允許的執行緒等待事件，而<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
  </Members>
</Type>