<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8516467f988f4de6e245aa90142fb3d512bca805" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39855702" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="eab50-101">表示執行緒同步處理事件。</span>
      <span class="sxs-lookup">
        <span data-stu-id="eab50-101">Represents a thread synchronization event.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-102"><xref:System.Threading.EventWaitHandle>類別可讓執行緒藉由發出訊號，與彼此進行通訊。</span><span class="sxs-lookup"><span data-stu-id="eab50-102">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling.</span></span> <span data-ttu-id="eab50-103">一般而言，一個或多個執行緒封鎖<xref:System.Threading.EventWaitHandle>之前解除封鎖的執行緒呼叫<xref:System.Threading.EventWaitHandle.Set%2A>方法時，釋出一或多個遭封鎖的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-103">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads.</span></span> <span data-ttu-id="eab50-104">執行緒可以發出信號<xref:System.Threading.EventWaitHandle>，然後被阻斷，藉由呼叫`static`(`Shared`在 Visual Basic 中)<xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="eab50-104">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eab50-105"><xref:System.Threading.EventWaitHandle>類別提供存取具名的系統同步處理事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-105">The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.</span></span>  
  
 <span data-ttu-id="eab50-106">行為<xref:System.Threading.EventWaitHandle>，已收到信號取決於其重設 」 模式。</span><span class="sxs-lookup"><span data-stu-id="eab50-106">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode.</span></span> <span data-ttu-id="eab50-107"><xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標會自動重設時收到信號時，在釋出單一等候執行緒後。</span><span class="sxs-lookup"><span data-stu-id="eab50-107">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="eab50-108"><xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標會維持收到訊號的狀態，直到其<xref:System.Threading.EventWaitHandle.Reset%2A>呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="eab50-108">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="eab50-109">自動重設事件會提供資源的獨佔存取權。</span><span class="sxs-lookup"><span data-stu-id="eab50-109">Automatic reset events provide exclusive access to a resource.</span></span> <span data-ttu-id="eab50-110">如果自動重設事件在沒有任何執行緒處於等候狀態時收到訊號，它會維持收到訊號的狀態，直到有執行緒嘗試等候它為止。</span><span class="sxs-lookup"><span data-stu-id="eab50-110">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="eab50-111">此事件會釋出執行緒並立即重設，以阻斷後續的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-111">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
 <span data-ttu-id="eab50-112">手動重設事件就像是大門。</span><span class="sxs-lookup"><span data-stu-id="eab50-112">Manual reset events are like gates.</span></span> <span data-ttu-id="eab50-113">當事件不會發出訊號時，則會封鎖等候它的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-113">When the event is not signaled, threads that wait on it will block.</span></span> <span data-ttu-id="eab50-114">當事件收到訊號時，會釋放所有等候中執行緒，而事件會維持收到訊號的狀態 （也就是，就不會封鎖後續的等待） 直到其<xref:System.Threading.EventWaitHandle.Reset%2A>呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="eab50-114">When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="eab50-115">手動重設事件執行緒在其他執行緒可以繼續之前，必須完成活動時很有用。</span><span class="sxs-lookup"><span data-stu-id="eab50-115">Manual reset events are useful when one thread must complete an activity before other threads can proceed.</span></span>  
  
 <span data-ttu-id="eab50-116"><xref:System.Threading.EventWaitHandle> 物件可以搭配`static`(`Shared` Visual Basic 中)<xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>和<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="eab50-116"><xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="eab50-117">如需執行緒的同步處理機制的詳細資訊，請參閱[EventWaitHandle、 AutoResetEvent、 CountdownEvent、 ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)。</span><span class="sxs-lookup"><span data-stu-id="eab50-117">For more information about thread synchronization mechanisms, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eab50-118">下列程式碼範例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法多載來允許主執行緒發出信號已封鎖的執行緒，以及執行緒完成工作，然後等候。</span><span class="sxs-lookup"><span data-stu-id="eab50-118">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="eab50-119">此範例會啟動五個執行緒，並讓他們封鎖<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標，然後釋放一個執行緒時間，使用者按下 ENTER 鍵。</span><span class="sxs-lookup"><span data-stu-id="eab50-119">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="eab50-120">此範例會排入佇列的另一個的五個執行緒，並釋放所有使用<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="eab50-120">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="eab50-121">此型別具備執行緒安全。</span>
      <span class="sxs-lookup">
        <span data-stu-id="eab50-121">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eab50-122">初始化 <see cref="T:System.Threading.EventWaitHandle" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-122">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="eab50-123">
            <see langword="true" /> 表示初始狀態設定為已收到信號，<see langword="false" /> 表示初始狀態設定為未收到信號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-123">
              <see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="eab50-124">其中一個 <see cref="T:System.Threading.EventResetMode" /> 值，決定事件是否要自動或手動重設。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-124">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eab50-125">初始化 <see cref="T:System.Threading.EventWaitHandle" /> 類別的新執行個體、指定等候控制代碼是否一開始就會收到信號，以及是以自動還是手動方式來重設。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-125">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-126">如果未收到信號的事件的初始狀態，將會封鎖等候事件的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-126">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="eab50-127">如果已收到訊號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，也不會封鎖等候事件的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-127">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="eab50-128">如果已收到訊號的初始狀態，並`mode`是<xref:System.Threading.EventResetMode.AutoReset>等待事件的第一個執行緒就會釋出立即，其後會重設事件，且將會封鎖後續的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-128">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eab50-129">下列程式碼範例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法多載來允許主執行緒發出信號已封鎖的執行緒，以及執行緒完成工作，然後等候。</span><span class="sxs-lookup"><span data-stu-id="eab50-129">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="eab50-130">此範例會啟動五個執行緒，並讓他們封鎖<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標，然後釋放一個執行緒時間，使用者按下 ENTER 鍵。</span><span class="sxs-lookup"><span data-stu-id="eab50-130">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses ENTER key.</span></span> <span data-ttu-id="eab50-131">此範例會排入佇列的另一個的五個執行緒，並釋放所有使用<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="eab50-131">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="eab50-132">如果已因此呼叫而建立具名事件，則為 <see langword="true" /> 以將初始狀態設定為收到信號；否則為 <see langword="false" /> 以將其設定為未收到信號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-132">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="eab50-133">其中一個 <see cref="T:System.Threading.EventResetMode" /> 值，決定事件是否要自動或手動重設。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-133">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="eab50-134">整個系統的同步處理事件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-134">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eab50-135">初始化 <see cref="T:System.Threading.EventWaitHandle" /> 類別的新執行個體、指定等候控制代碼是否一開始就會收到信號 (如果它是因這個呼叫而建立)、是以自動還是手動方式進行重設，以及系統同步處理事件的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-135">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-136">如果`name`已`null`或空字串，本機<xref:System.Threading.EventWaitHandle>建立。</span><span class="sxs-lookup"><span data-stu-id="eab50-136">If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created.</span></span>  
  
 <span data-ttu-id="eab50-137">如果指定的名稱與系統事件`name`參數已存在，`initialState`參數會被忽略。</span><span class="sxs-lookup"><span data-stu-id="eab50-137">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eab50-138">當使用這個建構函式的具名的系統事件，指定`false`針對`initialState`。</span><span class="sxs-lookup"><span data-stu-id="eab50-138">When using this constructor for named system events, specify `false` for `initialState`.</span></span> <span data-ttu-id="eab50-139">這個建構函式會提供任何方法來判斷是否已建立具名的系統事件，因此您不能做出任何假設具名事件的狀態。</span><span class="sxs-lookup"><span data-stu-id="eab50-139">This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</span></span> <span data-ttu-id="eab50-140">若要判斷是否已建立具名的事件，請使用<xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29>建構函式或<xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="eab50-140">To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.</span></span>  
  
 <span data-ttu-id="eab50-141">如果未收到信號的事件的初始狀態，將會封鎖等候事件的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-141">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="eab50-142">如果已收到訊號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，也不會封鎖等候事件的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-142">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="eab50-143">如果已收到訊號的初始狀態，並`mode`是<xref:System.Threading.EventResetMode.AutoReset>等待事件的第一個執行緒就會釋出立即，其後會重設事件，且將會封鎖後續的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-143">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eab50-144">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-144">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="eab50-145">具名事件存在，並具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-145">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="eab50-146">無法建立具名事件，可能是因為不同類型的等候控制代碼具有相同的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-146">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eab50-147">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-147">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eab50-148">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-148">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eab50-149">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-149">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="eab50-150">如果已因此呼叫而建立具名事件，則為 <see langword="true" /> 以將初始狀態設定為收到信號；否則為 <see langword="false" /> 以將其設定為未收到信號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-150">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="eab50-151">其中一個 <see cref="T:System.Threading.EventResetMode" /> 值，決定事件是否要自動或手動重設。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-151">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="eab50-152">整個系統的同步處理事件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-152">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="eab50-153">這個方法傳回時，如果已建立本機事件 (也就是說，如果 <c>name</c> 為 <see langword="null" /> 或空字串)，或是已建立指定的具名系統事件，則會包含 <see langword="true" />；如果指定的具名系統事件已經存在，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-153">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          </span>
          <span data-ttu-id="eab50-154">這個參數會以未初始化的狀態傳遞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-154">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eab50-155">初始化 <see cref="T:System.Threading.EventWaitHandle" /> 類別的新執行個體，指定如果等候控制代碼是因此呼叫而建立，一開始是否會發出信號；它是否會自動或手動重設；系統同步處理事件的名稱；以及布林值變數，其值會在呼叫之後指出是否已建立具名系統事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-155">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-156">如果指定的名稱與系統事件`name`參數已存在，`initialState`參數會被忽略。</span><span class="sxs-lookup"><span data-stu-id="eab50-156">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="eab50-157">之後呼叫這個建構函式，使用指定的變數中的值`ref`參數 (`ByRef` Visual Basic 中的參數)`createdNew`以判斷是否具名的系統事件已經存在，或已建立。</span><span class="sxs-lookup"><span data-stu-id="eab50-157">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="eab50-158">如果未收到信號的事件的初始狀態，將會封鎖等候事件的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-158">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="eab50-159">如果已收到訊號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，也不會封鎖等候事件的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-159">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="eab50-160">如果已收到訊號的初始狀態，並`mode`是<xref:System.Threading.EventResetMode.AutoReset>等待事件的第一個執行緒就會釋出立即，其後會重設事件，且將會封鎖後續的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-160">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eab50-161">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-161">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="eab50-162">具名事件存在，並具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-162">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="eab50-163">無法建立具名事件，可能是因為不同類型的等候控制代碼具有相同的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-163">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eab50-164">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-164">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eab50-165">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-165">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eab50-166">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-166">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="eab50-167">如果已因此呼叫而建立具名事件，則為 <see langword="true" /> 以將初始狀態設定為收到信號；否則為 <see langword="false" /> 以將其設定為未收到信號。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-167">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="eab50-168">其中一個 <see cref="T:System.Threading.EventResetMode" /> 值，決定事件是否要自動或手動重設。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-168">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="eab50-169">整個系統的同步處理事件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-169">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="eab50-170">這個方法傳回時，如果已建立本機事件 (也就是說，如果 <c>name</c> 為 <see langword="null" /> 或空字串)，或是已建立指定的具名系統事件，則會包含 <see langword="true" />；如果指定的具名系統事件已經存在，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-170">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          </span>
          <span data-ttu-id="eab50-171">這個參數會以未初始化的狀態傳遞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-171">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="eventSecurity">
          <span data-ttu-id="eab50-172">
            <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 物件，代表要套用至具名系統事件的存取控制安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-172">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eab50-173">初始化 <see cref="T:System.Threading.EventWaitHandle" /> 類別的新執行個體，指定如果等候控制代碼是因此呼叫而建立，一開始是否會發出信號；它是否會自動或手動重設；系統同步處理事件的名稱；布林值變數，其值會在呼叫之後指出是否已建立具名系統事件；以及要套用至具名事件 (如果已建立) 的存取控制項安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-173">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-174">您可以使用這個建構函式套用到具名的系統事件建立時，防止其他程式碼事件的控制的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-174">Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</span></span>  
  
 <span data-ttu-id="eab50-175">這個建構函式初始化<xref:System.Threading.EventWaitHandle>物件，代表系統事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-175">This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event.</span></span> <span data-ttu-id="eab50-176">您可以建立多個<xref:System.Threading.EventWaitHandle>代表相同的系統事件的物件。</span><span class="sxs-lookup"><span data-stu-id="eab50-176">You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.</span></span>  
  
 <span data-ttu-id="eab50-177">如果系統事件不存在，它會建立具有指定的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-177">If the system event does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="eab50-178">如果此事件存在，則會忽略指定的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-178">If the event exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="eab50-179">呼叫端具有全權掌控新建<xref:System.Threading.EventWaitHandle>物件，即使`eventSecurity`拒絕，或無法授與給目前的使用者部分存取權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-179">The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="eab50-180">不過，如果目前的使用者嘗試取得另一個<xref:System.Threading.EventWaitHandle>物件代表相同具名事件，使用建構函式或<xref:System.Threading.EventWaitHandle.OpenExisting%2A>方法，套用存取控制安全性的 Windows。</span><span class="sxs-lookup"><span data-stu-id="eab50-180">However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="eab50-181">如果指定的名稱與系統事件`name`參數已存在，`initialState`參數會被忽略。</span><span class="sxs-lookup"><span data-stu-id="eab50-181">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="eab50-182">之後呼叫這個建構函式，使用指定的變數中的值`ref`參數 (`ByRef` Visual Basic 中的參數)`createdNew`以判斷是否具名的系統事件已經存在，或已建立。</span><span class="sxs-lookup"><span data-stu-id="eab50-182">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="eab50-183">如果未收到信號的事件的初始狀態，將會封鎖等候事件的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-183">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="eab50-184">如果已收到訊號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，也不會封鎖等候事件的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-184">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="eab50-185">如果已收到訊號的初始狀態，並`mode`是<xref:System.Threading.EventResetMode.AutoReset>等待事件的第一個執行緒就會釋出立即，其後會重設事件，且將會封鎖後續的執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-185">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eab50-186">下列程式碼範例示範的具名的系統事件的跨處理序行為具有存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-186">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="eab50-187">此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-187">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="eab50-188">如果事件不存在，它會建立初始擁有權與拒絕目前使用者的權限，請使用事件，但會授與讀取和變更事件的權限的權限的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-188">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="eab50-189">如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="eab50-189">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="eab50-190">攔截到例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來等候事件來讀取和變更的權限所需的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-190">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="eab50-191">權限變更之後，事件會開啟在其上等候，並對其發出通知所需的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-191">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="eab50-192">如果您從第三個 [命令] 視窗中執行編譯的範例，範例會執行使用新的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-192">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eab50-193">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-193">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="eab50-194">具名事件存在，並具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-194">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="eab50-195">無法建立具名事件，可能是因為不同類型的等候控制代碼具有相同的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-195">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eab50-196">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-196">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eab50-197">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-197">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eab50-198">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-198">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="eab50-199">取得 <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 物件，此物件代表由目前 <see cref="T:System.Threading.EventWaitHandle" /> 物件所表示的具名系統事件的存取控制安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-199">Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eab50-200">
            <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 物件，代表具名系統事件的存取控制安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-200">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-201"><xref:System.Threading.EventWaitHandle.GetAccessControl%2A>方法會使用下列旗標 （使用位元 OR 運算結合） 的組合來搜尋權限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="eab50-201">The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="eab50-202">使用者必須擁有<xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType>呼叫這個方法和事件的權限必須是與開啟<xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="eab50-202">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eab50-203">下列程式碼範例示範的具名的系統事件的跨處理序行為具有存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-203">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="eab50-204">此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-204">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="eab50-205">如果事件不存在，它會建立初始擁有權與拒絕目前使用者的權限，請使用事件，但會授與讀取和變更事件的權限的權限的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-205">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="eab50-206">如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="eab50-206">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="eab50-207">攔截到例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來等候事件來讀取和變更的權限所需的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-207">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="eab50-208">權限已閱讀、 使用之後<xref:System.Threading.EventWaitHandle.GetAccessControl%2A>方法，而且變更，事件會開啟在其上等候，並對其發出通知所需的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-208">After the permissions have been read, using the <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method, and changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="eab50-209">如果您從第三個 [命令] 視窗中執行編譯的範例，範例會執行使用新的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-209">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="eab50-210">目前的 <see cref="T:System.Threading.EventWaitHandle" /> 物件代表具名系統事件，但是使用者沒有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-210">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          </span>
          <span data-ttu-id="eab50-211">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-211">-or-</span>
          </span>
          <span data-ttu-id="eab50-212">目前的 <see cref="T:System.Threading.EventWaitHandle" /> 物件代表具名系統事件，且不是以 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /> 開啟。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-212">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="eab50-213">不支援 Windows 98 或 Windows Millennium Edition。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-213">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eab50-214">之前在這個 <see cref="M:System.Threading.WaitHandle.Close" /> 上呼叫 <see cref="T:System.Threading.EventWaitHandle" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-214">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eab50-215">開啟指定的具名同步處理事件 (如果已經存在)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-215">Opens a specified named synchronization event, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="eab50-216">要開啟的系統同步處理事件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-216">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eab50-217">開啟指定的具名同步處理事件 (如果已經存在)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-217">Opens the specified named synchronization event, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eab50-218">表示具名系統事件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-218">An  object that represents the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-219"><xref:System.Threading.EventWaitHandle.OpenExisting%2A>方法嘗試開啟指定的具名的系統事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-219">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event.</span></span> <span data-ttu-id="eab50-220">如果系統事件不存在，這個方法會擲回的例外狀況，而不是建立系統事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-220">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="eab50-221">若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="eab50-221">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="eab50-222">使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-222">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 <span data-ttu-id="eab50-223">這個方法多載就相當於呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。</span><span class="sxs-lookup"><span data-stu-id="eab50-223">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="eab50-224">指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒等候具名的系統事件，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="eab50-224">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eab50-225">下列程式碼範例示範的具名的系統事件的跨處理序行為具有存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-225">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="eab50-226">此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-226">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="eab50-227">如果事件不存在，它會建立初始擁有權與拒絕目前使用者的權限，請使用事件，但會授與讀取和變更事件的權限的權限的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-227">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="eab50-228">如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="eab50-228">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="eab50-229">攔截到例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來等候事件來讀取和變更的權限所需的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-229">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="eab50-230">權限變更之後，事件會開啟在其上等候，並對其發出通知所需的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-230">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="eab50-231">如果您從第三個 [命令] 視窗中執行編譯的範例，範例會執行使用新的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-231">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eab50-232">
            <paramref name="name" /> 為空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-232">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="eab50-233">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-233">-or-</span>
          </span>
          <span data-ttu-id="eab50-234">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-234">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="eab50-235">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-235">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="eab50-236">具名系統事件不存在。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-236">The named system event does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eab50-237">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-237">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="eab50-238">具名事件存在，但是使用者並沒有使用它所需的安全性存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-238">The named event exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eab50-239">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-239">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eab50-240">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-240">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="eab50-241">要開啟的系統同步處理事件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-241">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="eab50-242">列舉值的位元組合，表示所需的安全性存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-242">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eab50-243">使用所需的安全性存取權，開啟指定的具名同步處理事件 (如果已經存在)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-243">Opens the specified named synchronization event, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eab50-244">表示具名系統事件的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-244">An object that represents the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-245">`rights`參數必須包含<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標，好讓執行緒等候事件，而<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="eab50-245">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="eab50-246"><xref:System.Threading.EventWaitHandle.OpenExisting%2A>方法嘗試開啟現有的具名的系統事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-246">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event.</span></span> <span data-ttu-id="eab50-247">如果系統事件不存在，這個方法會擲回的例外狀況，而不是建立系統事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-247">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="eab50-248">若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="eab50-248">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="eab50-249">使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-249">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eab50-250">下列程式碼範例示範的具名的系統事件的跨處理序行為具有存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-250">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="eab50-251">此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-251">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="eab50-252">如果事件不存在，它會建立初始擁有權與拒絕目前使用者的權限，請使用事件，但會授與讀取和變更事件的權限的權限的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-252">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="eab50-253">如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="eab50-253">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="eab50-254">攔截到例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來等候事件來讀取和變更的權限所需的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-254">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="eab50-255">權限變更之後，事件會開啟在其上等候，並對其發出通知所需的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-255">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="eab50-256">如果您從第三個 [命令] 視窗中執行編譯的範例，範例會執行使用新的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-256">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eab50-257">
            <paramref name="name" /> 為空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-257">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="eab50-258">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-258">-or-</span>
          </span>
          <span data-ttu-id="eab50-259">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-259">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="eab50-260">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-260">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="eab50-261">具名系統事件不存在。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-261">The named system event does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eab50-262">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-262">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="eab50-263">具名事件存在，但使用者沒有所需的安全性存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-263">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eab50-264">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-264">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eab50-265">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-265">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="eab50-266">將事件的狀態設定為未收到信號，因而造成執行緒封鎖。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-266">Sets the state of the event to nonsignaled, causing threads to block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eab50-267">如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" /> .</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-267">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eab50-268">之前在這個 <see cref="M:System.Threading.WaitHandle.Close" /> 上呼叫 <see cref="T:System.Threading.EventWaitHandle" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-268">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="eab50-269">將事件的狀態設定為收到信號，允許一個或多個等待中的執行緒繼續執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-269">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eab50-270">如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" /> .</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-270">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-271">針對<xref:System.Threading.EventWaitHandle>具有<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>(包括<xref:System.Threading.AutoResetEvent>)，則<xref:System.Threading.EventWaitHandle.Set%2A>方法會釋放單一執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-271">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread.</span></span> <span data-ttu-id="eab50-272">如果沒有任何等候中執行緒，等候控制代碼直到已收到訊號的執行緒嘗試等候它，或直到其<xref:System.Threading.EventWaitHandle.Reset%2A>呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="eab50-272">If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="eab50-273">不保證，每次呼叫<xref:System.Threading.EventWaitHandle.Set%2A>方法會釋放執行緒<xref:System.Threading.EventWaitHandle>其重設 模式是<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="eab50-273">There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span></span> <span data-ttu-id="eab50-274">如果兩個呼叫太接近，以便之前已釋放執行緒，就會發生在第二個呼叫，會釋放只有一個執行緒。</span><span class="sxs-lookup"><span data-stu-id="eab50-274">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</span></span> <span data-ttu-id="eab50-275">這是因為如果第二次呼叫未發生。</span><span class="sxs-lookup"><span data-stu-id="eab50-275">It is as if the second call did not happen.</span></span> <span data-ttu-id="eab50-276">此外，如果<xref:System.Threading.EventWaitHandle.Set%2A>沒有等待的執行緒時，會呼叫和<xref:System.Threading.EventWaitHandle>已收到訊號，呼叫沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="eab50-276">Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.</span></span>  
  
 <span data-ttu-id="eab50-277">針對<xref:System.Threading.EventWaitHandle>具有<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>(包括<xref:System.Threading.ManualResetEvent>)，則呼叫<xref:System.Threading.EventWaitHandle.Set%2A>方法會等候控制代碼保留在收到信號的狀態，直到其<xref:System.Threading.EventWaitHandle.Reset%2A>呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="eab50-277">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eab50-278">下列程式碼範例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法多載來允許主執行緒發出信號已封鎖的執行緒，以及執行緒完成工作，然後等候。</span><span class="sxs-lookup"><span data-stu-id="eab50-278">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="eab50-279">此範例會啟動五個執行緒，並讓他們封鎖<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標，然後釋放一個執行緒時間，使用者按下 ENTER 鍵。</span><span class="sxs-lookup"><span data-stu-id="eab50-279">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="eab50-280">此範例會排入佇列的另一個的五個執行緒，並釋放所有使用<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="eab50-280">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eab50-281">之前在這個 <see cref="M:System.Threading.WaitHandle.Close" /> 上呼叫 <see cref="T:System.Threading.EventWaitHandle" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-281">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">
          <span data-ttu-id="eab50-282">
            <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 物件，代表要套用至具名系統事件的存取控制安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-282">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eab50-283">為具名系統事件設定存取控制安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-283">Sets the access control security for a named system event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-284">使用者必須擁有<xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType>呼叫這個方法和事件的權限必須是與開啟<xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="eab50-284">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="eab50-285">下列程式碼範例示範的具名的系統事件的跨處理序行為具有存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-285">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="eab50-286">此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-286">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="eab50-287">如果事件不存在，它會建立初始擁有權與拒絕目前使用者的權限，請使用事件，但會授與讀取和變更事件的權限的權限的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="eab50-287">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="eab50-288">如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="eab50-288">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="eab50-289">攔截到例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來等候事件來讀取和變更的權限所需的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-289">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="eab50-290">變更權限，使用後<xref:System.Threading.EventWaitHandle.SetAccessControl%2A>事件的方法，會開啟在其上等候，並對其發出通知所需的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-290">After the permissions are changed, using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="eab50-291">如果您從第三個 [命令] 視窗中執行編譯的範例，範例會執行使用新的權限。</span><span class="sxs-lookup"><span data-stu-id="eab50-291">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="eab50-292">
            <paramref name="eventSecurity" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-292">
              <paramref name="eventSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="eab50-293">使用者沒有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-293">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          </span>
          <span data-ttu-id="eab50-294">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-294">-or-</span>
          </span>
          <span data-ttu-id="eab50-295">並未以 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /> 開啟事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-295">The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="eab50-296">目前的 <see cref="T:System.Threading.EventWaitHandle" /> 物件不表示具名系統事件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-296">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="eab50-297">之前在這個 <see cref="M:System.Threading.WaitHandle.Close" /> 上呼叫 <see cref="T:System.Threading.EventWaitHandle" /> 方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-297">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="eab50-298">開啟指定的具名同步處理事件 (如果已經存在)，並傳回值，指出作業是否成功。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-298">Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="eab50-299">要開啟的系統同步處理事件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-299">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="eab50-300">這個方法傳回時，如果呼叫成功，則包含 <see cref="T:System.Threading.EventWaitHandle" /> 物件，此物件代表具名同步處理事件，如果呼叫失敗，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-300">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="eab50-301">這個參數會被視為未初始化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-301">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eab50-302">開啟指定的具名同步處理事件 (如果已經存在)，並傳回值，指出作業是否成功。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-302">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eab50-303">如果已成功開啟具名同步處理事件，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-303">
              <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-304">如果具名同步處理事件不存在，這個方法不會建立它。</span><span class="sxs-lookup"><span data-stu-id="eab50-304">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="eab50-305">若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="eab50-305">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="eab50-306">如果您不確定是否存在的具名同步處理事件，請使用這個方法多載，而不是<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載，則會擲回例外狀況，如果同步處理事件不存在。</span><span class="sxs-lookup"><span data-stu-id="eab50-306">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="eab50-307">這個方法多載就相當於呼叫<xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29>方法多載，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。</span><span class="sxs-lookup"><span data-stu-id="eab50-307">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="eab50-308">指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒等候具名的系統事件，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="eab50-308">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="eab50-309">使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-309">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eab50-310">
            <paramref name="name" /> 為空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-310">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="eab50-311">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-311">-or-</span>
          </span>
          <span data-ttu-id="eab50-312">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-312">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="eab50-313">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-313">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eab50-314">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-314">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="eab50-315">具名事件存在，但使用者沒有所需的安全性存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-315">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eab50-316">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-316">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eab50-317">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-317">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="eab50-318">要開啟的系統同步處理事件名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-318">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="eab50-319">列舉值的位元組合，表示所需的安全性存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-319">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="eab50-320">這個方法傳回時，如果呼叫成功，則包含 <see cref="T:System.Threading.EventWaitHandle" /> 物件，此物件代表具名同步處理事件，如果呼叫失敗，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-320">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="eab50-321">這個參數會被視為未初始化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-321">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="eab50-322">使用所需的安全性存取權，開啟指定的具名同步處理事件 (如果已經存在)，並傳回值，指出作業是否成功。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-322">Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="eab50-323">如果已成功開啟具名同步處理事件，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-323">
              <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="eab50-324">如果具名同步處理事件不存在，這個方法不會建立它。</span><span class="sxs-lookup"><span data-stu-id="eab50-324">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="eab50-325">若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="eab50-325">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="eab50-326">如果您不確定是否存在的具名同步處理事件，請使用這個方法多載，而不是<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載，則會擲回例外狀況，如果同步處理事件不存在。</span><span class="sxs-lookup"><span data-stu-id="eab50-326">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="eab50-327">`rights`參數必須包含<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標，好讓執行緒等候事件，而<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="eab50-327">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="eab50-328">使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。</span><span class="sxs-lookup"><span data-stu-id="eab50-328">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="eab50-329">
            <paramref name="name" /> 為空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-329">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="eab50-330">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-330">-or-</span>
          </span>
          <span data-ttu-id="eab50-331">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-331">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="eab50-332">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-332">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="eab50-333">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-333">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="eab50-334">具名事件存在，但使用者沒有所需的安全性存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-334">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="eab50-335">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-335">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="eab50-336">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="eab50-336">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>