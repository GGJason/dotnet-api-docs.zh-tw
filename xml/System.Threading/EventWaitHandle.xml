<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8516467f988f4de6e245aa90142fb3d512bca805" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39855702" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示執行緒同步處理事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle>類別可讓執行緒藉由發出訊號，與彼此進行通訊。 一般而言，一個或多個執行緒封鎖<xref:System.Threading.EventWaitHandle>之前解除封鎖的執行緒呼叫<xref:System.Threading.EventWaitHandle.Set%2A>方法時，釋出一或多個遭封鎖的執行緒。 執行緒可以發出信號<xref:System.Threading.EventWaitHandle>，然後被阻斷，藉由呼叫`static`(`Shared`在 Visual Basic 中)<xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  <xref:System.Threading.EventWaitHandle>類別提供存取具名的系統同步處理事件。  
  
 行為<xref:System.Threading.EventWaitHandle>，已收到信號取決於其重設 」 模式。 <xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標會自動重設時收到信號時，在釋出單一等候執行緒後。 <xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標會維持收到訊號的狀態，直到其<xref:System.Threading.EventWaitHandle.Reset%2A>呼叫方法。  
  
 自動重設事件會提供資源的獨佔存取權。 如果自動重設事件在沒有任何執行緒處於等候狀態時收到訊號，它會維持收到訊號的狀態，直到有執行緒嘗試等候它為止。 此事件會釋出執行緒並立即重設，以阻斷後續的執行緒。  
  
 手動重設事件就像是大門。 當事件不會發出訊號時，則會封鎖等候它的執行緒。 當事件收到訊號時，會釋放所有等候中執行緒，而事件會維持收到訊號的狀態 （也就是，就不會封鎖後續的等待） 直到其<xref:System.Threading.EventWaitHandle.Reset%2A>呼叫方法。 手動重設事件執行緒在其他執行緒可以繼續之前，必須完成活動時很有用。  
  
 <xref:System.Threading.EventWaitHandle> 物件可以搭配`static`(`Shared` Visual Basic 中)<xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>和<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>方法。  
  
 如需執行緒的同步處理機制的詳細資訊，請參閱[EventWaitHandle、 AutoResetEvent、 CountdownEvent、 ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法多載來允許主執行緒發出信號已封鎖的執行緒，以及執行緒完成工作，然後等候。  
  
 此範例會啟動五個執行緒，並讓他們封鎖<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標，然後釋放一個執行緒時間，使用者按下 ENTER 鍵。 此範例會排入佇列的另一個的五個執行緒，並釋放所有使用<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.EventWaitHandle" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> 表示初始狀態設定為已收到信號，<see langword="false" /> 表示初始狀態設定為未收到信號。</param>
        <param name="mode">其中一個 <see cref="T:System.Threading.EventResetMode" /> 值，決定事件是否要自動或手動重設。</param>
        <summary>初始化 <see cref="T:System.Threading.EventWaitHandle" /> 類別的新執行個體、指定等候控制代碼是否一開始就會收到信號，以及是以自動還是手動方式來重設。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未收到信號的事件的初始狀態，將會封鎖等候事件的執行緒。 如果已收到訊號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，也不會封鎖等候事件的執行緒。 如果已收到訊號的初始狀態，並`mode`是<xref:System.Threading.EventResetMode.AutoReset>等待事件的第一個執行緒就會釋出立即，其後會重設事件，且將會封鎖後續的執行緒。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法多載來允許主執行緒發出信號已封鎖的執行緒，以及執行緒完成工作，然後等候。  
  
 此範例會啟動五個執行緒，並讓他們封鎖<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標，然後釋放一個執行緒時間，使用者按下 ENTER 鍵。 此範例會排入佇列的另一個的五個執行緒，並釋放所有使用<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">如果已因此呼叫而建立具名事件，則為 <see langword="true" /> 以將初始狀態設定為收到信號；否則為 <see langword="false" /> 以將其設定為未收到信號。</param>
        <param name="mode">其中一個 <see cref="T:System.Threading.EventResetMode" /> 值，決定事件是否要自動或手動重設。</param>
        <param name="name">整個系統的同步處理事件名稱。</param>
        <summary>初始化 <see cref="T:System.Threading.EventWaitHandle" /> 類別的新執行個體、指定等候控制代碼是否一開始就會收到信號 (如果它是因這個呼叫而建立)、是以自動還是手動方式進行重設，以及系統同步處理事件的名稱。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`name`已`null`或空字串，本機<xref:System.Threading.EventWaitHandle>建立。  
  
 如果指定的名稱與系統事件`name`參數已存在，`initialState`參數會被忽略。  
  
> [!IMPORTANT]
>  當使用這個建構函式的具名的系統事件，指定`false`針對`initialState`。 這個建構函式會提供任何方法來判斷是否已建立具名的系統事件，因此您不能做出任何假設具名事件的狀態。 若要判斷是否已建立具名的事件，請使用<xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29>建構函式或<xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29>建構函式。  
  
 如果未收到信號的事件的初始狀態，將會封鎖等候事件的執行緒。 如果已收到訊號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，也不會封鎖等候事件的執行緒。 如果已收到訊號的初始狀態，並`mode`是<xref:System.Threading.EventResetMode.AutoReset>等待事件的第一個執行緒就會釋出立即，其後會重設事件，且將會封鎖後續的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名事件存在，並具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">無法建立具名事件，可能是因為不同類型的等候控制代碼具有相同的名稱。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">如果已因此呼叫而建立具名事件，則為 <see langword="true" /> 以將初始狀態設定為收到信號；否則為 <see langword="false" /> 以將其設定為未收到信號。</param>
        <param name="mode">其中一個 <see cref="T:System.Threading.EventResetMode" /> 值，決定事件是否要自動或手動重設。</param>
        <param name="name">整個系統的同步處理事件名稱。</param>
        <param name="createdNew">這個方法傳回時，如果已建立本機事件 (也就是說，如果 <c>name</c> 為 <see langword="null" /> 或空字串)，或是已建立指定的具名系統事件，則會包含 <see langword="true" />；如果指定的具名系統事件已經存在，則為 <see langword="false" />。 這個參數會以未初始化的狀態傳遞。</param>
        <summary>初始化 <see cref="T:System.Threading.EventWaitHandle" /> 類別的新執行個體，指定如果等候控制代碼是因此呼叫而建立，一開始是否會發出信號；它是否會自動或手動重設；系統同步處理事件的名稱；以及布林值變數，其值會在呼叫之後指出是否已建立具名系統事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的名稱與系統事件`name`參數已存在，`initialState`參數會被忽略。 之後呼叫這個建構函式，使用指定的變數中的值`ref`參數 (`ByRef` Visual Basic 中的參數)`createdNew`以判斷是否具名的系統事件已經存在，或已建立。  
  
 如果未收到信號的事件的初始狀態，將會封鎖等候事件的執行緒。 如果已收到訊號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，也不會封鎖等候事件的執行緒。 如果已收到訊號的初始狀態，並`mode`是<xref:System.Threading.EventResetMode.AutoReset>等待事件的第一個執行緒就會釋出立即，其後會重設事件，且將會封鎖後續的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名事件存在，並具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">無法建立具名事件，可能是因為不同類型的等候控制代碼具有相同的名稱。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">如果已因此呼叫而建立具名事件，則為 <see langword="true" /> 以將初始狀態設定為收到信號；否則為 <see langword="false" /> 以將其設定為未收到信號。</param>
        <param name="mode">其中一個 <see cref="T:System.Threading.EventResetMode" /> 值，決定事件是否要自動或手動重設。</param>
        <param name="name">整個系統的同步處理事件名稱。</param>
        <param name="createdNew">這個方法傳回時，如果已建立本機事件 (也就是說，如果 <c>name</c> 為 <see langword="null" /> 或空字串)，或是已建立指定的具名系統事件，則會包含 <see langword="true" />；如果指定的具名系統事件已經存在，則為 <see langword="false" />。 這個參數會以未初始化的狀態傳遞。</param>
        <param name="eventSecurity">
          <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 物件，代表要套用至具名系統事件的存取控制安全性。</param>
        <summary>初始化 <see cref="T:System.Threading.EventWaitHandle" /> 類別的新執行個體，指定如果等候控制代碼是因此呼叫而建立，一開始是否會發出信號；它是否會自動或手動重設；系統同步處理事件的名稱；布林值變數，其值會在呼叫之後指出是否已建立具名系統事件；以及要套用至具名事件 (如果已建立) 的存取控制項安全性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用這個建構函式套用到具名的系統事件建立時，防止其他程式碼事件的控制的存取控制安全性。  
  
 這個建構函式初始化<xref:System.Threading.EventWaitHandle>物件，代表系統事件。 您可以建立多個<xref:System.Threading.EventWaitHandle>代表相同的系統事件的物件。  
  
 如果系統事件不存在，它會建立具有指定的存取控制安全性。 如果此事件存在，則會忽略指定的存取控制安全性。  
  
> [!NOTE]
>  呼叫端具有全權掌控新建<xref:System.Threading.EventWaitHandle>物件，即使`eventSecurity`拒絕，或無法授與給目前的使用者部分存取權限。 不過，如果目前的使用者嘗試取得另一個<xref:System.Threading.EventWaitHandle>物件代表相同具名事件，使用建構函式或<xref:System.Threading.EventWaitHandle.OpenExisting%2A>方法，套用存取控制安全性的 Windows。  
  
 如果指定的名稱與系統事件`name`參數已存在，`initialState`參數會被忽略。 之後呼叫這個建構函式，使用指定的變數中的值`ref`參數 (`ByRef` Visual Basic 中的參數)`createdNew`以判斷是否具名的系統事件已經存在，或已建立。  
  
 如果未收到信號的事件的初始狀態，將會封鎖等候事件的執行緒。 如果已收到訊號的初始狀態，而<xref:System.Threading.EventResetMode.ManualReset>旗標指定給`mode`，也不會封鎖等候事件的執行緒。 如果已收到訊號的初始狀態，並`mode`是<xref:System.Threading.EventResetMode.AutoReset>等待事件的第一個執行緒就會釋出立即，其後會重設事件，且將會封鎖後續的執行緒。  
  
   
  
## Examples  
 下列程式碼範例示範的具名的系統事件的跨處理序行為具有存取控制安全性。 此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。  
  
 如果事件不存在，它會建立初始擁有權與拒絕目前使用者的權限，請使用事件，但會授與讀取和變更事件的權限的權限的存取控制安全性。  
  
 如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。 攔截到例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來等候事件來讀取和變更的權限所需的權限。  
  
 權限變更之後，事件會開啟在其上等候，並對其發出通知所需的權限。 如果您從第三個 [命令] 視窗中執行編譯的範例，範例會執行使用新的權限。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名事件存在，並具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">無法建立具名事件，可能是因為不同類型的等候控制代碼具有相同的名稱。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 物件，此物件代表由目前 <see cref="T:System.Threading.EventWaitHandle" /> 物件所表示的具名系統事件的存取控制安全性。</summary>
        <returns>
          <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 物件，代表具名系統事件的存取控制安全性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.GetAccessControl%2A>方法會使用下列旗標 （使用位元 OR 運算結合） 的組合來搜尋權限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。  
  
 使用者必須擁有<xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType>呼叫這個方法和事件的權限必須是與開啟<xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType>旗標。  
  
   
  
## Examples  
 下列程式碼範例示範的具名的系統事件的跨處理序行為具有存取控制安全性。 此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。  
  
 如果事件不存在，它會建立初始擁有權與拒絕目前使用者的權限，請使用事件，但會授與讀取和變更事件的權限的權限的存取控制安全性。  
  
 如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。 攔截到例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來等候事件來讀取和變更的權限所需的權限。  
  
 權限已閱讀、 使用之後<xref:System.Threading.EventWaitHandle.GetAccessControl%2A>方法，而且變更，事件會開啟在其上等候，並對其發出通知所需的權限。 如果您從第三個 [命令] 視窗中執行編譯的範例，範例會執行使用新的權限。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">目前的 <see cref="T:System.Threading.EventWaitHandle" /> 物件代表具名系統事件，但是使用者沒有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />。  
  
-或- 
目前的 <see cref="T:System.Threading.EventWaitHandle" /> 物件代表具名系統事件，且不是以 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /> 開啟。</exception>
        <exception cref="T:System.NotSupportedException">不支援 Windows 98 或 Windows Millennium Edition。</exception>
        <exception cref="T:System.ObjectDisposedException">之前在這個 <see cref="M:System.Threading.WaitHandle.Close" /> 上呼叫 <see cref="T:System.Threading.EventWaitHandle" /> 方法。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開啟指定的具名同步處理事件 (如果已經存在)。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要開啟的系統同步處理事件名稱。</param>
        <summary>開啟指定的具名同步處理事件 (如果已經存在)。</summary>
        <returns>表示具名系統事件的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A>方法嘗試開啟指定的具名的系統事件。 如果系統事件不存在，這個方法會擲回的例外狀況，而不是建立系統事件。 若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。  
  
 這個方法多載就相當於呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。  
  
 指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒等候具名的系統事件，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。  
  
   
  
## Examples  
 下列程式碼範例示範的具名的系統事件的跨處理序行為具有存取控制安全性。 此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。  
  
 如果事件不存在，它會建立初始擁有權與拒絕目前使用者的權限，請使用事件，但會授與讀取和變更事件的權限的權限的存取控制安全性。  
  
 如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。 攔截到例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來等候事件來讀取和變更的權限所需的權限。  
  
 權限變更之後，事件會開啟在其上等候，並對其發出通知所需的權限。 如果您從第三個 [命令] 視窗中執行編譯的範例，範例會執行使用新的權限。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 為空字串。  
  
-或- 
 <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">具名系統事件不存在。</exception>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名事件存在，但是使用者並沒有使用它所需的安全性存取權。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">要開啟的系統同步處理事件名稱。</param>
        <param name="rights">列舉值的位元組合，表示所需的安全性存取。</param>
        <summary>使用所需的安全性存取權，開啟指定的具名同步處理事件 (如果已經存在)。</summary>
        <returns>表示具名系統事件的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights`參數必須包含<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標，好讓執行緒等候事件，而<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。  
  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A>方法嘗試開啟現有的具名的系統事件。 如果系統事件不存在，這個方法會擲回的例外狀況，而不是建立系統事件。 若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。  
  
   
  
## Examples  
 下列程式碼範例示範的具名的系統事件的跨處理序行為具有存取控制安全性。 此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。  
  
 如果事件不存在，它會建立初始擁有權與拒絕目前使用者的權限，請使用事件，但會授與讀取和變更事件的權限的權限的存取控制安全性。  
  
 如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。 攔截到例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來等候事件來讀取和變更的權限所需的權限。  
  
 權限變更之後，事件會開啟在其上等候，並對其發出通知所需的權限。 如果您從第三個 [命令] 視窗中執行編譯的範例，範例會執行使用新的權限。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 為空字串。  
  
-或- 
 <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">具名系統事件不存在。</exception>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名事件存在，但使用者沒有所需的安全性存取權。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將事件的狀態設定為未收到信號，因而造成執行緒封鎖。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" /> .</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">之前在這個 <see cref="M:System.Threading.WaitHandle.Close" /> 上呼叫 <see cref="T:System.Threading.EventWaitHandle" /> 方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將事件的狀態設定為收到信號，允許一個或多個等待中的執行緒繼續執行。</summary>
        <returns>如果作業成功，則為 <see langword="true" />，否則為 <see langword="false" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 針對<xref:System.Threading.EventWaitHandle>具有<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>(包括<xref:System.Threading.AutoResetEvent>)，則<xref:System.Threading.EventWaitHandle.Set%2A>方法會釋放單一執行緒。 如果沒有任何等候中執行緒，等候控制代碼直到已收到訊號的執行緒嘗試等候它，或直到其<xref:System.Threading.EventWaitHandle.Reset%2A>呼叫方法。  
  
> [!IMPORTANT]
>  不保證，每次呼叫<xref:System.Threading.EventWaitHandle.Set%2A>方法會釋放執行緒<xref:System.Threading.EventWaitHandle>其重設 模式是<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>。 如果兩個呼叫太接近，以便之前已釋放執行緒，就會發生在第二個呼叫，會釋放只有一個執行緒。 這是因為如果第二次呼叫未發生。 此外，如果<xref:System.Threading.EventWaitHandle.Set%2A>沒有等待的執行緒時，會呼叫和<xref:System.Threading.EventWaitHandle>已收到訊號，呼叫沒有任何作用。  
  
 針對<xref:System.Threading.EventWaitHandle>具有<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>(包括<xref:System.Threading.ManualResetEvent>)，則呼叫<xref:System.Threading.EventWaitHandle.Set%2A>方法會等候控制代碼保留在收到信號的狀態，直到其<xref:System.Threading.EventWaitHandle.Reset%2A>呼叫方法。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法多載來允許主執行緒發出信號已封鎖的執行緒，以及執行緒完成工作，然後等候。  
  
 此範例會啟動五個執行緒，並讓他們封鎖<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標，然後釋放一個執行緒時間，使用者按下 ENTER 鍵。 此範例會排入佇列的另一個的五個執行緒，並釋放所有使用<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">之前在這個 <see cref="M:System.Threading.WaitHandle.Close" /> 上呼叫 <see cref="T:System.Threading.EventWaitHandle" /> 方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">
          <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> 物件，代表要套用至具名系統事件的存取控制安全性。</param>
        <summary>為具名系統事件設定存取控制安全性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用者必須擁有<xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType>呼叫這個方法和事件的權限必須是與開啟<xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType>旗標。  
  
   
  
## Examples  
 下列程式碼範例示範的具名的系統事件的跨處理序行為具有存取控制安全性。 此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載來測試是否存在的具名事件。  
  
 如果事件不存在，它會建立初始擁有權與拒絕目前使用者的權限，請使用事件，但會授與讀取和變更事件的權限的權限的存取控制安全性。  
  
 如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>。 攔截到例外狀況時，和此範例會使用<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載來等候事件來讀取和變更的權限所需的權限。  
  
 變更權限，使用後<xref:System.Threading.EventWaitHandle.SetAccessControl%2A>事件的方法，會開啟在其上等候，並對其發出通知所需的權限。 如果您從第三個 [命令] 視窗中執行編譯的範例，範例會執行使用新的權限。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">使用者沒有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />。  
  
-或- 
並未以 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /> 開啟事件。</exception>
        <exception cref="T:System.SystemException">目前的 <see cref="T:System.Threading.EventWaitHandle" /> 物件不表示具名系統事件。</exception>
        <exception cref="T:System.ObjectDisposedException">之前在這個 <see cref="M:System.Threading.WaitHandle.Close" /> 上呼叫 <see cref="T:System.Threading.EventWaitHandle" /> 方法。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開啟指定的具名同步處理事件 (如果已經存在)，並傳回值，指出作業是否成功。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">要開啟的系統同步處理事件名稱。</param>
        <param name="result">這個方法傳回時，如果呼叫成功，則包含 <see cref="T:System.Threading.EventWaitHandle" /> 物件，此物件代表具名同步處理事件，如果呼叫失敗，則為 <see langword="null" />。 這個參數會被視為未初始化。</param>
        <summary>開啟指定的具名同步處理事件 (如果已經存在)，並傳回值，指出作業是否成功。</summary>
        <returns>如果已成功開啟具名同步處理事件，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果具名同步處理事件不存在，這個方法不會建立它。 若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。  
  
 如果您不確定是否存在的具名同步處理事件，請使用這個方法多載，而不是<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>方法多載，則會擲回例外狀況，如果同步處理事件不存在。  
  
 這個方法多載就相當於呼叫<xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29>方法多載，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。 指定<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒等候具名的系統事件，並指定<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 為空字串。  
  
-或- 
 <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名事件存在，但使用者沒有所需的安全性存取權。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">要開啟的系統同步處理事件名稱。</param>
        <param name="rights">列舉值的位元組合，表示所需的安全性存取。</param>
        <param name="result">這個方法傳回時，如果呼叫成功，則包含 <see cref="T:System.Threading.EventWaitHandle" /> 物件，此物件代表具名同步處理事件，如果呼叫失敗，則為 <see langword="null" />。 這個參數會被視為未初始化。</param>
        <summary>使用所需的安全性存取權，開啟指定的具名同步處理事件 (如果已經存在)，並傳回值，指出作業是否成功。</summary>
        <returns>如果已成功開啟具名同步處理事件，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果具名同步處理事件不存在，這個方法不會建立它。 若要建立的系統事件不存在時，使用其中一種<xref:System.Threading.EventWaitHandle.%23ctor%2A>建構函式具有`name`參數。  
  
 如果您不確定是否存在的具名同步處理事件，請使用這個方法多載，而不是<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>方法多載，則會擲回例外狀況，如果同步處理事件不存在。  
  
 `rights`參數必須包含<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>旗標，好讓執行緒等候事件，而<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.EventWaitHandle.Set%2A>和<xref:System.Threading.EventWaitHandle.Reset%2A>方法。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.EventWaitHandle>物件，即使傳回的物件代表相同的具名的系統事件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 為空字串。  
  
-或- 
 <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名事件存在，但使用者沒有所需的安全性存取權。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
  </Members>
</Type>