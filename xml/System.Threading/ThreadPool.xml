<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a3111b9d3890e99871797d80fe33a669a253dba6" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39851171" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="209c8-101">提供執行緒的集區，可用來執行工作、張貼工作項目、處理非同步 I/O、代表其他執行緒等候，以及處理計時器。</span>
      <span class="sxs-lookup">
        <span data-stu-id="209c8-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-102">許多應用程式建立花太多的時間處於睡眠狀態，等候事件發生的執行緒。</span><span class="sxs-lookup"><span data-stu-id="209c8-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="209c8-103">其他執行緒可能會進入休眠狀態後才能定期喚醒來輪詢有變更或更新的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="209c8-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="209c8-104">執行緒集區可讓您更有效率地使用藉由提供您的應用程式的系統所管理的背景工作執行緒集區的執行緒。</span><span class="sxs-lookup"><span data-stu-id="209c8-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="209c8-105">使用執行緒集區作業的範例包括下列各項：</span><span class="sxs-lookup"><span data-stu-id="209c8-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="209c8-106">當您建立<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>以非同步方式執行一些工作，根據預設，執行緒集區執行緒上執行排程工作的物件。</span><span class="sxs-lookup"><span data-stu-id="209c8-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="209c8-107">非同步的計時器會使用執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="209c8-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="209c8-108">執行緒集區執行緒執行回呼<xref:System.Threading.Timer?displayProperty=nameWithType>類別，並引發事件<xref:System.Timers.Timer?displayProperty=nameWithType>類別。</span><span class="sxs-lookup"><span data-stu-id="209c8-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="209c8-109">當您使用已註冊的等候控制代碼時，則系統執行緒會監視在等候控制代碼的狀態。</span><span class="sxs-lookup"><span data-stu-id="209c8-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="209c8-110">等候作業完成時，執行緒集區的背景工作執行緒會執行對應的回呼函式。</span><span class="sxs-lookup"><span data-stu-id="209c8-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="209c8-111">當您呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>排入佇列的方法，以便在執行緒集區執行緒上執行的方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="209c8-112">您可以傳遞給方法<xref:System.Threading.WaitCallback>委派。</span><span class="sxs-lookup"><span data-stu-id="209c8-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="209c8-113">委派的簽章</span><span class="sxs-lookup"><span data-stu-id="209c8-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="209c8-114">其中`state`是物件，包含由委派所要使用的資料。</span><span class="sxs-lookup"><span data-stu-id="209c8-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="209c8-115">實際的資料可以傳遞至委派，藉由呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="209c8-116">Managed 的執行緒集區中的執行緒為背景執行緒。</span><span class="sxs-lookup"><span data-stu-id="209c8-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="209c8-117">也就是他們<xref:System.Threading.Thread.IsBackground%2A>屬性是`true`。</span><span class="sxs-lookup"><span data-stu-id="209c8-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="209c8-118">這表示<xref:System.Threading.ThreadPool>執行緒不會持續執行的所有前景執行緒都結束後的應用程式。</span><span class="sxs-lookup"><span data-stu-id="209c8-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="209c8-119">當執行緒集區會重複使用的執行緒時，它不會清除執行緒區域儲存區中，或標示的欄位中的資料<xref:System.ThreadStaticAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="209c8-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="209c8-120">因此，當方法會檢查執行緒區域儲存區，或欄位，會標示<xref:System.ThreadStaticAttribute>屬性，它找到的值可能剩餘的執行緒集區執行緒的先前版本會使用。</span><span class="sxs-lookup"><span data-stu-id="209c8-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="209c8-121">您也可以將佇列的執行緒集區以等候作業無關的工作項目。</span><span class="sxs-lookup"><span data-stu-id="209c8-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="209c8-122">若要要求工作項目由執行緒集區中的執行緒，呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="209c8-123">此方法會採用做為參數的方法或將會從執行緒集區中選取的執行緒所呼叫的委派的參考。</span><span class="sxs-lookup"><span data-stu-id="209c8-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="209c8-124">沒有任何方法可取消的工作項目之後已加入佇列。</span><span class="sxs-lookup"><span data-stu-id="209c8-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="209c8-125">計時器佇列中的計時器和已註冊之等候作業也會使用執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="209c8-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="209c8-126">它們的回呼函式會排入執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="209c8-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="209c8-127">沒有每個處理序的一個執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="209c8-127">There is one thread pool per process.</span></span> <span data-ttu-id="209c8-128">從 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 開始，處理序的執行緒集區預設大小取決於數個因素，例如虛擬位址空間的大小。</span><span class="sxs-lookup"><span data-stu-id="209c8-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="209c8-129">處理序可以呼叫 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 方法來決定執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="209c8-130">可以使用變更的執行緒集區中的執行緒數目<xref:System.Threading.ThreadPool.SetMaxThreads%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="209c8-131">每個執行緒會使用預設堆疊大小，並在預設的優先權執行。</span><span class="sxs-lookup"><span data-stu-id="209c8-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="209c8-132">裝載.NET Framework 的 unmanaged 程式碼可以使用變更的執行緒集區大小`CorSetMaxThreads`函式，定義於 mscoree.h 檔案。</span><span class="sxs-lookup"><span data-stu-id="209c8-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="209c8-133">執行緒集區視需要提供新的背景工作執行緒或 I/O 完成執行緒，直到它到達每個類別目錄的最小值。</span><span class="sxs-lookup"><span data-stu-id="209c8-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="209c8-134">當到達最小值時，執行緒集區可以建立額外的執行緒，該類別中，或等到部分工作完成。</span><span class="sxs-lookup"><span data-stu-id="209c8-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="209c8-135">從 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 開始，執行緒集區會建立並終結背景工作執行緒，以便最佳化輸送量，輸送量的定義為每個時間單位完成的工作數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="209c8-136">執行緒太少可能無法最有效地利用可用資源，而執行緒太多則可能增加資源爭用的情況。</span><span class="sxs-lookup"><span data-stu-id="209c8-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="209c8-137">當需求很低時，執行緒集區執行緒的實際數目可能低於最小值。</span><span class="sxs-lookup"><span data-stu-id="209c8-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="209c8-138">您可以使用 <xref:System.Threading.ThreadPool.GetMinThreads%2A> 方法取得這些最小值。</span><span class="sxs-lookup"><span data-stu-id="209c8-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="209c8-139">您可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法，以增加最低的執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="209c8-140">不過，不必要地增加這些值，可能會造成效能問題。</span><span class="sxs-lookup"><span data-stu-id="209c8-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="209c8-141">如果太多工作同時啟動，則所有工作可能都會變慢。</span><span class="sxs-lookup"><span data-stu-id="209c8-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="209c8-142">在大部分情況下，執行緒集區使用自己的演算法來配置執行緒的效能較佳。</span><span class="sxs-lookup"><span data-stu-id="209c8-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="209c8-143">在下列範例中，主應用程式執行緒方法排入佇列名為`ThreadProc`執行緒集區執行緒，而會休眠一秒，，然後結束上執行。</span><span class="sxs-lookup"><span data-stu-id="209c8-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="209c8-144">`ThreadProc`方法只會顯示一則訊息。</span><span class="sxs-lookup"><span data-stu-id="209c8-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="209c8-145">如果您註解的呼叫<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法中，主執行緒結束的執行緒集區執行緒上的方法執行之前。</span><span class="sxs-lookup"><span data-stu-id="209c8-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="209c8-146">執行緒集區會使用背景執行緒，不讓應用程式順利執行中的所有前景執行緒已經都終止。</span><span class="sxs-lookup"><span data-stu-id="209c8-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="209c8-147">（這是簡單的範例，競爭條件）。</span><span class="sxs-lookup"><span data-stu-id="209c8-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="209c8-148">此型別具備執行緒安全。</span>
      <span class="sxs-lookup">
        <span data-stu-id="209c8-148">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="209c8-149">可將作業系統的控制代碼繫結至 <see cref="T:System.Threading.ThreadPool" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-149">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="209c8-150">持有控制代碼的 <see cref="T:System.IntPtr" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-150">An <see cref="T:System.IntPtr" /> that holds the handle.</span>
          </span>
          <span data-ttu-id="209c8-151">控制代碼必須已經對 Unmanaged 側的重疊 I/O 開啟。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-151">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-152">可將作業系統的控制代碼繫結至 <see cref="T:System.Threading.ThreadPool" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-152">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-153">如果控制代碼已繫結，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-153">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="209c8-154">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-154">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="209c8-155">提供呼叫 unmanaged 程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-155">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="209c8-156">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-156">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="209c8-157">
            <see cref="T:System.Runtime.InteropServices.SafeHandle" />，包含作業系統控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span>
          </span>
          <span data-ttu-id="209c8-158">控制代碼必須已經對 Unmanaged 側的重疊 I/O 開啟。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-158">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-159">可將作業系統的控制代碼繫結至 <see cref="T:System.Threading.ThreadPool" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-159">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-160">如果控制代碼已繫結，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-160">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-161">`osHandle`參數應該<xref:Microsoft.Win32.SafeHandles.SafeFileHandle>，其衍生自抽象<xref:System.Runtime.InteropServices.SafeHandle>類別。</span><span class="sxs-lookup"><span data-stu-id="209c8-161">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="209c8-162">
            <paramref name="osHandle" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-162">
              <paramref name="osHandle" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="209c8-163">提供呼叫 unmanaged 程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-163">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="209c8-164">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-164">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="209c8-165">可用背景工作執行緒的數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-165">The number of available worker threads.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="209c8-166">可用非同步 I/O 執行緒的數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-166">The number of available asynchronous I/O threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-167">擷取 <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> 方法所傳回之執行緒集區的執行緒最大數目，與目前作用中數目之間的差異。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-167">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-168">當<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>會傳回指定的變數`workerThreads`含有額外的背景工作執行緒可以啟動，且指定的變數`completionPortThreads`包含其他可能的非同步 I/O 執行緒的數目已啟動。</span><span class="sxs-lookup"><span data-stu-id="209c8-168">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="209c8-169">如果沒有可用的執行緒，額外的執行緒集區要求保留已排入佇列直到執行緒集區執行緒變成可用。</span><span class="sxs-lookup"><span data-stu-id="209c8-169">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="209c8-170">簡單的應用程式啟動時，下列範例會顯示背景工作執行緒和可用的 I/O 執行緒的數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-170">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="209c8-171">執行緒集區中的背景工作執行緒最大數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-171">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="209c8-172">執行緒集區中的非同步 I/O 執行緒最大數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-172">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-173">擷取可並行使用之執行緒集區的要求數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-173">Retrieves the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="209c8-174">超過該數目的所有要求會繼續佇列，直到可以使用執行緒集區執行緒為止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-174">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-175">當<xref:System.Threading.ThreadPool.GetMaxThreads%2A>會傳回指定的變數`workerThreads`包含允許執行緒集區中的背景工作執行緒和變數所指定的最大數目`completionPortThreads`包含中允許的非同步 I/O 執行緒最大數目執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="209c8-175">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="209c8-176">您可以使用<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>方法，以判斷在任何指定時間的實際的執行緒集區中的執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-176">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="209c8-177">您可以使用<xref:System.Threading.ThreadPool.SetMaxThreads%2A>設定執行緒集區中的背景工作執行緒和非同步 I/O 執行緒的最大數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-177">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="209c8-178">您可以在無數個執行緒集區的要求，因為系統記憶體可讓佇列。</span><span class="sxs-lookup"><span data-stu-id="209c8-178">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="209c8-179">如果有更多的要求，超過的執行緒集區，其他要求會繼續已排入佇列，直到執行緒集區執行緒變成可用為止。</span><span class="sxs-lookup"><span data-stu-id="209c8-179">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="209c8-180">下列程式碼範例示範如何擷取最大和可用的執行緒集區中的執行緒數目的計數。</span><span class="sxs-lookup"><span data-stu-id="209c8-180">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="209c8-181">工作項目會排入佇列，會使用`FileStream`以非同步方式寫入兩個檔案。</span><span class="sxs-lookup"><span data-stu-id="209c8-181">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="209c8-182">回呼方法的計時重疊。</span><span class="sxs-lookup"><span data-stu-id="209c8-182">The callback methods are timed to overlap.</span></span> <span data-ttu-id="209c8-183">背景工作執行緒處理的工作項目，並根據速度和電腦上的處理器數目，一或兩個完成連接埠執行緒處理 「 寫入 」 操作。</span><span class="sxs-lookup"><span data-stu-id="209c8-183">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="209c8-184">當這個方法傳回時，會包含執行緒集區視需要建立的背景工作執行緒最小數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-184">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="209c8-185">當這個方法傳回時，會包含執行緒集區視需要建立的非同步 I/O 執行緒最小數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-185">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-186">在切換至管理執行緒建立和解構的演算法之前，擷取執行緒集區隨著提出新要求，視需要建立的執行緒最小數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-186">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-187">執行緒集區視需要提供新的背景工作執行緒或 I/O 完成執行緒，直到它到達每個類別目錄的最小值。</span><span class="sxs-lookup"><span data-stu-id="209c8-187">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="209c8-188">根據預設，執行緒的數目下限設為在系統上的處理器數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-188">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="209c8-189">當到達最小值時，執行緒集區可以建立額外的執行緒，該類別中，或等到部分工作完成。</span><span class="sxs-lookup"><span data-stu-id="209c8-189">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="209c8-190">開頭為[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，執行緒集區建立和終結執行緒，以便最佳化輸送量，而定義為每個時間單位完成的工作數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-190">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="209c8-191">執行緒太少可能無法最有效地利用可用資源，而執行緒太多則可能增加資源爭用的情況。</span><span class="sxs-lookup"><span data-stu-id="209c8-191">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="209c8-192">當需求很低時，執行緒集區執行緒的實際數目可能低於最小值。</span><span class="sxs-lookup"><span data-stu-id="209c8-192">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="209c8-193">下列範例會設定背景工作執行緒的數目下限為 4，並保留原始值的非同步 I/O 完成執行緒的數目下限。</span><span class="sxs-lookup"><span data-stu-id="209c8-193">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="209c8-194">將方法排入佇列，以等候執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-194">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="209c8-195">可以使用執行緒集區執行緒時，即可執行這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-195">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="209c8-196">
            <see cref="T:System.Threading.WaitCallback" />，代表要執行的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-196">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-197">將方法排入佇列，以等候執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-197">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="209c8-198">可以使用執行緒集區執行緒時，即可執行這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-198">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-199">如果方法成功佇列則為 <see langword="true" />；如果工作項目無法佇列則會擲回 <see cref="T:System.NotSupportedException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-199">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-200">您可以將已排入佇列的方法，在方法定義，或您可以使用此類別的執行個體欄位中所需的資料<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>多載會接受物件，其中包含必要的資料。</span><span class="sxs-lookup"><span data-stu-id="209c8-200">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="209c8-201">Visual Basic 使用者可以省略<xref:System.Threading.WaitCallback>建構函式，並只使用`AddressOf`運算子傳遞至回呼方法時<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。</span><span class="sxs-lookup"><span data-stu-id="209c8-201">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="209c8-202">Visual Basic 會自動呼叫正確的委派建構函式。</span><span class="sxs-lookup"><span data-stu-id="209c8-202">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="209c8-203">版本資訊</span><span class="sxs-lookup"><span data-stu-id="209c8-203">Version Information</span></span>  
 <span data-ttu-id="209c8-204">在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-204">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="209c8-205">在舊版中，主體的資訊不會傳播。</span><span class="sxs-lookup"><span data-stu-id="209c8-205">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="209c8-206">下列範例會使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29>方法多載來工作排入佇列，這由`ThreadProc`方法，讓執行緒變成可用時執行。</span><span class="sxs-lookup"><span data-stu-id="209c8-206">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="209c8-207">沒有工作資訊會提供使用這個多載。</span><span class="sxs-lookup"><span data-stu-id="209c8-207">No task information is supplied with this overload.</span></span> <span data-ttu-id="209c8-208">因此，若要使用的資訊`ThreadProc`方法僅限於方法所屬的物件。</span><span class="sxs-lookup"><span data-stu-id="209c8-208">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="209c8-209">
            <paramref name="callBack" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-209">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="209c8-210">Common Language Runtime (CLR) 已裝載，而且主機不支援這個動作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-210">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="209c8-211">
            <see cref="T:System.Threading.WaitCallback" />，代表要執行的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-211">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="209c8-212">物件，包含這個方法所要使用的資料。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-212">An object containing data to be used by the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-213">將方法排入佇列，以等候執行，並指定包含這個方法所要使用之資料的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-213">Queues a method for execution, and specifies an object containing data to be used by the method.</span>
          </span>
          <span data-ttu-id="209c8-214">可以使用執行緒集區執行緒時，即可執行這個方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-214">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-215">如果方法成功佇列則為 <see langword="true" />；如果工作項目無法佇列則會擲回 <see cref="T:System.NotSupportedException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-215">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-216">如果回呼方法需要複雜的資料，您可以定義包含資料的類別。</span><span class="sxs-lookup"><span data-stu-id="209c8-216">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="209c8-217">Visual Basic 使用者可以省略<xref:System.Threading.WaitCallback>建構函式，並只使用`AddressOf`運算子傳遞至回呼方法時<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。</span><span class="sxs-lookup"><span data-stu-id="209c8-217">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="209c8-218">Visual Basic 會自動呼叫正確的委派建構函式。</span><span class="sxs-lookup"><span data-stu-id="209c8-218">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="209c8-219">版本資訊</span><span class="sxs-lookup"><span data-stu-id="209c8-219">Version Information</span></span>  
 <span data-ttu-id="209c8-220">在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-220">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="209c8-221">在舊版中，主體的資訊不會傳播。</span><span class="sxs-lookup"><span data-stu-id="209c8-221">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="209c8-222">下列範例會使用.NET 執行緒集區來計算`Fibonacci`五個數字，介於 20 到 40 之間的結果。</span><span class="sxs-lookup"><span data-stu-id="209c8-222">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="209c8-223">每個 `Fibonacci` 結果都會以 `Fibonacci` 類別表示，該類別提供一個執行計算的方法，稱為 `ThreadPoolCallback`。</span><span class="sxs-lookup"><span data-stu-id="209c8-223">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="209c8-224">這會建立代表每個 `Fibonacci` 值的物件，並將 `ThreadPoolCallback` 方法傳遞至 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>，以指派集區中的可用執行緒來執行此方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-224">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="209c8-225">因為每個`Fibonacci`物件提供半隨機值來計算，以及每個執行緒會競爭處理器時間，因為您不知道事先花多少時間將會計算所有五個結果。</span><span class="sxs-lookup"><span data-stu-id="209c8-225">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="209c8-226">這就是為什麼會在建構期間將每個 `Fibonacci` 物件傳遞至 <xref:System.Threading.ManualResetEvent> 類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="209c8-226">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="209c8-227">每個物件表示提供的事件物件計算完成時，這可讓使用區塊執行主要執行緒<xref:System.Threading.WaitHandle.WaitAll%2A>直到所有五個`Fibonacci`物件都已計算的結果。</span><span class="sxs-lookup"><span data-stu-id="209c8-227">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="209c8-228">`Main` 方法接著會顯示每個 `Fibonacci` 結果。</span><span class="sxs-lookup"><span data-stu-id="209c8-228">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="209c8-229">Common Language Runtime (CLR) 已裝載，而且主機不支援這個動作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-229">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="209c8-230">
            <paramref name="callBack" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-230">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="209c8-231">註冊正在等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-231">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="209c8-232">要註冊的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-232">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="209c8-233">使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-233">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="209c8-234">通知 <c>waitObject</c> 參數時要呼叫的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-234">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="209c8-235">傳遞至委派的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-235">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="209c8-236">逾時以毫秒為單位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-236">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="209c8-237">如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-237">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="209c8-238">如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-238">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="209c8-239">
            <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-239">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-240">指定 32 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-240">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-241">封裝原生控制代碼的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-241">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-242">完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。</span><span class="sxs-lookup"><span data-stu-id="209c8-242">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="209c8-243">我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="209c8-243">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="209c8-244">記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。</span><span class="sxs-lookup"><span data-stu-id="209c8-244">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="209c8-245"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法排入佇列的執行緒集區指定的委派。</span><span class="sxs-lookup"><span data-stu-id="209c8-245">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="209c8-246">當發生下列其中一項時，背景工作執行緒將執行委派：</span><span class="sxs-lookup"><span data-stu-id="209c8-246">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="209c8-247">指定的物件處於收到信號的狀態。</span><span class="sxs-lookup"><span data-stu-id="209c8-247">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="209c8-248">經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="209c8-248">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="209c8-249"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法會檢查指定的物件的目前狀態<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="209c8-249">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="209c8-250">如果未發出信號狀態的物件，則方法會註冊等候作業。</span><span class="sxs-lookup"><span data-stu-id="209c8-250">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="209c8-251">等候作業是由執行緒集區的執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="209c8-251">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="209c8-252">物件的狀態變成發出訊號，或經過逾時間隔時，背景工作執行緒會執行委派。</span><span class="sxs-lookup"><span data-stu-id="209c8-252">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="209c8-253">如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，計時器會重設，每次事件收到訊號，或經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="209c8-253">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="209c8-254">使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。</span><span class="sxs-lookup"><span data-stu-id="209c8-254">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="209c8-255">而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。</span><span class="sxs-lookup"><span data-stu-id="209c8-255">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="209c8-256">若要取消之等候作業，呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-256">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="209c8-257">等候執行緒會使用 Win32`WaitForMultipleObjects`函式，以監視已註冊之等候作業。</span><span class="sxs-lookup"><span data-stu-id="209c8-257">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="209c8-258">因此，如果您必須使用相同的原生作業系統控制代碼，以多次呼叫<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。</span><span class="sxs-lookup"><span data-stu-id="209c8-258">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="209c8-259">請注意，您不應該轉盤式事件物件，傳遞至<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因為等待執行緒可能會不會偵測事件收到信號之前重設。</span><span class="sxs-lookup"><span data-stu-id="209c8-259">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="209c8-260">在傳回之前，此函式會修改某些類型的同步處理物件的狀態。</span><span class="sxs-lookup"><span data-stu-id="209c8-260">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="209c8-261">修改只會發生在其收到信號的狀態造成要滿足等候條件的物件。</span><span class="sxs-lookup"><span data-stu-id="209c8-261">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="209c8-262">比方說，號誌的計數就會減少一個。</span><span class="sxs-lookup"><span data-stu-id="209c8-262">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="209c8-263">版本資訊</span><span class="sxs-lookup"><span data-stu-id="209c8-263">Version Information</span></span>  
 <span data-ttu-id="209c8-264">從.NET Framework 2.0 版中，開始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-264">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="209c8-265">在舊版中，主體的資訊不會傳播。</span><span class="sxs-lookup"><span data-stu-id="209c8-265">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="209c8-266">
            <paramref name="millisecondsTimeOutInterval" /> 參數小於 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-266">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="209c8-267">要註冊的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-267">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="209c8-268">使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-268">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="209c8-269">通知 <c>waitObject</c> 參數時要呼叫的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-269">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="209c8-270">傳送至委派的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-270">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="209c8-271">逾時以毫秒為單位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-271">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="209c8-272">如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-272">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="209c8-273">如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-273">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="209c8-274">
            <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-274">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-275">指定 64 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-275">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-276">封裝原生控制代碼的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-276">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-277">完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。</span><span class="sxs-lookup"><span data-stu-id="209c8-277">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="209c8-278">我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="209c8-278">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="209c8-279">記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。</span><span class="sxs-lookup"><span data-stu-id="209c8-279">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="209c8-280"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法排入佇列的執行緒集區指定的委派。</span><span class="sxs-lookup"><span data-stu-id="209c8-280">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="209c8-281">當發生下列其中一項時，背景工作執行緒將執行委派：</span><span class="sxs-lookup"><span data-stu-id="209c8-281">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="209c8-282">指定的物件處於收到信號的狀態。</span><span class="sxs-lookup"><span data-stu-id="209c8-282">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="209c8-283">經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="209c8-283">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="209c8-284"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法會檢查指定的物件的目前狀態<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="209c8-284">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="209c8-285">如果未發出信號狀態的物件，則方法會註冊等候作業。</span><span class="sxs-lookup"><span data-stu-id="209c8-285">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="209c8-286">等候作業是由執行緒集區的執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="209c8-286">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="209c8-287">物件的狀態變成發出訊號，或經過逾時間隔時，背景工作執行緒會執行委派。</span><span class="sxs-lookup"><span data-stu-id="209c8-287">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="209c8-288">如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，計時器會重設，每次事件收到訊號，或經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="209c8-288">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="209c8-289">使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。</span><span class="sxs-lookup"><span data-stu-id="209c8-289">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="209c8-290">而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。</span><span class="sxs-lookup"><span data-stu-id="209c8-290">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="209c8-291">若要取消之等候作業，呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-291">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="209c8-292">等候執行緒會使用 Win32`WaitForMultipleObjects`函式，以監視已註冊之等候作業。</span><span class="sxs-lookup"><span data-stu-id="209c8-292">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="209c8-293">因此，如果您必須使用相同的原生作業系統控制代碼，以多次呼叫<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。</span><span class="sxs-lookup"><span data-stu-id="209c8-293">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="209c8-294">請注意，您不應該轉盤式事件物件，傳遞至<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因為等待執行緒可能會不會偵測事件收到信號之前重設。</span><span class="sxs-lookup"><span data-stu-id="209c8-294">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="209c8-295">在傳回之前，此函式會修改某些類型的同步處理物件的狀態。</span><span class="sxs-lookup"><span data-stu-id="209c8-295">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="209c8-296">修改只會發生在其收到信號的狀態造成要滿足等候條件的物件。</span><span class="sxs-lookup"><span data-stu-id="209c8-296">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="209c8-297">比方說，號誌的計數就會減少一個。</span><span class="sxs-lookup"><span data-stu-id="209c8-297">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="209c8-298">版本資訊</span><span class="sxs-lookup"><span data-stu-id="209c8-298">Version Information</span></span>  
 <span data-ttu-id="209c8-299">從.NET Framework 2.0 版中，開始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-299">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="209c8-300">在舊版中，主體的資訊不會傳播。</span><span class="sxs-lookup"><span data-stu-id="209c8-300">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="209c8-301">
            <paramref name="millisecondsTimeOutInterval" /> 參數小於 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-301">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="209c8-302">要註冊的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-302">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="209c8-303">使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-303">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="209c8-304">通知 <c>waitObject</c> 參數時要呼叫的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-304">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="209c8-305">傳送至委派的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-305">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="209c8-306">以 <see cref="T:System.TimeSpan" /> 表示的逾時值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-306">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="209c8-307">如果 <c>timeout</c> 為 0 (零)，則函式會測試物件的狀態並立即傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-307">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="209c8-308">如果 <c>timeout</c> 為 -1，則絕對不會耗用函式的逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-308">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="209c8-309">
            <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-309">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-310">指定 <see cref="T:System.TimeSpan" /> 值表示逾時值，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-310">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-311">封裝原生控制代碼的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-311">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-312">完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。</span><span class="sxs-lookup"><span data-stu-id="209c8-312">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="209c8-313">我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="209c8-313">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="209c8-314">記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。</span><span class="sxs-lookup"><span data-stu-id="209c8-314">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="209c8-315"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法排入佇列的執行緒集區指定的委派。</span><span class="sxs-lookup"><span data-stu-id="209c8-315">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="209c8-316">當發生下列其中一項時，背景工作執行緒將執行委派：</span><span class="sxs-lookup"><span data-stu-id="209c8-316">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="209c8-317">指定的物件處於收到信號的狀態。</span><span class="sxs-lookup"><span data-stu-id="209c8-317">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="209c8-318">經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="209c8-318">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="209c8-319"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法會檢查指定的物件的目前狀態<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="209c8-319">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="209c8-320">如果未發出信號狀態的物件，則方法會註冊等候作業。</span><span class="sxs-lookup"><span data-stu-id="209c8-320">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="209c8-321">等候作業是由執行緒集區的執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="209c8-321">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="209c8-322">物件的狀態變成發出訊號，或經過逾時間隔時，背景工作執行緒會執行委派。</span><span class="sxs-lookup"><span data-stu-id="209c8-322">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="209c8-323">如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，計時器會重設，每次事件收到訊號，或經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="209c8-323">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="209c8-324">使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。</span><span class="sxs-lookup"><span data-stu-id="209c8-324">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="209c8-325">而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。</span><span class="sxs-lookup"><span data-stu-id="209c8-325">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="209c8-326">若要取消之等候作業，呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-326">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="209c8-327">等候執行緒會使用 Win32`WaitForMultipleObjects`函式，以監視已註冊之等候作業。</span><span class="sxs-lookup"><span data-stu-id="209c8-327">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="209c8-328">因此，如果您必須使用相同的原生作業系統控制代碼，以多次呼叫<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。</span><span class="sxs-lookup"><span data-stu-id="209c8-328">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="209c8-329">請注意，您不應該轉盤式事件物件，傳遞至<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因為等待執行緒可能會不會偵測事件收到信號之前重設。</span><span class="sxs-lookup"><span data-stu-id="209c8-329">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="209c8-330">在傳回之前，此函式會修改某些類型的同步處理物件的狀態。</span><span class="sxs-lookup"><span data-stu-id="209c8-330">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="209c8-331">修改只會發生在其收到信號的狀態造成要滿足等候條件的物件。</span><span class="sxs-lookup"><span data-stu-id="209c8-331">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="209c8-332">比方說，號誌的計數就會減少一個。</span><span class="sxs-lookup"><span data-stu-id="209c8-332">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="209c8-333">版本資訊</span><span class="sxs-lookup"><span data-stu-id="209c8-333">Version Information</span></span>  
 <span data-ttu-id="209c8-334">從.NET Framework 2.0 版中，開始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-334">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="209c8-335">在舊版中，主體的資訊不會傳播。</span><span class="sxs-lookup"><span data-stu-id="209c8-335">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="209c8-336">
            <paramref name="timeout" /> 參數小於 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-336">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="209c8-337">
            <paramref name="timeout" /> 參數大於 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-337">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="209c8-338">要註冊的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-338">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="209c8-339">使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-339">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="209c8-340">通知 <c>waitObject</c> 參數時要呼叫的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-340">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="209c8-341">傳送至委派的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-341">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="209c8-342">逾時以毫秒為單位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-342">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="209c8-343">如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-343">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="209c8-344">如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-344">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="209c8-345">
            <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-345">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-346">指定 32 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-346">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-347">可用來取消已註冊之等候作業的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-347">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-348">完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。</span><span class="sxs-lookup"><span data-stu-id="209c8-348">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="209c8-349">我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="209c8-349">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="209c8-350">記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。</span><span class="sxs-lookup"><span data-stu-id="209c8-350">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="209c8-351"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法排入佇列的執行緒集區指定的委派。</span><span class="sxs-lookup"><span data-stu-id="209c8-351">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="209c8-352">當發生下列其中一項時，背景工作執行緒將執行委派：</span><span class="sxs-lookup"><span data-stu-id="209c8-352">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="209c8-353">指定的物件處於收到信號的狀態。</span><span class="sxs-lookup"><span data-stu-id="209c8-353">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="209c8-354">經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="209c8-354">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="209c8-355"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法會檢查指定的物件的目前狀態<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="209c8-355">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="209c8-356">如果未發出信號狀態的物件，則方法會註冊等候作業。</span><span class="sxs-lookup"><span data-stu-id="209c8-356">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="209c8-357">等候作業是由執行緒集區的執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="209c8-357">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="209c8-358">物件的狀態變成發出訊號，或經過逾時間隔時，背景工作執行緒會執行委派。</span><span class="sxs-lookup"><span data-stu-id="209c8-358">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="209c8-359">如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，計時器會重設，每次事件收到訊號，或經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="209c8-359">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="209c8-360">使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。</span><span class="sxs-lookup"><span data-stu-id="209c8-360">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="209c8-361">而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。</span><span class="sxs-lookup"><span data-stu-id="209c8-361">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="209c8-362">若要取消之等候作業，呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-362">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="209c8-363">等候執行緒會使用 Win32`WaitForMultipleObjects`函式，以監視已註冊之等候作業。</span><span class="sxs-lookup"><span data-stu-id="209c8-363">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="209c8-364">因此，如果您必須使用相同的原生作業系統控制代碼，以多次呼叫<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。</span><span class="sxs-lookup"><span data-stu-id="209c8-364">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="209c8-365">請注意，您不應該轉盤式事件物件，傳遞至<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因為等待執行緒可能會不會偵測事件收到信號之前重設。</span><span class="sxs-lookup"><span data-stu-id="209c8-365">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="209c8-366">在傳回之前，此函式會修改某些類型的同步處理物件的狀態。</span><span class="sxs-lookup"><span data-stu-id="209c8-366">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="209c8-367">修改只會發生在其收到信號的狀態造成要滿足等候條件的物件。</span><span class="sxs-lookup"><span data-stu-id="209c8-367">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="209c8-368">比方說，號誌的計數就會減少一個。</span><span class="sxs-lookup"><span data-stu-id="209c8-368">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="209c8-369">版本資訊</span><span class="sxs-lookup"><span data-stu-id="209c8-369">Version Information</span></span>  
 <span data-ttu-id="209c8-370">從.NET Framework 2.0 版中，開始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-370">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="209c8-371">在舊版中，主體的資訊不會傳播。</span><span class="sxs-lookup"><span data-stu-id="209c8-371">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="209c8-372">下列範例示範如何使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法來指定的等候控制代碼會收到信號時，執行指定的回呼方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-372">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="209c8-373">在此範例中，是回呼方法`WaitProc`，並等候控制代碼是<xref:System.Threading.AutoResetEvent>。</span><span class="sxs-lookup"><span data-stu-id="209c8-373">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="209c8-374">此範例會定義`TaskInfo`類別來保存執行時傳遞至回呼的資訊。</span><span class="sxs-lookup"><span data-stu-id="209c8-374">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="209c8-375">此範例會建立`TaskInfo`物件，並將其指派一些字串資料。</span><span class="sxs-lookup"><span data-stu-id="209c8-375">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="209c8-376"><xref:System.Threading.RegisteredWaitHandle>傳回的<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指派給`Handle`欄位`TaskInfo`物件，使回呼方法可以存取<xref:System.Threading.RegisteredWaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="209c8-376">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="209c8-377">除了指定`TaskInfo`做為要傳遞至回呼方法的呼叫物件<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法會指定<xref:System.Threading.AutoResetEvent>等候工作，<xref:System.Threading.WaitOrTimerCallback>委派，表示`WaitProc`回呼方法一秒的逾時間隔，以及多個回呼。</span><span class="sxs-lookup"><span data-stu-id="209c8-377">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="209c8-378">當主執行緒發出信號<xref:System.Threading.AutoResetEvent>藉由呼叫其<xref:System.Threading.EventWaitHandle.Set%2A>方法，<xref:System.Threading.WaitOrTimerCallback>叫用委派。</span><span class="sxs-lookup"><span data-stu-id="209c8-378">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="209c8-379">`WaitProc`方法會測試<xref:System.Threading.RegisteredWaitHandle>來判斷是否發生逾時。</span><span class="sxs-lookup"><span data-stu-id="209c8-379">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="209c8-380">如果等候控制代碼發出訊號，因為叫用回呼`WaitProc`方法會移除註冊<xref:System.Threading.RegisteredWaitHandle>，停止其他回呼。</span><span class="sxs-lookup"><span data-stu-id="209c8-380">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="209c8-381">在逾時，工作會繼續等候。</span><span class="sxs-lookup"><span data-stu-id="209c8-381">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="209c8-382">`WaitProc`方法結束列印至主控台的訊息。</span><span class="sxs-lookup"><span data-stu-id="209c8-382">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="209c8-383">
            <paramref name="millisecondsTimeOutInterval" /> 參數小於 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-383">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="209c8-384">執行緒集區中的背景工作執行緒最大數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-384">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="209c8-385">執行緒集區中的非同步 I/O 執行緒最大數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-385">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-386">設定可並行使用之執行緒集區的要求數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-386">Sets the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="209c8-387">超過該數目的所有要求會繼續佇列，直到可以使用執行緒集區執行緒為止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-387">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-388">如果變更成功，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-388">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-389">您無法設定背景工作執行緒或 I/O 完成執行緒的最大數目的數字小於電腦上的處理器數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-389">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="209c8-390">若要判斷有多少個處理器，擷取的值<xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="209c8-390">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="209c8-391">此外，您無法設定背景工作執行緒或 I/O 完成執行緒的數字小於對應的最小數目的背景工作執行緒或 I/O 完成執行緒的最大數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-391">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="209c8-392">若要判斷最小執行緒集區大小，請呼叫<xref:System.Threading.ThreadPool.GetMinThreads%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="209c8-392">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="209c8-393">如果裝載通用語言執行平台，例如藉由 Internet Information Services (IIS) 或 SQL Server 中，主機可以限制或阻止變更執行緒集區大小。</span><span class="sxs-lookup"><span data-stu-id="209c8-393">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="209c8-394">變更執行緒集區中的執行緒數目上限時，請務必小心。</span><span class="sxs-lookup"><span data-stu-id="209c8-394">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="209c8-395">雖然您的程式碼可能會因此而受益，所做的變更可能造成負面影響您使用的程式碼程式庫。</span><span class="sxs-lookup"><span data-stu-id="209c8-395">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="209c8-396">設定執行緒集區大小太大，可能會造成效能問題。</span><span class="sxs-lookup"><span data-stu-id="209c8-396">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="209c8-397">如果太多的執行緒正在同時執行，工作切換額外負荷會變成重大的因素。</span><span class="sxs-lookup"><span data-stu-id="209c8-397">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="209c8-398">提供控制執行緒的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-398">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="209c8-399">權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-399">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="209c8-400">執行緒集區視需要建立的背景工作執行緒最小數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-400">The minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="209c8-401">執行緒集區視需要建立的非同步 I/O 執行緒最小數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-401">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-402">在切換至管理執行緒建立和解構的演算法之前，設定執行緒集區隨著提出新要求，視需要建立的執行緒最小數目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-402">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-403">如果變更成功，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-403">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-404">執行緒集區視需要提供新的背景工作執行緒或 I/O 完成執行緒，直到它到達每個類別目錄的最小值。</span><span class="sxs-lookup"><span data-stu-id="209c8-404">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="209c8-405">當到達最小值時，執行緒集區可以建立額外的執行緒，該類別中，或等到部分工作完成。</span><span class="sxs-lookup"><span data-stu-id="209c8-405">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="209c8-406">開頭為[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，執行緒集區建立和終結執行緒，以便最佳化輸送量，而定義為每個時間單位完成的工作數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-406">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="209c8-407">執行緒太少可能無法最有效地利用可用資源，而執行緒太多則可能增加資源爭用的情況。</span><span class="sxs-lookup"><span data-stu-id="209c8-407">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="209c8-408">當需求很低時，執行緒集區執行緒的實際數目可能低於最小值。</span><span class="sxs-lookup"><span data-stu-id="209c8-408">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="209c8-409">如果您指定為負數或大於的使用中執行緒集區執行緒的數目上限的數字 (使用取得<xref:System.Threading.ThreadPool.GetMaxThreads%2A>)，<xref:System.Threading.ThreadPool.SetMinThreads%2A>傳回`false`並不會變更其中一個最小值。</span><span class="sxs-lookup"><span data-stu-id="209c8-409">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="209c8-410">根據預設，執行緒的數目下限設為在系統上的處理器數目。</span><span class="sxs-lookup"><span data-stu-id="209c8-410">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="209c8-411">您可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法，以增加最低的數字 ofthreads。</span><span class="sxs-lookup"><span data-stu-id="209c8-411">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="209c8-412">不過，不必要地增加這些值，可能會造成效能問題。</span><span class="sxs-lookup"><span data-stu-id="209c8-412">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="209c8-413">如果太多工作同時啟動，則所有工作可能都會變慢。</span><span class="sxs-lookup"><span data-stu-id="209c8-413">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="209c8-414">在大部分情況下，執行緒集區會比較好使用它自己的演算法來配置執行緒。</span><span class="sxs-lookup"><span data-stu-id="209c8-414">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="209c8-415">減少到小於處理器數目也會降低效能的最小值。</span><span class="sxs-lookup"><span data-stu-id="209c8-415">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="209c8-416">下列範例會設定背景工作執行緒的數目下限為 4，並保留原始值的非同步 I/O 完成執行緒的數目下限。</span><span class="sxs-lookup"><span data-stu-id="209c8-416">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="209c8-417">提供控制執行緒的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-417">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="209c8-418">權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-418">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">
          <span data-ttu-id="209c8-419">要排入佇列的 <see cref="T:System.Threading.NativeOverlapped" /> 結構。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-419">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-420">將重疊的 I/O 作業排入佇列，以等候執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-420">Queues an overlapped I/O operation for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-421">如果這項作業已成功排入 I/O 完成連接埠的佇列，則為 <see langword="true" />；否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-421">
              <see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-422">如需有關使用原生 Win32 資訊重疊的 I/O，請參閱 <<c0> <xref:System.Threading.Overlapped> 類別，<xref:System.Threading.NativeOverlapped>結構，而`OVERLAPPED`Win32 平台 SDK 中的結構。</span><span class="sxs-lookup"><span data-stu-id="209c8-422">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="209c8-423">使用<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>方法可能會不慎開啟造成安全性漏洞。</span><span class="sxs-lookup"><span data-stu-id="209c8-423">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="209c8-424">程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。</span><span class="sxs-lookup"><span data-stu-id="209c8-424">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="209c8-425">工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>，執行緒集區執行緒的堆疊並沒有實際的呼叫端的內容。</span><span class="sxs-lookup"><span data-stu-id="209c8-425">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="209c8-426">惡意程式碼可能可以利用此選項可避免權限檢查。</span><span class="sxs-lookup"><span data-stu-id="209c8-426">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="209c8-427">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-427">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="209c8-428">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-428">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="209c8-429">
            <see cref="T:System.Threading.WaitCallback" />，代表當執行緒集區中的執行緒選取工作項目時，要叫用的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-429">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="209c8-430">接受執行緒集區的服務時，傳遞給委派的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-430">The object that is passed to the delegate when serviced from the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-431">將指定的委派排入執行緒集區的佇列，但不會將呼叫堆疊傳播至背景工作執行緒。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-431">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-432">如果方法成功，則為 <see langword="true" />；如果無法將工作項目排入佇列，則會擲回 <see cref="T:System.OutOfMemoryException" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-432">
              <see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-433">不同於<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法，<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>不會傳播至背景工作執行緒的呼叫堆疊。</span><span class="sxs-lookup"><span data-stu-id="209c8-433">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="209c8-434">這可讓程式碼會遺失呼叫堆疊，因此提高其安全性特殊權限。</span><span class="sxs-lookup"><span data-stu-id="209c8-434">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="209c8-435">使用<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>造成安全性漏洞可能會不慎開啟。</span><span class="sxs-lookup"><span data-stu-id="209c8-435">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="209c8-436">程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。</span><span class="sxs-lookup"><span data-stu-id="209c8-436">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="209c8-437">工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。</span><span class="sxs-lookup"><span data-stu-id="209c8-437">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="209c8-438">惡意程式碼可能可以利用此選項可避免權限檢查。</span><span class="sxs-lookup"><span data-stu-id="209c8-438">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="209c8-439">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-439">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="209c8-440">發生了記憶體不足的狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-440">An out-of-memory condition was encountered.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="209c8-441">無法將此工作項目排入佇列中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-441">The work item could not be queued.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="209c8-442">
            <paramref name="callBack" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-442">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="209c8-443">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-443">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="209c8-444">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-444">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="209c8-445">註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派，但不會將呼叫堆疊傳播至背景工作執行緒。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-445">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="209c8-446">要註冊的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-446">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="209c8-447">使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-447">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="209c8-448">通知 <c>waitObject</c> 參數時要呼叫的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-448">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="209c8-449">傳遞至委派的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-449">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="209c8-450">逾時以毫秒為單位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-450">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="209c8-451">如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-451">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="209c8-452">如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-452">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="209c8-453">
            <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-453">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-454">使用 32 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-454">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="209c8-455">這個方法不會將呼叫堆疊傳播至背景工作執行緒。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-455">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-456">可用來取消已註冊之等候作業的 <see cref="T:System.Threading.RegisteredWaitHandle" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-456">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-457">不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不會傳播至背景工作執行緒的呼叫堆疊。</span><span class="sxs-lookup"><span data-stu-id="209c8-457">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="209c8-458">這可讓程式碼會遺失呼叫堆疊，因此提高其安全性特殊權限。</span><span class="sxs-lookup"><span data-stu-id="209c8-458">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="209c8-459">使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>造成安全性漏洞可能會不慎開啟。</span><span class="sxs-lookup"><span data-stu-id="209c8-459">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="209c8-460">程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。</span><span class="sxs-lookup"><span data-stu-id="209c8-460">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="209c8-461">工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。</span><span class="sxs-lookup"><span data-stu-id="209c8-461">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="209c8-462">惡意程式碼可能可以利用此選項可避免權限檢查。</span><span class="sxs-lookup"><span data-stu-id="209c8-462">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="209c8-463">使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。</span><span class="sxs-lookup"><span data-stu-id="209c8-463">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="209c8-464">完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。</span><span class="sxs-lookup"><span data-stu-id="209c8-464">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="209c8-465">我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="209c8-465">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="209c8-466">記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。</span><span class="sxs-lookup"><span data-stu-id="209c8-466">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="209c8-467">
            <paramref name="millisecondsTimeOutInterval" /> 參數小於 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-467">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="209c8-468">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-468">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="209c8-469">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-469">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="209c8-470">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-470">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="209c8-471">要註冊的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-471">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="209c8-472">使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-472">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="209c8-473">通知 <c>waitObject</c> 參數時要呼叫的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-473">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="209c8-474">傳遞至委派的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-474">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="209c8-475">逾時以毫秒為單位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-475">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="209c8-476">如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-476">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="209c8-477">如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-477">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="209c8-478">
            <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-478">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-479">指定 64 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-479">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="209c8-480">這個方法不會將呼叫堆疊傳播至背景工作執行緒。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-480">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-481">可用來取消已註冊之等候作業的 <see cref="T:System.Threading.RegisteredWaitHandle" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-481">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-482">不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不會傳播至背景工作執行緒的呼叫堆疊。</span><span class="sxs-lookup"><span data-stu-id="209c8-482">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="209c8-483">這可讓程式碼會遺失呼叫堆疊，因此提高其安全性特殊權限。</span><span class="sxs-lookup"><span data-stu-id="209c8-483">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="209c8-484">使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>造成安全性漏洞可能會不慎開啟。</span><span class="sxs-lookup"><span data-stu-id="209c8-484">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="209c8-485">程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。</span><span class="sxs-lookup"><span data-stu-id="209c8-485">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="209c8-486">工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。</span><span class="sxs-lookup"><span data-stu-id="209c8-486">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="209c8-487">惡意程式碼可能可以利用此選項可避免權限檢查。</span><span class="sxs-lookup"><span data-stu-id="209c8-487">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="209c8-488">使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。</span><span class="sxs-lookup"><span data-stu-id="209c8-488">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="209c8-489">完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。</span><span class="sxs-lookup"><span data-stu-id="209c8-489">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="209c8-490">我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="209c8-490">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="209c8-491">記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。</span><span class="sxs-lookup"><span data-stu-id="209c8-491">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="209c8-492">
            <paramref name="millisecondsTimeOutInterval" /> 參數小於 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-492">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="209c8-493">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-493">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="209c8-494">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-494">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="209c8-495">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-495">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="209c8-496">要註冊的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-496">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="209c8-497">使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-497">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="209c8-498">通知 <c>waitObject</c> 參數時要呼叫的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-498">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="209c8-499">傳遞至委派的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-499">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="209c8-500">以 <see cref="T:System.TimeSpan" /> 表示的逾時值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-500">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="209c8-501">如果 <c>timeout</c> 為 0 (零)，則函式會測試物件的狀態並立即傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-501">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="209c8-502">如果 <c>timeout</c> 為 -1，則絕對不會耗用函式的逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-502">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="209c8-503">
            <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-503">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-504">指定 <see cref="T:System.TimeSpan" /> 值表示逾時值，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。這個方法不會將呼叫堆疊傳播至背景工作執行緒。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-504">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-505">可用來取消已註冊之等候作業的 <see cref="T:System.Threading.RegisteredWaitHandle" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-505">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-506">不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不會傳播至背景工作執行緒的呼叫堆疊。</span><span class="sxs-lookup"><span data-stu-id="209c8-506">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="209c8-507">這可讓程式碼會遺失呼叫堆疊，因此提高其安全性特殊權限。</span><span class="sxs-lookup"><span data-stu-id="209c8-507">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="209c8-508">使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>造成安全性漏洞可能會不慎開啟。</span><span class="sxs-lookup"><span data-stu-id="209c8-508">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="209c8-509">程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。</span><span class="sxs-lookup"><span data-stu-id="209c8-509">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="209c8-510">工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。</span><span class="sxs-lookup"><span data-stu-id="209c8-510">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="209c8-511">惡意程式碼可能可以利用此選項可避免權限檢查。</span><span class="sxs-lookup"><span data-stu-id="209c8-511">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="209c8-512">使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。</span><span class="sxs-lookup"><span data-stu-id="209c8-512">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="209c8-513">完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。</span><span class="sxs-lookup"><span data-stu-id="209c8-513">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="209c8-514">我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="209c8-514">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="209c8-515">記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。</span><span class="sxs-lookup"><span data-stu-id="209c8-515">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="209c8-516">
            <paramref name="timeout" /> 參數小於 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-516">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="209c8-517">
            <paramref name="timeout" /> 參數大於 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-517">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="209c8-518">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-518">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="209c8-519">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-519">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="209c8-520">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-520">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="209c8-521">要註冊的 <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-521">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="209c8-522">使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-522">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="209c8-523">通知 <c>waitObject</c> 參數時要呼叫的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-523">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="209c8-524">傳遞至委派的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-524">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="209c8-525">逾時以毫秒為單位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-525">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="209c8-526">如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-526">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="209c8-527">如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-527">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="209c8-528">
            <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-528">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="209c8-529">指定 32 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-529">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="209c8-530">這個方法不會將呼叫堆疊傳播至背景工作執行緒。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-530">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="209c8-531">可用來取消已註冊之等候作業的 <see cref="T:System.Threading.RegisteredWaitHandle" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-531">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="209c8-532">不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不會傳播至背景工作執行緒的呼叫堆疊。</span><span class="sxs-lookup"><span data-stu-id="209c8-532">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="209c8-533">這可讓程式碼會遺失呼叫堆疊，因此提高其安全性特殊權限。</span><span class="sxs-lookup"><span data-stu-id="209c8-533">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="209c8-534">使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>造成安全性漏洞可能會不慎開啟。</span><span class="sxs-lookup"><span data-stu-id="209c8-534">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="209c8-535">程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。</span><span class="sxs-lookup"><span data-stu-id="209c8-535">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="209c8-536">工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。</span><span class="sxs-lookup"><span data-stu-id="209c8-536">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="209c8-537">惡意程式碼可能可以利用此選項可避免權限檢查。</span><span class="sxs-lookup"><span data-stu-id="209c8-537">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="209c8-538">使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。</span><span class="sxs-lookup"><span data-stu-id="209c8-538">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="209c8-539">完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。</span><span class="sxs-lookup"><span data-stu-id="209c8-539">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="209c8-540">我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。</span><span class="sxs-lookup"><span data-stu-id="209c8-540">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="209c8-541">記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。</span><span class="sxs-lookup"><span data-stu-id="209c8-541">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="209c8-542">呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-542">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="209c8-543">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-543">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="209c8-544">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="209c8-544">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>