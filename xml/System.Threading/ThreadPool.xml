<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a3111b9d3890e99871797d80fe33a669a253dba6" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39851171" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供執行緒的集區，可用來執行工作、張貼工作項目、處理非同步 I/O、代表其他執行緒等候，以及處理計時器。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 許多應用程式建立花太多的時間處於睡眠狀態，等候事件發生的執行緒。 其他執行緒可能會進入休眠狀態後才能定期喚醒來輪詢有變更或更新的狀態資訊。 執行緒集區可讓您更有效率地使用藉由提供您的應用程式的系統所管理的背景工作執行緒集區的執行緒。 使用執行緒集區作業的範例包括下列各項：  
  
-   當您建立<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>以非同步方式執行一些工作，根據預設，執行緒集區執行緒上執行排程工作的物件。  
  
-   非同步的計時器會使用執行緒集區。 執行緒集區執行緒執行回呼<xref:System.Threading.Timer?displayProperty=nameWithType>類別，並引發事件<xref:System.Timers.Timer?displayProperty=nameWithType>類別。  
  
-   當您使用已註冊的等候控制代碼時，則系統執行緒會監視在等候控制代碼的狀態。 等候作業完成時，執行緒集區的背景工作執行緒會執行對應的回呼函式。  
  
-   當您呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>排入佇列的方法，以便在執行緒集區執行緒上執行的方法。 您可以傳遞給方法<xref:System.Threading.WaitCallback>委派。   委派的簽章  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     其中`state`是物件，包含由委派所要使用的資料。 實際的資料可以傳遞至委派，藉由呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>方法。  
  
> [!NOTE]
>  Managed 的執行緒集區中的執行緒為背景執行緒。 也就是他們<xref:System.Threading.Thread.IsBackground%2A>屬性是`true`。 這表示<xref:System.Threading.ThreadPool>執行緒不會持續執行的所有前景執行緒都結束後的應用程式。  
  
> [!IMPORTANT]
>  當執行緒集區會重複使用的執行緒時，它不會清除執行緒區域儲存區中，或標示的欄位中的資料<xref:System.ThreadStaticAttribute>屬性。 因此，當方法會檢查執行緒區域儲存區，或欄位，會標示<xref:System.ThreadStaticAttribute>屬性，它找到的值可能剩餘的執行緒集區執行緒的先前版本會使用。  
  
 您也可以將佇列的執行緒集區以等候作業無關的工作項目。 若要要求工作項目由執行緒集區中的執行緒，呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。 此方法會採用做為參數的方法或將會從執行緒集區中選取的執行緒所呼叫的委派的參考。 沒有任何方法可取消的工作項目之後已加入佇列。  
  
 計時器佇列中的計時器和已註冊之等候作業也會使用執行緒集區。 它們的回呼函式會排入執行緒集區。  
  
 沒有每個處理序的一個執行緒集區。 從 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 開始，處理序的執行緒集區預設大小取決於數個因素，例如虛擬位址空間的大小。 處理序可以呼叫 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 方法來決定執行緒數目。 可以使用變更的執行緒集區中的執行緒數目<xref:System.Threading.ThreadPool.SetMaxThreads%2A>方法。 每個執行緒會使用預設堆疊大小，並在預設的優先權執行。  
  
> [!NOTE]
>  裝載.NET Framework 的 unmanaged 程式碼可以使用變更的執行緒集區大小`CorSetMaxThreads`函式，定義於 mscoree.h 檔案。  
  
 執行緒集區視需要提供新的背景工作執行緒或 I/O 完成執行緒，直到它到達每個類別目錄的最小值。 當到達最小值時，執行緒集區可以建立額外的執行緒，該類別中，或等到部分工作完成。 從 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 開始，執行緒集區會建立並終結背景工作執行緒，以便最佳化輸送量，輸送量的定義為每個時間單位完成的工作數目。 執行緒太少可能無法最有效地利用可用資源，而執行緒太多則可能增加資源爭用的情況。  
  
> [!NOTE]
>  當需求很低時，執行緒集區執行緒的實際數目可能低於最小值。  
  
 您可以使用 <xref:System.Threading.ThreadPool.GetMinThreads%2A> 方法取得這些最小值。  
  
> [!CAUTION]
>  您可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法，以增加最低的執行緒數目。 不過，不必要地增加這些值，可能會造成效能問題。 如果太多工作同時啟動，則所有工作可能都會變慢。 在大部分情況下，執行緒集區使用自己的演算法來配置執行緒的效能較佳。  
  
   
  
## Examples  
 在下列範例中，主應用程式執行緒方法排入佇列名為`ThreadProc`執行緒集區執行緒，而會休眠一秒，，然後結束上執行。 `ThreadProc`方法只會顯示一則訊息。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 如果您註解的呼叫<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法中，主執行緒結束的執行緒集區執行緒上的方法執行之前。  執行緒集區會使用背景執行緒，不讓應用程式順利執行中的所有前景執行緒已經都終止。  （這是簡單的範例，競爭條件）。  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>可將作業系統的控制代碼繫結至 <see cref="T:System.Threading.ThreadPool" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">持有控制代碼的 <see cref="T:System.IntPtr" />。 控制代碼必須已經對 Unmanaged 側的重疊 I/O 開啟。</param>
        <summary>可將作業系統的控制代碼繫結至 <see cref="T:System.Threading.ThreadPool" />。</summary>
        <returns>如果控制代碼已繫結，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供呼叫 unmanaged 程式碼的能力。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <see cref="T:System.Runtime.InteropServices.SafeHandle" />，包含作業系統控制代碼。 控制代碼必須已經對 Unmanaged 側的重疊 I/O 開啟。</param>
        <summary>可將作業系統的控制代碼繫結至 <see cref="T:System.Threading.ThreadPool" />。</summary>
        <returns>如果控制代碼已繫結，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `osHandle`參數應該<xref:Microsoft.Win32.SafeHandles.SafeFileHandle>，其衍生自抽象<xref:System.Runtime.InteropServices.SafeHandle>類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="osHandle" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供呼叫 unmanaged 程式碼的能力。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">可用背景工作執行緒的數目。</param>
        <param name="completionPortThreads">可用非同步 I/O 執行緒的數目。</param>
        <summary>擷取 <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> 方法所傳回之執行緒集區的執行緒最大數目，與目前作用中數目之間的差異。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>會傳回指定的變數`workerThreads`含有額外的背景工作執行緒可以啟動，且指定的變數`completionPortThreads`包含其他可能的非同步 I/O 執行緒的數目已啟動。  
  
 如果沒有可用的執行緒，額外的執行緒集區要求保留已排入佇列直到執行緒集區執行緒變成可用。  
  
   
  
## Examples  
 簡單的應用程式啟動時，下列範例會顯示背景工作執行緒和可用的 I/O 執行緒的數目。  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">執行緒集區中的背景工作執行緒最大數目。</param>
        <param name="completionPortThreads">執行緒集區中的非同步 I/O 執行緒最大數目。</param>
        <summary>擷取可並行使用之執行緒集區的要求數目。 超過該數目的所有要求會繼續佇列，直到可以使用執行緒集區執行緒為止。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.Threading.ThreadPool.GetMaxThreads%2A>會傳回指定的變數`workerThreads`包含允許執行緒集區中的背景工作執行緒和變數所指定的最大數目`completionPortThreads`包含中允許的非同步 I/O 執行緒最大數目執行緒集區。  
  
 您可以使用<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>方法，以判斷在任何指定時間的實際的執行緒集區中的執行緒數目。  
  
 您可以使用<xref:System.Threading.ThreadPool.SetMaxThreads%2A>設定執行緒集區中的背景工作執行緒和非同步 I/O 執行緒的最大數目。  
  
 您可以在無數個執行緒集區的要求，因為系統記憶體可讓佇列。 如果有更多的要求，超過的執行緒集區，其他要求會繼續已排入佇列，直到執行緒集區執行緒變成可用為止。  
  
   
  
## Examples  
 下列程式碼範例示範如何擷取最大和可用的執行緒集區中的執行緒數目的計數。 工作項目會排入佇列，會使用`FileStream`以非同步方式寫入兩個檔案。 回呼方法的計時重疊。 背景工作執行緒處理的工作項目，並根據速度和電腦上的處理器數目，一或兩個完成連接埠執行緒處理 「 寫入 」 操作。  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">當這個方法傳回時，會包含執行緒集區視需要建立的背景工作執行緒最小數目。</param>
        <param name="completionPortThreads">當這個方法傳回時，會包含執行緒集區視需要建立的非同步 I/O 執行緒最小數目。</param>
        <summary>在切換至管理執行緒建立和解構的演算法之前，擷取執行緒集區隨著提出新要求，視需要建立的執行緒最小數目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒集區視需要提供新的背景工作執行緒或 I/O 完成執行緒，直到它到達每個類別目錄的最小值。 根據預設，執行緒的數目下限設為在系統上的處理器數目。 當到達最小值時，執行緒集區可以建立額外的執行緒，該類別中，或等到部分工作完成。 開頭為[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，執行緒集區建立和終結執行緒，以便最佳化輸送量，而定義為每個時間單位完成的工作數目。 執行緒太少可能無法最有效地利用可用資源，而執行緒太多則可能增加資源爭用的情況。  
  
> [!NOTE]
>  當需求很低時，執行緒集區執行緒的實際數目可能低於最小值。  
  
   
  
## Examples  
 下列範例會設定背景工作執行緒的數目下限為 4，並保留原始值的非同步 I/O 完成執行緒的數目下限。  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將方法排入佇列，以等候執行。 可以使用執行緒集區執行緒時，即可執行這個方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <see cref="T:System.Threading.WaitCallback" />，代表要執行的方法。</param>
        <summary>將方法排入佇列，以等候執行。 可以使用執行緒集區執行緒時，即可執行這個方法。</summary>
        <returns>如果方法成功佇列則為 <see langword="true" />；如果工作項目無法佇列則會擲回 <see cref="T:System.NotSupportedException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以將已排入佇列的方法，在方法定義，或您可以使用此類別的執行個體欄位中所需的資料<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>多載會接受物件，其中包含必要的資料。  
  
> [!NOTE]
>  Visual Basic 使用者可以省略<xref:System.Threading.WaitCallback>建構函式，並只使用`AddressOf`運算子傳遞至回呼方法時<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。 Visual Basic 會自動呼叫正確的委派建構函式。  
  
## <a name="version-information"></a>版本資訊  
 在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。 在舊版中，主體的資訊不會傳播。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29>方法多載來工作排入佇列，這由`ThreadProc`方法，讓執行緒變成可用時執行。 沒有工作資訊會提供使用這個多載。 因此，若要使用的資訊`ThreadProc`方法僅限於方法所屬的物件。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">Common Language Runtime (CLR) 已裝載，而且主機不支援這個動作。</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <see cref="T:System.Threading.WaitCallback" />，代表要執行的方法。</param>
        <param name="state">物件，包含這個方法所要使用的資料。</param>
        <summary>將方法排入佇列，以等候執行，並指定包含這個方法所要使用之資料的物件。 可以使用執行緒集區執行緒時，即可執行這個方法。</summary>
        <returns>如果方法成功佇列則為 <see langword="true" />；如果工作項目無法佇列則會擲回 <see cref="T:System.NotSupportedException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果回呼方法需要複雜的資料，您可以定義包含資料的類別。  
  
> [!NOTE]
>  Visual Basic 使用者可以省略<xref:System.Threading.WaitCallback>建構函式，並只使用`AddressOf`運算子傳遞至回呼方法時<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。 Visual Basic 會自動呼叫正確的委派建構函式。  
  
## <a name="version-information"></a>版本資訊  
 在.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。 在舊版中，主體的資訊不會傳播。  
  
   
  
## Examples  
 下列範例會使用.NET 執行緒集區來計算`Fibonacci`五個數字，介於 20 到 40 之間的結果。 每個 `Fibonacci` 結果都會以 `Fibonacci` 類別表示，該類別提供一個執行計算的方法，稱為 `ThreadPoolCallback`。 這會建立代表每個 `Fibonacci` 值的物件，並將 `ThreadPoolCallback` 方法傳遞至 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>，以指派集區中的可用執行緒來執行此方法。  
  
 因為每個`Fibonacci`物件提供半隨機值來計算，以及每個執行緒會競爭處理器時間，因為您不知道事先花多少時間將會計算所有五個結果。 這就是為什麼會在建構期間將每個 `Fibonacci` 物件傳遞至 <xref:System.Threading.ManualResetEvent> 類別的執行個體。 每個物件表示提供的事件物件計算完成時，這可讓使用區塊執行主要執行緒<xref:System.Threading.WaitHandle.WaitAll%2A>直到所有五個`Fibonacci`物件都已計算的結果。 `Main` 方法接著會顯示每個 `Fibonacci` 結果。
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Common Language Runtime (CLR) 已裝載，而且主機不支援這個動作。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>註冊正在等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要註冊的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">通知 <c>waitObject</c> 參數時要呼叫的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委派。</param>
        <param name="state">傳遞至委派的物件。</param>
        <param name="millisecondsTimeOutInterval">逾時以毫秒為單位。 如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。 如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</param>
        <summary>指定 32 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</summary>
        <returns>封裝原生控制代碼的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。 我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。 記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法排入佇列的執行緒集區指定的委派。 當發生下列其中一項時，背景工作執行緒將執行委派：  
  
-   指定的物件處於收到信號的狀態。  
  
-   經過逾時間隔。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法會檢查指定的物件的目前狀態<xref:System.Threading.WaitHandle>。 如果未發出信號狀態的物件，則方法會註冊等候作業。 等候作業是由執行緒集區的執行緒執行。 物件的狀態變成發出訊號，或經過逾時間隔時，背景工作執行緒會執行委派。 如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，計時器會重設，每次事件收到訊號，或經過逾時間隔。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。  
  
 若要取消之等候作業，呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等候執行緒會使用 Win32`WaitForMultipleObjects`函式，以監視已註冊之等候作業。 因此，如果您必須使用相同的原生作業系統控制代碼，以多次呼叫<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。 請注意，您不應該轉盤式事件物件，傳遞至<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因為等待執行緒可能會不會偵測事件收到信號之前重設。  
  
 在傳回之前，此函式會修改某些類型的同步處理物件的狀態。 修改只會發生在其收到信號的狀態造成要滿足等候條件的物件。 比方說，號誌的計數就會減少一個。  
  
## <a name="version-information"></a>版本資訊  
 從.NET Framework 2.0 版中，開始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在舊版中，主體的資訊不會傳播。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 參數小於 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要註冊的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">通知 <c>waitObject</c> 參數時要呼叫的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委派。</param>
        <param name="state">傳送至委派的物件。</param>
        <param name="millisecondsTimeOutInterval">逾時以毫秒為單位。 如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。 如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</param>
        <summary>指定 64 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</summary>
        <returns>封裝原生控制代碼的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。 我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。 記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法排入佇列的執行緒集區指定的委派。 當發生下列其中一項時，背景工作執行緒將執行委派：  
  
-   指定的物件處於收到信號的狀態。  
  
-   經過逾時間隔。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法會檢查指定的物件的目前狀態<xref:System.Threading.WaitHandle>。 如果未發出信號狀態的物件，則方法會註冊等候作業。 等候作業是由執行緒集區的執行緒執行。 物件的狀態變成發出訊號，或經過逾時間隔時，背景工作執行緒會執行委派。 如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，計時器會重設，每次事件收到訊號，或經過逾時間隔。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。  
  
 若要取消之等候作業，呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等候執行緒會使用 Win32`WaitForMultipleObjects`函式，以監視已註冊之等候作業。 因此，如果您必須使用相同的原生作業系統控制代碼，以多次呼叫<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。 請注意，您不應該轉盤式事件物件，傳遞至<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因為等待執行緒可能會不會偵測事件收到信號之前重設。  
  
 在傳回之前，此函式會修改某些類型的同步處理物件的狀態。 修改只會發生在其收到信號的狀態造成要滿足等候條件的物件。 比方說，號誌的計數就會減少一個。  
  
## <a name="version-information"></a>版本資訊  
 從.NET Framework 2.0 版中，開始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在舊版中，主體的資訊不會傳播。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 參數小於 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要註冊的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">通知 <c>waitObject</c> 參數時要呼叫的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委派。</param>
        <param name="state">傳送至委派的物件。</param>
        <param name="timeout">以 <see cref="T:System.TimeSpan" /> 表示的逾時值。 如果 <c>timeout</c> 為 0 (零)，則函式會測試物件的狀態並立即傳回。 如果 <c>timeout</c> 為 -1，則絕對不會耗用函式的逾時間隔。</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</param>
        <summary>指定 <see cref="T:System.TimeSpan" /> 值表示逾時值，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</summary>
        <returns>封裝原生控制代碼的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。 我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。 記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法排入佇列的執行緒集區指定的委派。 當發生下列其中一項時，背景工作執行緒將執行委派：  
  
-   指定的物件處於收到信號的狀態。  
  
-   經過逾時間隔。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法會檢查指定的物件的目前狀態<xref:System.Threading.WaitHandle>。 如果未發出信號狀態的物件，則方法會註冊等候作業。 等候作業是由執行緒集區的執行緒執行。 物件的狀態變成發出訊號，或經過逾時間隔時，背景工作執行緒會執行委派。 如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，計時器會重設，每次事件收到訊號，或經過逾時間隔。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。  
  
 若要取消之等候作業，呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等候執行緒會使用 Win32`WaitForMultipleObjects`函式，以監視已註冊之等候作業。 因此，如果您必須使用相同的原生作業系統控制代碼，以多次呼叫<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。 請注意，您不應該轉盤式事件物件，傳遞至<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因為等待執行緒可能會不會偵測事件收到信號之前重設。  
  
 在傳回之前，此函式會修改某些類型的同步處理物件的狀態。 修改只會發生在其收到信號的狀態造成要滿足等候條件的物件。 比方說，號誌的計數就會減少一個。  
  
## <a name="version-information"></a>版本資訊  
 從.NET Framework 2.0 版中，開始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在舊版中，主體的資訊不會傳播。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 參數小於 -1。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="timeout" /> 參數大於 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要註冊的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">通知 <c>waitObject</c> 參數時要呼叫的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委派。</param>
        <param name="state">傳送至委派的物件。</param>
        <param name="millisecondsTimeOutInterval">逾時以毫秒為單位。 如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。 如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</param>
        <summary>指定 32 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。</summary>
        <returns>可用來取消已註冊之等候作業的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。 我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。 記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法排入佇列的執行緒集區指定的委派。 當發生下列其中一項時，背景工作執行緒將執行委派：  
  
-   指定的物件處於收到信號的狀態。  
  
-   經過逾時間隔。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法會檢查指定的物件的目前狀態<xref:System.Threading.WaitHandle>。 如果未發出信號狀態的物件，則方法會註冊等候作業。 等候作業是由執行緒集區的執行緒執行。 物件的狀態變成發出訊號，或經過逾時間隔時，背景工作執行緒會執行委派。 如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，計時器會重設，每次事件收到訊號，或經過逾時間隔。  
  
> [!IMPORTANT]
>  使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。  
  
 若要取消之等候作業，呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等候執行緒會使用 Win32`WaitForMultipleObjects`函式，以監視已註冊之等候作業。 因此，如果您必須使用相同的原生作業系統控制代碼，以多次呼叫<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。 請注意，您不應該轉盤式事件物件，傳遞至<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因為等待執行緒可能會不會偵測事件收到信號之前重設。  
  
 在傳回之前，此函式會修改某些類型的同步處理物件的狀態。 修改只會發生在其收到信號的狀態造成要滿足等候條件的物件。 比方說，號誌的計數就會減少一個。  
  
## <a name="version-information"></a>版本資訊  
 從.NET Framework 2.0 版中，開始<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>屬性值會傳播至背景工作執行緒已排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。 在舊版中，主體的資訊不會傳播。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法來指定的等候控制代碼會收到信號時，執行指定的回呼方法。 在此範例中，是回呼方法`WaitProc`，並等候控制代碼是<xref:System.Threading.AutoResetEvent>。  
  
 此範例會定義`TaskInfo`類別來保存執行時傳遞至回呼的資訊。 此範例會建立`TaskInfo`物件，並將其指派一些字串資料。 <xref:System.Threading.RegisteredWaitHandle>傳回的<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法指派給`Handle`欄位`TaskInfo`物件，使回呼方法可以存取<xref:System.Threading.RegisteredWaitHandle>。  
  
 除了指定`TaskInfo`做為要傳遞至回呼方法的呼叫物件<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法會指定<xref:System.Threading.AutoResetEvent>等候工作，<xref:System.Threading.WaitOrTimerCallback>委派，表示`WaitProc`回呼方法一秒的逾時間隔，以及多個回呼。  
  
 當主執行緒發出信號<xref:System.Threading.AutoResetEvent>藉由呼叫其<xref:System.Threading.EventWaitHandle.Set%2A>方法，<xref:System.Threading.WaitOrTimerCallback>叫用委派。 `WaitProc`方法會測試<xref:System.Threading.RegisteredWaitHandle>來判斷是否發生逾時。 如果等候控制代碼發出訊號，因為叫用回呼`WaitProc`方法會移除註冊<xref:System.Threading.RegisteredWaitHandle>，停止其他回呼。 在逾時，工作會繼續等候。 `WaitProc`方法結束列印至主控台的訊息。  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 參數小於 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">執行緒集區中的背景工作執行緒最大數目。</param>
        <param name="completionPortThreads">執行緒集區中的非同步 I/O 執行緒最大數目。</param>
        <summary>設定可並行使用之執行緒集區的要求數目。 超過該數目的所有要求會繼續佇列，直到可以使用執行緒集區執行緒為止。</summary>
        <returns>如果變更成功，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您無法設定背景工作執行緒或 I/O 完成執行緒的最大數目的數字小於電腦上的處理器數目。 若要判斷有多少個處理器，擷取的值<xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType>屬性。 此外，您無法設定背景工作執行緒或 I/O 完成執行緒的數字小於對應的最小數目的背景工作執行緒或 I/O 完成執行緒的最大數目。 若要判斷最小執行緒集區大小，請呼叫<xref:System.Threading.ThreadPool.GetMinThreads%2A>方法。  
  
 如果裝載通用語言執行平台，例如藉由 Internet Information Services (IIS) 或 SQL Server 中，主機可以限制或阻止變更執行緒集區大小。  
  
 變更執行緒集區中的執行緒數目上限時，請務必小心。 雖然您的程式碼可能會因此而受益，所做的變更可能造成負面影響您使用的程式碼程式庫。  
  
 設定執行緒集區大小太大，可能會造成效能問題。 如果太多的執行緒正在同時執行，工作切換額外負荷會變成重大的因素。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供控制執行緒的能力。 權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">執行緒集區視需要建立的背景工作執行緒最小數目。</param>
        <param name="completionPortThreads">執行緒集區視需要建立的非同步 I/O 執行緒最小數目。</param>
        <summary>在切換至管理執行緒建立和解構的演算法之前，設定執行緒集區隨著提出新要求，視需要建立的執行緒最小數目。</summary>
        <returns>如果變更成功，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒集區視需要提供新的背景工作執行緒或 I/O 完成執行緒，直到它到達每個類別目錄的最小值。 當到達最小值時，執行緒集區可以建立額外的執行緒，該類別中，或等到部分工作完成。 開頭為[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，執行緒集區建立和終結執行緒，以便最佳化輸送量，而定義為每個時間單位完成的工作數目。 執行緒太少可能無法最有效地利用可用資源，而執行緒太多則可能增加資源爭用的情況。  
  
 當需求很低時，執行緒集區執行緒的實際數目可能低於最小值。  
  
 如果您指定為負數或大於的使用中執行緒集區執行緒的數目上限的數字 (使用取得<xref:System.Threading.ThreadPool.GetMaxThreads%2A>)，<xref:System.Threading.ThreadPool.SetMinThreads%2A>傳回`false`並不會變更其中一個最小值。  
  
> [!CAUTION]
>  根據預設，執行緒的數目下限設為在系統上的處理器數目。 您可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法，以增加最低的數字 ofthreads。 不過，不必要地增加這些值，可能會造成效能問題。 如果太多工作同時啟動，則所有工作可能都會變慢。 在大部分情況下，執行緒集區會比較好使用它自己的演算法來配置執行緒。 減少到小於處理器數目也會降低效能的最小值。  
  
   
  
## Examples  
 下列範例會設定背景工作執行緒的數目下限為 4，並保留原始值的非同步 I/O 完成執行緒的數目下限。  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供控制執行緒的能力。 權限的值： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">要排入佇列的 <see cref="T:System.Threading.NativeOverlapped" /> 結構。</param>
        <summary>將重疊的 I/O 作業排入佇列，以等候執行。</summary>
        <returns>如果這項作業已成功排入 I/O 完成連接埠的佇列，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需有關使用原生 Win32 資訊重疊的 I/O，請參閱 <<c0> <xref:System.Threading.Overlapped> 類別，<xref:System.Threading.NativeOverlapped>結構，而`OVERLAPPED`Win32 平台 SDK 中的結構。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>方法可能會不慎開啟造成安全性漏洞。 程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。 工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>，執行緒集區執行緒的堆疊並沒有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <see cref="T:System.Threading.WaitCallback" />，代表當執行緒集區中的執行緒選取工作項目時，要叫用的委派。</param>
        <param name="state">接受執行緒集區的服務時，傳遞給委派的物件。</param>
        <summary>將指定的委派排入執行緒集區的佇列，但不會將呼叫堆疊傳播至背景工作執行緒。</summary>
        <returns>如果方法成功，則為 <see langword="true" />；如果無法將工作項目排入佇列，則會擲回 <see cref="T:System.OutOfMemoryException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法，<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>不會傳播至背景工作執行緒的呼叫堆疊。 這可讓程式碼會遺失呼叫堆疊，因此提高其安全性特殊權限。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>造成安全性漏洞可能會不慎開啟。 程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。 工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ApplicationException">發生了記憶體不足的狀況。</exception>
        <exception cref="T:System.OutOfMemoryException">無法將此工作項目排入佇列中。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> 為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派，但不會將呼叫堆疊傳播至背景工作執行緒。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要註冊的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">通知 <c>waitObject</c> 參數時要呼叫的委派。</param>
        <param name="state">傳遞至委派的物件。</param>
        <param name="millisecondsTimeOutInterval">逾時以毫秒為單位。 如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。 如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</param>
        <summary>使用 32 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。 這個方法不會將呼叫堆疊傳播至背景工作執行緒。</summary>
        <returns>可用來取消已註冊之等候作業的 <see cref="T:System.Threading.RegisteredWaitHandle" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不會傳播至背景工作執行緒的呼叫堆疊。 這可讓程式碼會遺失呼叫堆疊，因此提高其安全性特殊權限。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>造成安全性漏洞可能會不慎開啟。 程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。 工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。  
  
 使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。  
  
 完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。 我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。 記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 參數小於 -1。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要註冊的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">通知 <c>waitObject</c> 參數時要呼叫的委派。</param>
        <param name="state">傳遞至委派的物件。</param>
        <param name="millisecondsTimeOutInterval">逾時以毫秒為單位。 如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。 如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</param>
        <summary>指定 64 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。 這個方法不會將呼叫堆疊傳播至背景工作執行緒。</summary>
        <returns>可用來取消已註冊之等候作業的 <see cref="T:System.Threading.RegisteredWaitHandle" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不會傳播至背景工作執行緒的呼叫堆疊。 這可讓程式碼會遺失呼叫堆疊，因此提高其安全性特殊權限。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>造成安全性漏洞可能會不慎開啟。 程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。 工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。  
  
 使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。  
  
 完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。 我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。 記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeOutInterval" /> 參數小於 -1。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要註冊的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">通知 <c>waitObject</c> 參數時要呼叫的委派。</param>
        <param name="state">傳遞至委派的物件。</param>
        <param name="timeout">以 <see cref="T:System.TimeSpan" /> 表示的逾時值。 如果 <c>timeout</c> 為 0 (零)，則函式會測試物件的狀態並立即傳回。 如果 <c>timeout</c> 為 -1，則絕對不會耗用函式的逾時間隔。</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</param>
        <summary>指定 <see cref="T:System.TimeSpan" /> 值表示逾時值，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。這個方法不會將呼叫堆疊傳播至背景工作執行緒。</summary>
        <returns>可用來取消已註冊之等候作業的 <see cref="T:System.Threading.RegisteredWaitHandle" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不會傳播至背景工作執行緒的呼叫堆疊。 這可讓程式碼會遺失呼叫堆疊，因此提高其安全性特殊權限。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>造成安全性漏洞可能會不慎開啟。 程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。 工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。  
  
 使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。  
  
 完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。 我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。 記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 參數小於 -1。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="timeout" /> 參數大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要註冊的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" />，而不要使用 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">通知 <c>waitObject</c> 參數時要呼叫的委派。</param>
        <param name="state">傳遞至委派的物件。</param>
        <param name="millisecondsTimeOutInterval">逾時以毫秒為單位。 如果 <c>millisecondsTimeOutInterval</c> 參數為 0 (零)，函式會測試物件的狀態並立即傳回。 如果 <c>millisecondsTimeOutInterval</c> 為 -1，則絕對不會耗用函式的逾時間隔。</param>
        <param name="executeOnlyOnce">
          <see langword="true" /> 表示在呼叫委派之後，執行緒將不再等候 <c>waitObject</c> 參數；<see langword="false" /> 表示每當等候作業完成即重設計時器，直到移除註冊等候作業為止。</param>
        <summary>指定 32 位元帶正負號的整數表示逾時值 (以毫秒為單位)，藉此註冊要等候 <see cref="T:System.Threading.WaitHandle" /> 的委派。 這個方法不會將呼叫堆疊傳播至背景工作執行緒。</summary>
        <returns>可用來取消已註冊之等候作業的 <see cref="T:System.Threading.RegisteredWaitHandle" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法，<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不會傳播至背景工作執行緒的呼叫堆疊。 這可讓程式碼會遺失呼叫堆疊，因此提高其安全性特殊權限。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>造成安全性漏洞可能會不慎開啟。 程式碼存取安全性基底的使用權限檢查堆疊上的所有呼叫端的權限。 工作執行緒集區執行緒使用的佇列時<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。  
  
 使用<xref:System.Threading.Mutex>for`waitObject`不提供用於回呼的互斥，因為基礎 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，讓每一個回呼會分派另一個執行緒集區執行緒上。  
  
 完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法來釋放等候控制代碼的參考。 我們建議您務必呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，即使您指定`true`如`executeOnlyOnce`。 記憶體回收的運作方式更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法，而非根據已註冊之等候控制代碼的完成項。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
  </Members>
</Type>