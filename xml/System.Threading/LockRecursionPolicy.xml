<Type Name="LockRecursionPolicy" FullName="System.Threading.LockRecursionPolicy">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="95b114e85c2b87b1b63dfc17d45647b87dc6c714" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37548743" />
  </Metadata>
  <TypeSignature Language="C#" Value="public enum LockRecursionPolicy" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed LockRecursionPolicy extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Threading.LockRecursionPolicy" />
  <TypeSignature Language="VB.NET" Value="Public Enum LockRecursionPolicy" />
  <TypeSignature Language="C++ CLI" Value="public enum class LockRecursionPolicy" />
  <TypeSignature Language="F#" Value="type LockRecursionPolicy = " />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>
      <span data-ttu-id="810f7-101">指定相同的執行緒是否可以多次進入鎖定。</span>
      <span class="sxs-lookup">
        <span data-stu-id="810f7-101">Specifies whether a lock can be entered multiple times by the same thread.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="810f7-102">預設的遞迴原則會因鎖定類型而定。</span><span class="sxs-lookup"><span data-stu-id="810f7-102">The default recursion policy depends on the type of lock.</span></span> <span data-ttu-id="810f7-103">預設原則及任何給定的鎖定類型的鎖定遞迴的精確的行為，請參閱文件類型。</span><span class="sxs-lookup"><span data-stu-id="810f7-103">For the default policy and the precise behavior of lock recursion for any given lock type, see the documentation for the type.</span></span> <span data-ttu-id="810f7-104">比方說，<xref:System.Threading.ReaderWriterLockSlim>類別不允許一個執行緒來鎖定進入寫入模式，如果它已經進入鎖定的讀取模式，不論鎖定原則設定，以降低死結的機率。</span><span class="sxs-lookup"><span data-stu-id="810f7-104">For example, the <xref:System.Threading.ReaderWriterLockSlim> class does not allow a thread to enter the lock in write mode if it already entered the lock in read mode, regardless of the lock policy setting, in order to reduce the chance of deadlocks.</span></span>  
  
 <span data-ttu-id="810f7-105">目前只有一個鎖定會使用這個列舉型別：</span><span class="sxs-lookup"><span data-stu-id="810f7-105">Currently only one lock uses this enumeration:</span></span>  
  
-   <span data-ttu-id="810f7-106"><xref:System.Threading.ReaderWriterLockSlim>。</span><span class="sxs-lookup"><span data-stu-id="810f7-106"><xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="810f7-107">如需詳細資訊，請參閱 <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> 屬性 (Property)。</span><span class="sxs-lookup"><span data-stu-id="810f7-107">For more information, see the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="810f7-108">下列範例顯示兩個例外狀況，其中一個，取決於<xref:System.Threading.LockRecursionPolicy>設定，另一個則否。</span><span class="sxs-lookup"><span data-stu-id="810f7-108">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="810f7-109">在第一個案例中，執行緒會進入讀取模式的鎖定，並嘗試遞迴地進入讀取的模式。</span><span class="sxs-lookup"><span data-stu-id="810f7-109">In the first scenario, the thread enters the lock in read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="810f7-110">如果<xref:System.Threading.ReaderWriterLockSlim>建立使用預設建構函式，將 NoRecursion 設為遞迴原則，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="810f7-110">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the default constructor, which sets recursion policy to NoRecursion, an exception is thrown.</span></span> <span data-ttu-id="810f7-111">如果 SupportsRecursion 用來建立<xref:System.Threading.ReaderWriterLockSlim>，會擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="810f7-111">If SupportsRecursion is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="810f7-112">在第二個案例中，執行緒會進入讀取模式的鎖定，並嘗試進入寫入模式的鎖定。</span><span class="sxs-lookup"><span data-stu-id="810f7-112">In the second scenario, the thread enters the lock in read mode and then tries to enter the lock in write mode.</span></span> <span data-ttu-id="810f7-113"><xref:System.Threading.LockRecursionException> 無論鎖定遞迴原則就會擲回。</span><span class="sxs-lookup"><span data-stu-id="810f7-113"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
 [!code-csharp[System.Threading.LockRecursionPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/example1.cs#1)]
 [!code-vb[System.Threading.LockRecursionPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="NoRecursion">
      <MemberSignature Language="C#" Value="NoRecursion" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.LockRecursionPolicy NoRecursion = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.LockRecursionPolicy.NoRecursion" />
      <MemberSignature Language="VB.NET" Value="NoRecursion" />
      <MemberSignature Language="C++ CLI" Value="NoRecursion" />
      <MemberSignature Language="F#" Value="NoRecursion = 0" Usage="System.Threading.LockRecursionPolicy.NoRecursion" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="810f7-114">如果執行緒嘗試遞迴地進入鎖定，則會擲回例外狀況。</span>
          <span class="sxs-lookup">
            <span data-stu-id="810f7-114">If a thread tries to enter a lock recursively, an exception is thrown.</span>
          </span>
          <span data-ttu-id="810f7-115">某些類別可能會在此設定有效時允許特定的遞迴。</span>
          <span class="sxs-lookup">
            <span data-stu-id="810f7-115">Some classes may allow certain recursions when this setting is in effect.</span>
          </span>
        </summary>
      </Docs>
    </Member>
    <Member MemberName="SupportsRecursion">
      <MemberSignature Language="C#" Value="SupportsRecursion" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.LockRecursionPolicy SupportsRecursion = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.LockRecursionPolicy.SupportsRecursion" />
      <MemberSignature Language="VB.NET" Value="SupportsRecursion" />
      <MemberSignature Language="C++ CLI" Value="SupportsRecursion" />
      <MemberSignature Language="F#" Value="SupportsRecursion = 1" Usage="System.Threading.LockRecursionPolicy.SupportsRecursion" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="810f7-116">執行緒可以遞迴地進入鎖定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="810f7-116">A thread can enter a lock recursively.</span>
          </span>
          <span data-ttu-id="810f7-117">某些類別可能會限制此功能。</span>
          <span class="sxs-lookup">
            <span data-stu-id="810f7-117">Some classes may restrict this capability.</span>
          </span>
        </summary>
      </Docs>
    </Member>
  </Members>
</Type>