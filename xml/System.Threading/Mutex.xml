<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="092df8a132c6280f7c2111bcb3ab0226334bc0f4" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407050" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A synchronization primitive that can also be used for interprocess synchronization.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當兩個或多個執行緒需要同時存取共用的資源時，系統就會需要同步處理機制，以確保一次只有一個執行緒使用的資源。 <xref:System.Threading.Mutex> 為基本，只有一個執行緒的共用資源獨佔存取權授與同步處理。 如果執行緒取得 mutex，則會暫停想要取得該 mutex 的第二個執行緒，直到第一個執行緒釋放 mutex。  
  
> [!IMPORTANT]
>  此類型會實作<xref:System.IDisposable>介面。 當您完成使用類型時，您應該會處置它直接或間接。 若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
 您可以使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法，要求 mutex 擁有權。 呼叫執行緒封鎖，直到發生下列其中一項：  
  
-   Mutex 發出信號以指出它未擁有。 當發生這種情況時，<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`true`，和呼叫的執行緒會假設 mutex 擁有權，並存取 mutex 所保護的資源。 當它完成存取資源時，必須呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法，以釋放 mutex 擁有權。 在範例區段中的第一個範例說明這個模式。  
  
-   若要呼叫中指定的逾時間隔<xref:System.Threading.WaitHandle.WaitOne%2A>方法`millisecondsTimeout`或`timeout`參數。 當發生這種情況時，<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`false`，和呼叫的執行緒不會進一步嘗試取得 mutex 擁有權。 在此情況下，您應該建構您的程式碼以便 mutex 所保護之資源的存取被拒呼叫執行緒。 執行緒永遠不會取得 mutex 擁有權，因為它不可以呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。 在範例區段中的第二個範例說明這個模式。  
  
 <xref:System.Threading.Mutex>因此只要取得它的執行緒釋放 mutex 執行緒識別、 強制執行的類別。 相反地，<xref:System.Threading.Semaphore>類別不會強制執行執行緒識別。 Mutex，也可以跨應用程式定義域界限傳遞。  
  
 擁有 mutex 的執行緒可以要求中重複呼叫相同的 mutex<xref:System.Threading.WaitHandle.WaitOne%2A>而不會封鎖其執行。 不過，必須呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法釋放 mutex 擁有權相同次數。  
  
 因為<xref:System.Threading.Mutex>類別繼承自<xref:System.Threading.WaitHandle>，您也可以呼叫靜態<xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>和<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>方法以同步存取受保護的資源。  
  
 如果執行緒終止時擁有 mutex，即稱為放棄 mutex。 Mutex 的狀態會設為收到信號，並等候的執行緒會取得擁有權。 .NET Framework 2.0 版開始<xref:System.Threading.AbandonedMutexException>取得已放棄的 mutex 的下一個執行緒中擲回。 之前版本的.NET Framework 2.0，不擲回例外狀況。  
  
> [!CAUTION]
>  已放棄的 mutex 通常表示程式碼中的嚴重錯誤。 當執行緒結束但未釋放 mutex 時，mutex 所保護的資料結構可能未處於一致的狀態。 要求 mutex 擁有權的下一個執行緒可以處理這個例外狀況，並繼續進行，如果能夠確認資料結構的完整性。  
  
 如果是全系統 Mutex，遭到放棄的 Mutex 可能表示應用程式已意外終止 (例如，透過使用「Windows 工作管理員」)。  
  
 Mutex 有兩種類型： 本機 mutex，也就是未命名，然後具名系統 mutex。 本機 Mutex只存在於您的處理序內。 可供您參考的程序中的任何執行緒<xref:System.Threading.Mutex>表示將 mutex 的物件。 每個未命名的<xref:System.Threading.Mutex>物件都代表不同的本機 mutex。  
  
 具名的系統 mutex 可在作業系統各處並可用來同步處理程序的活動。 您可以建立<xref:System.Threading.Mutex>藉由使用的建構函式接受名稱，表示具名的系統 mutex 的物件。 可以建立作業系統物件，在相同的時間，或者可以存在之前建立<xref:System.Threading.Mutex>物件。 您可以建立多個 <xref:System.Threading.Mutex> 物件來代表同一個具名系統 Mutex，而且可以使用 <xref:System.Threading.Mutex.OpenExisting%2A> 方法來開啟現有的具名系統 Mutex。  
  
> [!NOTE]
>  在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。 如果其名稱開頭為前置詞"Global\\"，mutex 會顯示所有的終端機伺服器工作階段中。 如果其名稱開頭為前置詞 「 本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。 在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。 如果您沒有指定前置詞建立具名的 mutex 時，會在前置詞 「 本機\\"。 在終端機伺服器工作階段中，兩個名稱只有不同及其前置詞的 mutex 個別 mutex，而且兩者都在終端機伺服器工作階段中顯示所有處理程序。 也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段、 不是相對於處理程序的 mutex 名稱的範圍。  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 這個範例會示範如何在本機<xref:System.Threading.Mutex>物件用來同步存取受保護的資源。 因為每個呼叫的執行緒會封鎖，直到它會取得 mutex 擁有權，必須呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>方法，以釋放執行緒的擁有權。  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 在下列範例中，每個執行緒呼叫<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29>取得 mutex 的方法。 如果超過逾時間隔，則方法會傳回`false`，並在執行緒或都不會取得 mutex 取得 mutex 所保護之資源的存取。 <xref:System.Threading.Mutex.ReleaseMutex%2A>只要取得 mutex 的執行緒呼叫方法。  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個建構函式多載會呼叫相同<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式多載，並指定`false`mutex 的初始擁有權。 也就是說，呼叫的執行緒未擁有 mutex。  
  
   
  
## Examples  
 下列程式碼範例示範如何在本機<xref:System.Threading.Mutex>物件用來同步存取受保護的資源。 建立 mutex 的執行緒未擁有它一開始。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何在本機<xref:System.Threading.Mutex>物件用來同步存取受保護的資源。 建立的執行緒<xref:System.Threading.Mutex>一開始擁有它。  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the <see cref="T:System.Threading.Mutex" />. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`name`不`null`和`initiallyOwned`是`true`，只有這個呼叫的結果建立了具名的系統 mutex 時，呼叫的執行緒擁有 mutex。 因為沒有任何機制可判斷是否已建立了具名的系統 mutex，最好是在指定`false`如`initiallyOwned`時呼叫這個建構函式多載。 您可以使用<xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29>建構函式，如果您需要決定的初始擁有權。  
  
 這個建構函式初始化<xref:System.Threading.Mutex>代表具名的系統 mutex 的物件。 您可以建立多個<xref:System.Threading.Mutex>物件，代表相同的具名系統 mutex。  
  
 如果具名的 mutex 已建立具有存取控制安全性，而且呼叫端沒有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>，擲回例外狀況。 若要開啟現有的具名 mutex 以所需的同步處理執行緒活動，這些權限，請參閱<xref:System.Threading.Mutex.OpenExisting%2A>方法。  
  
 如果您指定`null`或為空字串。 `name`，建立本機 mutex 時，您必須呼叫<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式。 在此情況下，`createdNew`一律`true`。  
  
 因為它們是全系統，具名的 mutex 可以用於協調資源使用跨處理序界限。  
  
> [!NOTE]
>  在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。 如果其名稱開頭為前置詞"Global\\"，mutex 會顯示所有的終端機伺服器工作階段中。 如果其名稱開頭為前置詞 「 本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。 在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。 如果您沒有指定前置詞建立具名的 mutex 時，會在前置詞 「 本機\\"。 在終端機伺服器工作階段中，兩個名稱只有不同及其前置詞的 mutex 個別 mutex，而且兩者都在終端機伺服器工作階段中顯示所有處理程序。 也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段、 不是相對於處理程序的 mutex 名稱的範圍。  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 下列範例示範如何用來表示兩個不同的處理序中執行的執行緒之間的具名的 mutex。  
  
 從兩個或多個命令視窗執行此程式。 每個程序會建立<xref:System.Threading.Mutex>物件，代表具名的 mutex `MyMutex`。 具名的 mutex 為系統物件的存留期會受限於其存留期<xref:System.Threading.Mutex>代表它的物件。 第一個程序建立時，系統會建立具名的 mutex 其<xref:System.Threading.Mutex>物件; 在此範例中，具名的 mutex 擁有者是執行程式的第一個程序。 具名的 mutex 被終結時所有<xref:System.Threading.Mutex>已發行物件，表示它。  
  
 此範例中使用的建構函式多載無法分辨是否具名 mutex 的初始擁有權已授與呼叫執行緒。 您不應該使用這個建構函式來要求的初始擁有權，除非您可以確定執行緒會建立具名的 mutex。  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the <see cref="T:System.Threading.Mutex" />. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <param name="createdNew">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed. This parameter is passed uninitialized.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`name`不`null`和`initiallyOwned`是`true`，呼叫的執行緒擁有具名的 mutex 才`createdNew`是`true`呼叫之後。 否則，執行緒時，可以藉由呼叫要求 mutex<xref:System.Threading.WaitHandle.WaitOne%2A>方法。  
  
 這個建構函式初始化<xref:System.Threading.Mutex>代表具名的系統 mutex 的物件。 您可以建立多個<xref:System.Threading.Mutex>物件，代表相同的具名系統 mutex。  
  
 如果具名的 mutex 已建立具有存取控制安全性，而且呼叫端沒有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>權限，擲回例外狀況。 若要開啟現有的具名 mutex 以所需的同步處理執行緒活動，這些權限，請參閱<xref:System.Threading.Mutex.OpenExisting%2A>方法。  
  
 如果您指定`null`或為空字串。 `name`，建立本機 mutex 時，您必須呼叫<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式。 在此情況下，`createdNew`一律`true`。  
  
 因為它們是全系統，具名的 mutex 可以用於協調資源使用跨處理序界限。  
  
> [!NOTE]
>  在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。 如果其名稱開頭為前置詞"Global\\"，mutex 會顯示所有的終端機伺服器工作階段中。 如果其名稱開頭為前置詞 「 本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。 在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。 如果您沒有指定前置詞建立具名的 mutex 時，會在前置詞 「 本機\\"。 在終端機伺服器工作階段中，兩個名稱只有不同及其前置詞的 mutex 個別 mutex，而且兩者都在終端機伺服器工作階段中顯示所有處理程序。 也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段、 不是相對於處理程序的 mutex 名稱的範圍。  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 下列程式碼範例示範如何用來表示處理序或執行緒之間的具名的 mutex。 從兩個或多個命令視窗執行此程式。 每個程序會建立<xref:System.Threading.Mutex>物件，代表具名的 mutex"MyMutex"。 具名的 mutex 為系統物件。 在此範例中，其存留期會受限於的存留期<xref:System.Threading.Mutex>代表它的物件。 第一個程序會建立其區域變數時，系統會建立具名的 mutex<xref:System.Threading.Mutex>物件，並終結時所有<xref:System.Threading.Mutex>已發行物件，表示它。 具名的 mutex，一開始是由第一個處理序所擁有。 第二個程序和任何後續的處理序等候先前的處理序釋放具名的 mutex。  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the system mutex. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <param name="createdNew">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed. This parameter is passed uninitialized.</param>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`name`不`null`和`initiallyOwned`是`true`，呼叫的執行緒擁有具名的 mutex 才`createdNew`是`true`呼叫之後。 否則，執行緒時，可以藉由呼叫要求 mutex<xref:System.Threading.WaitHandle.WaitOne%2A>方法。  
  
 您可以使用這個建構函式套用至具名的系統 mutex 的存取控制安全性，其建立時，避免其他程式碼取得 mutex 的控制項。  
  
 這個建構函式初始化<xref:System.Threading.Mutex>代表具名的系統 mutex 的物件。 您可以建立多個<xref:System.Threading.Mutex>物件，代表相同的具名系統 mutex。  
  
 如果不存在了具名的系統 mutex，則會建立具有指定的存取控制安全性。 如果具名的 mutex 已存在，則會忽略指定的存取控制安全性。  
  
> [!NOTE]
>  呼叫端具有對於新建立的完整控制權<xref:System.Threading.Mutex>物件，即使`mutexSecurity`拒絕，或將某些存取權授與目前的使用者就會失敗。 不過，如果目前的使用者試圖取得另一個<xref:System.Threading.Mutex>物件來代表相同的具名 mutex，使用建構函式或<xref:System.Threading.Mutex.OpenExisting%2A>方法時，Windows 會套用存取控制安全性。  
  
 如果具名的 mutex 已建立具有存取控制安全性，而且呼叫端沒有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>，擲回例外狀況。 若要開啟現有的具名 mutex 以所需的同步處理執行緒活動，這些權限，請參閱<xref:System.Threading.Mutex.OpenExisting%2A>方法。  
  
 如果您指定`null`或為空字串。 `name`，建立本機 mutex 時，您必須呼叫<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式。 在此情況下，`createdNew`一律`true`。  
  
 因為它們是全系統，具名的 mutex 可以用於協調資源使用跨處理序界限。  
  
> [!NOTE]
>  在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。 如果其名稱開頭為前置詞"Global\\"，mutex 會顯示所有的終端機伺服器工作階段中。 如果其名稱開頭為前置詞 「 本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。 在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。 如果您沒有指定前置詞建立具名的 mutex 時，會在前置詞 「 本機\\"。 在終端機伺服器工作階段中，兩個名稱只有不同及其前置詞的 mutex 個別 mutex，而且兩者都在終端機伺服器工作階段中顯示所有處理程序。 也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段、 不是相對於處理程序的 mutex 名稱的範圍。  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 下列程式碼範例示範具名 mutex 的跨處理序的行為與存取控制安全性。 此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。  
  
 如果 mutex 不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限使用 mutex，但讀取和變更的權限將 mutex 的權限會授與存取控制安全性。  
  
 如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。 例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限所需的權限來開啟 mutex。  
  
 變更權限之後，輸入，並釋放它所需的權限開啟 mutex。 如果您是從第三個命令視窗執行編譯的範例，它會使用執行新的權限。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A>方法會使用下列旗標 （使用位元 OR 運算結合） 的組合來搜尋權限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。  
  
 使用者必須擁有<xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>呼叫這個方法和 mutex 必須已經開啟與<xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例示範具名 mutex 的跨處理序的行為與存取控制安全性。 此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。  
  
 如果 mutex 不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限使用 mutex，但讀取和變更的權限將 mutex 的權限會授與存取控制安全性。  
  
 如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。 例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限，並使用所需的權限來開啟 mutex<xref:System.Threading.Mutex.GetAccessControl%2A>和<xref:System.Threading.Mutex.SetAccessControl%2A>方法。  
  
 變更權限之後，輸入，並釋放它所需的權限開啟 mutex。 如果您是從第三個命令視窗執行編譯的範例，它會使用執行新的權限。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  -or-  The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Not supported for Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named mutex, if it already exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <summary>Opens the specified named mutex, if it already exists.</summary>
        <returns>An object that represents the named system mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A>方法嘗試開啟指定的具名系統 mutex。 如果不存在的系統 mutex，這個方法會擲回的例外狀況，而非建立系統物件。 若要建立的系統 mutex，已經不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。  
  
 這個方法多載就相當於呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載，並指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。  
  
 指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒正在等候 mutex，並指定<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。  
  
 這個方法不會要求 mutex 擁有權。  
  
   
  
## Examples  
 下列程式碼範例示範具名 mutex 的跨處理序的行為與存取控制安全性。 此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。  
  
 如果 mutex 不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限使用 mutex，但讀取和變更的權限將 mutex 的權限會授與存取控制安全性。  
  
 如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。 例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限所需的權限來開啟 mutex。  
  
 變更權限之後，輸入，並釋放它所需的權限開啟 mutex。 如果您是從第三個命令視窗執行編譯的範例，它會使用執行新的權限。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <summary>Opens the specified named mutex, if it already exists, with the desired security access.</summary>
        <returns>An object that represents the named system mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights`參數必須包含<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標以允許 mutex，等候的執行緒和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。  
  
 <xref:System.Threading.Mutex.OpenExisting%2A>方法嘗試開啟現有的具名 mutex。 如果不存在的系統 mutex，這個方法會擲回的例外狀況，而非建立系統物件。 若要建立的系統 mutex，已經不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。  
  
 這個方法不會要求 mutex 擁有權。  
  
   
  
## Examples  
 下列程式碼範例示範具名 mutex 的跨處理序的行為與存取控制安全性。 此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。  
  
 如果 mutex 不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限使用 mutex，但讀取和變更的權限將 mutex 的權限會授與存取控制安全性。  
  
 如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。 例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限所需的權限來開啟 mutex。  
  
 變更權限之後，輸入，並釋放它所需的權限開啟 mutex。 如果您是從第三個命令視窗執行編譯的範例，它會使用執行新的權限。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the <see cref="T:System.Threading.Mutex" /> once.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每當執行緒取得 mutex (例如，藉由呼叫其<xref:System.Threading.WaitHandle.WaitOne%2A>方法)，必須在後續呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>放棄 mutex 擁有權及解除鎖定其他執行緒，嘗試取得 mutex 的擁有權。 如果嘗試取得 mutex 擁有權就會失敗 (例如，當呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>方法`millisecondsTimeout`或`timeout`參數傳回`false`因為要求逾時)，執行緒不應該呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>，在此案例中，執行緒應該也不允許存取受保護的 mutex，如下列範例所示的資源。  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 擁有 mutex 執行緒可以重複的等候函式呼叫中指定相同的 mutex 而不會封鎖其執行。 Common language runtime 所保留的呼叫數。 必須在呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>相同次數釋放 mutex 擁有權。  
  
 如果執行緒終止時擁有 mutex，即稱為放棄 mutex。 Mutex 的狀態設定為收到信號並等候的執行緒會取得擁有權。 如果沒有人擁有 mutex，則會指示的 mutex 狀態。 .NET Framework 2.0 版開始<xref:System.Threading.AbandonedMutexException>取得 mutex 的下一個執行緒中擲回。 之前版本的.NET Framework 2.0，不擲回例外狀況。  
  
> [!CAUTION]
>  已放棄的 mutex 通常表示程式碼中的嚴重錯誤。 當執行緒結束但未釋放 mutex 時，mutex 所保護的資料結構可能未處於一致的狀態。 要求 mutex 擁有權的下一個執行緒可以處理這個例外狀況，並繼續進行，如果能夠確認資料結構的完整性。  
  
 如果是全系統 Mutex，遭到放棄的 Mutex 可能表示應用程式已意外終止 (例如，透過使用「Windows 工作管理員」)。  
  
   
  
## Examples  
 下列範例會示範如何在本機<xref:System.Threading.Mutex>物件用來同步存取受保護的資源。 建立 mutex 的執行緒未擁有它一開始。 <xref:System.Threading.Mutex.ReleaseMutex%2A>方法用來在不再需要時釋放 mutex。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">The calling thread does not own the mutex.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</param>
        <summary>Sets the access control security for a named system mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用者必須擁有<xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>呼叫這個方法，並將 mutex 的權限必須是與開啟<xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例示範具名 mutex 的跨處理序的行為與存取控制安全性。 此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。  
  
 如果 mutex 不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限使用 mutex，但讀取和變更的權限將 mutex 的權限會授與存取控制安全性。  
  
 如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。 例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限，並使用所需的權限來開啟 mutex<xref:System.Threading.Mutex.GetAccessControl%2A>和<xref:System.Threading.Mutex.SetAccessControl%2A>方法。  
  
 變更權限之後，輸入，並釋放它所需的權限開啟 mutex。 如果您是從第三個命令視窗執行編譯的範例，它會使用執行新的權限。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  -or-  The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不存在的具名的 mutex，這個方法不會建立它。 若要建立的系統 mutex，已經不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。  
  
 如果您不確定是否存在的具名的 mutex，則使用這個方法多載，而不是<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載，如果 mutex 不存在，擲回例外狀況。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。  
  
 這個方法多載就相當於呼叫<xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29>方法多載，並指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。 指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒正在等候 mutex，並指定<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。  
  
 這個方法不會要求 mutex 擁有權。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不存在的具名的 mutex，這個方法不會建立它。 若要建立的系統 mutex，已經不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。  
  
 如果您不確定是否存在的具名的 mutex，則使用這個方法多載，而不是<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載，如果 mutex 不存在，擲回例外狀況。  
  
 `rights`參數必須包含<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標以允許 mutex，等候的執行緒和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。  
  
 這個方法不會要求 mutex 擁有權。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
  </Members>
</Type>