<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="75309784a7f2ba45e91d42b9f73bf62285725b43" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52200776" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>同步處理原始物件也可用於進行處理序之間的同步處理。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當兩個或多個執行緒需要同時存取共用的資源時，系統就會需要同步處理機制，以確保一次只有一個執行緒使用的資源。 <xref:System.Threading.Mutex> 是同步處理基本，可授與僅限一個執行緒共用資源獨佔存取權。 如果執行緒取得 mutex，想要取得該 mutex 的第二個執行緒會暫停，直到第一個執行緒釋放 mutex。  
  
> [!IMPORTANT]
>  此類型會實作<xref:System.IDisposable>介面。 當您完成使用型別時，您應該處置它直接或間接。 若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
 您可以使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法來要求擁有權的 mutex。 呼叫端執行緒封鎖，直到發生下列其中一項：  
  
-   Mutex 收到訊號，表示未擁有。 當發生這種情況<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`true`，和呼叫的執行緒會假設 mutex 擁有權，並存取 mutex 所保護的資源。 當它完成存取資源時，必須呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法來釋放 mutex 擁有權。 範例 > 一節的第一個範例會示範這個模式。  
  
-   若要呼叫中指定的逾時間隔<xref:System.Threading.WaitHandle.WaitOne%2A>方法具有`millisecondsTimeout`或`timeout`參數。 當發生這種情況<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`false`，和呼叫的執行緒不會進一步嘗試取得 mutex 的擁有權。 在此情況下，您應該建構您的程式碼，以便 mutex 所保護的資源的存取被拒進行呼叫的執行緒。 執行緒永遠不會取得 mutex 的擁有權，因為它必須呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。 範例區段中的第二個範例會示範這個模式。  
  
 <xref:System.Threading.Mutex>類別會強制執行緒身分識別，因此可以釋出 mutex，只能由取得它的執行緒。 相較之下，<xref:System.Threading.Semaphore>類別不會強制執行緒身分識別。 Mutex，也可跨應用程式定義域界限傳遞。  
  
 擁有 mutex 的執行緒可以要求在重複呼叫相同的 mutex<xref:System.Threading.WaitHandle.WaitOne%2A>而不會封鎖其執行。 不過，呼叫執行緒必須<xref:System.Threading.Mutex.ReleaseMutex%2A>方法相同的數字的次數，以釋放 mutex 的擁有權。  
  
 因為<xref:System.Threading.Mutex>類別繼承自<xref:System.Threading.WaitHandle>，您也可以呼叫靜態<xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>和<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>方法來同步處理受保護資源的存取權。  
  
 如果執行緒終止時擁有 mutex，就表示已放棄 mutex。 Mutex 的狀態會設為收到信號，且下一個等候執行緒取得擁有權。 .NET Framework 2.0 版開始<xref:System.Threading.AbandonedMutexException>取得已放棄的 mutex 的下一個執行緒中擲回。 之前版本的.NET Framework 2.0，不擲回例外狀況。  
  
> [!CAUTION]
>  已放棄的 mutex 通常表示嚴重的錯誤，程式碼中。 當執行緒結束但未釋放 mutex 時，mutex 所保護的資料結構可能無法一致的狀態。 要求擁有權的 mutex 的下一個執行緒可以處理這個例外狀況，並繼續進行，如果可以確認資料結構的完整性。  
  
 如果是全系統 Mutex，遭到放棄的 Mutex 可能表示應用程式已意外終止 (例如，透過使用「Windows 工作管理員」)。  
  
 Mutex 有兩種類型： 本機 mutex，未命名的並且具名系統 mutex。 本機 Mutex只存在於您的處理序內。 它可供您參考的程序中的任何執行緒<xref:System.Threading.Mutex>表示此 mutex 的物件。 每個未命名的<xref:System.Threading.Mutex>物件都代表不同的本機 mutex。  
  
 具名的系統 mutex 會顯示整個作業系統，而且可用來同步處理程序的活動。 您可以建立<xref:System.Threading.Mutex>物件，表示使用建構函式可接受名稱的具名的系統 mutex。 可以在此同時，建立作業系統物件，或它可以在建立之前存在<xref:System.Threading.Mutex>物件。 您可以建立多個 <xref:System.Threading.Mutex> 物件來代表同一個具名系統 Mutex，而且可以使用 <xref:System.Threading.Mutex.OpenExisting%2A> 方法來開啟現有的具名系統 Mutex。  
  
> [!NOTE]
>  在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。 如果其名稱開頭為前置詞"Global\\"，則顯示在所有的終端機伺服器工作階段 mutex。 如果其名稱開頭為前置詞"本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。 在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。 如果當您建立具名的 mutex 時，您不會指定前置詞，它會採用前置詞"本機\\"。 終端機伺服器工作階段中，名稱只能由其前置詞不同的兩個 mutex 有個別的 mutex，而且兩者都看得到所有處理程序終端機伺服器工作階段中。 也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段，不是相對於處理程序之 mutex 名稱的範圍。  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 此範例會示範如何在本機<xref:System.Threading.Mutex>物件用來同步處理受保護資源的存取權。 因為每個呼叫的執行緒會封鎖，直到它取得 mutex 的擁有權，必須呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>方法，以釋放擁有權的執行緒。  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 在下列範例中，每個執行緒呼叫<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29>取得 mutex 的方法。 如果超過指定時間的逾時間隔，此方法會傳回`false`，和執行緒取得 mutex 都獲得存取權的 mutex 所保護的資源。 <xref:System.Threading.Mutex.ReleaseMutex%2A>只能由執行緒取得 mutex 的呼叫方法。  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutex</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>使用預設屬性，初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個建構函式多載等同於呼叫<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式多載，並指定`false`mutex 的初始擁有權。 也就是說，呼叫的執行緒未擁有 mutex。  
  
   
  
## Examples  
 下列程式碼範例示範如何在本機<xref:System.Threading.Mutex>物件用來同步處理受保護資源的存取權。 建立 mutex 的執行緒不擁有該一開始。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutex</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">如果要把 Mutex 的初始擁有權提供給呼叫執行緒，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>使用表示呼叫執行緒是否應該具有 Mutex 的初始擁有權的布林值，初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何在本機<xref:System.Threading.Mutex>物件用來同步處理受保護資源的存取權。 建立的執行緒<xref:System.Threading.Mutex>一開始擁有它。  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutex</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> 表示如果這個呼叫的結果建立了具名系統 Mutex，則將具名系統 Mutex 的初始擁有權授與呼叫執行緒，否則為 <see langword="false" />。</param>
        <param name="name">
          <see cref="T:System.Threading.Mutex" /> 的名稱。 如果值是 <see langword="null" />，則 <see cref="T:System.Threading.Mutex" /> 未命名。</param>
        <summary>使用表示呼叫執行緒是否應該具有 Mutex 的初始擁有權的布林值，以及代表 Mutex 名稱的字串，初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`name`不是`null`並`initiallyOwned`是`true`，呼叫的執行緒擁有 mutex，才將具名的系統 mutex 已因此呼叫而建立。 因為沒有任何機制可用於判斷是否已建立了具名的系統 mutex，最好是指定`false`針對`initiallyOwned`時呼叫這個建構函式多載。 您可以使用<xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29>建構函式，如果您需要決定初始擁有權。  
  
 這個建構函式初始化<xref:System.Threading.Mutex>物件，表示具名的系統 mutex。 您可以建立多個<xref:System.Threading.Mutex>代表相同的物件的具名系統 mutex。  
  
 如果具名的 mutex 已建立存取控制安全性，而且呼叫端沒有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>，會擲回例外狀況。 若要開啟現有的所需的同步處理執行緒活動，這些權限的具名 mutex，請參閱<xref:System.Threading.Mutex.OpenExisting%2A>方法。  
  
 如果您指定`null`或空字串`name`，建立本機 mutex，視為已呼叫<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式。 在此情況下，`createdNew`總是`true`。  
  
 因為它們是全系統時，具名的 mutex 可以用於跨處理序界限協調資源使用。  
  
> [!NOTE]
>  在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。 如果其名稱開頭為前置詞"Global\\"，則顯示在所有的終端機伺服器工作階段 mutex。 如果其名稱開頭為前置詞"本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。 在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。 如果當您建立具名的 mutex 時，您不會指定前置詞，它會採用前置詞"本機\\"。 終端機伺服器工作階段中，名稱只能由其前置詞不同的兩個 mutex 有個別的 mutex，而且兩者都看得到所有處理程序終端機伺服器工作階段中。 也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段，不是相對於處理程序之 mutex 名稱的範圍。  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 下列範例顯示如何使用具名的 mutex 來表示兩個不同的處理序中執行的執行緒之間。  
  
 從兩個或多個命令視窗中執行此程式。 每個程序會建立<xref:System.Threading.Mutex>物件，表示具名的 mutex `MyMutex`。 具名的 mutex 為系統物件的存留期會受限於其存留期<xref:System.Threading.Mutex>代表它的物件。 第一個處理序建立時，會建立具名的 mutex 其<xref:System.Threading.Mutex>物件; 在此範例中，具名的 mutex 擁有者會執行程式的第一個程序。 具名的 mutex 已終結時所有<xref:System.Threading.Mutex>已發行物件，代表它。  
  
 在此範例中使用的建構函式多載無法分辨呼叫執行緒是否被授與的具名 mutex 的初始擁有權。 您不應該使用這個建構函式要求的初始擁有權，除非您可以確定執行緒會建立具名的 mutex。  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">具名 Mutex 已存在，並且具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</exception>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">無法建立具名 Mutex，可能是因為不同類型的等候控制代碼具有相同的名稱。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutex</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> 表示如果這個呼叫的結果建立了具名系統 Mutex，則將具名系統 Mutex 的初始擁有權授與呼叫執行緒，否則為 <see langword="false" />。</param>
        <param name="name">
          <see cref="T:System.Threading.Mutex" /> 的名稱。 如果值是 <see langword="null" />，則 <see cref="T:System.Threading.Mutex" /> 未命名。</param>
        <param name="createdNew">當這個方法傳回時，如果已建立本機 Mutex (也就是說，如果 <paramref name="name" /> 為 <see langword="null" /> 或空字串)，或是已建立指定的具名系統 Mutex，則會包含 <see langword="true" /> 的布林值；如果指定的具名系統 Mutex 已存在，則為 <see langword="false" />。 這個參數會以未初始化的狀態傳遞。</param>
        <summary>使用表示呼叫執行緒是否應該具有 Mutex 的初始擁有權的布林值、代表 Mutex 名稱的字串，以及當方法傳回時表示是否將 Mutex 的初始擁有權授與呼叫執行緒的布林值，初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`name`不是`null`並`initiallyOwned`是`true`，呼叫的執行緒擁有具名的 mutex 只有當`createdNew`是`true`之後呼叫。 否則，執行緒時，可以藉由呼叫要求 mutex<xref:System.Threading.WaitHandle.WaitOne%2A>方法。  
  
 這個建構函式初始化<xref:System.Threading.Mutex>物件，表示具名的系統 mutex。 您可以建立多個<xref:System.Threading.Mutex>代表相同的物件的具名系統 mutex。  
  
 如果具名的 mutex 已建立存取控制安全性，而且呼叫端沒有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>權限，擲回例外狀況。 若要開啟現有的所需的同步處理執行緒活動，這些權限的具名 mutex，請參閱<xref:System.Threading.Mutex.OpenExisting%2A>方法。  
  
 如果您指定`null`或空字串`name`，建立本機 mutex，視為已呼叫<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式。 在此情況下，`createdNew`總是`true`。  
  
 因為它們是全系統時，具名的 mutex 可以用於跨處理序界限協調資源使用。  
  
> [!NOTE]
>  在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。 如果其名稱開頭為前置詞"Global\\"，則顯示在所有的終端機伺服器工作階段 mutex。 如果其名稱開頭為前置詞"本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。 在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。 如果當您建立具名的 mutex 時，您不會指定前置詞，它會採用前置詞"本機\\"。 終端機伺服器工作階段中，名稱只能由其前置詞不同的兩個 mutex 有個別的 mutex，而且兩者都看得到所有處理程序終端機伺服器工作階段中。 也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段，不是相對於處理程序之 mutex 名稱的範圍。  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 下列程式碼範例示範如何使用具名的 mutex 來處理序或執行緒之間發出信號。 從兩個或多個命令視窗中執行此程式。 每個程序會建立<xref:System.Threading.Mutex>物件，表示具名的 mutex 」 MyMutex"。 具名的 mutex 為系統物件。 在此範例中，其存留期會受限於的存留期<xref:System.Threading.Mutex>代表它的物件。 第一個處理序會建立其區域變數時，系統會建立具名的 mutex<xref:System.Threading.Mutex>物件，並終結時所有<xref:System.Threading.Mutex>已發行物件，代表它。 具名的 mutex，一開始是由第一個處理序所擁有。 第二個程序和任何後續的處理序等候先前的處理序釋放具名的 mutex。  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">具名 Mutex 已存在，並且具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</exception>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">無法建立具名 Mutex，可能是因為不同類型的等候控制代碼具有相同的名稱。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutex</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> 表示如果這個呼叫的結果建立了具名系統 Mutex，則將具名系統 Mutex 的初始擁有權授與呼叫執行緒，否則為 <see langword="false" />。</param>
        <param name="name">系統 Mutex 的名稱。 如果值是 <see langword="null" />，則 <see cref="T:System.Threading.Mutex" /> 未命名。</param>
        <param name="createdNew">當這個方法傳回時，如果已建立本機 Mutex (也就是說，如果 <paramref name="name" /> 為 <see langword="null" /> 或空字串)，或是已建立指定的具名系統 Mutex，則會包含 <see langword="true" /> 的布林值；如果指定的具名系統 Mutex 已存在，則為 <see langword="false" />。 這個參數會以未初始化的狀態傳遞。</param>
        <param name="mutexSecurity">
          <see cref="T:System.Security.AccessControl.MutexSecurity" /> 物件，代表要套用至具名系統 Mutex 的存取控制安全性。</param>
        <summary>使用表示呼叫執行緒是否應該具有 Mutex 的初始擁有權的布林值、代表 Mutex 名稱的字串、當這個方法傳回時表示是否將 Mutex 的初始擁有權授與呼叫執行緒的布林值，以及要套用至具名 Mutex 的存取控制安全性，初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`name`不是`null`並`initiallyOwned`是`true`，呼叫的執行緒擁有具名的 mutex 只有當`createdNew`是`true`之後呼叫。 否則，執行緒時，可以藉由呼叫要求 mutex<xref:System.Threading.WaitHandle.WaitOne%2A>方法。  
  
 您可以使用這個建構函式套用至具名的系統 mutex 的存取控制安全性，建立時，防止其他程式碼採用 mutex 的控制項。  
  
 這個建構函式初始化<xref:System.Threading.Mutex>物件，表示具名的系統 mutex。 您可以建立多個<xref:System.Threading.Mutex>代表相同的物件的具名系統 mutex。  
  
 如果不存在的具名的系統 mutex，則會建立具有指定的存取控制安全性。 如果具名的 mutex 已存在，則會忽略指定的存取控制安全性。  
  
> [!NOTE]
>  呼叫端具有全權掌控新建<xref:System.Threading.Mutex>物件，即使`mutexSecurity`拒絕，或無法授與給目前的使用者部分存取權限。 不過，如果目前的使用者嘗試取得另一個<xref:System.Threading.Mutex>物件代表相同具名 mutex，使用建構函式或<xref:System.Threading.Mutex.OpenExisting%2A>方法，套用存取控制安全性的 Windows。  
  
 如果具名的 mutex 已建立存取控制安全性，而且呼叫端沒有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>，會擲回例外狀況。 若要開啟現有的所需的同步處理執行緒活動，這些權限的具名 mutex，請參閱<xref:System.Threading.Mutex.OpenExisting%2A>方法。  
  
 如果您指定`null`或空字串`name`，建立本機 mutex，視為已呼叫<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式。 在此情況下，`createdNew`總是`true`。  
  
 因為它們是全系統時，具名的 mutex 可以用於跨處理序界限協調資源使用。  
  
> [!NOTE]
>  在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。 如果其名稱開頭為前置詞"Global\\"，則顯示在所有的終端機伺服器工作階段 mutex。 如果其名稱開頭為前置詞"本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。 在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。 如果當您建立具名的 mutex 時，您不會指定前置詞，它會採用前置詞"本機\\"。 終端機伺服器工作階段中，名稱只能由其前置詞不同的兩個 mutex 有個別的 mutex，而且兩者都看得到所有處理程序終端機伺服器工作階段中。 也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段，不是相對於處理程序之 mutex 名稱的範圍。  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 下列程式碼範例會示範具名 mutex 的跨處理序行為具有存取控制安全性。 此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。  
  
 如果 mutex 不存在，它會建立初始擁有權與拒絕目前的使用者使用 mutex 的權限，但是會授與讀取和變更 mutex 的權限的權限的存取控制安全性。  
  
 如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。 攔截到例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限所需的權限開啟 mutex。  
  
 權限變更之後，輸入，並釋放它所需的權限開啟 mutex。 如果您從第三個 [命令] 視窗中執行編譯的範例，它會執行使用新的權限。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名 Mutex 已存在，並且具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">無法建立具名 Mutex，可能是因為不同類型的等候控制代碼具有相同的名稱。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 物件，代表具名 Mutex 的存取控制安全性。</summary>
        <returns>
          <see cref="T:System.Security.AccessControl.MutexSecurity" /> 物件，代表具名 Mutex 的存取控制安全性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A>方法會使用下列旗標 （使用位元 OR 運算結合） 的組合來搜尋權限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。  
  
 使用者必須擁有<xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>呼叫這個方法和 mutex 必須已經開啟與<xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例會示範具名 mutex 的跨處理序行為具有存取控制安全性。 此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。  
  
 如果 mutex 不存在，它會建立初始擁有權與拒絕目前的使用者使用 mutex 的權限，但是會授與讀取和變更 mutex 的權限的權限的存取控制安全性。  
  
 如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。 攔截到例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更權限，並使用所需的權限開啟 mutex<xref:System.Threading.Mutex.GetAccessControl%2A>和<xref:System.Threading.Mutex.SetAccessControl%2A>方法。  
  
 權限變更之後，輸入，並釋放它所需的權限開啟 mutex。 如果您從第三個 [命令] 視窗中執行編譯的範例，它會執行使用新的權限。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">目前的 <see cref="T:System.Threading.Mutex" /> 物件表示具名系統 Mutex，但是使用者沒有 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />。  
  
-或- 
目前的 <see cref="T:System.Threading.Mutex" /> 物件表示具名系統 Mutex，而且不是以 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> 開啟。</exception>
        <exception cref="T:System.NotSupportedException">不支援 Windows 98 或 Windows Millennium Edition。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開啟指定的具名 mutex (如果已經存在)。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要開啟的系統 Mutex 的名稱。</param>
        <summary>開啟指定的具名 mutex (如果已經存在)。</summary>
        <returns>表示具名系統 Mutex 的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A>方法嘗試開啟指定的具名系統 mutex。 如果系統 mutex 不存在，這個方法會擲回的例外狀況，而不是建立系統物件。 若要建立的系統 mutex，已不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。  
  
 這個方法多載就相當於呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載，並指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。  
  
 指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒等候 mutex，並指定<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。  
  
 這個方法不會要求 mutex 擁有權。  
  
   
  
## Examples  
 下列程式碼範例會示範具名 mutex 的跨處理序行為具有存取控制安全性。 此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。  
  
 如果 mutex 不存在，它會建立初始擁有權與拒絕目前的使用者使用 mutex 的權限，但是會授與讀取和變更 mutex 的權限的權限的存取控制安全性。  
  
 如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。 攔截到例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限所需的權限開啟 mutex。  
  
 權限變更之後，輸入，並釋放它所需的權限開啟 mutex。 如果您從第三個 [命令] 視窗中執行編譯的範例，它會執行使用新的權限。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 為空字串。  
  
-或- 
 <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">具名 Mutex 不存在。</exception>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名的 Mutex 已存在，但使用者沒有使用它所需的安全性存取權。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">要開啟的系統 Mutex 的名稱。</param>
        <param name="rights">列舉值的位元組合，表示所需的安全性存取。</param>
        <summary>使用所需的安全性存取權，開啟指定的具名 mutex (如果已經存在)。</summary>
        <returns>表示具名系統 Mutex 的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights`參數必須包含<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標，好讓執行緒等候 mutex，而<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。  
  
 <xref:System.Threading.Mutex.OpenExisting%2A>方法嘗試開啟現有的具名 mutex。 如果系統 mutex 不存在，這個方法會擲回的例外狀況，而不是建立系統物件。 若要建立的系統 mutex，已不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。  
  
 這個方法不會要求 mutex 擁有權。  
  
   
  
## Examples  
 下列程式碼範例會示範具名 mutex 的跨處理序行為具有存取控制安全性。 此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。  
  
 如果 mutex 不存在，它會建立初始擁有權與拒絕目前的使用者使用 mutex 的權限，但是會授與讀取和變更 mutex 的權限的權限的存取控制安全性。  
  
 如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。 攔截到例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限所需的權限開啟 mutex。  
  
 權限變更之後，輸入，並釋放它所需的權限開啟 mutex。 如果您從第三個 [命令] 視窗中執行編譯的範例，它會執行使用新的權限。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 為空字串。  
  
-或- 
 <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">具名 Mutex 不存在。</exception>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名 Mutex 已存在，但是使用者沒有所需的安全性存取權。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋出 <see cref="T:System.Threading.Mutex" /> 一次。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每當執行緒取得 mutex (例如，藉由呼叫其<xref:System.Threading.WaitHandle.WaitOne%2A>方法)，它必須接著呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>放棄的 mutex 擁有權和解除封鎖嘗試取得 mutex 的擁有權的其他執行緒。 如果嘗試取得 mutex 的擁有權就會失敗 (例如，當呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>方法`millisecondsTimeout`或`timeout`參數會傳回`false`因為要求逾時)，執行緒不應該呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>，在此情況下，執行緒應該也不會允許存取受保護的 mutex，如下列範例所示的資源。  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 擁有 mutex 的執行緒可以指定在重複的等候函式呼叫相同的 mutex，而不會封鎖其執行。 Common language runtime 所保留的呼叫數。 必須在呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>相同數目的時間，以釋放 mutex 的擁有權。  
  
 如果執行緒終止時擁有 mutex，就表示已放棄 mutex。 Mutex 的狀態設定為已收到訊號並等候下一步 中的執行緒取得擁有權。 如果沒有人擁有 mutex，mutex 的狀態將會收到信號。 .NET Framework 2.0 版開始<xref:System.Threading.AbandonedMutexException>取得 mutex 的下一個執行緒中擲回。 早於 2.0 版的.NET framework，擲不回任何例外狀況。  
  
> [!CAUTION]
>  已放棄的 mutex 通常表示嚴重的錯誤，程式碼中。 當執行緒結束但未釋放 mutex 時，mutex 所保護的資料結構可能無法一致的狀態。 要求擁有權的 mutex 的下一個執行緒可以處理這個例外狀況，並繼續進行，如果可以確認資料結構的完整性。  
  
 如果是全系統 Mutex，遭到放棄的 Mutex 可能表示應用程式已意外終止 (例如，透過使用「Windows 工作管理員」)。  
  
   
  
## Examples  
 下列範例會示範如何在本機<xref:System.Threading.Mutex>物件用來同步處理受保護資源的存取權。 建立 mutex 的執行緒不擁有該一開始。 <xref:System.Threading.Mutex.ReleaseMutex%2A>方法用來釋放 mutex，不再需要時。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">呼叫端執行緒未擁有 Mutex。</exception>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutex</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">
          <see cref="T:System.Security.AccessControl.MutexSecurity" /> 物件，代表要套用至具名系統 Mutex 的存取控制安全性。</param>
        <summary>為具名系統 Mutex 設定存取控制安全性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用者必須擁有<xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>呼叫這個方法中，並將 mutex 的權限必須是與開啟<xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列程式碼範例會示範具名 mutex 的跨處理序行為具有存取控制安全性。 此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。  
  
 如果 mutex 不存在，它會建立初始擁有權與拒絕目前的使用者使用 mutex 的權限，但是會授與讀取和變更 mutex 的權限的權限的存取控制安全性。  
  
 如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。 攔截到例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更權限，並使用所需的權限開啟 mutex<xref:System.Threading.Mutex.GetAccessControl%2A>和<xref:System.Threading.Mutex.SetAccessControl%2A>方法。  
  
 權限變更之後，輸入，並釋放它所需的權限開啟 mutex。 如果您從第三個 [命令] 視窗中執行編譯的範例，它會執行使用新的權限。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.UnauthorizedAccessException">該使用者沒有 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />。  
  
-或- 
並未以 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> 開啟 Mutex。</exception>
        <exception cref="T:System.SystemException">目前的 <see cref="T:System.Threading.Mutex" /> 物件不代表具名系統 Mutex。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開啟指定的具名 mutex (如果已經存在)，並傳回值，指出作業是否成功。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">要開啟的系統 Mutex 的名稱。</param>
        <param name="result">當這個方法傳回時，如果呼叫成功，則包含代表具名 Mutex 的 <see cref="T:System.Threading.Mutex" /> 物件；如果呼叫失敗，則為 <see langword="null" />。 這個參數會被視為未初始化。</param>
        <summary>開啟指定的具名 mutex (如果已經存在)，並傳回值，指出作業是否成功。</summary>
        <returns>如果已成功開啟具名 Mutex，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果具名的 mutex 不存在，這個方法不會建立它。 若要建立的系統 mutex，已不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。  
  
 如果您不確定是否已命名的 mutex 已存在，請使用這個方法多載，而不是<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載，則會擲回例外狀況，如果 mutex 不存在。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。  
  
 這個方法多載就相當於呼叫<xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29>方法多載，並指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。 指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒等候 mutex，並指定<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。  
  
 這個方法不會要求 mutex 擁有權。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 為空字串。  
  
-或- 
 <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名的 Mutex 已存在，但使用者沒有使用它所需的安全性存取權。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">要開啟的系統 Mutex 的名稱。</param>
        <param name="rights">列舉值的位元組合，表示所需的安全性存取。</param>
        <param name="result">當這個方法傳回時，如果呼叫成功，則包含代表具名 Mutex 的 <see cref="T:System.Threading.Mutex" /> 物件；如果呼叫失敗，則為 <see langword="null" />。 這個參數會被視為未初始化。</param>
        <summary>使用所需的安全性存取權，開啟指定的具名 mutex (如果已經存在)，並傳回值，指出作業是否成功。</summary>
        <returns>如果已成功開啟具名 Mutex，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果具名的 mutex 不存在，這個方法不會建立它。 若要建立的系統 mutex，已不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。  
  
 如果您不確定是否已命名的 mutex 已存在，請使用這個方法多載，而不是<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載，則會擲回例外狀況，如果 mutex 不存在。  
  
 `rights`參數必須包含<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標，好讓執行緒等候 mutex，而<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。  
  
 使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。  
  
 這個方法不會要求 mutex 擁有權。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> 為空字串。  
  
-或- 
 <paramref name="name" /> 的長度超過 260 個字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">發生 Win32 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">具名的 Mutex 已存在，但使用者沒有使用它所需的安全性存取權。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
      </Docs>
    </Member>
  </Members>
</Type>