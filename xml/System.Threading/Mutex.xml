<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6bce0feaf14f66f8608164cfa777620d7f3b329f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530992" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="2ec5f-101">同步處理原始物件也可用於進行處理序之間的同步處理。</span>
      <span class="sxs-lookup">
        <span data-stu-id="2ec5f-101">A synchronization primitive that can also be used for interprocess synchronization.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-102">當兩個或多個執行緒需要同時存取共用的資源時，系統就會需要同步處理機制，以確保一次只有一個執行緒使用的資源。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-102">When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</span></span> <span data-ttu-id="2ec5f-103"><xref:System.Threading.Mutex> 為基本，只有一個執行緒的共用資源獨佔存取權授與同步處理。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-103"><xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</span></span> <span data-ttu-id="2ec5f-104">如果執行緒取得 mutex，則會暫停想要取得該 mutex 的第二個執行緒，直到第一個執行緒釋放 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-104">If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2ec5f-105">此類型會實作<xref:System.IDisposable>介面。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-105">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="2ec5f-106">當您完成使用類型時，您應該會處置它直接或間接。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-106">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="2ec5f-107">若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-107">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="2ec5f-108">若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-108">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="2ec5f-109">如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-109">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="2ec5f-110">您可以使用<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>方法，要求 mutex 擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-110">You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method to request ownership of a mutex.</span></span> <span data-ttu-id="2ec5f-111">呼叫執行緒封鎖，直到發生下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="2ec5f-111">The calling thread blocks until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="2ec5f-112">Mutex 發出信號以指出它未擁有。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-112">The mutex is signaled to indicate that it is not owned.</span></span> <span data-ttu-id="2ec5f-113">當發生這種情況時，<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`true`，和呼叫的執行緒會假設 mutex 擁有權，並存取 mutex 所保護的資源。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-113">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</span></span> <span data-ttu-id="2ec5f-114">當它完成存取資源時，必須呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法，以釋放 mutex 擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-114">When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex.</span></span> <span data-ttu-id="2ec5f-115">在範例區段中的第一個範例說明這個模式。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-115">The first example in the Examples section illustrates this pattern.</span></span>  
  
-   <span data-ttu-id="2ec5f-116">若要呼叫中指定的逾時間隔<xref:System.Threading.WaitHandle.WaitOne%2A>方法`millisecondsTimeout`或`timeout`參數。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-116">The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed.</span></span> <span data-ttu-id="2ec5f-117">當發生這種情況時，<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`false`，和呼叫的執行緒不會進一步嘗試取得 mutex 擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-117">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex.</span></span> <span data-ttu-id="2ec5f-118">在此情況下，您應該建構您的程式碼以便 mutex 所保護之資源的存取被拒呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-118">In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</span></span> <span data-ttu-id="2ec5f-119">執行緒永遠不會取得 mutex 擁有權，因為它不可以呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-119">Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span> <span data-ttu-id="2ec5f-120">在範例區段中的第二個範例說明這個模式。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-120">The second example in the Examples section illustrates this pattern.</span></span>  
  
 <span data-ttu-id="2ec5f-121"><xref:System.Threading.Mutex>因此只要取得它的執行緒釋放 mutex 執行緒識別、 強制執行的類別。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-121">The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</span></span> <span data-ttu-id="2ec5f-122">相反地，<xref:System.Threading.Semaphore>類別不會強制執行執行緒識別。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-122">By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity.</span></span> <span data-ttu-id="2ec5f-123">Mutex，也可以跨應用程式定義域界限傳遞。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-123">A mutex can also be passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="2ec5f-124">擁有 mutex 的執行緒可以要求中重複呼叫相同的 mutex<xref:System.Threading.WaitHandle.WaitOne%2A>而不會封鎖其執行。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-124">The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution.</span></span> <span data-ttu-id="2ec5f-125">不過，必須呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法釋放 mutex 擁有權相同次數。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-125">However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-126">因為<xref:System.Threading.Mutex>類別繼承自<xref:System.Threading.WaitHandle>，您也可以呼叫靜態<xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>和<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>方法以同步存取受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-126">Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods to synchronize access to a protected resource.</span></span>  
  
 <span data-ttu-id="2ec5f-127">如果執行緒終止時擁有 mutex，即稱為放棄 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-127">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="2ec5f-128">Mutex 的狀態會設為收到信號，並等候的執行緒會取得擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-128">The state of the mutex is set to signaled, and the next waiting thread gets ownership.</span></span> <span data-ttu-id="2ec5f-129">.NET Framework 2.0 版開始<xref:System.Threading.AbandonedMutexException>取得已放棄的 mutex 的下一個執行緒中擲回。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-129">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex.</span></span> <span data-ttu-id="2ec5f-130">之前版本的.NET Framework 2.0，不擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-130">Before version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="2ec5f-131">已放棄的 mutex 通常表示程式碼中的嚴重錯誤。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-131">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="2ec5f-132">當執行緒結束但未釋放 mutex 時，mutex 所保護的資料結構可能未處於一致的狀態。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-132">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="2ec5f-133">要求 mutex 擁有權的下一個執行緒可以處理這個例外狀況，並繼續進行，如果能夠確認資料結構的完整性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-133">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="2ec5f-134">如果是全系統 Mutex，遭到放棄的 Mutex 可能表示應用程式已意外終止 (例如，透過使用「Windows 工作管理員」)。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-134">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
 <span data-ttu-id="2ec5f-135">Mutex 有兩種類型： 本機 mutex，也就是未命名，然後具名系統 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-135">Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</span></span> <span data-ttu-id="2ec5f-136">本機 Mutex只存在於您的處理序內。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-136">A local mutex exists only within your process.</span></span> <span data-ttu-id="2ec5f-137">可供您參考的程序中的任何執行緒<xref:System.Threading.Mutex>表示將 mutex 的物件。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-137">It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex.</span></span> <span data-ttu-id="2ec5f-138">每個未命名的<xref:System.Threading.Mutex>物件都代表不同的本機 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-138">Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-139">具名的系統 mutex 可在作業系統各處並可用來同步處理程序的活動。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-139">Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="2ec5f-140">您可以建立<xref:System.Threading.Mutex>藉由使用的建構函式接受名稱，表示具名的系統 mutex 的物件。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-140">You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name.</span></span> <span data-ttu-id="2ec5f-141">可以建立作業系統物件，在相同的時間，或者可以存在之前建立<xref:System.Threading.Mutex>物件。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-141">The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object.</span></span> <span data-ttu-id="2ec5f-142">您可以建立多個 <xref:System.Threading.Mutex> 物件來代表同一個具名系統 Mutex，而且可以使用 <xref:System.Threading.Mutex.OpenExisting%2A> 方法來開啟現有的具名系統 Mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-142">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2ec5f-143">在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-143">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="2ec5f-144">如果其名稱開頭為前置詞"Global\\"，mutex 會顯示所有的終端機伺服器工作階段中。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-144">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="2ec5f-145">如果其名稱開頭為前置詞 「 本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-145">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="2ec5f-146">在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-146">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="2ec5f-147">如果您沒有指定前置詞建立具名的 mutex 時，會在前置詞 「 本機\\"。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-147">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="2ec5f-148">在終端機伺服器工作階段中，兩個名稱只有不同及其前置詞的 mutex 個別 mutex，而且兩者都在終端機伺服器工作階段中顯示所有處理程序。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-148">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="2ec5f-149">也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段、 不是相對於處理程序的 mutex 名稱的範圍。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-149">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 <span data-ttu-id="2ec5f-150">這個範例會示範如何在本機<xref:System.Threading.Mutex>物件用來同步存取受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-150">This example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="2ec5f-151">因為每個呼叫的執行緒會封鎖，直到它會取得 mutex 擁有權，必須呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>方法，以釋放執行緒的擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-151">Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the thread.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="2ec5f-152">在下列範例中，每個執行緒呼叫<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29>取得 mutex 的方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-152">In the following example, each thread calls the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> method to acquire the mutex.</span></span> <span data-ttu-id="2ec5f-153">如果超過逾時間隔，則方法會傳回`false`，並在執行緒或都不會取得 mutex 取得 mutex 所保護之資源的存取。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-153">If the time-out interval elapses, the method returns `false`, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</span></span> <span data-ttu-id="2ec5f-154"><xref:System.Threading.Mutex.ReleaseMutex%2A>只要取得 mutex 的執行緒呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-154">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is called only by the thread that acquires the mutex.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="2ec5f-155">此型別具備執行緒安全。</span>
      <span class="sxs-lookup">
        <span data-stu-id="2ec5f-155">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2ec5f-156">初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-156">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2ec5f-157">使用預設屬性，初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-157">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-158">呼叫這個建構函式多載會呼叫相同<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式多載，並指定`false`mutex 的初始擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-158">Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex.</span></span> <span data-ttu-id="2ec5f-159">也就是說，呼叫的執行緒未擁有 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-159">That is, the calling thread does not own the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2ec5f-160">下列程式碼範例示範如何在本機<xref:System.Threading.Mutex>物件用來同步存取受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-160">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="2ec5f-161">建立 mutex 的執行緒未擁有它一開始。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-161">The thread that creates the mutex does not own it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="2ec5f-162">如果要把 Mutex 的初始擁有權提供給呼叫執行緒，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-162">
              <see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2ec5f-163">使用表示呼叫執行緒是否應該具有 Mutex 的初始擁有權的布林值，初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-163">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2ec5f-164">下列程式碼範例示範如何在本機<xref:System.Threading.Mutex>物件用來同步存取受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-164">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="2ec5f-165">建立的執行緒<xref:System.Threading.Mutex>一開始擁有它。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-165">The thread that creates the <xref:System.Threading.Mutex> owns it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="2ec5f-166">
            <see langword="true" /> 表示如果這個呼叫的結果建立了具名系統 Mutex，則將具名系統 Mutex 的初始擁有權授與呼叫執行緒，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-166">
              <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="2ec5f-167">
            <see cref="T:System.Threading.Mutex" /> 的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-167">The name of the <see cref="T:System.Threading.Mutex" />.</span>
          </span>
          <span data-ttu-id="2ec5f-168">如果值是 <see langword="null" />，則 <see cref="T:System.Threading.Mutex" /> 未命名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-168">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2ec5f-169">使用表示呼叫執行緒是否應該具有 Mutex 的初始擁有權的布林值，以及代表 Mutex 名稱的字串，初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-169">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-170">如果`name`不`null`和`initiallyOwned`是`true`，只有這個呼叫的結果建立了具名的系統 mutex 時，呼叫的執行緒擁有 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-170">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</span></span> <span data-ttu-id="2ec5f-171">因為沒有任何機制可判斷是否已建立了具名的系統 mutex，最好是在指定`false`如`initiallyOwned`時呼叫這個建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-171">Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload.</span></span> <span data-ttu-id="2ec5f-172">您可以使用<xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29>建構函式，如果您需要決定的初始擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-172">You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.</span></span>  
  
 <span data-ttu-id="2ec5f-173">這個建構函式初始化<xref:System.Threading.Mutex>代表具名的系統 mutex 的物件。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-173">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="2ec5f-174">您可以建立多個<xref:System.Threading.Mutex>物件，代表相同的具名系統 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-174">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-175">如果具名的 mutex 已建立具有存取控制安全性，而且呼叫端沒有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>，擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-175">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="2ec5f-176">若要開啟現有的具名 mutex 以所需的同步處理執行緒活動，這些權限，請參閱<xref:System.Threading.Mutex.OpenExisting%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-176">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="2ec5f-177">如果您指定`null`或為空字串。 `name`，建立本機 mutex 時，您必須呼叫<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-177">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="2ec5f-178">在此情況下，`createdNew`一律`true`。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-178">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="2ec5f-179">因為它們是全系統，具名的 mutex 可以用於協調資源使用跨處理序界限。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-179">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2ec5f-180">在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-180">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="2ec5f-181">如果其名稱開頭為前置詞"Global\\"，mutex 會顯示所有的終端機伺服器工作階段中。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-181">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="2ec5f-182">如果其名稱開頭為前置詞 「 本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-182">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="2ec5f-183">在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-183">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="2ec5f-184">如果您沒有指定前置詞建立具名的 mutex 時，會在前置詞 「 本機\\"。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-184">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="2ec5f-185">在終端機伺服器工作階段中，兩個名稱只有不同及其前置詞的 mutex 個別 mutex，而且兩者都在終端機伺服器工作階段中顯示所有處理程序。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-185">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="2ec5f-186">也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段、 不是相對於處理程序的 mutex 名稱的範圍。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-186">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 <span data-ttu-id="2ec5f-187">下列範例示範如何用來表示兩個不同的處理序中執行的執行緒之間的具名的 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-187">The following example shows how a named mutex is used to signal between threads running in two separate processes.</span></span>  
  
 <span data-ttu-id="2ec5f-188">從兩個或多個命令視窗執行此程式。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-188">Run this program from two or more command windows.</span></span> <span data-ttu-id="2ec5f-189">每個程序會建立<xref:System.Threading.Mutex>物件，代表具名的 mutex `MyMutex`。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-189">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex `MyMutex`.</span></span> <span data-ttu-id="2ec5f-190">具名的 mutex 為系統物件的存留期會受限於其存留期<xref:System.Threading.Mutex>代表它的物件。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-190">The named mutex is a system object whose lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="2ec5f-191">第一個程序建立時，系統會建立具名的 mutex 其<xref:System.Threading.Mutex>物件; 在此範例中，具名的 mutex 擁有者是執行程式的第一個程序。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-191">The named mutex is created when the first process creates its <xref:System.Threading.Mutex> object; in this example, the named mutex is owned by the first process that runs the program.</span></span> <span data-ttu-id="2ec5f-192">具名的 mutex 被終結時所有<xref:System.Threading.Mutex>已發行物件，表示它。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-192">The named mutex is destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span>  
  
 <span data-ttu-id="2ec5f-193">此範例中使用的建構函式多載無法分辨是否具名 mutex 的初始擁有權已授與呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-193">The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</span></span> <span data-ttu-id="2ec5f-194">您不應該使用這個建構函式來要求的初始擁有權，除非您可以確定執行緒會建立具名的 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-194">You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="2ec5f-195">具名 Mutex 已存在，並且具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-195">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="2ec5f-196">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-196">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="2ec5f-197">無法建立具名 Mutex，可能是因為不同類型的等候控制代碼具有相同的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-197">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2ec5f-198">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-198">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2ec5f-199">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-199">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2ec5f-200">這個成員無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-200">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="2ec5f-201">
            <see langword="true" /> 表示如果這個呼叫的結果建立了具名系統 Mutex，則將具名系統 Mutex 的初始擁有權授與呼叫執行緒，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-201">
              <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="2ec5f-202">
            <see cref="T:System.Threading.Mutex" /> 的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-202">The name of the <see cref="T:System.Threading.Mutex" />.</span>
          </span>
          <span data-ttu-id="2ec5f-203">如果值是 <see langword="null" />，則 <see cref="T:System.Threading.Mutex" /> 未命名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-203">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="2ec5f-204">當此方法傳回時，如果已建立本機 Mutex (也就是說，如果 <c>Name</c> 為 <see langword="null" /> 或空字串)，或是已建立指定的具名系統 Mutex，則會包含 <see langword="true" /> 的布林值；如果指定的具名系統 Mutex 已存在，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-204">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span>
          </span>
          <span data-ttu-id="2ec5f-205">這個參數會以未初始化的狀態傳遞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-205">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2ec5f-206">使用表示呼叫執行緒是否應該具有 Mutex 的初始擁有權的布林值、代表 Mutex 名稱的字串，以及當方法傳回時表示是否將 Mutex 的初始擁有權授與呼叫執行緒的布林值，初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-206">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-207">如果`name`不`null`和`initiallyOwned`是`true`，呼叫的執行緒擁有具名的 mutex 才`createdNew`是`true`呼叫之後。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-207">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="2ec5f-208">否則，執行緒時，可以藉由呼叫要求 mutex<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-208">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="2ec5f-209">這個建構函式初始化<xref:System.Threading.Mutex>代表具名的系統 mutex 的物件。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-209">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="2ec5f-210">您可以建立多個<xref:System.Threading.Mutex>物件，代表相同的具名系統 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-210">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-211">如果具名的 mutex 已建立具有存取控制安全性，而且呼叫端沒有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>權限，擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-211">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> rights, an exception is thrown.</span></span> <span data-ttu-id="2ec5f-212">若要開啟現有的具名 mutex 以所需的同步處理執行緒活動，這些權限，請參閱<xref:System.Threading.Mutex.OpenExisting%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-212">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="2ec5f-213">如果您指定`null`或為空字串。 `name`，建立本機 mutex 時，您必須呼叫<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-213">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="2ec5f-214">在此情況下，`createdNew`一律`true`。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-214">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="2ec5f-215">因為它們是全系統，具名的 mutex 可以用於協調資源使用跨處理序界限。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-215">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2ec5f-216">在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-216">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="2ec5f-217">如果其名稱開頭為前置詞"Global\\"，mutex 會顯示所有的終端機伺服器工作階段中。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-217">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="2ec5f-218">如果其名稱開頭為前置詞 「 本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-218">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="2ec5f-219">在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-219">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="2ec5f-220">如果您沒有指定前置詞建立具名的 mutex 時，會在前置詞 「 本機\\"。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-220">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="2ec5f-221">在終端機伺服器工作階段中，兩個名稱只有不同及其前置詞的 mutex 個別 mutex，而且兩者都在終端機伺服器工作階段中顯示所有處理程序。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-221">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="2ec5f-222">也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段、 不是相對於處理程序的 mutex 名稱的範圍。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-222">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 <span data-ttu-id="2ec5f-223">下列程式碼範例示範如何用來表示處理序或執行緒之間的具名的 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-223">The following code example shows how a named mutex is used to signal between processes or threads.</span></span> <span data-ttu-id="2ec5f-224">從兩個或多個命令視窗執行此程式。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-224">Run this program from two or more command windows.</span></span> <span data-ttu-id="2ec5f-225">每個程序會建立<xref:System.Threading.Mutex>物件，代表具名的 mutex"MyMutex"。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-225">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex "MyMutex".</span></span> <span data-ttu-id="2ec5f-226">具名的 mutex 為系統物件。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-226">The named mutex is a system object.</span></span> <span data-ttu-id="2ec5f-227">在此範例中，其存留期會受限於的存留期<xref:System.Threading.Mutex>代表它的物件。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-227">In this example, its lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="2ec5f-228">第一個程序會建立其區域變數時，系統會建立具名的 mutex<xref:System.Threading.Mutex>物件，並終結時所有<xref:System.Threading.Mutex>已發行物件，表示它。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-228">The named mutex is created when the first process creates its local <xref:System.Threading.Mutex> object, and destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span> <span data-ttu-id="2ec5f-229">具名的 mutex，一開始是由第一個處理序所擁有。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-229">The named mutex is initially owned by the first process.</span></span> <span data-ttu-id="2ec5f-230">第二個程序和任何後續的處理序等候先前的處理序釋放具名的 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-230">The second process and any subsequent processes wait for earlier processes to release the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="2ec5f-231">具名 Mutex 已存在，並且具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-231">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="2ec5f-232">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-232">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="2ec5f-233">無法建立具名 Mutex，可能是因為不同類型的等候控制代碼具有相同的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-233">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2ec5f-234">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-234">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2ec5f-235">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-235">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2ec5f-236">這個成員無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-236">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <span data-ttu-id="2ec5f-237">
            <see langword="true" /> 表示如果這個呼叫的結果建立了具名系統 Mutex，則將具名系統 Mutex 的初始擁有權授與呼叫執行緒，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-237">
              <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="2ec5f-238">系統 Mutex 的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-238">The name of the system mutex.</span>
          </span>
          <span data-ttu-id="2ec5f-239">如果值是 <see langword="null" />，則 <see cref="T:System.Threading.Mutex" /> 未命名。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-239">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="2ec5f-240">當此方法傳回時，如果已建立本機 Mutex (也就是說，如果 <c>Name</c> 為 <see langword="null" /> 或空字串)，或是已建立指定的具名系統 Mutex，則會包含 <see langword="true" /> 的布林值；如果指定的具名系統 Mutex 已存在，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-240">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span>
          </span>
          <span data-ttu-id="2ec5f-241">這個參數會以未初始化的狀態傳遞。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-241">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="mutexSecurity">
          <span data-ttu-id="2ec5f-242">
            <see cref="T:System.Security.AccessControl.MutexSecurity" /> 物件，代表要套用至具名系統 Mutex 的存取控制安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-242">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2ec5f-243">使用表示呼叫執行緒是否應該具有 Mutex 的初始擁有權的布林值、代表 Mutex 名稱的字串、當這個方法傳回時表示是否將 Mutex 的初始擁有權授與呼叫執行緒的布林值，以及要套用至具名 Mutex 的存取控制安全性，初始化 <see cref="T:System.Threading.Mutex" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-243">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-244">如果`name`不`null`和`initiallyOwned`是`true`，呼叫的執行緒擁有具名的 mutex 才`createdNew`是`true`呼叫之後。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-244">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="2ec5f-245">否則，執行緒時，可以藉由呼叫要求 mutex<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-245">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="2ec5f-246">您可以使用這個建構函式套用至具名的系統 mutex 的存取控制安全性，其建立時，避免其他程式碼取得 mutex 的控制項。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-246">Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-247">這個建構函式初始化<xref:System.Threading.Mutex>代表具名的系統 mutex 的物件。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-247">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="2ec5f-248">您可以建立多個<xref:System.Threading.Mutex>物件，代表相同的具名系統 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-248">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-249">如果不存在了具名的系統 mutex，則會建立具有指定的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-249">If the named system mutex does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="2ec5f-250">如果具名的 mutex 已存在，則會忽略指定的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-250">If the named mutex exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2ec5f-251">呼叫端具有對於新建立的完整控制權<xref:System.Threading.Mutex>物件，即使`mutexSecurity`拒絕，或將某些存取權授與目前的使用者就會失敗。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-251">The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="2ec5f-252">不過，如果目前的使用者試圖取得另一個<xref:System.Threading.Mutex>物件來代表相同的具名 mutex，使用建構函式或<xref:System.Threading.Mutex.OpenExisting%2A>方法時，Windows 會套用存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-252">However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="2ec5f-253">如果具名的 mutex 已建立具有存取控制安全性，而且呼叫端沒有<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>，擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-253">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="2ec5f-254">若要開啟現有的具名 mutex 以所需的同步處理執行緒活動，這些權限，請參閱<xref:System.Threading.Mutex.OpenExisting%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-254">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="2ec5f-255">如果您指定`null`或為空字串。 `name`，建立本機 mutex 時，您必須呼叫<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-255">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="2ec5f-256">在此情況下，`createdNew`一律`true`。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-256">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="2ec5f-257">因為它們是全系統，具名的 mutex 可以用於協調資源使用跨處理序界限。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-257">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2ec5f-258">在伺服器上執行終端機服務，具名的系統 mutex 可以有兩個層級的可見性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-258">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="2ec5f-259">如果其名稱開頭為前置詞"Global\\"，mutex 會顯示所有的終端機伺服器工作階段中。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-259">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="2ec5f-260">如果其名稱開頭為前置詞 「 本機\\"，mutex 只會顯示在終端機伺服器工作階段建立位置。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-260">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="2ec5f-261">在此情況下，具有相同名稱的另一個 mutex 可以存在於每個伺服器上的其他終端機伺服器工作階段。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-261">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="2ec5f-262">如果您沒有指定前置詞建立具名的 mutex 時，會在前置詞 「 本機\\"。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-262">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="2ec5f-263">在終端機伺服器工作階段中，兩個名稱只有不同及其前置詞的 mutex 個別 mutex，而且兩者都在終端機伺服器工作階段中顯示所有處理程序。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-263">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="2ec5f-264">也就是前置詞名稱"Global\\」 和 「 本機\\」 描述相對於終端機伺服器工作階段、 不是相對於處理程序的 mutex 名稱的範圍。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-264">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 <span data-ttu-id="2ec5f-265">下列程式碼範例示範具名 mutex 的跨處理序的行為與存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-265">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="2ec5f-266">此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-266">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-267">如果 mutex 不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限使用 mutex，但讀取和變更的權限將 mutex 的權限會授與存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-267">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-268">如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-268">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="2ec5f-269">例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限所需的權限來開啟 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-269">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="2ec5f-270">變更權限之後，輸入，並釋放它所需的權限開啟 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-270">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="2ec5f-271">如果您是從第三個命令視窗執行編譯的範例，它會使用執行新的權限。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-271">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="2ec5f-272">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-272">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="2ec5f-273">具名 Mutex 已存在，並且具有存取控制安全性，但使用者沒有 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-273">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="2ec5f-274">無法建立具名 Mutex，可能是因為不同類型的等候控制代碼具有相同的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-274">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2ec5f-275">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-275">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2ec5f-276">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-276">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2ec5f-277">這個成員無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-277">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2ec5f-278">取得 <see cref="T:System.Security.AccessControl.MutexSecurity" /> 物件，代表具名 Mutex 的存取控制安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-278">Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2ec5f-279">
            <see cref="T:System.Security.AccessControl.MutexSecurity" /> 物件，代表具名 Mutex 的存取控制安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-279">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-280"><xref:System.Threading.Mutex.GetAccessControl%2A>方法會使用下列旗標 （使用位元 OR 運算結合） 的組合來搜尋權限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-280">The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2ec5f-281">使用者必須擁有<xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>呼叫這個方法和 mutex 必須已經開啟與<xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-281">The user must have <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2ec5f-282">下列程式碼範例示範具名 mutex 的跨處理序的行為與存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-282">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="2ec5f-283">此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-283">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-284">如果 mutex 不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限使用 mutex，但讀取和變更的權限將 mutex 的權限會授與存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-284">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-285">如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-285">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="2ec5f-286">例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限，並使用所需的權限來開啟 mutex<xref:System.Threading.Mutex.GetAccessControl%2A>和<xref:System.Threading.Mutex.SetAccessControl%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-286">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="2ec5f-287">變更權限之後，輸入，並釋放它所需的權限開啟 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-287">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="2ec5f-288">如果您是從第三個命令視窗執行編譯的範例，它會使用執行新的權限。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-288">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="2ec5f-289">目前的 <see cref="T:System.Threading.Mutex" /> 物件表示具名系統 Mutex，但是使用者沒有 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-289">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span>
          </span>
          <span data-ttu-id="2ec5f-290">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-290">-or-</span>
          </span>
          <span data-ttu-id="2ec5f-291">目前的 <see cref="T:System.Threading.Mutex" /> 物件表示具名系統 Mutex，而且不是以 <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> 開啟。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-291">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2ec5f-292">不支援 Windows 98 或 Windows Millennium Edition。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-292">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2ec5f-293">開啟指定的具名 mutex (如果已經存在)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-293">Opens a specified named mutex, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2ec5f-294">要開啟的系統 Mutex 的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-294">The name of the system mutex to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2ec5f-295">開啟指定的具名 mutex (如果已經存在)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-295">Opens the specified named mutex, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2ec5f-296">表示具名系統 Mutex 的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-296">An object that represents the named system mutex.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-297"><xref:System.Threading.Mutex.OpenExisting%2A>方法嘗試開啟指定的具名系統 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-297">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex.</span></span> <span data-ttu-id="2ec5f-298">如果不存在的系統 mutex，這個方法會擲回的例外狀況，而非建立系統物件。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-298">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="2ec5f-299">若要建立的系統 mutex，已經不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-299">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="2ec5f-300">使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-300">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-301">這個方法多載就相當於呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載，並指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-301">This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="2ec5f-302">指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒正在等候 mutex，並指定<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-302">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="2ec5f-303">這個方法不會要求 mutex 擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-303">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2ec5f-304">下列程式碼範例示範具名 mutex 的跨處理序的行為與存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-304">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="2ec5f-305">此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-305">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-306">如果 mutex 不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限使用 mutex，但讀取和變更的權限將 mutex 的權限會授與存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-306">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-307">如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-307">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="2ec5f-308">例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限所需的權限來開啟 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-308">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="2ec5f-309">變更權限之後，輸入，並釋放它所需的權限開啟 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-309">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="2ec5f-310">如果您是從第三個命令視窗執行編譯的範例，它會使用執行新的權限。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-310">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2ec5f-311">
            <paramref name="name" /> 為空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-311">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="2ec5f-312">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-312">-or-</span>
          </span>
          <span data-ttu-id="2ec5f-313">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-313">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2ec5f-314">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-314">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="2ec5f-315">具名 Mutex 不存在。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-315">The named mutex does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="2ec5f-316">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-316">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="2ec5f-317">具名的 Mutex 已存在，但使用者沒有使用它所需的安全性存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-317">The named mutex exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2ec5f-318">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-318">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2ec5f-319">這個成員無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-319">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2ec5f-320">要開啟的系統 Mutex 的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-320">The name of the system mutex to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="2ec5f-321">列舉值的位元組合，表示所需的安全性存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-321">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2ec5f-322">使用所需的安全性存取權，開啟指定的具名 mutex (如果已經存在)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-322">Opens the specified named mutex, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2ec5f-323">表示具名系統 Mutex 的物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-323">An object that represents the named system mutex.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-324">`rights`參數必須包含<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標以允許 mutex，等候的執行緒和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-324">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="2ec5f-325"><xref:System.Threading.Mutex.OpenExisting%2A>方法嘗試開啟現有的具名 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-325">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex.</span></span> <span data-ttu-id="2ec5f-326">如果不存在的系統 mutex，這個方法會擲回的例外狀況，而非建立系統物件。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-326">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="2ec5f-327">若要建立的系統 mutex，已經不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-327">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="2ec5f-328">使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-328">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-329">這個方法不會要求 mutex 擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-329">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2ec5f-330">下列程式碼範例示範具名 mutex 的跨處理序的行為與存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-330">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="2ec5f-331">此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-331">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-332">如果 mutex 不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限使用 mutex，但讀取和變更的權限將 mutex 的權限會授與存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-332">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-333">如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-333">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="2ec5f-334">例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限所需的權限來開啟 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-334">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="2ec5f-335">變更權限之後，輸入，並釋放它所需的權限開啟 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-335">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="2ec5f-336">如果您是從第三個命令視窗執行編譯的範例，它會使用執行新的權限。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-336">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2ec5f-337">
            <paramref name="name" /> 為空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-337">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="2ec5f-338">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-338">-or-</span>
          </span>
          <span data-ttu-id="2ec5f-339">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-339">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2ec5f-340">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-340">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="2ec5f-341">具名 Mutex 不存在。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-341">The named mutex does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="2ec5f-342">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-342">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="2ec5f-343">具名 Mutex 已存在，但是使用者沒有所需的安全性存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-343">The named mutex exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2ec5f-344">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-344">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2ec5f-345">這個成員無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-345">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2ec5f-346">釋出 <see cref="T:System.Threading.Mutex" /> 一次。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-346">Releases the <see cref="T:System.Threading.Mutex" /> once.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-347">每當執行緒取得 mutex (例如，藉由呼叫其<xref:System.Threading.WaitHandle.WaitOne%2A>方法)，必須在後續呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>放棄 mutex 擁有權及解除鎖定其他執行緒，嘗試取得 mutex 的擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-347">Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</span></span> <span data-ttu-id="2ec5f-348">如果嘗試取得 mutex 擁有權就會失敗 (例如，當呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>方法`millisecondsTimeout`或`timeout`參數傳回`false`因為要求逾時)，執行緒不應該呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>，在此案例中，執行緒應該也不允許存取受保護的 mutex，如下列範例所示的資源。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-348">If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 <span data-ttu-id="2ec5f-349">擁有 mutex 執行緒可以重複的等候函式呼叫中指定相同的 mutex 而不會封鎖其執行。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-349">A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</span></span> <span data-ttu-id="2ec5f-350">Common language runtime 所保留的呼叫數。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-350">The number of calls is kept by the common language runtime.</span></span> <span data-ttu-id="2ec5f-351">必須在呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>相同次數釋放 mutex 擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-351">The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-352">如果執行緒終止時擁有 mutex，即稱為放棄 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-352">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="2ec5f-353">Mutex 的狀態設定為收到信號並等候的執行緒會取得擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-353">The state of the mutex is set to signaled and the next waiting thread gets ownership.</span></span> <span data-ttu-id="2ec5f-354">如果沒有人擁有 mutex，則會指示的 mutex 狀態。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-354">If no one owns the mutex, the state of the mutex is signaled.</span></span> <span data-ttu-id="2ec5f-355">.NET Framework 2.0 版開始<xref:System.Threading.AbandonedMutexException>取得 mutex 的下一個執行緒中擲回。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-355">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex.</span></span> <span data-ttu-id="2ec5f-356">之前版本的.NET Framework 2.0，不擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-356">Prior to version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="2ec5f-357">已放棄的 mutex 通常表示程式碼中的嚴重錯誤。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-357">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="2ec5f-358">當執行緒結束但未釋放 mutex 時，mutex 所保護的資料結構可能未處於一致的狀態。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-358">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="2ec5f-359">要求 mutex 擁有權的下一個執行緒可以處理這個例外狀況，並繼續進行，如果能夠確認資料結構的完整性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-359">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="2ec5f-360">如果是全系統 Mutex，遭到放棄的 Mutex 可能表示應用程式已意外終止 (例如，透過使用「Windows 工作管理員」)。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-360">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2ec5f-361">下列範例會示範如何在本機<xref:System.Threading.Mutex>物件用來同步存取受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-361">The following example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="2ec5f-362">建立 mutex 的執行緒未擁有它一開始。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-362">The thread that creates the mutex does not own it initially.</span></span> <span data-ttu-id="2ec5f-363"><xref:System.Threading.Mutex.ReleaseMutex%2A>方法用來在不再需要時釋放 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-363">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is used to release the mutex when it is no longer needed.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="2ec5f-364">呼叫端執行緒未擁有 Mutex。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-364">The calling thread does not own the mutex.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="2ec5f-365">目前的執行個體已經過處置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-365">The current instance has already been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">
          <span data-ttu-id="2ec5f-366">
            <see cref="T:System.Security.AccessControl.MutexSecurity" /> 物件，代表要套用至具名系統 Mutex 的存取控制安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-366">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2ec5f-367">為具名系統 Mutex 設定存取控制安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-367">Sets the access control security for a named system mutex.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-368">使用者必須擁有<xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>呼叫這個方法，並將 mutex 的權限必須是與開啟<xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-368">The user must have <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2ec5f-369">下列程式碼範例示範具名 mutex 的跨處理序的行為與存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-369">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="2ec5f-370">此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載來測試是否存在的具名 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-370">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-371">如果 mutex 不存在，就會建立使用的初始擁有權和拒絕目前使用者的權限使用 mutex，但讀取和變更的權限將 mutex 的權限會授與存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-371">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-372">如果您從兩個命令視窗執行編譯的範例，第二個副本將會擲回存取違規的例外狀況上呼叫<xref:System.Threading.Mutex.OpenExisting%28System.String%29>。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-372">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="2ec5f-373">例外狀況時，和此範例會使用<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載來讀取和變更的權限，並使用所需的權限來開啟 mutex<xref:System.Threading.Mutex.GetAccessControl%2A>和<xref:System.Threading.Mutex.SetAccessControl%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-373">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="2ec5f-374">變更權限之後，輸入，並釋放它所需的權限開啟 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-374">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="2ec5f-375">如果您是從第三個命令視窗執行編譯的範例，它會使用執行新的權限。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-375">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2ec5f-376">
            <paramref name="mutexSecurity" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-376">
              <paramref name="mutexSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="2ec5f-377">使用者沒有 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-377">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span>
          </span>
          <span data-ttu-id="2ec5f-378">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-378">-or-</span>
          </span>
          <span data-ttu-id="2ec5f-379">並未以 <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> 開啟 Mutex。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-379">The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="2ec5f-380">目前的 <see cref="T:System.Threading.Mutex" /> 物件不代表具名系統 Mutex。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-380">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2ec5f-381">開啟指定的具名 mutex (如果已經存在)，並傳回值，指出作業是否成功。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-381">Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2ec5f-382">要開啟的系統 Mutex 的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-382">The name of the system mutex to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="2ec5f-383">當這個方法傳回時，如果呼叫成功，則包含代表具名 Mutex 的 <see cref="T:System.Threading.Mutex" /> 物件；如果呼叫失敗，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-383">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="2ec5f-384">這個參數會被視為未初始化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-384">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2ec5f-385">開啟指定的具名 mutex (如果已經存在)，並傳回值，指出作業是否成功。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-385">Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2ec5f-386">如果已成功開啟具名 Mutex，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-386">
              <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-387">如果不存在的具名的 mutex，這個方法不會建立它。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-387">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="2ec5f-388">若要建立的系統 mutex，已經不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-388">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="2ec5f-389">如果您不確定是否存在的具名的 mutex，則使用這個方法多載，而不是<xref:System.Threading.Mutex.OpenExisting%28System.String%29>方法多載，如果 mutex 不存在，擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-389">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="2ec5f-390">使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-390">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-391">這個方法多載就相當於呼叫<xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29>方法多載，並指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-391">This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="2ec5f-392">指定<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒正在等候 mutex，並指定<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-392">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="2ec5f-393">這個方法不會要求 mutex 擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-393">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2ec5f-394">
            <paramref name="name" /> 為空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-394">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="2ec5f-395">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-395">-or-</span>
          </span>
          <span data-ttu-id="2ec5f-396">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-396">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2ec5f-397">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-397">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="2ec5f-398">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-398">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="2ec5f-399">具名的 Mutex 已存在，但使用者沒有使用它所需的安全性存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-399">The named mutex exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2ec5f-400">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-400">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2ec5f-401">這個成員無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-401">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2ec5f-402">要開啟的系統 Mutex 的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-402">The name of the system mutex to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="2ec5f-403">列舉值的位元組合，表示所需的安全性存取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-403">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="2ec5f-404">當這個方法傳回時，如果呼叫成功，則包含代表具名 Mutex 的 <see cref="T:System.Threading.Mutex" /> 物件；如果呼叫失敗，則為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-404">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="2ec5f-405">這個參數會被視為未初始化。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-405">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2ec5f-406">使用所需的安全性存取權，開啟指定的具名 mutex (如果已經存在)，並傳回值，指出作業是否成功。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-406">Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2ec5f-407">如果已成功開啟具名 Mutex，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-407">
              <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2ec5f-408">如果不存在的具名的 mutex，這個方法不會建立它。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-408">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="2ec5f-409">若要建立的系統 mutex，已經不存在時，使用其中一種<xref:System.Threading.Mutex.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-409">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="2ec5f-410">如果您不確定是否存在的具名的 mutex，則使用這個方法多載，而不是<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>方法多載，如果 mutex 不存在，擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-410">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="2ec5f-411">`rights`參數必須包含<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>旗標以允許 mutex，等候的執行緒和<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.Mutex.ReleaseMutex%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-411">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="2ec5f-412">使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Mutex>物件，即使傳回的物件代表相同的具名的系統 mutex。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-412">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="2ec5f-413">這個方法不會要求 mutex 擁有權。</span><span class="sxs-lookup"><span data-stu-id="2ec5f-413">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2ec5f-414">
            <paramref name="name" /> 為空字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-414">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="2ec5f-415">-或-</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-415">-or-</span>
          </span>
          <span data-ttu-id="2ec5f-416">
            <paramref name="name" /> 的長度超過 260 個字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-416">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2ec5f-417">
            <paramref name="name" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-417">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="2ec5f-418">發生 Win32 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-418">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="2ec5f-419">具名的 Mutex 已存在，但使用者沒有使用它所需的安全性存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-419">The named mutex exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2ec5f-420">需要完全信任立即呼叫者。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-420">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2ec5f-421">這個成員無法供部分信任或安全性透明程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="2ec5f-421">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>