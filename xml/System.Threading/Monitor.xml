<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a64388618647a3dd8b7bcaeb6947b0859c86418b" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58707430" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供一套機制，同步處理物件的存取。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Monitor>類別可讓您取得和釋放特定物件上的鎖定，藉由呼叫由同步處理的程式碼區域的存取<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>， <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>，和<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>方法。 物件鎖定提供限制存取的程式碼中，通常稱為重要區段區塊的能力。 雖然執行緒擁有物件的鎖定，沒有其他執行緒可以取得該鎖定。 您也可以使用<xref:System.Threading.Monitor>類別，以確保沒有其他執行緒是否可存取應用程式一段程式碼正在執行的鎖定擁有者，除非另一個執行緒正在執行使用不同的鎖定的物件的程式碼。  
  
 本文內容：  
  
 [監視類別：概觀](#Overview)   
 [鎖定物件](#Lock)   
 [重要區段](#CriticalSection)   
 [Pulse 及 PulseAll 等候](#Pulse)   
 [監視與等候控制代碼](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>監視類別：概觀  
 <xref:System.Threading.Monitor> 具有下列功能：  
  
-   它是隨選物件相關聯。  
  
-   它是未繫結，這表示它可以直接從任何內容進行呼叫。  
  
-   執行個體<xref:System.Threading.Monitor>無法建立類別; 方法的<xref:System.Threading.Monitor>類別都是靜態的。 每個方法會同步處理的物件可控制存取重要的一節。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>字串以外的鎖定物件的類別 (也就是參考型別以外<xref:System.String>)，不實值型別。 如需詳細資訊，請參閱的多載<xref:System.Threading.Monitor.Enter%2A>方法和[之鎖定物件](#Lock)本文稍後的章節。  
  
 下表描述可以存取已同步處理的物件的執行緒所採取的動作：  
  
|動作|描述|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>、 <xref:System.Threading.Monitor.TryEnter%2A>|取得物件的鎖定。 此動作也會標示重要區段的開頭。 沒有任何其他執行緒可以進入重要區段，除非它使用不同的鎖定的物件的重要區段中執行的指示。|  
|<xref:System.Threading.Monitor.Wait%2A>|釋放鎖定物件以允許其他執行緒鎖定，並存取該物件。 另一個執行緒存取的物件，就會等候呼叫執行緒。 Pulse 信號用來通知等候中執行緒的相關物件的狀態變更。|  
|<xref:System.Threading.Monitor.Pulse%2A> （信號）， <xref:System.Threading.Monitor.PulseAll%2A>|傳送訊號給一或多個等候中執行緒。 訊號通知等候的執行緒已鎖定物件的狀態已變更，並鎖定的擁有者已準備好解除鎖定。 等候執行緒位於物件的就緒佇列，使其最終可能會接收物件的鎖定。 一旦執行緒擁有鎖定，它可以檢查以查看是否已到達所需的狀態物件的新狀態。|  
|<xref:System.Threading.Monitor.Exit%2A>|釋放物件上的鎖定。 此動作也會標示重要區段保護鎖定物件的結尾。|  
  
 開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，有兩組多載<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.TryEnter%2A>方法。 有一組多載`ref`（在 C# 中) 或`ByRef`（在 Visual Basic)<xref:System.Boolean>參數，自動設定為`true`如果已取得鎖定，即使取得鎖定時，會擲回例外狀況。 它是很重要，即使鎖定所保護的資源可能未處於一致的狀態，釋放在所有情況下，鎖定，請使用這些多載。  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>鎖定物件  
 Monitor 類別組成`static`（在 C# 中) 或`Shared`（在 Visual Basic)，控制的存取重要區段物件操作的方法。  每個同步處理的物件，並維護的下列資訊：  
  
-   目前擁有鎖定的執行緒參考。  
  
-   就緒佇列，其中包含已準備好取得鎖定的執行緒參考。  
  
-   等候佇列，其中包含正在等候的鎖定物件的狀態變更通知的執行緒參考。  
  
 <xref:System.Threading.Monitor> 會鎖定物件 (也就是參考類型)，而不會鎖定值類型。 雖然您可以傳遞值類型到 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>，它會個別針對每個呼叫進行 boxed 處理。 因為每個呼叫會建立不同的物件，<xref:System.Threading.Monitor.Enter%2A> 絕不會封鎖，且它應該要保護的程式碼不會真地同步處理。 此外，傳遞給 <xref:System.Threading.Monitor.Exit%2A> 的物件不同於傳遞給 <xref:System.Threading.Monitor.Enter%2A> 的物件，因此 <xref:System.Threading.Monitor> 會擲回 <xref:System.Threading.SynchronizationLockException> 例外狀況，以及訊息「從未同步處理的程式碼區塊呼叫物件同步化方法」。  
  
 下列範例說明此問題。 它會啟動 10 個工作，其中每個工作睡眠 250 毫秒。 每一項工作接著會更新計數器變數 `nTasks`，這是要計算實際啟動並執行的工作數目。 由於 `nTasks` 是可以同時由多個工作更新的全域變數，因此使用監視器來防止多個工作同時修改。 不過，如範例的輸出所示，每項工作都擲回 <xref:System.Threading.SynchronizationLockException> 例外狀況。  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 每個工作都擲回 <xref:System.Threading.SynchronizationLockException> 例外狀況是因為 `nTasks` 變數在呼叫每個工作中的 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法之前會進行 boxed 處理。 換句話說，每個方法呼叫都被傳遞個別的變數，且與其他變數無關。 `nTasks` 在呼叫 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 方法時會再次進行 boxed 處理。 同樣地，這會建立十個彼此獨立的新 boxed 變數 `nTasks`，以及在呼叫 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法時建立的十個 boxed 變數。 接著便擲回例外狀況，因為我們的程式碼嘗試對於先前未鎖定的新建變數釋放鎖定。  
  
 雖然您可以先將值類型變數進行 box 處理，然後再呼叫 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>，如下列範例所示，並將相同的 boxed 物件傳遞給這兩種方法，但這麼做並沒有任何益處。 變更 unboxed 變數不會反映在 boxed 複本，且沒有任何方法可變更 boxed 複本的值。  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 選取要同步處理的物件，您應該只鎖定私用或內部的物件。 外部物件上的鎖定可能會導致死結，因為不相關的程式碼可以選擇要針對不同用途鎖定相同物件。  
  
 請注意，您可以同步處理多個應用程式定義域中的物件如果用於鎖定的物件衍生自<xref:System.MarshalByRefObject>。  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>重要區段  
 使用<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>標記開頭和結尾的重要區段的方法。  
  
> [!NOTE]
>  所提供的功能<xref:System.Threading.Monitor.Enter%2A>並<xref:System.Threading.Monitor.Exit%2A>方法等同於所提供的[鎖定](~/docs/csharp/language-reference/keywords/lock-statement.md)在 C# 中的陳述式和[SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md)以外，在 Visual Basic 中的陳述式語言建構包裝<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType>方法多載而<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>方法中的`try`...`finally` 若要確保此監視器會釋出區塊。  
  
 如果關鍵區段是一組連續的指示，然後取得的鎖定<xref:System.Threading.Monitor.Enter%2A>方法可確保只有單一執行緒可以執行括住的程式碼與鎖定的物件。 在此情況下，我們建議您將放在該程式碼`try`封鎖，並呼叫<xref:System.Threading.Monitor.Exit%2A>方法中的`finally`區塊。 這可確保即使發生例外狀況，就會釋放鎖定。 下列程式碼片段會示範這個模式。  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 這項功能通常用來同步處理存取設為靜態或類別的執行個體方法。  
  
 鎖定功能如果重要區段跨越整個方法，可藉由將放<xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>方法，並指定<xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized>建構函式中的值<xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>。 當您使用這個屬性，<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>方法呼叫則不需要。 下列程式碼片段會說明這種模式：  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 請注意，此屬性會使目前的執行緒持有的鎖定，直到此方法會傳回;如果可以更快解除鎖定，使用<xref:System.Threading.Monitor>類別，C#[鎖定](~/docs/csharp/language-reference/keywords/lock-statement.md)陳述式或 Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md)方法，而不是屬性內的陳述式。  
  
 雖然您可以針對<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>鎖定並釋放跨成員或類別界限或兩者的指定的物件的陳述式，不建議這種做法。  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Pulse 及 PulseAll 等候  
 一旦執行緒擁有鎖定，而且已進入鎖定保護重要區段，它可以呼叫<xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>， <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>，和<xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>方法。  
  
 當執行緒保留的鎖定呼叫<xref:System.Threading.Monitor.Wait%2A>、 解除鎖定和執行緒會新增至同步處理的物件的等候佇列。 第一個執行緒在準備好的佇列中，如果有的話，取得鎖定，並進入重要區段。 執行緒會從等待佇列移到就緒佇列時任一<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>（要移動，執行緒必須等待佇列的開頭） 或<xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>持有鎖定的執行緒會呼叫方法。 <xref:System.Threading.Monitor.Wait%2A>方法傳回時呼叫的執行緒重新取得鎖定。  
  
 當執行緒保留的鎖定呼叫<xref:System.Threading.Monitor.Pulse%2A>，開頭的等候佇列的執行緒會移到就緒佇列。 若要呼叫<xref:System.Threading.Monitor.PulseAll%2A>方法將所有執行緒從等待佇列都移到就緒佇列。  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>監視與等候控制代碼  
 請務必注意使用之間的差別<xref:System.Threading.Monitor>類別和<xref:System.Threading.WaitHandle>物件。  
  
-   <xref:System.Threading.Monitor>類別是純粹 managed、 完全可攜性，而且可能是作業系統資源需求方面更有效率。  
  
-   <xref:System.Threading.WaitHandle> 物件代表作業系統可等候物件、適用於 managed 和 unmanaged 程式碼之間的同步處理，並且公開一些進階的作業系統功能，例如一次等候許多物件的能力。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Threading.Monitor>類別來同步存取所代表的隨機號碼產生器的單一執行個體<xref:System.Random>類別。 此範例會建立 10 個工作，其中每一個執行緒集區執行緒以非同步方式執行。 每個工作會產生 10,000 個隨機數字，計算其平均值，然後更新維護加總產生的隨機數字的數目和其總和的兩個程序層級變數。 尚未執行所有工作之後，這兩個值然後用來計算整體的平均值。  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 從任何執行緒集區執行緒上執行的工作，可以存取它們，因為存取變數`total`和`n`也必須同步處理。 <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType>方法適用於此目的。  
  
 下列範例示範如何結合的使用<xref:System.Threading.Monitor>類別 (實作`lock`或`SyncLock`語言建構)，則<xref:System.Threading.Interlocked>類別，而<xref:System.Threading.AutoResetEvent>類別。 它會定義兩個 `internal` (在 C# 中) 或 `Friend` (在 Visual Basic 中) 類別 `SyncResource` 和 `UnSyncResource`，分別提供對資源的同步存取和非同步存取。 為了確保範例說明同步存取和非同步存取 (如果每個方法呼叫都迅速完成則可能發生這種情況) 之間的差異，這個方法會包含隨機延遲：針對其 <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> 屬性為偶數的執行緒，這個方法會呼叫 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 以引入 2,000 毫秒的延遲。 請注意，由於 `SyncResource` 類別不是公用的，因此不會有任何用戶端程式碼在同步處理的資源上取得鎖定；內部類別本身會取得鎖定。 這可防止惡意程式碼在公開物件上取得鎖定。  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 這個範例會定義變數 `numOps`，以定義將會嘗試存取資源的執行緒數目。 應用程式執行緒會針對同步存取和非同步存取各呼叫 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 方法五次。 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 方法具有單一參數和不接受任何參數的一個委派，並且不會傳回任何值。 針對同步存取，它會叫用 `SyncUpdateResource` 方法；針對未同步存取，它會叫用 `UnSyncUpdateResource` 方法。 在方法呼叫的每個設定之後呼叫的應用程式執行緒[AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*)方法，以封鎖直到<xref:System.Threading.AutoResetEvent>執行個體收到訊號。  
  
 每次呼叫 `SyncUpdateResource` 方法都會呼叫內部 `SyncResource.Access` 方法，然後呼叫 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 方法以遞減 `numOps` 計數器。 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法會用於遞減計數器，因為否則您無法確定第二個執行緒將會存取值，才能在第一個執行緒的遞減值儲存在變數。 當上次同步處理背景工作執行緒遞減計數器為零時，表示所有同步處理的執行緒已完成存取資源，`SyncUpdateResource`方法呼叫<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>方法，以指示主執行緒繼續執行執行。  
  
 每次呼叫 `UnSyncUpdateResource` 方法都會呼叫內部 `UnSyncResource.Access` 方法，然後呼叫 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 方法以遞減 `numOps` 計數器。 同樣地，<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法會用於遞減計數器，以確保第二個執行緒不會無法存取值在第一個執行緒的遞減值已指派給變數之前。 當上次非同步處理背景工作執行緒遞減計數器為零時，指出沒有其他非同步處理的執行緒需要存取資源，`UnSyncUpdateResource`方法呼叫<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>方法，以指示主執行緒繼續執行.  
  
 如範例輸出所示，同步存取可確保呼叫執行緒會先結束受保護的資源，其他執行緒才能存取該資源；每個執行緒都會等候其前置項。 相反地，若未鎖定，則會依執行緒到達的順序來呼叫 `UnSyncResource.Access` 方法。  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">執行緒物件和功能</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得指定之物件的獨佔鎖定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要從其上取得監視器鎖定的物件。</param>
        <summary>取得指定物件的獨佔鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`Enter`取得<xref:System.Threading.Monitor>上做為參數傳遞的物件。 如果已執行另一個執行緒`Enter`物件上但尚未執行對應<xref:System.Threading.Monitor.Exit%2A>，目前的執行緒將會封鎖直到另一個執行緒釋放物件。 它是合法的叫用相同的執行緒`Enter`不止一次，而不封鎖它; 不過，相同數目的`Exit`物件正在等候其他執行緒會解除封鎖之前，必須叫用呼叫。  
  
 使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。 當您傳遞到實值類型變數`Enter`，它會進行 boxed 處理做為物件。 如果您傳遞至相同的變數`Enter`同樣地，它會進行 boxed 處理為個別的物件，而且不會封鎖執行緒。 在此情況下，程式碼，`Monitor`是應該要保護不受保護。 此外，當您將變數傳遞給`Exit`，建立另一個不同的物件。 因為物件傳遞給`Exit`不同於傳遞至物件`Enter`，`Monitor`就會擲回<xref:System.Threading.SynchronizationLockException>。 如需詳細資訊，請參閱概念性主題[監視器](xref:System.Threading.Monitor)。  
  
 <xref:System.Threading.Thread.Interrupt%2A> 可插斷的執行緒正在等候輸入`Monitor`物件上。 A<xref:System.Threading.ThreadInterruptedException>就會擲回。  
  
 使用 C# `try`...`finally` block (`Try`…`Finally` 在 Visual Basic)，以確保您發行 「 監視器 」，或使用 C#`lock`陳述式 (`SyncLock`陳述式，在 Visual Basic 中的)，其中包裝<xref:System.Threading.Monitor.Enter%2A>並<xref:System.Threading.Monitor.Exit%2A>中的方法`try`...`finally` 區塊。  
  
   
  
## Examples  
 下列範例示範如何使用 `Enter` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <param name="lockTaken">嘗試取得鎖定的結果 (以傳址方式傳遞)。 輸入必須是 <see langword="false" />。 如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。 嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。  
  
注意：如果沒有發生例外狀況，這個方法的輸出一律為 <see langword="true" />。</param>
        <summary>取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`Enter`來取得<xref:System.Threading.Monitor>做為傳遞的物件上`obj`參數。 如果已執行另一個執行緒`Enter`物件上但尚未執行對應<xref:System.Threading.Monitor.Exit%2A>，目前的執行緒將會封鎖直到另一個執行緒釋放物件。 它是合法的叫用相同的執行緒`Enter`不止一次，而不封鎖它; 不過，相同數目的`Exit`物件正在等候其他執行緒會解除封鎖之前，必須叫用呼叫。  
  
 如果無法取得鎖定，因為發生例外狀況，針對指定的變數`lockTaken`參數是`false`這個方法會結束之後。 這可讓程式，以判斷是否需要釋出鎖定，請在所有情況下。 如果這個方法會傳回而不擲回例外狀況，針對指定的變數`lockTaken`參數永遠是`true`，並不需要進行測試。  
  
 使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。 當您傳遞到實值類型變數`Enter`，它會進行 boxed 處理做為物件。 如果您傳遞至相同的變數`Enter`同樣地，它會進行 boxed 處理為個別的物件，而且不會封鎖執行緒。 在此情況下，程式碼，`Monitor`是應該要保護不受保護。 此外，當您將變數傳遞給`Exit`，建立另一個不同的物件。 因為物件傳遞給`Exit`不同於傳遞至物件`Enter`，`Monitor`就會擲回<xref:System.Threading.SynchronizationLockException>。 如需詳細資訊，請參閱概念性主題[監視器](xref:System.Threading.Monitor)。  
  
 <xref:System.Threading.Thread.Interrupt%2A> 可插斷的執行緒正在等候輸入`Monitor`物件上。 A<xref:System.Threading.ThreadInterruptedException>就會擲回。  
  
   
  
## Examples  
 下列程式碼示範基本模式使用<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>方法多載。 這個多載一定會設定傳遞至變數的值`ref`參數 (`ByRef` Visual Basic 中) `lockTaken`，即使方法會擲回例外狀況，因此變數的值是以可靠的方式，來測試是否鎖定必須為釋出。  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要從其上釋出鎖定的物件。</param>
        <summary>釋出指定物件的獨佔鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫的執行緒必須在擁有鎖定`obj`參數。 如果呼叫的執行緒擁有之指定的物件上的鎖定，且有相同數目的`Exit`和<xref:System.Threading.Monitor.Enter%2A>呼叫物件，然後釋放鎖定為止。 如果呼叫執行緒已不會叫用`Exit`次數一樣多`Enter`，不會釋放鎖定。  
  
 如果解除鎖定其他執行緒處於就緒佇列物件，其中一個執行緒取得鎖定。 如果其他執行緒在等候取得鎖定的等候佇列中，它們不會自動移動到就緒佇列時的鎖定擁有者會呼叫`Exit`。 若要一或多個等候執行緒進入就緒佇列，呼叫<xref:System.Threading.Monitor.Pulse%2A>或是<xref:System.Threading.Monitor.PulseAll%2A>叫用之前`Exit`。  
  
   
  
## Examples  
 下列範例示範如何使用 `Exit` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">目前執行緒沒有指定物件的鎖定。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">要測試的物件。</param>
        <summary>判斷目前執行緒是否保持鎖定指定的物件。</summary>
        <returns>如果目前的執行緒掌握 <paramref name="obj" /> 的鎖定，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法僅適用於所使用的方法取得的鎖定<xref:System.Threading.Monitor>類別，或使用 C#`lock`陳述式或 Visual Basic`SyncLock`陳述式，以實作<xref:System.Threading.Monitor>。  
  
 使用此方法使用診斷工具，例如<xref:System.Diagnostics.Debug.Assert%2A>方法和<xref:System.Diagnostics.Contracts.Contract>類別，涉及的鎖定問題進行偵錯<xref:System.Threading.Monitor>類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">執行緒正等候的物件。</param>
        <summary>通知等候佇列中的執行緒，鎖定物件的狀態有所變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有目前鎖定的擁有者可以發出信號，使用等候物件`Pulse`。  
  
 目前擁有指定的物件上鎖定的執行緒叫用這個方法來通知鎖定的行中的下一個執行緒。 在收到的 pulse 時，等候的執行緒會移到就緒佇列。 當執行緒叫用`Pulse`釋出鎖定，準備佇列 （也就是不一定接受 pulse 的執行緒） 中的下一個執行緒取得鎖定。  
  
> [!IMPORTANT]
>  <xref:System.Threading.Monitor>類別不會維護狀態，指出<xref:System.Threading.Monitor.Pulse%2A>已呼叫方法。 因此，如果您呼叫<xref:System.Threading.Monitor.Pulse%2A>當沒有執行緒在等候下, 一個呼叫的執行緒<xref:System.Threading.Monitor.Wait%2A>區塊如同<xref:System.Threading.Monitor.Pulse%2A>從未呼叫。 如果使用兩個執行緒<xref:System.Threading.Monitor.Pulse%2A>和<xref:System.Threading.Monitor.Wait%2A>互動，這可能導致死結。 與此相反的行為與<xref:System.Threading.AutoResetEvent>類別：如果您發出信號<xref:System.Threading.AutoResetEvent>藉由呼叫其<xref:System.Threading.EventWaitHandle.Set%2A>方法，沒有執行緒在等待，而<xref:System.Threading.AutoResetEvent>仍會處於收到信號的狀態，直到執行緒呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>， <xref:System.Threading.WaitHandle.WaitAny%2A>，或<xref:System.Threading.WaitHandle.WaitAll%2A>。 <xref:System.Threading.AutoResetEvent>釋放該執行緒，並傳回未發出訊號的狀態。  
  
 請注意 同步處理的物件擁有數個的參考，包括目前持有鎖定、 參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考的等候佇列之執行緒的參考它包含執行緒等候的物件的狀態變更通知。  
  
 `Pulse`， <xref:System.Threading.Monitor.PulseAll%2A>，和<xref:System.Threading.Monitor.Wait%2A>方法必須從叫用同步處理的程式碼區塊中。  
  
 若要表示多個執行緒，使用<xref:System.Threading.Monitor.PulseAll%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼叫執行緒沒有指定物件的鎖定。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">送出 Pulse 的物件。</param>
        <summary>通知所有等候中的執行緒，物件的狀態有所變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前擁有指定的物件上鎖定的執行緒叫用這個方法來通知所有執行緒等候取得鎖定的物件。 傳送訊號後，等候中執行緒會移到就緒佇列。 當執行緒叫用`PulseAll`釋出鎖定，就緒佇列中的下一個執行緒取得鎖定。  
  
 請注意 同步處理的物件擁有數個的參考，包括目前持有鎖定、 參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考的等候佇列之執行緒的參考它包含執行緒等候的物件的狀態變更通知。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， `PulseAll`，和<xref:System.Threading.Monitor.Wait%2A>方法必須從叫用同步處理的程式碼區塊中。  
  
 如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。  
  
 若要表示的單一執行緒，使用`Pulse`方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼叫執行緒沒有指定物件的鎖定。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>嘗試取得指定物件的獨佔鎖定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <summary>嘗試取得指定物件的獨佔鎖定。</summary>
        <returns>如果目前執行緒取得鎖定，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成功，這個方法會取得獨佔的鎖定上`obj`參數。 這個方法會立即傳回，鎖定可用。  
  
 這個方法很類似<xref:System.Threading.Monitor.Enter%2A>，但它會永遠不會封鎖目前的執行緒。 如果執行緒無法輸入而不會封鎖，則方法會傳回`false,`。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>文章。  
  
 若要確保執行緒不會進入重要區段，您應該檢查方法的傳回值，並在重要區段中執行程式碼，其傳回值時，才`true`。 下列程式碼片段會顯示用來呼叫這個方法的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 `TryEnter` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <param name="lockTaken">嘗試取得鎖定的結果 (以傳址方式傳遞)。 輸入必須是 <see langword="false" />。 如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。 嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。</param>
        <summary>嘗試取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成功，這個方法會取得獨佔的鎖定上`obj`參數。 這個方法會立即傳回，鎖定可用。  
  
 如果無法取得鎖定，因為發生例外狀況，針對指定的變數`lockTaken`參數是`false`這個方法會結束之後。 這可讓程式，以判斷是否需要釋出鎖定，請在所有情況下。  
  
 這個方法很類似<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>，但它會永遠不會封鎖目前的執行緒。 如果執行緒無法輸入而不會封鎖，`lockTaken`引數設定為`false`方法傳回時。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>文章。  
  
 為了確保執行緒不會進入重要區段，您應該檢查的值`lockTaken`並執行程式碼在重要區段中，只有其值是`true`。 下列程式碼片段會顯示用來呼叫這個方法的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 下列程式碼示範基本模式使用<xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>方法多載。 這個多載一定會設定傳遞至變數的值`ref`參數 (`ByRef` Visual Basic 中) `lockTaken`，即使方法會擲回例外狀況，因此變數的值是以可靠的方式，來測試是否鎖定必須為釋出。  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <param name="millisecondsTimeout">等候鎖定的毫秒數。</param>
        <summary>嘗試取得指定物件的獨佔鎖定 (在指定的毫秒數時間內)。</summary>
        <returns>如果目前執行緒取得鎖定，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`參數等於<xref:System.Threading.Timeout.Infinite>，這個方法相當於<xref:System.Threading.Monitor.Enter%2A>。 如果`millisecondsTimeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%2A>。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>文章。  
  
 若要確保執行緒不會進入重要區段，您應該檢查方法的傳回值，並在重要區段中執行程式碼，其傳回值時，才`true`。 下列程式碼片段會顯示用來呼叫這個方法的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 是負數，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />，代表等候鎖定的時間量。 -1 毫秒的值會指定無限期等候。</param>
        <summary>嘗試取得指定物件的獨佔鎖定 (在指定的時間內)。</summary>
        <returns>如果目前執行緒取得鎖定，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果值`timeout`轉換為毫秒的參數等於-1，這個方法就相當於<xref:System.Threading.Monitor.Enter%2A>。 如果值`timeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%2A>。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>類別主題。  
  
 若要確保執行緒不會進入重要區段，您應該檢查方法的傳回值，並在重要區段中執行程式碼，其傳回值時，才`true`。 下列程式碼片段會顯示用來呼叫這個方法的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 的毫秒值為負值且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (-1 毫秒)，或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <param name="millisecondsTimeout">等候鎖定的毫秒數。</param>
        <param name="lockTaken">嘗試取得鎖定的結果 (以傳址方式傳遞)。 輸入必須是 <see langword="false" />。 如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。 嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。</param>
        <summary>嘗試在指定的毫秒數內取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`參數等於<xref:System.Threading.Timeout.Infinite>，這個方法相當於<xref:System.Threading.Monitor.Enter%28System.Object%29>。 如果`millisecondsTimeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%28System.Object%29>。  
  
 如果無法取得鎖定，因為發生例外狀況，針對指定的變數`lockTaken`參數是`false`這個方法會結束之後。 這可讓程式，以判斷是否需要釋出鎖定，請在所有情況下。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>類別主題。  
  
 為了確保執行緒不會進入重要區段，您應該檢查的值`lockTaken`並執行程式碼在重要區段中，只有其值是`true`。 下列程式碼片段會顯示用來呼叫這個方法的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 下列程式碼示範基本模式使用<xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>方法多載。 這個多載一定會設定傳遞至變數的值`ref`參數 (`ByRef` Visual Basic 中) `lockTaken`，即使方法會擲回例外狀況，因此變數的值是以可靠的方式，來測試是否鎖定必須為釋出。  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 是負數，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <param name="timeout">等候鎖定的時間長度。 -1 毫秒的值會指定無限期等候。</param>
        <param name="lockTaken">嘗試取得鎖定的結果 (以傳址方式傳遞)。 輸入必須是 <see langword="false" />。 如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。 嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。</param>
        <summary>嘗試在指定的時間內取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果值`timeout`轉換為毫秒的參數等於-1，這個方法就相當於<xref:System.Threading.Monitor.Enter%28System.Object%29>。 如果值`timeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%28System.Object%29>。  
  
 如果無法取得鎖定，因為發生例外狀況，針對指定的變數`lockTaken`參數是`false`這個方法會結束之後。 這可讓程式，以判斷是否需要釋出鎖定，請在所有情況下。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>類別主題。  
  
 為了確保執行緒不會進入重要區段，您應該檢查的值`lockTaken`並執行程式碼在重要區段中，只有其值是`true`。 下列程式碼片段會顯示用來呼叫這個方法的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 的毫秒值為負值且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (-1 毫秒)，或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。</summary>
        <returns>如果因為呼叫端重新取得指定物件的鎖定所以呼叫被傳回，則為 <see langword="true" />。 如果鎖定不被重新取得，則這個方法不會傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，另一個執行緒可以存取它。 等候重新取得鎖定時，會封鎖呼叫端。 當呼叫端需要等待，因為另一個執行緒的作業而造成狀態變更時，會呼叫這個方法。  
  
 當執行緒呼叫`Wait`，它會釋放該物件上的鎖定，並進入物件的等候佇列。 物件的就緒佇列中的下一個執行緒 （如果有的話） 取得鎖定並會獨佔使用的物件。 所有呼叫的執行緒`Wait`仍在等待佇列，直到它們收到信號，以從<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>、 鎖定的擁有者所傳送。 如果`Pulse`傳送時，只有在等候佇列頂端的執行緒會受到影響。 如果`PulseAll`傳送時，會等候物件的所有執行緒會受到都影響。 收到訊號時，一或多個執行緒會離開等候佇列，並進入就緒佇列。 就緒佇列中的執行緒可以重新取得鎖定。  
  
 這個方法傳回時呼叫的執行緒重新取得鎖定的物件上。 請注意，此方法會無限期地封鎖如果鎖定的持有者不會呼叫`Pulse`或`PulseAll`。  
  
 呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。 就概念而言，`Wait`方法將儲存在呼叫端叫用次數`Enter`物件上叫用`Exit`次數所需的完全釋放鎖定的物件。 呼叫端會再封鎖等候重新取得物件時。 當呼叫端重新取得鎖定時，系統就會呼叫`Enter`所需的還原已儲存次數`Enter`呼叫端的計數。 呼叫`Wait`解除鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，會釋放這些鎖定不。  
  
 請注意 同步處理的物件擁有數個的參考，包括目前持有鎖定、 參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考的等候佇列之執行緒的參考它包含執行緒等候的物件的狀態變更通知。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊中。  
  
 如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼叫執行緒沒有指定物件的鎖定。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。 當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <param name="millisecondsTimeout">在執行緒進入就緒序列之前要等候的毫秒數。</param>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。 如果超過指定的逾時間隔時間，執行緒會進入就緒序列。</summary>
        <returns>如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。 要等到重新取得鎖定之後，此方法才會傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會傳回在重新取得獨佔鎖定直到`obj`參數。  
  
 目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，另一個執行緒可以存取它。 等候重新取得鎖定時，會封鎖呼叫端。 當呼叫端需要等待，因為另一個執行緒的作業而造成狀態變更時，會呼叫這個方法。  
  
 逾時可確保目前的執行緒在如果另一個執行緒釋放的鎖定，但是未先呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 它也會在執行緒移動到就緒佇列，以便它可以更快重新取得鎖定，請略過它之前等候佇列中的其他執行緒。 執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新取得鎖定之前的逾時。執行緒可以評估導致它進入等候條件，才需要呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。  
  
 當執行緒呼叫`Wait`，它會釋放該物件上的鎖定，並進入物件的等候佇列。 物件的就緒佇列中的下一個執行緒 （如果有的話） 取得鎖定並會獨佔使用的物件。 叫用的執行緒`Wait`仍會保留在等候佇列，直到保留鎖定的執行緒叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保留鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。 不過，如果`millisecondsTimeout`另一個執行緒叫用這個物件的前經過<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移到就緒佇列上，才能重新取得鎖定。  
  
> [!NOTE]
>  如果<xref:System.Threading.Timeout.Infinite>指定了`millisecondsTimeout`參數，此方法會封鎖無限期地鎖定的持有者會呼叫除非<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`millisecondsTimeout`等於 0，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。  
  
 呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。 就概念而言，`Wait`方法將儲存在呼叫端叫用次數<xref:System.Threading.Monitor.Enter%2A>物件上叫用<xref:System.Threading.Monitor.Exit%2A>次數所需的完全釋放鎖定的物件。 呼叫端會再封鎖等候重新取得物件時。 當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>所需的還原已儲存次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。 呼叫`Wait`解除鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，會釋放這些鎖定不。  
  
> [!NOTE]
>  同步處理的物件擁有數個參考，包括目前持有鎖定，參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考等候佇列，其中包含執行緒的參考正在等候的物件的狀態變更通知的執行緒。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊中。  
  
 如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼叫執行緒沒有指定物件的鎖定。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。 當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 參數的值為負，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />，代表在執行緒進入就緒佇列之前要等候的時間量。</param>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。 如果超過指定的逾時間隔時間，執行緒會進入就緒序列。</summary>
        <returns>如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。 要等到重新取得鎖定之後，此方法才會傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會傳回在重新取得獨佔鎖定直到`obj`參數。  
  
 目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，另一個執行緒可以存取它。 等候重新取得鎖定時，會封鎖呼叫端。 當呼叫端需要等待，因為另一個執行緒的作業而造成狀態變更時，會呼叫這個方法。  
  
 逾時可確保目前的執行緒在如果另一個執行緒釋放的鎖定，但是未先呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 它也會在執行緒移動到就緒佇列，以便它可以更快重新取得鎖定，請略過它之前等候佇列中的其他執行緒。 執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新取得鎖定之前的逾時。執行緒可以評估導致它進入等候條件，才需要呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。  
  
 當執行緒呼叫`Wait`，它會釋放該物件上的鎖定，並進入物件的等候佇列。 物件的就緒佇列中的下一個執行緒 （如果有的話） 取得鎖定並會獨佔使用的物件。 叫用的執行緒`Wait`仍會保留在等候佇列，直到保留鎖定的執行緒叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保留鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。 不過，如果`timeout`另一個執行緒叫用這個物件的前經過<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移到就緒佇列上，才能重新取得鎖定。  
  
> [!NOTE]
>  如果<xref:System.TimeSpan>會指定代表-1 毫秒`timeout`參數，此方法會封鎖無限期地鎖定的持有者會呼叫除非<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`timeout`為 0 毫秒，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。  
  
 呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。 就概念而言，`Wait`方法將儲存在呼叫端叫用次數<xref:System.Threading.Monitor.Enter%2A>物件上叫用<xref:System.Threading.Monitor.Exit%2A>次數所需的完全釋放鎖定的物件。 呼叫端會再封鎖等候重新取得物件時。 當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>所需的還原已儲存次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。 呼叫`Wait`解除鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，會釋放這些鎖定不。  
  
> [!NOTE]
>  同步處理的物件擁有數個參考，包括目前持有鎖定，參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考等候佇列，其中包含執行緒的參考正在等候的物件的狀態變更通知的執行緒。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊中。  
  
 如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼叫執行緒沒有指定物件的鎖定。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。 當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 參數的毫秒值為負值且不表示 <see cref="F:System.Threading.Timeout.Infinite" /> (-1 毫秒)，或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <param name="millisecondsTimeout">在執行緒進入就緒序列之前要等候的毫秒數。</param>
        <param name="exitContext">在等候前離開內容的同步化領域 (如果在同步化內容中) 並重新取得它，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。 如果超過指定的逾時間隔時間，執行緒會進入就緒序列。 這個方法也會指定等候之前和重新取得之後，是否要離開內容 (Context) 的同步處理領域 (如果在同步化內容中的話)。</summary>
        <returns>如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。 要等到重新取得鎖定之後，此方法才會傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會傳回在重新取得獨佔鎖定直到`obj`參數。  
  
 目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，另一個執行緒可以存取它。 等候重新取得鎖定時，會封鎖呼叫端。 當呼叫端需要等待，因為另一個執行緒的作業而造成狀態變更時，會呼叫這個方法。  
  
 逾時可確保目前的執行緒在如果另一個執行緒釋放的鎖定，但是未先呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 它也會在執行緒移動到就緒佇列，以便它可以更快重新取得鎖定，請略過它之前等候佇列中的其他執行緒。 執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新取得鎖定之前的逾時。執行緒可以評估導致它進入等候條件，才需要呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。  
  
 當執行緒呼叫`Wait`，它會釋放鎖定，並進入等待佇列。 此時，就緒佇列中的下一個執行緒 （如果有的話） 允許鎖定的控制。 叫用的執行緒`Wait`仍會保留在等候佇列，直到保留鎖定的執行緒叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保留鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。 不過，如果`millisecondsTimeout`另一個執行緒叫用這個物件的前經過<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移到就緒佇列上，才能重新取得鎖定。  
  
> [!NOTE]
>  如果<xref:System.Threading.Timeout.Infinite>指定了`millisecondsTimeout`參數，此方法會封鎖無限期地鎖定的持有者會呼叫除非<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`millisecondsTimeout`等於 0，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。  
  
 呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。 就概念而言，`Wait`方法將儲存在呼叫端叫用次數<xref:System.Threading.Monitor.Enter%2A>物件上叫用<xref:System.Threading.Monitor.Exit%2A>次數所需的完全釋放鎖定的物件。 呼叫端會再封鎖等候重新取得物件時。 當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>所需的還原已儲存次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。 呼叫`Wait`解除鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，會釋放這些鎖定不。  
  
> [!NOTE]
>  同步處理的物件擁有數個參考，包括目前持有鎖定，參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考等候佇列，其中包含執行緒的參考正在等候的物件的狀態變更通知的執行緒。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊中。  
  
 如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。  
  
## <a name="notes-on-exiting-the-context"></a>在結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.Monitor.Wait%2A>從非預設受管理的內容中呼叫方法。 如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.Monitor.Wait%2A>方法。 它會傳回呼叫之後為原始的非預設內容<xref:System.Threading.Monitor.Wait%2A>方法完成。  
  
 這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>套用的屬性。 在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.Monitor.Wait%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。 當<xref:System.Threading.Monitor.Wait%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> 不是從同步處理的程式碼區塊中呼叫。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。 當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 參數的值為負，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />，代表在執行緒進入就緒佇列之前要等候的時間量。</param>
        <param name="exitContext">在等候前離開內容的同步化領域 (如果在同步化內容中) 並重新取得它，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。 如果超過指定的逾時間隔時間，執行緒會進入就緒序列。 在等候之前和重新取得領域之後，可選擇性地結束同步化內容的同步處理領域。</summary>
        <returns>如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。 要等到重新取得鎖定之後，此方法才會傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會傳回在重新取得獨佔鎖定直到`obj`參數。  
  
 目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，另一個執行緒可以存取它。 等候重新取得鎖定時，會封鎖呼叫端。 當呼叫端需要等待，因為另一個執行緒的作業而造成狀態變更時，會呼叫這個方法。  
  
 逾時可確保目前的執行緒在如果另一個執行緒釋放的鎖定，但是未先呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 它也會在執行緒移動到就緒佇列，以便它可以更快重新取得鎖定，請略過它之前等候佇列中的其他執行緒。 執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新取得鎖定之前的逾時。執行緒可以評估導致它進入等候條件，才需要呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。  
  
 當執行緒呼叫`Wait`，它會釋放鎖定，並進入等待佇列。 此時，就緒佇列中的下一個執行緒 （如果有的話） 允許鎖定的控制。 叫用的執行緒`Wait`仍會保留在等候佇列，直到保留鎖定的執行緒叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保留鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。 不過，如果`timeout`另一個執行緒叫用這個物件經過毫秒<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移到就緒佇列上，才能重新取得鎖定。  
  
> [!NOTE]
>  如果<xref:System.TimeSpan>會指定代表-1 毫秒`timeout`參數，此方法會封鎖無限期地鎖定的持有者會呼叫除非<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`timeout`為 0 毫秒，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。  
  
 呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。 就概念而言，`Wait`方法將儲存在呼叫端叫用次數<xref:System.Threading.Monitor.Enter%2A>物件上叫用<xref:System.Threading.Monitor.Exit%2A>次數所需的完全釋放鎖定的物件。 呼叫端會再封鎖等候重新取得物件時。 當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>所需的還原已儲存次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。 呼叫`Wait`解除鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，會釋放這些鎖定不。  
  
> [!NOTE]
>  同步處理的物件擁有數個參考，包括目前持有鎖定，參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考等候佇列，其中包含執行緒的參考正在等候的物件的狀態變更通知的執行緒。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊中。  
  
 如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。  
  
## <a name="notes-on-exiting-the-context"></a>在結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.Monitor.Wait%2A>從非預設受管理的內容中呼叫方法。 如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.Monitor.Wait%2A>方法。 它會傳回呼叫之後為原始的非預設內容<xref:System.Threading.Monitor.Wait%2A>方法完成。  
  
 這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>套用的屬性。 在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.Monitor.Wait%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。 當<xref:System.Threading.Monitor.Wait%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> 不是從同步處理的程式碼區塊中呼叫。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">叫用 Wait 的執行緒稍後會從等候狀態中斷。 當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 參數為負值且不表示 <see cref="F:System.Threading.Timeout.Infinite" /> (-1 毫秒)，或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Managed 執行緒處理</related>
      </Docs>
    </Member>
  </Members>
</Type>