<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e925d576d52267c0e301b6428f677609e99940d3" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53230737" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="75a71-101">提供一套機制，同步處理物件的存取。</span><span class="sxs-lookup"><span data-stu-id="75a71-101">Provides a mechanism that synchronizes access to objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-102"><xref:System.Threading.Monitor>類別可讓您取得和釋放特定物件上的鎖定，藉由呼叫由同步處理的程式碼區域的存取<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>， <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>，和<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-102">The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="75a71-103">物件鎖定提供限制存取的程式碼中，通常稱為重要區段區塊的能力。</span><span class="sxs-lookup"><span data-stu-id="75a71-103">Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</span></span> <span data-ttu-id="75a71-104">雖然執行緒擁有物件的鎖定，沒有其他執行緒可以取得該鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-104">While a thread owns the lock for an object, no other thread can acquire that lock.</span></span> <span data-ttu-id="75a71-105">您也可以使用<xref:System.Threading.Monitor>類別，以確保沒有其他執行緒是否可存取應用程式一段程式碼正在執行的鎖定擁有者，除非另一個執行緒正在執行使用不同的鎖定的物件的程式碼。</span><span class="sxs-lookup"><span data-stu-id="75a71-105">You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</span></span>  
  
 <span data-ttu-id="75a71-106">本文內容：</span><span class="sxs-lookup"><span data-stu-id="75a71-106">In this article:</span></span>  
  
 <span data-ttu-id="75a71-107">[監視類別：概觀](#Overview) </span><span class="sxs-lookup"><span data-stu-id="75a71-107">[The Monitor class: An overview](#Overview) </span></span>  
 <span data-ttu-id="75a71-108">[鎖定物件](#Lock) </span><span class="sxs-lookup"><span data-stu-id="75a71-108">[The lock object](#Lock) </span></span>  
 <span data-ttu-id="75a71-109">[重要區段](#CriticalSection) </span><span class="sxs-lookup"><span data-stu-id="75a71-109">[The critical section](#CriticalSection) </span></span>  
 <span data-ttu-id="75a71-110">[Pulse 及 PulseAll 等候](#Pulse) </span><span class="sxs-lookup"><span data-stu-id="75a71-110">[Pulse, PulseAll, and Wait](#Pulse) </span></span>  
 [<span data-ttu-id="75a71-111">監視與等候控制代碼</span><span class="sxs-lookup"><span data-stu-id="75a71-111">Monitors and wait handles</span></span>](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a><span data-ttu-id="75a71-112">監視類別：概觀</span><span class="sxs-lookup"><span data-stu-id="75a71-112">The Monitor class: An overview</span></span>  
 <span data-ttu-id="75a71-113"><xref:System.Threading.Monitor> 具有下列功能：</span><span class="sxs-lookup"><span data-stu-id="75a71-113"><xref:System.Threading.Monitor> has the following features:</span></span>  
  
-   <span data-ttu-id="75a71-114">它是隨選物件相關聯。</span><span class="sxs-lookup"><span data-stu-id="75a71-114">It is associated with an object on demand.</span></span>  
  
-   <span data-ttu-id="75a71-115">它是未繫結，這表示它可以直接從任何內容進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-115">It is unbound, which means it can be called directly from any context.</span></span>  
  
-   <span data-ttu-id="75a71-116">執行個體<xref:System.Threading.Monitor>無法建立類別; 方法的<xref:System.Threading.Monitor>類別都是靜態的。</span><span class="sxs-lookup"><span data-stu-id="75a71-116">An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static.</span></span> <span data-ttu-id="75a71-117">每個方法會同步處理的物件可控制存取重要的一節。</span><span class="sxs-lookup"><span data-stu-id="75a71-117">Each method is passed the synchronized object that controls access to the critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-118">使用<xref:System.Threading.Monitor>字串以外的鎖定物件的類別 (也就是參考型別以外<xref:System.String>)，不實值型別。</span><span class="sxs-lookup"><span data-stu-id="75a71-118">Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types.</span></span> <span data-ttu-id="75a71-119">如需詳細資訊，請參閱的多載<xref:System.Threading.Monitor.Enter%2A>方法和[之鎖定物件](#Lock)本文稍後的章節。</span><span class="sxs-lookup"><span data-stu-id="75a71-119">For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.</span></span>  
  
 <span data-ttu-id="75a71-120">下表描述可以存取已同步處理的物件的執行緒所採取的動作：</span><span class="sxs-lookup"><span data-stu-id="75a71-120">The following table describes the actions that can be taken by threads that access synchronized objects:</span></span>  
  
|<span data-ttu-id="75a71-121">動作</span><span class="sxs-lookup"><span data-stu-id="75a71-121">Action</span></span>|<span data-ttu-id="75a71-122">描述</span><span class="sxs-lookup"><span data-stu-id="75a71-122">Description</span></span>|  
|------------|-----------------|  
|<span data-ttu-id="75a71-123"><xref:System.Threading.Monitor.Enter%2A>、 <xref:System.Threading.Monitor.TryEnter%2A></span><span class="sxs-lookup"><span data-stu-id="75a71-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span></span>|<span data-ttu-id="75a71-124">取得物件的鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-124">Acquires a lock for an object.</span></span> <span data-ttu-id="75a71-125">此動作也會標示重要區段的開頭。</span><span class="sxs-lookup"><span data-stu-id="75a71-125">This action also marks the beginning of a critical section.</span></span> <span data-ttu-id="75a71-126">沒有任何其他執行緒可以進入重要區段，除非它使用不同的鎖定的物件的重要區段中執行的指示。</span><span class="sxs-lookup"><span data-stu-id="75a71-126">No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</span></span>|  
|<xref:System.Threading.Monitor.Wait%2A>|<span data-ttu-id="75a71-127">釋放鎖定物件以允許其他執行緒鎖定，並存取該物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-127">Releases the lock on an object in order to permit other threads to lock and access the object.</span></span> <span data-ttu-id="75a71-128">另一個執行緒存取的物件，就會等候呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-128">The calling thread waits while another thread accesses the object.</span></span> <span data-ttu-id="75a71-129">Pulse 信號用來通知等候中執行緒的相關物件的狀態變更。</span><span class="sxs-lookup"><span data-stu-id="75a71-129">Pulse signals are used to notify waiting threads about changes to an object's state.</span></span>|  
|<span data-ttu-id="75a71-130"><xref:System.Threading.Monitor.Pulse%2A> （信號）， <xref:System.Threading.Monitor.PulseAll%2A></span><span class="sxs-lookup"><span data-stu-id="75a71-130"><xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A></span></span>|<span data-ttu-id="75a71-131">傳送訊號給一或多個等候中執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-131">Sends a signal to one or more waiting threads.</span></span> <span data-ttu-id="75a71-132">訊號通知等候的執行緒已鎖定物件的狀態已變更，並鎖定的擁有者已準備好解除鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-132">The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</span></span> <span data-ttu-id="75a71-133">等候執行緒位於物件的就緒佇列，使其最終可能會接收物件的鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-133">The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</span></span> <span data-ttu-id="75a71-134">一旦執行緒擁有鎖定，它可以檢查以查看是否已到達所需的狀態物件的新狀態。</span><span class="sxs-lookup"><span data-stu-id="75a71-134">Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</span></span>|  
|<xref:System.Threading.Monitor.Exit%2A>|<span data-ttu-id="75a71-135">釋放物件上的鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-135">Releases the lock on an object.</span></span> <span data-ttu-id="75a71-136">此動作也會標示重要區段保護鎖定物件的結尾。</span><span class="sxs-lookup"><span data-stu-id="75a71-136">This action also marks the end of a critical section protected by the locked object.</span></span>|  
  
 <span data-ttu-id="75a71-137">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，有兩組多載<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.TryEnter%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-137">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods.</span></span> <span data-ttu-id="75a71-138">有一組多載`ref`（在 C# 中) 或`ByRef`（在 Visual Basic)<xref:System.Boolean>參數，自動設定為`true`如果已取得鎖定，即使取得鎖定時，會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-138">One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock.</span></span> <span data-ttu-id="75a71-139">它是很重要，即使鎖定所保護的資源可能未處於一致的狀態，釋放在所有情況下，鎖定，請使用這些多載。</span><span class="sxs-lookup"><span data-stu-id="75a71-139">Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</span></span>  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a><span data-ttu-id="75a71-140">鎖定物件</span><span class="sxs-lookup"><span data-stu-id="75a71-140">The lock object</span></span>  
 <span data-ttu-id="75a71-141">Monitor 類別組成`static`（在 C# 中) 或`Shared`（在 Visual Basic)，控制的存取重要區段物件操作的方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-141">The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.</span></span>  <span data-ttu-id="75a71-142">每個同步處理的物件，並維護的下列資訊：</span><span class="sxs-lookup"><span data-stu-id="75a71-142">The following information is maintained for each synchronized object:</span></span>  
  
-   <span data-ttu-id="75a71-143">目前擁有鎖定的執行緒參考。</span><span class="sxs-lookup"><span data-stu-id="75a71-143">A reference to the thread that currently holds the lock.</span></span>  
  
-   <span data-ttu-id="75a71-144">就緒佇列，其中包含已準備好取得鎖定的執行緒參考。</span><span class="sxs-lookup"><span data-stu-id="75a71-144">A reference to a ready queue, which contains the threads that are ready to obtain the lock.</span></span>  
  
-   <span data-ttu-id="75a71-145">等候佇列，其中包含正在等候的鎖定物件的狀態變更通知的執行緒參考。</span><span class="sxs-lookup"><span data-stu-id="75a71-145">A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</span></span>  
  
 <span data-ttu-id="75a71-146"><xref:System.Threading.Monitor> 會鎖定物件 (也就是參考類型)，而不會鎖定值類型。</span><span class="sxs-lookup"><span data-stu-id="75a71-146"><xref:System.Threading.Monitor> locks objects (that is, reference types), not value types.</span></span> <span data-ttu-id="75a71-147">雖然您可以傳遞值類型到 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>，它會個別針對每個呼叫進行 boxed 處理。</span><span class="sxs-lookup"><span data-stu-id="75a71-147">While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call.</span></span> <span data-ttu-id="75a71-148">因為每個呼叫會建立不同的物件，<xref:System.Threading.Monitor.Enter%2A> 絕不會封鎖，且它應該要保護的程式碼不會真地同步處理。</span><span class="sxs-lookup"><span data-stu-id="75a71-148">Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized.</span></span> <span data-ttu-id="75a71-149">此外，傳遞給 <xref:System.Threading.Monitor.Exit%2A> 的物件不同於傳遞給 <xref:System.Threading.Monitor.Enter%2A> 的物件，因此 <xref:System.Threading.Monitor> 會擲回 <xref:System.Threading.SynchronizationLockException> 例外狀況，以及訊息「從未同步處理的程式碼區塊呼叫物件同步化方法」。</span><span class="sxs-lookup"><span data-stu-id="75a71-149">In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message "Object synchronization method was called from an unsynchronized block of code."</span></span>  
  
 <span data-ttu-id="75a71-150">下列範例說明此問題。</span><span class="sxs-lookup"><span data-stu-id="75a71-150">The following example illustrates this problem.</span></span> <span data-ttu-id="75a71-151">它會啟動 10 個工作，其中每個工作睡眠 250 毫秒。</span><span class="sxs-lookup"><span data-stu-id="75a71-151">It launches ten tasks, each of which just sleeps for 250 milliseconds.</span></span> <span data-ttu-id="75a71-152">每一項工作接著會更新計數器變數 `nTasks`，這是要計算實際啟動並執行的工作數目。</span><span class="sxs-lookup"><span data-stu-id="75a71-152">Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed.</span></span> <span data-ttu-id="75a71-153">由於 `nTasks` 是可以同時由多個工作更新的全域變數，因此使用監視器來防止多個工作同時修改。</span><span class="sxs-lookup"><span data-stu-id="75a71-153">Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</span></span> <span data-ttu-id="75a71-154">不過，如範例的輸出所示，每項工作都擲回 <xref:System.Threading.SynchronizationLockException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-154">However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 <span data-ttu-id="75a71-155">每個工作都擲回 <xref:System.Threading.SynchronizationLockException> 例外狀況是因為 `nTasks` 變數在呼叫每個工作中的 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法之前會進行 boxed 處理。</span><span class="sxs-lookup"><span data-stu-id="75a71-155">Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method in each task.</span></span> <span data-ttu-id="75a71-156">換句話說，每個方法呼叫都被傳遞個別的變數，且與其他變數無關。</span><span class="sxs-lookup"><span data-stu-id="75a71-156">In other words, each method call is passed a separate variable that is independent of the others.</span></span> <span data-ttu-id="75a71-157">`nTasks` 在呼叫 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 方法時會再次進行 boxed 處理。</span><span class="sxs-lookup"><span data-stu-id="75a71-157">`nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="75a71-158">同樣地，這會建立十個彼此獨立的新 boxed 變數 `nTasks`，以及在呼叫 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法時建立的十個 boxed 變數。</span><span class="sxs-lookup"><span data-stu-id="75a71-158">Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="75a71-159">接著便擲回例外狀況，因為我們的程式碼嘗試對於先前未鎖定的新建變數釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-159">The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</span></span>  
  
 <span data-ttu-id="75a71-160">雖然您可以先將值類型變數進行 box 處理，然後再呼叫 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>，如下列範例所示，並將相同的 boxed 物件傳遞給這兩種方法，但這麼做並沒有任何益處。</span><span class="sxs-lookup"><span data-stu-id="75a71-160">Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</span></span> <span data-ttu-id="75a71-161">變更 unboxed 變數不會反映在 boxed 複本，且沒有任何方法可變更 boxed 複本的值。</span><span class="sxs-lookup"><span data-stu-id="75a71-161">Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 <span data-ttu-id="75a71-162">選取要同步處理的物件，您應該只鎖定私用或內部的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-162">When selecting an object on which to synchronize, you should lock only on private or internal objects.</span></span> <span data-ttu-id="75a71-163">外部物件上的鎖定可能會導致死結，因為不相關的程式碼可以選擇要針對不同用途鎖定相同物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-163">Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</span></span>  
  
 <span data-ttu-id="75a71-164">請注意，您可以同步處理多個應用程式定義域中的物件如果用於鎖定的物件衍生自<xref:System.MarshalByRefObject>。</span><span class="sxs-lookup"><span data-stu-id="75a71-164">Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a><span data-ttu-id="75a71-165">重要區段</span><span class="sxs-lookup"><span data-stu-id="75a71-165">The critical section</span></span>  
 <span data-ttu-id="75a71-166">使用<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>標記開頭和結尾的重要區段的方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-166">Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-167">所提供的功能<xref:System.Threading.Monitor.Enter%2A>並<xref:System.Threading.Monitor.Exit%2A>方法等同於所提供的[鎖定](~/docs/csharp/language-reference/keywords/lock-statement.md)在 C# 中的陳述式和[SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md)以外，在 Visual Basic 中的陳述式語言建構包裝<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType>方法多載而<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>方法中的`try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="75a71-167">The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method in a `try`…`finally`</span></span> <span data-ttu-id="75a71-168">若要確保此監視器會釋出區塊。</span><span class="sxs-lookup"><span data-stu-id="75a71-168">block to ensure that the monitor is released.</span></span>  
  
 <span data-ttu-id="75a71-169">如果關鍵區段是一組連續的指示，然後取得的鎖定<xref:System.Threading.Monitor.Enter%2A>方法可確保只有單一執行緒可以執行括住的程式碼與鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-169">If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object.</span></span> <span data-ttu-id="75a71-170">在此情況下，我們建議您將放在該程式碼`try`封鎖，並呼叫<xref:System.Threading.Monitor.Exit%2A>方法中的`finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="75a71-170">In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block.</span></span> <span data-ttu-id="75a71-171">這可確保即使發生例外狀況，就會釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-171">This ensures that the lock is released even if an exception occurs.</span></span> <span data-ttu-id="75a71-172">下列程式碼片段會示範這個模式。</span><span class="sxs-lookup"><span data-stu-id="75a71-172">The following code fragment illustrates this pattern.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 <span data-ttu-id="75a71-173">這項功能通常用來同步處理存取設為靜態或類別的執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-173">This facility is typically used to synchronize access to a static or instance method of a class.</span></span>  
  
 <span data-ttu-id="75a71-174">鎖定功能如果重要區段跨越整個方法，可藉由將放<xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>方法，並指定<xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized>建構函式中的值<xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="75a71-174">If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="75a71-175">當您使用這個屬性，<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>方法呼叫則不需要。</span><span class="sxs-lookup"><span data-stu-id="75a71-175">When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed.</span></span> <span data-ttu-id="75a71-176">下列程式碼片段會說明這種模式：</span><span class="sxs-lookup"><span data-stu-id="75a71-176">The following code fragment illustrates this pattern:</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 <span data-ttu-id="75a71-177">請注意，此屬性會使目前的執行緒持有的鎖定，直到此方法會傳回;如果可以更快解除鎖定，使用<xref:System.Threading.Monitor>類別，C#[鎖定](~/docs/csharp/language-reference/keywords/lock-statement.md)陳述式或 Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md)方法，而不是屬性內的陳述式。</span><span class="sxs-lookup"><span data-stu-id="75a71-177">Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement, or the Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement inside of the method instead of the attribute.</span></span>  
  
 <span data-ttu-id="75a71-178">雖然您可以針對<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>鎖定並釋放跨成員或類別界限或兩者的指定的物件的陳述式，不建議這種做法。</span><span class="sxs-lookup"><span data-stu-id="75a71-178">While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</span></span>  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a><span data-ttu-id="75a71-179">Pulse 及 PulseAll 等候</span><span class="sxs-lookup"><span data-stu-id="75a71-179">Pulse, PulseAll, and Wait</span></span>  
 <span data-ttu-id="75a71-180">一旦執行緒擁有鎖定，而且已進入鎖定保護重要區段，它可以呼叫<xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>， <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>，和<xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-180">Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="75a71-181">當執行緒保留的鎖定呼叫<xref:System.Threading.Monitor.Wait%2A>、 解除鎖定和執行緒會新增至同步處理的物件的等候佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-181">When the thread that holds the lock calls <xref:System.Threading.Monitor.Wait%2A>, the lock is released and the thread is added to the waiting queue of the synchronized object.</span></span> <span data-ttu-id="75a71-182">第一個執行緒在準備好的佇列中，如果有的話，取得鎖定，並進入重要區段。</span><span class="sxs-lookup"><span data-stu-id="75a71-182">The first thread in the ready queue, if any, acquires the lock and enters the critical section.</span></span> <span data-ttu-id="75a71-183">執行緒會從等待佇列移到就緒佇列時任一<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>（要移動，執行緒必須等待佇列的開頭） 或<xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>持有鎖定的執行緒會呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-183">The thread is moved from the waiting queue to the ready queue when either the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> (to be moved, the thread must be at the head of the waiting queue) or the <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> method is called by the thread that holds the lock.</span></span> <span data-ttu-id="75a71-184"><xref:System.Threading.Monitor.Wait%2A>方法傳回時呼叫的執行緒重新取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-184">The <xref:System.Threading.Monitor.Wait%2A> method returns when the calling thread reacquires the lock.</span></span>  
  
 <span data-ttu-id="75a71-185">當執行緒保留的鎖定呼叫<xref:System.Threading.Monitor.Pulse%2A>，開頭的等候佇列的執行緒會移到就緒佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-185">When the thread that holds the lock calls <xref:System.Threading.Monitor.Pulse%2A>, the thread at the head of the waiting queue is moved to the ready queue.</span></span> <span data-ttu-id="75a71-186">若要呼叫<xref:System.Threading.Monitor.PulseAll%2A>方法將所有執行緒從等待佇列都移到就緒佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-186">The call to the <xref:System.Threading.Monitor.PulseAll%2A> method moves all the threads from the waiting queue to the ready queue.</span></span>  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a><span data-ttu-id="75a71-187">監視與等候控制代碼</span><span class="sxs-lookup"><span data-stu-id="75a71-187">Monitors and wait handles</span></span>  
 <span data-ttu-id="75a71-188">請務必注意使用之間的差別<xref:System.Threading.Monitor>類別和<xref:System.Threading.WaitHandle>物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-188">It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.</span></span>  
  
-   <span data-ttu-id="75a71-189"><xref:System.Threading.Monitor>類別是純粹 managed、 完全可攜性，而且可能是作業系統資源需求方面更有效率。</span><span class="sxs-lookup"><span data-stu-id="75a71-189">The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</span></span>  
  
-   <span data-ttu-id="75a71-190"><xref:System.Threading.WaitHandle> 物件代表作業系統可等候物件、適用於 managed 和 unmanaged 程式碼之間的同步處理，並且公開一些進階的作業系統功能，例如一次等候許多物件的能力。</span><span class="sxs-lookup"><span data-stu-id="75a71-190"><xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75a71-191">下列範例會使用<xref:System.Threading.Monitor>類別來同步存取所代表的隨機號碼產生器的單一執行個體<xref:System.Random>類別。</span><span class="sxs-lookup"><span data-stu-id="75a71-191">The following example uses the <xref:System.Threading.Monitor> class to synchronize access to a single instance of a random number generator represented by the <xref:System.Random> class.</span></span> <span data-ttu-id="75a71-192">此範例會建立 10 個工作，其中每一個執行緒集區執行緒以非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="75a71-192">The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</span></span> <span data-ttu-id="75a71-193">每個工作會產生 10,000 個隨機數字，計算其平均值，然後更新維護加總產生的隨機數字的數目和其總和的兩個程序層級變數。</span><span class="sxs-lookup"><span data-stu-id="75a71-193">Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</span></span> <span data-ttu-id="75a71-194">尚未執行所有工作之後，這兩個值然後用來計算整體的平均值。</span><span class="sxs-lookup"><span data-stu-id="75a71-194">After all tasks have executed, these two values are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="75a71-195">從任何執行緒集區執行緒上執行的工作，可以存取它們，因為存取變數`total`和`n`也必須同步處理。</span><span class="sxs-lookup"><span data-stu-id="75a71-195">Because they can be accessed from any task running on a thread pool thread, access to the variables `total` and `n` must also be synchronized.</span></span> <span data-ttu-id="75a71-196"><xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType>方法適用於此目的。</span><span class="sxs-lookup"><span data-stu-id="75a71-196">The <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> method is used for this purpose.</span></span>  
  
 <span data-ttu-id="75a71-197">下列範例示範如何結合的使用<xref:System.Threading.Monitor>類別 (實作`lock`或`SyncLock`語言建構)，則<xref:System.Threading.Interlocked>類別，而<xref:System.Threading.AutoResetEvent>類別。</span><span class="sxs-lookup"><span data-stu-id="75a71-197">The following example demonstrates the combined use of the <xref:System.Threading.Monitor> class (implemented with the `lock` or `SyncLock` language construct), the <xref:System.Threading.Interlocked> class, and the <xref:System.Threading.AutoResetEvent> class.</span></span> <span data-ttu-id="75a71-198">它會定義兩個 `internal` (在 C# 中) 或 `Friend` (在 Visual Basic 中) 類別 `SyncResource` 和 `UnSyncResource`，分別提供對資源的同步存取和非同步存取。</span><span class="sxs-lookup"><span data-stu-id="75a71-198">It defines two `internal` (in C#) or `Friend` (in Visual Basic) classes, `SyncResource` and `UnSyncResource`, that respectively provide synchronized and unsynchronized access to a resource.</span></span> <span data-ttu-id="75a71-199">為了確保範例說明同步存取和非同步存取 (如果每個方法呼叫都迅速完成則可能發生這種情況) 之間的差異，這個方法會包含隨機延遲：針對其 <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> 屬性為偶數的執行緒，這個方法會呼叫 <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> 以引入 2,000 毫秒的延遲。</span><span class="sxs-lookup"><span data-stu-id="75a71-199">To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property is even, the method calls <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> to introduce a delay of 2,000 milliseconds.</span></span> <span data-ttu-id="75a71-200">請注意，由於 `SyncResource` 類別不是公用的，因此不會有任何用戶端程式碼在同步處理的資源上取得鎖定；內部類別本身會取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-200">Note that, because the `SyncResource` class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</span></span> <span data-ttu-id="75a71-201">這可防止惡意程式碼在公開物件上取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-201">This prevents malicious code from taking a lock on a public object.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 <span data-ttu-id="75a71-202">這個範例會定義變數 `numOps`，以定義將會嘗試存取資源的執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="75a71-202">The example defines a variable, `numOps`, that defines the number of threads that will attempt to access the resource.</span></span> <span data-ttu-id="75a71-203">應用程式執行緒會針對同步存取和非同步存取各呼叫 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 方法五次。</span><span class="sxs-lookup"><span data-stu-id="75a71-203">The application thread calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method for synchronized and unsynchronized access five times each.</span></span> <span data-ttu-id="75a71-204"><xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> 方法具有單一參數和不接受任何參數的一個委派，並且不會傳回任何值。</span><span class="sxs-lookup"><span data-stu-id="75a71-204">The <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method has a single parameter, a delegate that accepts no parameters and returns no value.</span></span> <span data-ttu-id="75a71-205">針對同步存取，它會叫用 `SyncUpdateResource` 方法；針對未同步存取，它會叫用 `UnSyncUpdateResource` 方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-205">For synchronized access, it invokes the `SyncUpdateResource` method; for unsynchronized access, it invokes the `UnSyncUpdateResource` method.</span></span> <span data-ttu-id="75a71-206">在方法呼叫的每個設定之後呼叫的應用程式執行緒[AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*)方法，以封鎖直到<xref:System.Threading.AutoResetEvent>執行個體收到訊號。</span><span class="sxs-lookup"><span data-stu-id="75a71-206">After each set of method calls, the application thread calls the [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) method so that it blocks until the <xref:System.Threading.AutoResetEvent> instance is signaled.</span></span>  
  
 <span data-ttu-id="75a71-207">每次呼叫 `SyncUpdateResource` 方法都會呼叫內部 `SyncResource.Access` 方法，然後呼叫 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 方法以遞減 `numOps` 計數器。</span><span class="sxs-lookup"><span data-stu-id="75a71-207">Each call to the `SyncUpdateResource` method calls the internal `SyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="75a71-208"><xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法會用於遞減計數器，因為否則您無法確定第二個執行緒將會存取值，才能在第一個執行緒的遞減值儲存在變數。</span><span class="sxs-lookup"><span data-stu-id="75a71-208">The <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</span></span> <span data-ttu-id="75a71-209">當上次同步處理背景工作執行緒遞減計數器為零時，表示所有同步處理的執行緒已完成存取資源，`SyncUpdateResource`方法呼叫<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>方法，以指示主執行緒繼續執行執行。</span><span class="sxs-lookup"><span data-stu-id="75a71-209">When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the `SyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="75a71-210">每次呼叫 `UnSyncUpdateResource` 方法都會呼叫內部 `UnSyncResource.Access` 方法，然後呼叫 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> 方法以遞減 `numOps` 計數器。</span><span class="sxs-lookup"><span data-stu-id="75a71-210">Each call to the `UnSyncUpdateResource` method calls the internal `UnSyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="75a71-211">同樣地，<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法會用於遞減計數器，以確保第二個執行緒不會無法存取值在第一個執行緒的遞減值已指派給變數之前。</span><span class="sxs-lookup"><span data-stu-id="75a71-211">Once again, the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</span></span> <span data-ttu-id="75a71-212">當上次非同步處理背景工作執行緒遞減計數器為零時，指出沒有其他非同步處理的執行緒需要存取資源，`UnSyncUpdateResource`方法呼叫<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>方法，以指示主執行緒繼續執行.</span><span class="sxs-lookup"><span data-stu-id="75a71-212">When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the `UnSyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="75a71-213">如範例輸出所示，同步存取可確保呼叫執行緒會先結束受保護的資源，其他執行緒才能存取該資源；每個執行緒都會等候其前置項。</span><span class="sxs-lookup"><span data-stu-id="75a71-213">As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</span></span> <span data-ttu-id="75a71-214">相反地，若未鎖定，則會依執行緒到達的順序來呼叫 `UnSyncResource.Access` 方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-214">On the other hand, without the lock, the `UnSyncResource.Access` method is called in the order in which threads reach it.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="75a71-215">此型別具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="75a71-215">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-216">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-216">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="75a71-217">執行緒物件和功能</span><span class="sxs-lookup"><span data-stu-id="75a71-217">Threading Objects and Features</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="75a71-218">取得指定之物件的獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-218">Acquires an exclusive lock on a specified object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-219">要從其上取得監視器鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-219">The object on which to acquire the monitor lock.</span></span></param>
        <summary><span data-ttu-id="75a71-220">取得指定物件的獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-220">Acquires an exclusive lock on the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-221">使用`Enter`取得<xref:System.Threading.Monitor>上做為參數傳遞的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-221">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter.</span></span> <span data-ttu-id="75a71-222">如果已執行另一個執行緒`Enter`物件上但尚未執行對應<xref:System.Threading.Monitor.Exit%2A>，目前的執行緒將會封鎖直到另一個執行緒釋放物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-222">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="75a71-223">它是合法的叫用相同的執行緒`Enter`不止一次，而不封鎖它; 不過，相同數目的`Exit`物件正在等候其他執行緒會解除封鎖之前，必須叫用呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-223">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="75a71-224">使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。</span><span class="sxs-lookup"><span data-stu-id="75a71-224">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="75a71-225">當您傳遞到實值類型變數`Enter`，它會進行 boxed 處理做為物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-225">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="75a71-226">如果您傳遞至相同的變數`Enter`同樣地，它會進行 boxed 處理為個別的物件，而且不會封鎖執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-226">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="75a71-227">在此情況下，程式碼，`Monitor`是應該要保護不受保護。</span><span class="sxs-lookup"><span data-stu-id="75a71-227">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="75a71-228">此外，當您將變數傳遞給`Exit`，建立另一個不同的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-228">Furthermore, when you pass the variable to `Exit`, still another separate object is created.</span></span> <span data-ttu-id="75a71-229">因為物件傳遞給`Exit`不同於傳遞至物件`Enter`，`Monitor`就會擲回<xref:System.Threading.SynchronizationLockException>。</span><span class="sxs-lookup"><span data-stu-id="75a71-229">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="75a71-230">如需詳細資訊，請參閱概念性主題[監視器](xref:System.Threading.Monitor)。</span><span class="sxs-lookup"><span data-stu-id="75a71-230">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="75a71-231"><xref:System.Threading.Thread.Interrupt%2A> 可插斷的執行緒正在等候輸入`Monitor`物件上。</span><span class="sxs-lookup"><span data-stu-id="75a71-231"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="75a71-232">A<xref:System.Threading.ThreadInterruptedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="75a71-232">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
 <span data-ttu-id="75a71-233">使用 C# `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="75a71-233">Use a C# `try`…`finally`</span></span> <span data-ttu-id="75a71-234">區塊 (`Try`...`Finally`</span><span class="sxs-lookup"><span data-stu-id="75a71-234">block (`Try`…`Finally`</span></span> <span data-ttu-id="75a71-235">在 Visual Basic)，以確保您發行 「 監視器 」，或使用 C#`lock`陳述式 (`SyncLock`陳述式，在 Visual Basic 中的)，其中包裝<xref:System.Threading.Monitor.Enter%2A>並<xref:System.Threading.Monitor.Exit%2A>中的方法`try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="75a71-235">in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`…`finally`</span></span> <span data-ttu-id="75a71-236">區塊。</span><span class="sxs-lookup"><span data-stu-id="75a71-236">block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75a71-237">下列範例示範如何使用 `Enter` 方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-237">The following example demonstrates how to use the `Enter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-238"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-238">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-239">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-239">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-240">要等候的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-240">The object on which to wait.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="75a71-241">嘗試取得鎖定的結果 (以傳址方式傳遞)。</span><span class="sxs-lookup"><span data-stu-id="75a71-241">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="75a71-242">輸入必須是 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-242">The input must be <see langword="false" />.</span></span> <span data-ttu-id="75a71-243">如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-243">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="75a71-244">嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。</span><span class="sxs-lookup"><span data-stu-id="75a71-244">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span>  
  
<span data-ttu-id="75a71-245">注意：如果沒有發生例外狀況，這個方法的輸出一律為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-245">Note   If no exception occurs, the output of this method is always <see langword="true" />.</span></span></param>
        <summary><span data-ttu-id="75a71-246">取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-246">Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-247">使用`Enter`來取得<xref:System.Threading.Monitor>做為傳遞的物件上`obj`參數。</span><span class="sxs-lookup"><span data-stu-id="75a71-247">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter.</span></span> <span data-ttu-id="75a71-248">如果已執行另一個執行緒`Enter`物件上但尚未執行對應<xref:System.Threading.Monitor.Exit%2A>，目前的執行緒將會封鎖直到另一個執行緒釋放物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-248">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="75a71-249">它是合法的叫用相同的執行緒`Enter`不止一次，而不封鎖它; 不過，相同數目的`Exit`物件正在等候其他執行緒會解除封鎖之前，必須叫用呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-249">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="75a71-250">如果無法取得鎖定，因為發生例外狀況，針對指定的變數`lockTaken`參數是`false`這個方法會結束之後。</span><span class="sxs-lookup"><span data-stu-id="75a71-250">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="75a71-251">這可讓程式，以判斷是否需要釋出鎖定，請在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="75a71-251">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span> <span data-ttu-id="75a71-252">如果這個方法會傳回而不擲回例外狀況，針對指定的變數`lockTaken`參數永遠是`true`，並不需要進行測試。</span><span class="sxs-lookup"><span data-stu-id="75a71-252">If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.</span></span>  
  
 <span data-ttu-id="75a71-253">使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。</span><span class="sxs-lookup"><span data-stu-id="75a71-253">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="75a71-254">當您傳遞到實值類型變數`Enter`，它會進行 boxed 處理做為物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-254">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="75a71-255">如果您傳遞至相同的變數`Enter`同樣地，它會進行 boxed 處理為個別的物件，而且不會封鎖執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-255">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="75a71-256">在此情況下，程式碼，`Monitor`是應該要保護不受保護。</span><span class="sxs-lookup"><span data-stu-id="75a71-256">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="75a71-257">此外，當您將變數傳遞給`Exit`，建立另一個不同的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-257">Furthermore, when you pass the variable to `Exit`, another separate object is created.</span></span> <span data-ttu-id="75a71-258">因為物件傳遞給`Exit`不同於傳遞至物件`Enter`，`Monitor`就會擲回<xref:System.Threading.SynchronizationLockException>。</span><span class="sxs-lookup"><span data-stu-id="75a71-258">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="75a71-259">如需詳細資訊，請參閱概念性主題[監視器](xref:System.Threading.Monitor)。</span><span class="sxs-lookup"><span data-stu-id="75a71-259">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="75a71-260"><xref:System.Threading.Thread.Interrupt%2A> 可插斷的執行緒正在等候輸入`Monitor`物件上。</span><span class="sxs-lookup"><span data-stu-id="75a71-260"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="75a71-261">A<xref:System.Threading.ThreadInterruptedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="75a71-261">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75a71-262">下列程式碼示範基本模式使用<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="75a71-262">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="75a71-263">這個多載一定會設定傳遞至變數的值`ref`參數 (`ByRef` Visual Basic 中) `lockTaken`，即使方法會擲回例外狀況，因此變數的值是以可靠的方式，來測試是否鎖定必須為釋出。</span><span class="sxs-lookup"><span data-stu-id="75a71-263">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="75a71-264"><paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-264">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-265"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-265">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-266">要從其上釋出鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-266">The object on which to release the lock.</span></span></param>
        <summary><span data-ttu-id="75a71-267">釋出指定物件的獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-267">Releases an exclusive lock on the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-268">呼叫的執行緒必須在擁有鎖定`obj`參數。</span><span class="sxs-lookup"><span data-stu-id="75a71-268">The calling thread must own the lock on the `obj` parameter.</span></span> <span data-ttu-id="75a71-269">如果呼叫的執行緒擁有之指定的物件上的鎖定，且有相同數目的`Exit`和<xref:System.Threading.Monitor.Enter%2A>呼叫物件，然後釋放鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="75a71-269">If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released.</span></span> <span data-ttu-id="75a71-270">如果呼叫執行緒已不會叫用`Exit`次數一樣多`Enter`，不會釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-270">If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.</span></span>  
  
 <span data-ttu-id="75a71-271">如果解除鎖定其他執行緒處於就緒佇列物件，其中一個執行緒取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-271">If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</span></span> <span data-ttu-id="75a71-272">如果其他執行緒在等候取得鎖定的等候佇列中，它們不會自動移動到就緒佇列時的鎖定擁有者會呼叫`Exit`。</span><span class="sxs-lookup"><span data-stu-id="75a71-272">If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`.</span></span> <span data-ttu-id="75a71-273">若要一或多個等候執行緒進入就緒佇列，呼叫<xref:System.Threading.Monitor.Pulse%2A>或是<xref:System.Threading.Monitor.PulseAll%2A>叫用之前`Exit`。</span><span class="sxs-lookup"><span data-stu-id="75a71-273">To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="75a71-274">下列範例示範如何使用 `Exit` 方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-274">The following example demonstrates how to use the `Exit` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-275"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-275">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="75a71-276">目前執行緒沒有指定物件的鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-276">The current thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-277">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-277">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-278">要測試的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-278">The object to test.</span></span></param>
        <summary><span data-ttu-id="75a71-279">判斷目前執行緒是否保持鎖定指定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-279">Determines whether the current thread holds the lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="75a71-280">如果目前的執行緒持有 <paramref name="obj" /> 的鎖定，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-280"><see langword="true" /> if the current thread holds the lock on <paramref name="obj" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-281">這個方法僅適用於所使用的方法取得的鎖定<xref:System.Threading.Monitor>類別，或使用 C#`lock`陳述式或 Visual Basic`SyncLock`陳述式，以實作<xref:System.Threading.Monitor>。</span><span class="sxs-lookup"><span data-stu-id="75a71-281">This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="75a71-282">使用此方法使用診斷工具，例如<xref:System.Diagnostics.Debug.Assert%2A>方法和<xref:System.Diagnostics.Contracts.Contract>類別，涉及的鎖定問題進行偵錯<xref:System.Threading.Monitor>類別。</span><span class="sxs-lookup"><span data-stu-id="75a71-282">Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-283"><paramref name="obj" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-283"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-284">執行緒正等候的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-284">The object a thread is waiting for.</span></span></param>
        <summary><span data-ttu-id="75a71-285">通知等候佇列中的執行緒，鎖定物件的狀態有所變更。</span><span class="sxs-lookup"><span data-stu-id="75a71-285">Notifies a thread in the waiting queue of a change in the locked object's state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-286">只有目前鎖定的擁有者可以發出信號，使用等候物件`Pulse`。</span><span class="sxs-lookup"><span data-stu-id="75a71-286">Only the current owner of the lock can signal a waiting object using `Pulse`.</span></span>  
  
 <span data-ttu-id="75a71-287">目前擁有指定的物件上鎖定的執行緒叫用這個方法來通知鎖定的行中的下一個執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-287">The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</span></span> <span data-ttu-id="75a71-288">在收到的 pulse 時，等候的執行緒會移到就緒佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-288">Upon receiving the pulse, the waiting thread is moved to the ready queue.</span></span> <span data-ttu-id="75a71-289">當執行緒叫用`Pulse`釋出鎖定，準備佇列 （也就是不一定接受 pulse 的執行緒） 中的下一個執行緒取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-289">When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="75a71-290"><xref:System.Threading.Monitor>類別不會維護狀態，指出<xref:System.Threading.Monitor.Pulse%2A>已呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-290">The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called.</span></span> <span data-ttu-id="75a71-291">因此，如果您呼叫<xref:System.Threading.Monitor.Pulse%2A>當沒有執行緒在等候下, 一個呼叫的執行緒<xref:System.Threading.Monitor.Wait%2A>區塊如同<xref:System.Threading.Monitor.Pulse%2A>從未呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-291">Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called.</span></span> <span data-ttu-id="75a71-292">如果使用兩個執行緒<xref:System.Threading.Monitor.Pulse%2A>和<xref:System.Threading.Monitor.Wait%2A>互動，這可能導致死結。</span><span class="sxs-lookup"><span data-stu-id="75a71-292">If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock.</span></span> <span data-ttu-id="75a71-293">與此相反的行為與<xref:System.Threading.AutoResetEvent>類別：如果您發出信號<xref:System.Threading.AutoResetEvent>藉由呼叫其<xref:System.Threading.EventWaitHandle.Set%2A>方法，沒有執行緒在等待，而<xref:System.Threading.AutoResetEvent>仍會處於收到信號的狀態，直到執行緒呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>， <xref:System.Threading.WaitHandle.WaitAny%2A>，或<xref:System.Threading.WaitHandle.WaitAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-293">Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="75a71-294"><xref:System.Threading.AutoResetEvent>釋放該執行緒，並傳回未發出訊號的狀態。</span><span class="sxs-lookup"><span data-stu-id="75a71-294">The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.</span></span>  
  
 <span data-ttu-id="75a71-295">請注意 同步處理的物件擁有數個的參考，包括目前持有鎖定、 參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考的等候佇列之執行緒的參考它包含執行緒等候的物件的狀態變更通知。</span><span class="sxs-lookup"><span data-stu-id="75a71-295">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="75a71-296">`Pulse`， <xref:System.Threading.Monitor.PulseAll%2A>，和<xref:System.Threading.Monitor.Wait%2A>方法必須從叫用同步處理的程式碼區塊中。</span><span class="sxs-lookup"><span data-stu-id="75a71-296">The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="75a71-297">若要表示多個執行緒，使用<xref:System.Threading.Monitor.PulseAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-297">To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-298"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-298">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="75a71-299">呼叫執行緒沒有指定物件的鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-299">The calling thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-300">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-300">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-301">送出 Pulse 的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-301">The object that sends the pulse.</span></span></param>
        <summary><span data-ttu-id="75a71-302">通知所有等候中的執行緒，物件的狀態有所變更。</span><span class="sxs-lookup"><span data-stu-id="75a71-302">Notifies all waiting threads of a change in the object's state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-303">目前擁有指定的物件上鎖定的執行緒叫用這個方法來通知所有執行緒等候取得鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-303">The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</span></span> <span data-ttu-id="75a71-304">傳送訊號後，等候中執行緒會移到就緒佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-304">After the signal is sent, the waiting threads are moved to the ready queue.</span></span> <span data-ttu-id="75a71-305">當執行緒叫用`PulseAll`釋出鎖定，就緒佇列中的下一個執行緒取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-305">When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.</span></span>  
  
 <span data-ttu-id="75a71-306">請注意 同步處理的物件擁有數個的參考，包括目前持有鎖定、 參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考的等候佇列之執行緒的參考它包含執行緒等候的物件的狀態變更通知。</span><span class="sxs-lookup"><span data-stu-id="75a71-306">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="75a71-307"><xref:System.Threading.Monitor.Pulse%2A>， `PulseAll`，和<xref:System.Threading.Monitor.Wait%2A>方法必須從叫用同步處理的程式碼區塊中。</span><span class="sxs-lookup"><span data-stu-id="75a71-307">The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="75a71-308">如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-308">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 <span data-ttu-id="75a71-309">若要表示的單一執行緒，使用`Pulse`方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-309">To signal a single thread, use the `Pulse` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-310"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-310">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="75a71-311">呼叫執行緒沒有指定物件的鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-311">The calling thread does not own the lock for the specified object.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-312">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-312">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="75a71-313">嘗試取得指定物件的獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-313">Attempts to acquire an exclusive lock on the specified object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-314">要取得鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-314">The object on which to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="75a71-315">嘗試取得指定物件的獨佔鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-315">Attempts to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="75a71-316">如果目前執行緒取得鎖定，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-316"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-317">如果成功，這個方法會取得獨佔的鎖定上`obj`參數。</span><span class="sxs-lookup"><span data-stu-id="75a71-317">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="75a71-318">這個方法會立即傳回，鎖定可用。</span><span class="sxs-lookup"><span data-stu-id="75a71-318">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="75a71-319">這個方法很類似<xref:System.Threading.Monitor.Enter%2A>，但它會永遠不會封鎖目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-319">This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread.</span></span> <span data-ttu-id="75a71-320">如果執行緒無法輸入而不會封鎖，則方法會傳回`false,`。</span><span class="sxs-lookup"><span data-stu-id="75a71-320">If the thread cannot enter without blocking, the method returns `false,`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-321">使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。</span><span class="sxs-lookup"><span data-stu-id="75a71-321">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="75a71-322">如需詳細資訊，請參閱<xref:System.Threading.Monitor>文章。</span><span class="sxs-lookup"><span data-stu-id="75a71-322">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="75a71-323">若要確保執行緒不會進入重要區段，您應該檢查方法的傳回值，並在重要區段中執行程式碼，其傳回值時，才`true`。</span><span class="sxs-lookup"><span data-stu-id="75a71-323">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="75a71-324">下列程式碼片段會顯示用來呼叫這個方法的模式。</span><span class="sxs-lookup"><span data-stu-id="75a71-324">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="75a71-325">請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-325">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="75a71-326">下列程式碼範例會示範如何使用 `TryEnter` 方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-326">The following code example demonstrates how to use the `TryEnter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-327"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-327">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-328">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-328">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-329">要取得鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-329">The object on which to acquire the lock.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="75a71-330">嘗試取得鎖定的結果 (以傳址方式傳遞)。</span><span class="sxs-lookup"><span data-stu-id="75a71-330">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="75a71-331">輸入必須是 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-331">The input must be <see langword="false" />.</span></span> <span data-ttu-id="75a71-332">如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-332">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="75a71-333">嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。</span><span class="sxs-lookup"><span data-stu-id="75a71-333">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="75a71-334">嘗試取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-334">Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-335">如果成功，這個方法會取得獨佔的鎖定上`obj`參數。</span><span class="sxs-lookup"><span data-stu-id="75a71-335">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="75a71-336">這個方法會立即傳回，鎖定可用。</span><span class="sxs-lookup"><span data-stu-id="75a71-336">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="75a71-337">如果無法取得鎖定，因為發生例外狀況，針對指定的變數`lockTaken`參數是`false`這個方法會結束之後。</span><span class="sxs-lookup"><span data-stu-id="75a71-337">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="75a71-338">這可讓程式，以判斷是否需要釋出鎖定，請在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="75a71-338">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
 <span data-ttu-id="75a71-339">這個方法很類似<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>，但它會永遠不會封鎖目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-339">This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread.</span></span> <span data-ttu-id="75a71-340">如果執行緒無法輸入而不會封鎖，`lockTaken`引數設定為`false`方法傳回時。</span><span class="sxs-lookup"><span data-stu-id="75a71-340">If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-341">使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。</span><span class="sxs-lookup"><span data-stu-id="75a71-341">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="75a71-342">如需詳細資訊，請參閱<xref:System.Threading.Monitor>文章。</span><span class="sxs-lookup"><span data-stu-id="75a71-342">For more information, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="75a71-343">為了確保執行緒不會進入重要區段，您應該檢查的值`lockTaken`並執行程式碼在重要區段中，只有其值是`true`。</span><span class="sxs-lookup"><span data-stu-id="75a71-343">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="75a71-344">下列程式碼片段會顯示用來呼叫這個方法的模式。</span><span class="sxs-lookup"><span data-stu-id="75a71-344">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="75a71-345">請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-345">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="75a71-346">下列程式碼示範基本模式使用<xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="75a71-346">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="75a71-347">這個多載一定會設定傳遞至變數的值`ref`參數 (`ByRef` Visual Basic 中) `lockTaken`，即使方法會擲回例外狀況，因此變數的值是以可靠的方式，來測試是否鎖定必須為釋出。</span><span class="sxs-lookup"><span data-stu-id="75a71-347">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="75a71-348"><paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-348">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-349"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-349">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-350">要取得鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-350">The object on which to acquire the lock.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="75a71-351">等候鎖定的毫秒數。</span><span class="sxs-lookup"><span data-stu-id="75a71-351">The number of milliseconds to wait for the lock.</span></span></param>
        <summary><span data-ttu-id="75a71-352">嘗試取得指定物件的獨佔鎖定 (在指定的毫秒數時間內)。</span><span class="sxs-lookup"><span data-stu-id="75a71-352">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="75a71-353">如果目前執行緒取得鎖定，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-353"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-354">如果`millisecondsTimeout`參數等於<xref:System.Threading.Timeout.Infinite>，這個方法相當於<xref:System.Threading.Monitor.Enter%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-354">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="75a71-355">如果`millisecondsTimeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-355">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-356">使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。</span><span class="sxs-lookup"><span data-stu-id="75a71-356">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="75a71-357">如需詳細資訊，請參閱<xref:System.Threading.Monitor>文章。</span><span class="sxs-lookup"><span data-stu-id="75a71-357">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="75a71-358">若要確保執行緒不會進入重要區段，您應該檢查方法的傳回值，並在重要區段中執行程式碼，其傳回值時，才`true`。</span><span class="sxs-lookup"><span data-stu-id="75a71-358">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="75a71-359">下列程式碼片段會顯示用來呼叫這個方法的模式。</span><span class="sxs-lookup"><span data-stu-id="75a71-359">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="75a71-360">請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-360">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-361"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-361">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75a71-362"><paramref name="millisecondsTimeout" /> 是負數，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-362"><paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-363">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-363">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-364">要取得鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-364">The object on which to acquire the lock.</span></span></param>
        <param name="timeout"><span data-ttu-id="75a71-365"><see cref="T:System.TimeSpan" />，代表等候鎖定的時間量。</span><span class="sxs-lookup"><span data-stu-id="75a71-365">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait for the lock.</span></span> <span data-ttu-id="75a71-366">-1 毫秒的值會指定無限期等候。</span><span class="sxs-lookup"><span data-stu-id="75a71-366">A value of -1 millisecond specifies an infinite wait.</span></span></param>
        <summary><span data-ttu-id="75a71-367">嘗試取得指定物件的獨佔鎖定 (在指定的時間內)。</span><span class="sxs-lookup"><span data-stu-id="75a71-367">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</span></span></summary>
        <returns><span data-ttu-id="75a71-368">如果目前執行緒取得鎖定，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-368"><see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-369">如果值`timeout`轉換為毫秒的參數等於-1，這個方法就相當於<xref:System.Threading.Monitor.Enter%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-369">If the value of the `timeout` parameter converted to milliseconds equals -1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="75a71-370">如果值`timeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-370">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-371">使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。</span><span class="sxs-lookup"><span data-stu-id="75a71-371">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="75a71-372">如需詳細資訊，請參閱<xref:System.Threading.Monitor>類別主題。</span><span class="sxs-lookup"><span data-stu-id="75a71-372">For details, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="75a71-373">若要確保執行緒不會進入重要區段，您應該檢查方法的傳回值，並在重要區段中執行程式碼，其傳回值時，才`true`。</span><span class="sxs-lookup"><span data-stu-id="75a71-373">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="75a71-374">下列程式碼片段會顯示用來呼叫這個方法的模式。</span><span class="sxs-lookup"><span data-stu-id="75a71-374">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="75a71-375">請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-375">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-376"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-376">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75a71-377"><paramref name="timeout" /> 的毫秒值為負值且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (-1 毫秒)，或大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-377">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-378">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-378">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-379">要取得鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-379">The object on which to acquire the lock.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="75a71-380">等候鎖定的毫秒數。</span><span class="sxs-lookup"><span data-stu-id="75a71-380">The number of milliseconds to wait for the lock.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="75a71-381">嘗試取得鎖定的結果 (以傳址方式傳遞)。</span><span class="sxs-lookup"><span data-stu-id="75a71-381">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="75a71-382">輸入必須是 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-382">The input must be <see langword="false" />.</span></span> <span data-ttu-id="75a71-383">如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-383">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="75a71-384">嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。</span><span class="sxs-lookup"><span data-stu-id="75a71-384">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="75a71-385">嘗試在指定的毫秒數內取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-385">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-386">如果`millisecondsTimeout`參數等於<xref:System.Threading.Timeout.Infinite>，這個方法相當於<xref:System.Threading.Monitor.Enter%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="75a71-386">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="75a71-387">如果`millisecondsTimeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="75a71-387">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="75a71-388">如果無法取得鎖定，因為發生例外狀況，針對指定的變數`lockTaken`參數是`false`這個方法會結束之後。</span><span class="sxs-lookup"><span data-stu-id="75a71-388">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="75a71-389">這可讓程式，以判斷是否需要釋出鎖定，請在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="75a71-389">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-390">使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。</span><span class="sxs-lookup"><span data-stu-id="75a71-390">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="75a71-391">如需詳細資訊，請參閱<xref:System.Threading.Monitor>類別主題。</span><span class="sxs-lookup"><span data-stu-id="75a71-391">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="75a71-392">為了確保執行緒不會進入重要區段，您應該檢查的值`lockTaken`並執行程式碼在重要區段中，只有其值是`true`。</span><span class="sxs-lookup"><span data-stu-id="75a71-392">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="75a71-393">下列程式碼片段會顯示用來呼叫這個方法的模式。</span><span class="sxs-lookup"><span data-stu-id="75a71-393">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="75a71-394">請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-394">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="75a71-395">下列程式碼示範基本模式使用<xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="75a71-395">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="75a71-396">這個多載一定會設定傳遞至變數的值`ref`參數 (`ByRef` Visual Basic 中) `lockTaken`，即使方法會擲回例外狀況，因此變數的值是以可靠的方式，來測試是否鎖定必須為釋出。</span><span class="sxs-lookup"><span data-stu-id="75a71-396">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="75a71-397"><paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-397">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-398"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-398">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75a71-399"><paramref name="millisecondsTimeout" /> 是負數，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-399"><paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-400">要取得鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-400">The object on which to acquire the lock.</span></span></param>
        <param name="timeout"><span data-ttu-id="75a71-401">等候鎖定的時間長度。</span><span class="sxs-lookup"><span data-stu-id="75a71-401">The amount of time to wait for the lock.</span></span> <span data-ttu-id="75a71-402">-1 毫秒的值會指定無限期等候。</span><span class="sxs-lookup"><span data-stu-id="75a71-402">A value of -1 millisecond specifies an infinite wait.</span></span></param>
        <param name="lockTaken"><span data-ttu-id="75a71-403">嘗試取得鎖定的結果 (以傳址方式傳遞)。</span><span class="sxs-lookup"><span data-stu-id="75a71-403">The result of the attempt to acquire the lock, passed by reference.</span></span> <span data-ttu-id="75a71-404">輸入必須是 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-404">The input must be <see langword="false" />.</span></span> <span data-ttu-id="75a71-405">如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-405">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span></span> <span data-ttu-id="75a71-406">嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。</span><span class="sxs-lookup"><span data-stu-id="75a71-406">The output is set even if an exception occurs during the attempt to acquire the lock.</span></span></param>
        <summary><span data-ttu-id="75a71-407">嘗試在指定的時間內取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-407">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-408">如果值`timeout`轉換為毫秒的參數等於-1，這個方法就相當於<xref:System.Threading.Monitor.Enter%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="75a71-408">If the value of the `timeout` parameter converted to milliseconds equals -1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="75a71-409">如果值`timeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%28System.Object%29>。</span><span class="sxs-lookup"><span data-stu-id="75a71-409">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="75a71-410">如果無法取得鎖定，因為發生例外狀況，針對指定的變數`lockTaken`參數是`false`這個方法會結束之後。</span><span class="sxs-lookup"><span data-stu-id="75a71-410">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="75a71-411">這可讓程式，以判斷是否需要釋出鎖定，請在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="75a71-411">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-412">使用<xref:System.Threading.Monitor>鎖定物件 （也就是參考類型），不實值型別。</span><span class="sxs-lookup"><span data-stu-id="75a71-412">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="75a71-413">如需詳細資訊，請參閱<xref:System.Threading.Monitor>類別主題。</span><span class="sxs-lookup"><span data-stu-id="75a71-413">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="75a71-414">為了確保執行緒不會進入重要區段，您應該檢查的值`lockTaken`並執行程式碼在重要區段中，只有其值是`true`。</span><span class="sxs-lookup"><span data-stu-id="75a71-414">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="75a71-415">下列程式碼片段會顯示用來呼叫這個方法的模式。</span><span class="sxs-lookup"><span data-stu-id="75a71-415">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="75a71-416">請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>在`finally`區塊以確保呼叫執行緒釋放重要區段上的鎖定，如果發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-416">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="75a71-417"><paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-417">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-418"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-418">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75a71-419"><paramref name="timeout" /> 的毫秒值為負值且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (-1 毫秒)，或大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-419">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-420">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-420">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="75a71-421">釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="75a71-421">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-422">要等候的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-422">The object on which to wait.</span></span></param>
        <summary><span data-ttu-id="75a71-423">釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="75a71-423">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span></summary>
        <returns><span data-ttu-id="75a71-424">如果因為呼叫端重新取得指定物件的鎖定所以呼叫被傳回，則為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-424"><see langword="true" /> if the call returned because the caller reacquired the lock for the specified object.</span></span> <span data-ttu-id="75a71-425">如果鎖定不被重新取得，則這個方法不會傳回。</span><span class="sxs-lookup"><span data-stu-id="75a71-425">This method does not return if the lock is not reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-426">目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，另一個執行緒可以存取它。</span><span class="sxs-lookup"><span data-stu-id="75a71-426">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="75a71-427">等候重新取得鎖定時，會封鎖呼叫端。</span><span class="sxs-lookup"><span data-stu-id="75a71-427">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="75a71-428">當呼叫端需要等待，因為另一個執行緒的作業而造成狀態變更時，會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-428">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="75a71-429">當執行緒呼叫`Wait`，它會釋放該物件上的鎖定，並進入物件的等候佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-429">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="75a71-430">物件的就緒佇列中的下一個執行緒 （如果有的話） 取得鎖定並會獨佔使用的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-430">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="75a71-431">所有呼叫的執行緒`Wait`仍在等待佇列，直到它們收到信號，以從<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>、 鎖定的擁有者所傳送。</span><span class="sxs-lookup"><span data-stu-id="75a71-431">All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock.</span></span> <span data-ttu-id="75a71-432">如果`Pulse`傳送時，只有在等候佇列頂端的執行緒會受到影響。</span><span class="sxs-lookup"><span data-stu-id="75a71-432">If `Pulse` is sent, only the thread at the head of the waiting queue is affected.</span></span> <span data-ttu-id="75a71-433">如果`PulseAll`傳送時，會等候物件的所有執行緒會受到都影響。</span><span class="sxs-lookup"><span data-stu-id="75a71-433">If `PulseAll` is sent, all threads that are waiting for the object are affected.</span></span> <span data-ttu-id="75a71-434">收到訊號時，一或多個執行緒會離開等候佇列，並進入就緒佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-434">When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</span></span> <span data-ttu-id="75a71-435">就緒佇列中的執行緒可以重新取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-435">A thread in the ready queue is permitted to reacquire the lock.</span></span>  
  
 <span data-ttu-id="75a71-436">這個方法傳回時呼叫的執行緒重新取得鎖定的物件上。</span><span class="sxs-lookup"><span data-stu-id="75a71-436">This method returns when the calling thread reacquires the lock on the object.</span></span> <span data-ttu-id="75a71-437">請注意，此方法會無限期地封鎖如果鎖定的持有者不會呼叫`Pulse`或`PulseAll`。</span><span class="sxs-lookup"><span data-stu-id="75a71-437">Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.</span></span>  
  
 <span data-ttu-id="75a71-438">呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-438">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="75a71-439">就概念而言，`Wait`方法將儲存在呼叫端叫用次數`Enter`物件上叫用`Exit`次數所需的完全釋放鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-439">Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="75a71-440">呼叫端會再封鎖等候重新取得物件時。</span><span class="sxs-lookup"><span data-stu-id="75a71-440">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="75a71-441">當呼叫端重新取得鎖定時，系統就會呼叫`Enter`所需的還原已儲存次數`Enter`呼叫端的計數。</span><span class="sxs-lookup"><span data-stu-id="75a71-441">When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller.</span></span> <span data-ttu-id="75a71-442">呼叫`Wait`解除鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，會釋放這些鎖定不。</span><span class="sxs-lookup"><span data-stu-id="75a71-442">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
 <span data-ttu-id="75a71-443">請注意 同步處理的物件擁有數個的參考，包括目前持有鎖定、 參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考的等候佇列之執行緒的參考它包含執行緒等候的物件的狀態變更通知。</span><span class="sxs-lookup"><span data-stu-id="75a71-443">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="75a71-444"><xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊中。</span><span class="sxs-lookup"><span data-stu-id="75a71-444">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="75a71-445">如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-445">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-446"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-446">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="75a71-447">呼叫執行緒沒有指定物件的鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-447">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="75a71-448">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。</span><span class="sxs-lookup"><span data-stu-id="75a71-448">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="75a71-449">當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-449">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-450">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-450">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-451">要等候的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-451">The object on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="75a71-452">在執行緒進入就緒佇列之前要等候的毫秒數。</span><span class="sxs-lookup"><span data-stu-id="75a71-452">The number of milliseconds to wait before the thread enters the ready queue.</span></span></param>
        <summary><span data-ttu-id="75a71-453">釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="75a71-453">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="75a71-454">如果超過指定的逾時間隔時間，執行緒會進入就緒序列。</span><span class="sxs-lookup"><span data-stu-id="75a71-454">If the specified time-out interval elapses, the thread enters the ready queue.</span></span></summary>
        <returns><span data-ttu-id="75a71-455">如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-455"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="75a71-456">要等到重新取得鎖定之後，此方法才會傳回。</span><span class="sxs-lookup"><span data-stu-id="75a71-456">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-457">這個方法不會傳回在重新取得獨佔鎖定直到`obj`參數。</span><span class="sxs-lookup"><span data-stu-id="75a71-457">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="75a71-458">目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，另一個執行緒可以存取它。</span><span class="sxs-lookup"><span data-stu-id="75a71-458">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="75a71-459">等候重新取得鎖定時，會封鎖呼叫端。</span><span class="sxs-lookup"><span data-stu-id="75a71-459">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="75a71-460">當呼叫端需要等待，因為另一個執行緒的作業而造成狀態變更時，會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-460">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="75a71-461">逾時可確保目前的執行緒在如果另一個執行緒釋放的鎖定，但是未先呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-461">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="75a71-462">它也會在執行緒移動到就緒佇列，以便它可以更快重新取得鎖定，請略過它之前等候佇列中的其他執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-462">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="75a71-463">執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新取得鎖定之前的逾時。執行緒可以評估導致它進入等候條件，才需要呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。</span><span class="sxs-lookup"><span data-stu-id="75a71-463">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="75a71-464">當執行緒呼叫`Wait`，它會釋放該物件上的鎖定，並進入物件的等候佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-464">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="75a71-465">物件的就緒佇列中的下一個執行緒 （如果有的話） 取得鎖定並會獨佔使用的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-465">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="75a71-466">叫用的執行緒`Wait`仍會保留在等候佇列，直到保留鎖定的執行緒叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保留鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-466">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="75a71-467">不過，如果`millisecondsTimeout`另一個執行緒叫用這個物件的前經過<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移到就緒佇列上，才能重新取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-467">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-468">如果<xref:System.Threading.Timeout.Infinite>指定了`millisecondsTimeout`參數，此方法會封鎖無限期地鎖定的持有者會呼叫除非<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-468">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="75a71-469">如果`millisecondsTimeout`等於 0，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-469">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="75a71-470">呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-470">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="75a71-471">就概念而言，`Wait`方法將儲存在呼叫端叫用次數<xref:System.Threading.Monitor.Enter%2A>物件上叫用<xref:System.Threading.Monitor.Exit%2A>次數所需的完全釋放鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-471">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="75a71-472">呼叫端會再封鎖等候重新取得物件時。</span><span class="sxs-lookup"><span data-stu-id="75a71-472">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="75a71-473">當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>所需的還原已儲存次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。</span><span class="sxs-lookup"><span data-stu-id="75a71-473">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="75a71-474">呼叫`Wait`解除鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，會釋放這些鎖定不。</span><span class="sxs-lookup"><span data-stu-id="75a71-474">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-475">同步處理的物件擁有數個參考，包括目前持有鎖定，參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考等候佇列，其中包含執行緒的參考正在等候的物件的狀態變更通知的執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-475">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="75a71-476"><xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊中。</span><span class="sxs-lookup"><span data-stu-id="75a71-476">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="75a71-477">如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-477">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-478"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-478">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="75a71-479">呼叫執行緒沒有指定物件的鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-479">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="75a71-480">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。</span><span class="sxs-lookup"><span data-stu-id="75a71-480">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="75a71-481">當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-481">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75a71-482"><paramref name="millisecondsTimeout" /> 參數的值為負，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-482">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-483">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-483">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-484">要等候的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-484">The object on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="75a71-485"><see cref="T:System.TimeSpan" />，代表在執行緒進入就緒佇列之前要等候的時間量。</span><span class="sxs-lookup"><span data-stu-id="75a71-485">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span></span></param>
        <summary><span data-ttu-id="75a71-486">釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="75a71-486">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="75a71-487">如果超過指定的逾時間隔時間，執行緒會進入就緒序列。</span><span class="sxs-lookup"><span data-stu-id="75a71-487">If the specified time-out interval elapses, the thread enters the ready queue.</span></span></summary>
        <returns><span data-ttu-id="75a71-488">如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-488"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="75a71-489">要等到重新取得鎖定之後，此方法才會傳回。</span><span class="sxs-lookup"><span data-stu-id="75a71-489">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-490">這個方法不會傳回在重新取得獨佔鎖定直到`obj`參數。</span><span class="sxs-lookup"><span data-stu-id="75a71-490">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="75a71-491">目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，另一個執行緒可以存取它。</span><span class="sxs-lookup"><span data-stu-id="75a71-491">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="75a71-492">等候重新取得鎖定時，會封鎖呼叫端。</span><span class="sxs-lookup"><span data-stu-id="75a71-492">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="75a71-493">當呼叫端需要等待，因為另一個執行緒的作業而造成狀態變更時，會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-493">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="75a71-494">逾時可確保目前的執行緒在如果另一個執行緒釋放的鎖定，但是未先呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-494">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="75a71-495">它也會在執行緒移動到就緒佇列，以便它可以更快重新取得鎖定，請略過它之前等候佇列中的其他執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-495">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="75a71-496">執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新取得鎖定之前的逾時。執行緒可以評估導致它進入等候條件，才需要呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。</span><span class="sxs-lookup"><span data-stu-id="75a71-496">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="75a71-497">當執行緒呼叫`Wait`，它會釋放該物件上的鎖定，並進入物件的等候佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-497">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="75a71-498">物件的就緒佇列中的下一個執行緒 （如果有的話） 取得鎖定並會獨佔使用的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-498">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="75a71-499">叫用的執行緒`Wait`仍會保留在等候佇列，直到保留鎖定的執行緒叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保留鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-499">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="75a71-500">不過，如果`timeout`另一個執行緒叫用這個物件的前經過<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移到就緒佇列上，才能重新取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-500">However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-501">如果<xref:System.TimeSpan>會指定代表-1 毫秒`timeout`參數，此方法會封鎖無限期地鎖定的持有者會呼叫除非<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-501">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="75a71-502">如果`timeout`為 0 毫秒，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-502">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="75a71-503">呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-503">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="75a71-504">就概念而言，`Wait`方法將儲存在呼叫端叫用次數<xref:System.Threading.Monitor.Enter%2A>物件上叫用<xref:System.Threading.Monitor.Exit%2A>次數所需的完全釋放鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-504">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="75a71-505">呼叫端會再封鎖等候重新取得物件時。</span><span class="sxs-lookup"><span data-stu-id="75a71-505">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="75a71-506">當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>所需的還原已儲存次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。</span><span class="sxs-lookup"><span data-stu-id="75a71-506">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="75a71-507">呼叫`Wait`解除鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，會釋放這些鎖定不。</span><span class="sxs-lookup"><span data-stu-id="75a71-507">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-508">同步處理的物件擁有數個參考，包括目前持有鎖定，參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考等候佇列，其中包含執行緒的參考正在等候的物件的狀態變更通知的執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-508">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="75a71-509"><xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊中。</span><span class="sxs-lookup"><span data-stu-id="75a71-509">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="75a71-510">如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-510">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-511"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-511">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="75a71-512">呼叫執行緒沒有指定物件的鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-512">The calling thread does not own the lock for the specified object.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="75a71-513">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。</span><span class="sxs-lookup"><span data-stu-id="75a71-513">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="75a71-514">當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-514">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75a71-515"><paramref name="timeout" /> 參數的毫秒值為負值且不表示 <see cref="F:System.Threading.Timeout.Infinite" /> (-1 毫秒)，或大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-515">The value of the <paramref name="timeout" /> parameter in milliseconds is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-516">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-516">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-517">要等候的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-517">The object on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="75a71-518">在執行緒進入就緒佇列之前要等候的毫秒數。</span><span class="sxs-lookup"><span data-stu-id="75a71-518">The number of milliseconds to wait before the thread enters the ready queue.</span></span></param>
        <param name="exitContext"><span data-ttu-id="75a71-519">在等候前離開內容的同步化領域 (如果在同步化內容中) 並重新取得它，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-519"><see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="75a71-520">釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="75a71-520">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="75a71-521">如果超過指定的逾時間隔時間，執行緒會進入就緒序列。</span><span class="sxs-lookup"><span data-stu-id="75a71-521">If the specified time-out interval elapses, the thread enters the ready queue.</span></span> <span data-ttu-id="75a71-522">這個方法也會指定等候之前和重新取得之後，是否要離開內容 (Context) 的同步處理領域 (如果在同步化內容中的話)。</span><span class="sxs-lookup"><span data-stu-id="75a71-522">This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</span></span></summary>
        <returns><span data-ttu-id="75a71-523">如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-523"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="75a71-524">要等到重新取得鎖定之後，此方法才會傳回。</span><span class="sxs-lookup"><span data-stu-id="75a71-524">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-525">這個方法不會傳回在重新取得獨佔鎖定直到`obj`參數。</span><span class="sxs-lookup"><span data-stu-id="75a71-525">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="75a71-526">目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，另一個執行緒可以存取它。</span><span class="sxs-lookup"><span data-stu-id="75a71-526">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="75a71-527">等候重新取得鎖定時，會封鎖呼叫端。</span><span class="sxs-lookup"><span data-stu-id="75a71-527">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="75a71-528">當呼叫端需要等待，因為另一個執行緒的作業而造成狀態變更時，會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-528">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="75a71-529">逾時可確保目前的執行緒在如果另一個執行緒釋放的鎖定，但是未先呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-529">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="75a71-530">它也會在執行緒移動到就緒佇列，以便它可以更快重新取得鎖定，請略過它之前等候佇列中的其他執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-530">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="75a71-531">執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新取得鎖定之前的逾時。執行緒可以評估導致它進入等候條件，才需要呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。</span><span class="sxs-lookup"><span data-stu-id="75a71-531">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="75a71-532">當執行緒呼叫`Wait`，它會釋放鎖定，並進入等待佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-532">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="75a71-533">此時，就緒佇列中的下一個執行緒 （如果有的話） 允許鎖定的控制。</span><span class="sxs-lookup"><span data-stu-id="75a71-533">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="75a71-534">叫用的執行緒`Wait`仍會保留在等候佇列，直到保留鎖定的執行緒叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保留鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-534">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="75a71-535">不過，如果`millisecondsTimeout`另一個執行緒叫用這個物件的前經過<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移到就緒佇列上，才能重新取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-535">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-536">如果<xref:System.Threading.Timeout.Infinite>指定了`millisecondsTimeout`參數，此方法會封鎖無限期地鎖定的持有者會呼叫除非<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-536">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="75a71-537">如果`millisecondsTimeout`等於 0，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-537">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="75a71-538">呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-538">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="75a71-539">就概念而言，`Wait`方法將儲存在呼叫端叫用次數<xref:System.Threading.Monitor.Enter%2A>物件上叫用<xref:System.Threading.Monitor.Exit%2A>次數所需的完全釋放鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-539">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="75a71-540">呼叫端會再封鎖等候重新取得物件時。</span><span class="sxs-lookup"><span data-stu-id="75a71-540">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="75a71-541">當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>所需的還原已儲存次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。</span><span class="sxs-lookup"><span data-stu-id="75a71-541">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="75a71-542">呼叫`Wait`解除鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，會釋放這些鎖定不。</span><span class="sxs-lookup"><span data-stu-id="75a71-542">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-543">同步處理的物件擁有數個參考，包括目前持有鎖定，參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考等候佇列，其中包含執行緒的參考正在等候的物件的狀態變更通知的執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-543">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="75a71-544"><xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊中。</span><span class="sxs-lookup"><span data-stu-id="75a71-544">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="75a71-545">如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-545">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="75a71-546">在結束內容的資訊</span><span class="sxs-lookup"><span data-stu-id="75a71-546">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="75a71-547">`exitContext`參數沒有任何作用，除非<xref:System.Threading.Monitor.Wait%2A>從非預設受管理的內容中呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-547">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="75a71-548">如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="75a71-548">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="75a71-549">即使您目前正在執行的方法不衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。</span><span class="sxs-lookup"><span data-stu-id="75a71-549">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="75a71-550">時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.Monitor.Wait%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-550">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="75a71-551">它會傳回呼叫之後為原始的非預設內容<xref:System.Threading.Monitor.Wait%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="75a71-551">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="75a71-552">這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>套用的屬性。</span><span class="sxs-lookup"><span data-stu-id="75a71-552">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="75a71-553">在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。</span><span class="sxs-lookup"><span data-stu-id="75a71-553">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="75a71-554">如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.Monitor.Wait%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。</span><span class="sxs-lookup"><span data-stu-id="75a71-554">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="75a71-555">當<xref:System.Threading.Monitor.Wait%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="75a71-555">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-556"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-556">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="75a71-557"><see langword="Wait" /> 不是從同步處理的程式碼區塊中呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-557"><see langword="Wait" /> is not invoked from within a synchronized block of code.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="75a71-558">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。</span><span class="sxs-lookup"><span data-stu-id="75a71-558">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span></span> <span data-ttu-id="75a71-559">當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-559">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75a71-560"><paramref name="millisecondsTimeout" /> 參數的值為負，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-560">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-561">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-561">Managed Threading</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="75a71-562">要等候的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-562">The object on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="75a71-563"><see cref="T:System.TimeSpan" />，代表在執行緒進入就緒佇列之前要等候的時間量。</span><span class="sxs-lookup"><span data-stu-id="75a71-563">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span></span></param>
        <param name="exitContext"><span data-ttu-id="75a71-564">在等候前離開內容的同步化領域 (如果在同步化內容中) 並重新取得它，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-564"><see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="75a71-565">釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。</span><span class="sxs-lookup"><span data-stu-id="75a71-565">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span></span> <span data-ttu-id="75a71-566">如果超過指定的逾時間隔時間，執行緒會進入就緒序列。</span><span class="sxs-lookup"><span data-stu-id="75a71-566">If the specified time-out interval elapses, the thread enters the ready queue.</span></span> <span data-ttu-id="75a71-567">在等候之前和重新取得領域之後，可選擇性地結束同步化內容的同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="75a71-567">Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</span></span></summary>
        <returns><span data-ttu-id="75a71-568">如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-568"><see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span></span> <span data-ttu-id="75a71-569">要等到重新取得鎖定之後，此方法才會傳回。</span><span class="sxs-lookup"><span data-stu-id="75a71-569">The method does not return until the lock is reacquired.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="75a71-570">這個方法不會傳回在重新取得獨佔鎖定直到`obj`參數。</span><span class="sxs-lookup"><span data-stu-id="75a71-570">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="75a71-571">目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，另一個執行緒可以存取它。</span><span class="sxs-lookup"><span data-stu-id="75a71-571">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="75a71-572">等候重新取得鎖定時，會封鎖呼叫端。</span><span class="sxs-lookup"><span data-stu-id="75a71-572">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="75a71-573">當呼叫端需要等待，因為另一個執行緒的作業而造成狀態變更時，會呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-573">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="75a71-574">逾時可確保目前的執行緒在如果另一個執行緒釋放的鎖定，但是未先呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-574">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="75a71-575">它也會在執行緒移動到就緒佇列，以便它可以更快重新取得鎖定，請略過它之前等候佇列中的其他執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-575">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="75a71-576">執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新取得鎖定之前的逾時。執行緒可以評估導致它進入等候條件，才需要呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。</span><span class="sxs-lookup"><span data-stu-id="75a71-576">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="75a71-577">當執行緒呼叫`Wait`，它會釋放鎖定，並進入等待佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-577">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="75a71-578">此時，就緒佇列中的下一個執行緒 （如果有的話） 允許鎖定的控制。</span><span class="sxs-lookup"><span data-stu-id="75a71-578">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="75a71-579">叫用的執行緒`Wait`仍會保留在等候佇列，直到保留鎖定的執行緒叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保留鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-579">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="75a71-580">不過，如果`timeout`另一個執行緒叫用這個物件經過毫秒<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移到就緒佇列上，才能重新取得鎖定。</span><span class="sxs-lookup"><span data-stu-id="75a71-580">However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-581">如果<xref:System.TimeSpan>會指定代表-1 毫秒`timeout`參數，此方法會封鎖無限期地鎖定的持有者會呼叫除非<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。</span><span class="sxs-lookup"><span data-stu-id="75a71-581">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="75a71-582">如果`timeout`為 0 毫秒，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。</span><span class="sxs-lookup"><span data-stu-id="75a71-582">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="75a71-583">呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-583">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="75a71-584">就概念而言，`Wait`方法將儲存在呼叫端叫用次數<xref:System.Threading.Monitor.Enter%2A>物件上叫用<xref:System.Threading.Monitor.Exit%2A>次數所需的完全釋放鎖定的物件。</span><span class="sxs-lookup"><span data-stu-id="75a71-584">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="75a71-585">呼叫端會再封鎖等候重新取得物件時。</span><span class="sxs-lookup"><span data-stu-id="75a71-585">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="75a71-586">當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>所需的還原已儲存次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。</span><span class="sxs-lookup"><span data-stu-id="75a71-586">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="75a71-587">呼叫`Wait`解除鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，會釋放這些鎖定不。</span><span class="sxs-lookup"><span data-stu-id="75a71-587">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="75a71-588">同步處理的物件擁有數個參考，包括目前持有鎖定，參考到就緒佇列，其中包含已準備好取得鎖定的執行緒，以及參考等候佇列，其中包含執行緒的參考正在等候的物件的狀態變更通知的執行緒。</span><span class="sxs-lookup"><span data-stu-id="75a71-588">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="75a71-589"><xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊中。</span><span class="sxs-lookup"><span data-stu-id="75a71-589">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="75a71-590">如 < 備註 ><xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>沒有執行緒在等候時，會呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-590">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="75a71-591">在結束內容的資訊</span><span class="sxs-lookup"><span data-stu-id="75a71-591">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="75a71-592">`exitContext`參數沒有任何作用，除非<xref:System.Threading.Monitor.Wait%2A>從非預設受管理的內容中呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-592">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="75a71-593">如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="75a71-593">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="75a71-594">即使您目前正在執行的方法不衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。</span><span class="sxs-lookup"><span data-stu-id="75a71-594">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="75a71-595">時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.Monitor.Wait%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="75a71-595">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="75a71-596">它會傳回呼叫之後為原始的非預設內容<xref:System.Threading.Monitor.Wait%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="75a71-596">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="75a71-597">這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>套用的屬性。</span><span class="sxs-lookup"><span data-stu-id="75a71-597">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="75a71-598">在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。</span><span class="sxs-lookup"><span data-stu-id="75a71-598">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="75a71-599">如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.Monitor.Wait%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。</span><span class="sxs-lookup"><span data-stu-id="75a71-599">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="75a71-600">當<xref:System.Threading.Monitor.Wait%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="75a71-600">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="75a71-601"><paramref name="obj" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-601">The <paramref name="obj" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="75a71-602"><see langword="Wait" /> 不是從同步處理的程式碼區塊中呼叫。</span><span class="sxs-lookup"><span data-stu-id="75a71-602"><see langword="Wait" /> is not invoked from within a synchronized block of code.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="75a71-603">叫用 Wait 的執行緒稍後會從等候狀態中斷。</span><span class="sxs-lookup"><span data-stu-id="75a71-603">The thread that invokes Wait is later interrupted from the waiting state.</span></span> <span data-ttu-id="75a71-604">當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</span><span class="sxs-lookup"><span data-stu-id="75a71-604">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="75a71-605"><paramref name="timeout" /> 參數為負值且不表示 <see cref="F:System.Threading.Timeout.Infinite" /> (-1 毫秒)，或大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="75a71-605">The <paramref name="timeout" /> parameter is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="75a71-606">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="75a71-606">Managed Threading</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>