<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cfafcfe91d4ef6eba6ebbbbe6d7101119c93823a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531372" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供一套機制，同步處理物件的存取。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Monitor>類別可讓您取得和釋放特定物件上的鎖定，藉由呼叫來同步存取程式的程式碼區域<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>， <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>，和<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>方法。 物件鎖定提供的功能限制的存取權的程式碼，通常稱為重要區段的區塊。 執行緒擁有之物件的鎖定，而沒有其他執行緒可以取得的鎖定。 您也可以使用<xref:System.Threading.Monitor>類別以確保沒有其他執行緒可以存取一段應用程式的程式碼正在執行的鎖定擁有者，除非另一個執行緒正在執行使用不同的鎖定的物件的程式碼。  
  
 本文內容：  
  
 [Monitor 類別： 概觀](#Overview)   
 [鎖定物件](#Lock)   
 [關鍵區段](#CriticalSection)   
 [Pulse、 PulseAll，並等候](#Pulse)   
 [監視與等候控制代碼](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Monitor 類別： 概觀  
 <xref:System.Threading.Monitor> 具有下列功能：  
  
-   它是隨選物件相關聯。  
  
-   它是未繫結，這表示它可以直接從任何的內容中呼叫。  
  
-   執行個體<xref:System.Threading.Monitor>無法建立類別; 的方法<xref:System.Threading.Monitor>類別都是靜態的。 同步處理控制存取的物件傳遞給每個方法的重要區段。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>字串以外的鎖定物件的類別 (也就是參考型別以外<xref:System.String>)，不實值類型。 如需詳細資訊，請參閱的多載<xref:System.Threading.Monitor.Enter%2A>方法和[之鎖定物件](#Lock)本文中稍後的章節。  
  
 下表描述可以存取已同步處理的物件的執行緒所採取的動作：  
  
|動作|描述|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|取得物件的鎖定。 此動作也會標示重要區段的開頭。 沒有其他執行緒可以進入重要區段，除非它使用不同的鎖定的物件的重要區段中執行的指示。|  
|<xref:System.Threading.Monitor.Wait%2A>|若要允許其他鎖定和存取物件的執行緒釋放物件上的鎖定。 呼叫執行緒等候另一個執行緒存取的物件。 Pulse 信號用來通知物件狀態變更的相關的等候中執行緒。|  
|<xref:System.Threading.Monitor.Pulse%2A> （信號）， <xref:System.Threading.Monitor.PulseAll%2A>|將訊號傳送至一個或多個等候中執行緒。 信號通知等候的鎖定物件的狀態已變更，執行緒和鎖定擁有者已準備好解除鎖定。 等候執行緒被放在物件的就緒佇列，讓它最後可能會收到物件的鎖定。 一旦執行緒擁有鎖定，它可以檢查以查看是否已到達所需的狀態物件的新狀態。|  
|<xref:System.Threading.Monitor.Exit%2A>|釋放物件上的鎖定。 此動作也會標示鎖定物件所保護的重要區段的結尾。|  
  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，有兩組多載<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.TryEnter%2A>方法。 一組多載具有`ref`（C# 中） 或`ByRef`（在 Visual Basic)<xref:System.Boolean>參數，自動設定為`true`如果已取得鎖定，即使取得鎖定時，會擲回例外狀況。 如果很重要，鎖定在所有情況下，即使鎖定所保護的資源可能未處於一致的狀態，請使用這些多載。  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>鎖定物件  
 Monitor 類別組成`static`（C# 中） 或`Shared`（在 Visual Basic) 控制存取關鍵區段的物件運作的方法。  下列資訊會保留每個同步處理的物件：  
  
-   參考目前擁有鎖定的執行緒。  
  
-   參考就緒佇列，其中包含要取得的鎖定的執行緒。  
  
-   等候佇列，其中包含的執行緒正在等候的鎖定物件的狀態變更通知所參考。  
  
 <xref:System.Threading.Monitor> 會鎖定物件 (也就是參考類型)，而不會鎖定值類型。 雖然您可以傳遞值類型到 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>，它會個別針對每個呼叫進行 boxed 處理。 因為每個呼叫會建立不同的物件，<xref:System.Threading.Monitor.Enter%2A> 絕不會封鎖，且它應該要保護的程式碼不會真地同步處理。 此外，傳遞給 <xref:System.Threading.Monitor.Exit%2A> 的物件不同於傳遞給 <xref:System.Threading.Monitor.Enter%2A> 的物件，因此 <xref:System.Threading.Monitor> 會擲回 <xref:System.Threading.SynchronizationLockException> 例外狀況，以及訊息「從未同步處理的程式碼區塊呼叫物件同步化方法」。  
  
 下列範例說明此問題。 它會啟動 10 個工作，其中每個工作睡眠 250 毫秒。 每一項工作接著會更新計數器變數 `nTasks`，這是要計算實際啟動並執行的工作數目。 由於 `nTasks` 是可以同時由多個工作更新的全域變數，因此使用監視器來防止多個工作同時修改。 不過，如範例的輸出所示，每項工作都擲回 <xref:System.Threading.SynchronizationLockException> 例外狀況。  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 每個工作都擲回 <xref:System.Threading.SynchronizationLockException> 例外狀況是因為 `nTasks` 變數在呼叫每個工作中的 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法之前會進行 boxed 處理。 換句話說，每個方法呼叫都被傳遞個別的變數，且與其他變數無關。 `nTasks` 在呼叫 <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> 方法時會再次進行 boxed 處理。 同樣地，這會建立十個彼此獨立的新 boxed 變數 `nTasks`，以及在呼叫 <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> 方法時建立的十個 boxed 變數。 接著便擲回例外狀況，因為我們的程式碼嘗試對於先前未鎖定的新建變數釋放鎖定。  
  
 雖然您可以先將值類型變數進行 box 處理，然後再呼叫 <xref:System.Threading.Monitor.Enter%2A> 和 <xref:System.Threading.Monitor.Exit%2A>，如下列範例所示，並將相同的 boxed 物件傳遞給這兩種方法，但這麼做並沒有任何益處。 變更 unboxed 變數不會反映在 boxed 複本，且沒有任何方法可變更 boxed 複本的值。  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 選取要同步處理的物件，您應該鎖定只有在私用或內部的物件上。 外部物件上鎖定可能會導致死結，因為不相關的程式碼可能會選擇相同的物件，來針對不同目的鎖定。  
  
 請注意，您可以同步處理多個應用程式定義域中的物件上如果用於鎖定的物件衍生自<xref:System.MarshalByRefObject>。  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>關鍵區段  
 使用<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>標記開頭和結尾關鍵區段的方法。  
  
> [!NOTE]
>  所提供的功能<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>方法等同於所提供的[鎖定](~/docs/csharp/language-reference/keywords/lock-statement.md)C# 中的陳述式和[SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) ，除了在 Visual Basic 中的陳述式語言建構包裝<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType>方法多載而<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>方法中的`try`...`finally` 區塊，以確保釋放監視器。  
  
 如果重要區段是一組連續的指示，然後取得的鎖定<xref:System.Threading.Monitor.Enter%2A>方法保證只有單一執行緒可以執行括住的程式碼，與鎖定的物件。 在此情況下，我們建議您將在該程式碼`try`封鎖，並將呼叫<xref:System.Threading.Monitor.Exit%2A>方法中的`finally`區塊。 這可確保即使發生例外狀況，就會釋放鎖定。 下列程式碼片段將示範這個模式。  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 這項工具通常用來同步處理存取靜態或類別的執行個體方法。  
  
 如果關鍵區段跨越整個方法，可以達成的鎖定機能放置<xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>於方法，並指定<xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized>的建構函式中的值<xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>。 當您使用這個屬性，<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>方法呼叫不需要。 下列程式碼片段將說明這種模式：  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 請注意，此屬性會造成目前的執行緒持有的鎖定，直到該方法傳回。如果可以更快地解除鎖定，使用<xref:System.Threading.Monitor>類別，C#[鎖定](~/docs/csharp/language-reference/keywords/lock-statement.md)陳述式或 Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md)方法，而不是屬性內的陳述式。  
  
 雖然您可以針對<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>鎖定和釋出跨成員或類別界限或兩者的指定的物件的陳述式，不建議此做法。  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Pulse、 PulseAll，並等候  
 一旦執行緒擁有鎖定，而且已進入鎖定來保護重要區段，它可以呼叫<xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>， <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>，和<xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>方法。  
  
 <xref:System.Threading.Monitor.Wait%2A> 如果它會保留、 允許等候執行緒或執行緒取得鎖定，進入重要區段，並等候通知呼叫釋放鎖定<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>或<xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>方法。 當 <xref:System.Threading.Monitor.Wait%2A> 收到通知時，它會傳回並再一次取得鎖定。  
  
 <xref:System.Threading.Monitor.Pulse%2A> 和 <xref:System.Threading.Monitor.PulseAll%2A> 都會傳送訊號，以便等候佇列中的下一個執行緒能繼續。  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>監視與等候控制代碼  
 請務必注意使用區別<xref:System.Threading.Monitor>類別和<xref:System.Threading.WaitHandle>物件。  
  
-   <xref:System.Threading.Monitor>類別是純粹 managed、 完全可攜，而且可能在作業系統資源需求方面更有效率。  
  
-   <xref:System.Threading.WaitHandle> 物件代表作業系統可等候物件、適用於 managed 和 unmanaged 程式碼之間的同步處理，並且公開一些進階的作業系統功能，例如一次等候許多物件的能力。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Threading.Monitor>類別以同步存取單一執行個體所表示的隨機號碼產生器<xref:System.Random>類別。 此範例會建立十個工作，其中每個執行緒集區執行緒非同步執行。 每項工作會產生 10,000 的隨機數字，計算其平均值，然後更新維護累計值產生隨機數字的數目和其總和的兩個程序層級變數。 尚未執行所有工作之後，這兩個值然後可用來計算整體的平均數。  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 它們可存取從任何執行緒集區執行緒上執行的工作，因為存取變數`total`和`n`也進行同步處理。 <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType>方法用於此目的。  
  
 下列範例示範如何結合的使用<xref:System.Threading.Monitor>類別 (實作`lock`或`SyncLock`語言建構)，則<xref:System.Threading.Interlocked>類別，而<xref:System.Threading.AutoResetEvent>類別。 它會定義兩個`internal`（C# 中） 或`Friend`（在 Visual Basic) 類別，`SyncResource`和`UnSyncResource`，分別提供同步和非同步存取資源。 為了確保範例說明同步存取和非同步存取 （這可能是大小寫，如果每個方法呼叫都迅速完成） 之間的差異，這個方法會包含隨機延遲： 針對其執行緒<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>屬性為偶數，方法會呼叫<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>以引入 2000 毫秒的延遲。 請注意，因為`SyncResource`類別不是公用的用戶端程式碼都在同步處理的資源上取得鎖定; 內部類別本身會取得鎖定。 這可防止惡意程式碼在公開物件上取得鎖定。  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 此範例會定義變數， `numOps`，定義嘗試存取資源的執行緒數目。 應用程式執行緒呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType>方法的同步和非同步存取五次時，每個。 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType>方法具有單一參數，不接受任何參數，且不傳回值的委派。 針對同步存取，它會叫用`SyncUpdateResource`方法; 針對未同步存取，它會叫用`UnSyncUpdateResource`方法。 在方法呼叫的每個設定之後呼叫的應用程式執行緒[AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*)方法，以封鎖直到<xref:System.Threading.AutoResetEvent>執行個體收到訊號。  
  
 每次呼叫`SyncUpdateResource`方法都會呼叫內部`SyncResource.Access`方法，然後呼叫<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法以遞減`numOps`計數器。 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法會用於遞減的計數器，因為否則您無法確定在第二個執行緒會存取該值，才能在第一個執行緒的遞減值儲存在變數。 當上次同步處理背景工作執行緒遞減的計數器為零時，表示所有同步處理的執行緒都已完成存取資源，`SyncUpdateResource`方法呼叫<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>方法，以指示主執行緒繼續執行。  
  
 每次呼叫`UnSyncUpdateResource`方法都會呼叫內部`UnSyncResource.Access`方法，然後呼叫<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法以遞減`numOps`計數器。 同樣地，<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>方法會用於遞減的計數器，以確保第二個執行緒不會無法存取值在第一個執行緒的遞減值已指派給變數之前。 當上次非同步處理背景工作執行緒將計數器為零時，表示沒有其他非同步處理的執行緒需要存取資源，`UnSyncUpdateResource`方法呼叫<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>方法，以指示主執行緒繼續執行.  
  
 如範例輸出所示，同步存取可確保呼叫執行緒會先結束受保護的資源，其他執行緒才能存取該資源；每個執行緒都會等候其前置項。 相反地，若未鎖定，`UnSyncResource.Access`依執行緒到達的順序呼叫方法。  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得指定之物件的獨佔鎖定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要從其上取得監視器鎖定的物件。</param>
        <summary>取得指定物件的獨佔鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`Enter`取得<xref:System.Threading.Monitor>上做為參數傳遞的物件。 如果另一個執行緒已執行`Enter`物件但尚未執行對應<xref:System.Threading.Monitor.Exit%2A>，目前的執行緒會封鎖直到另一個執行緒釋放物件。 它是合法的叫用的相同執行緒`Enter`不止一次，而不封鎖它; 不過，有相同數目的`Exit`其他執行緒等候的物件會解除封鎖之前，必須叫用呼叫。  
  
 使用<xref:System.Threading.Monitor>鎖定的物件 （也就是參考類型），不實值類型。 當您將傳遞的值類型變數`Enter`，它會進行 boxed 處理做為物件。 如果您將傳遞至相同的變數`Enter`同樣地，它會進行 boxed 處理為不同的物件，並不會封鎖執行緒。 在此情況下，程式碼，`Monitor`會真地保護未受保護。 此外，當您將變數傳遞給`Exit`，建立另一個不同的物件。 因為物件傳遞給`Exit`不同於傳遞給物件`Enter`，`Monitor`會擲回<xref:System.Threading.SynchronizationLockException>。 如需詳細資訊，請參閱觀念性主題[監視器](xref:System.Threading.Monitor)。  
  
 <xref:System.Threading.Thread.Interrupt%2A> 可以中斷執行緒正在等候輸入`Monitor`物件上。 A<xref:System.Threading.ThreadInterruptedException>就會擲回。  
  
 使用 C# `try`...`finally` 區塊 (`Try`...`Finally` 在 Visual Basic) 以確保您發行監視，或使用 C#`lock`陳述式 (`SyncLock`陳述式在 Visual Basic 中的)，其中包裝<xref:System.Threading.Monitor.Enter%2A>和<xref:System.Threading.Monitor.Exit%2A>方法`try`...`finally` 區塊。  
  
   
  
## Examples  
 下列範例示範如何使用 `Enter` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <param name="lockTaken">嘗試取得鎖定的結果 (以傳址方式傳遞)。 輸入必須是 <see langword="false" />。 如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。 嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。  
  
 注意：如果沒有發生例外狀況，這個方法的輸出一律為 <see langword="true" />。</param>
        <summary>取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`Enter`取得<xref:System.Threading.Monitor>方式傳遞的物件上`obj`參數。 如果另一個執行緒已執行`Enter`物件但尚未執行對應<xref:System.Threading.Monitor.Exit%2A>，目前的執行緒會封鎖直到另一個執行緒釋放物件。 它是合法的叫用的相同執行緒`Enter`不止一次，而不封鎖它; 不過，有相同數目的`Exit`其他執行緒等候的物件會解除封鎖之前，必須叫用呼叫。  
  
 如果無法取得鎖定，因為發生例外狀況，該變數的指定`lockTaken`參數是`false`這個方法會結束之後。 這可讓程式能夠判斷是否需要釋出鎖定，請在所有情況下。 如果這個方法會傳回而不擲回例外狀況變數指定`lockTaken`參數永遠是`true`，並不需要進行測試。  
  
 使用<xref:System.Threading.Monitor>鎖定的物件 （也就是參考類型），不實值類型。 當您將傳遞的值類型變數`Enter`，它會進行 boxed 處理做為物件。 如果您將傳遞至相同的變數`Enter`同樣地，它會進行 boxed 處理為不同的物件，並不會封鎖執行緒。 在此情況下，程式碼，`Monitor`會真地保護未受保護。 此外，當您將變數傳遞給`Exit`，建立另一個不同的物件。 因為物件傳遞給`Exit`不同於傳遞給物件`Enter`，`Monitor`會擲回<xref:System.Threading.SynchronizationLockException>。 如需詳細資訊，請參閱觀念性主題[監視器](xref:System.Threading.Monitor)。  
  
 <xref:System.Threading.Thread.Interrupt%2A> 可以中斷執行緒正在等候輸入`Monitor`物件上。 A<xref:System.Threading.ThreadInterruptedException>就會擲回。  
  
   
  
## Examples  
 下列程式碼示範基本模式使用<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>方法多載。 這個多載一律設定為傳遞給變數的值`ref`參數 (`ByRef`在 Visual Basic 中) `lockTaken`，即使方法擲回例外狀況，因此變數的值是可靠的方式來測試是否為已鎖定已發行。  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要從其上釋出鎖定的物件。</param>
        <summary>釋出指定物件的獨佔鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫的執行緒必須在擁有鎖定`obj`參數。 如果呼叫執行緒擁有之指定的物件上的鎖定，而且已有相同數目的`Exit`和<xref:System.Threading.Monitor.Enter%2A>呼叫物件的則會釋放鎖定。 如果呼叫執行緒已不會叫用`Exit`每次`Enter`，不會釋放鎖定。  
  
 如果在釋放鎖定其他執行緒處於就緒佇列物件，其中一個執行緒取得鎖定。 如果其他的執行緒在等候取得鎖定的等候佇列中，它們不會自動移動到就緒佇列時的鎖定擁有者呼叫`Exit`。 若要移動一或多個等候中執行緒進入就緒佇列，呼叫<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>叫用之前`Exit`。  
  
   
  
## Examples  
 下列範例示範如何使用 `Exit` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">目前執行緒沒有指定物件的鎖定。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要測試的物件。</param>
        <summary>判斷目前執行緒是否保持鎖定指定的物件。</summary>
        <returns>
          如果目前的執行緒持有 <paramref name="obj" /> 的鎖定，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法僅適用於所使用的方法取得的鎖定<xref:System.Threading.Monitor>類別，或使用 C#`lock`陳述式或 Visual Basic`SyncLock`陳述式，以實作<xref:System.Threading.Monitor>。  
  
 使用此方法使用診斷工具，例如<xref:System.Diagnostics.Debug.Assert%2A>方法和<xref:System.Diagnostics.Contracts.Contract>類別，以偵錯涉及的鎖定問題<xref:System.Threading.Monitor>類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">執行緒正等候的物件。</param>
        <summary>通知等候佇列中的執行緒，鎖定物件的狀態有所變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有目前的鎖定擁有者可以發出信號，正在等候的物件使用`Pulse`。  
  
 目前擁有指定的物件上鎖定的執行緒會叫用這個方法來通知鎖定列中的下一個執行緒。 接收 pulse，等候的執行緒會移到就緒佇列。 當執行緒，叫用`Pulse`釋出鎖定就緒佇列 （這不一定接受 pulse 的執行緒） 中的下一個執行緒取得鎖定。  
  
> [!IMPORTANT]
>  <xref:System.Threading.Monitor>類別不會維護狀態，表示<xref:System.Threading.Monitor.Pulse%2A>呼叫方法。 因此，如果您呼叫<xref:System.Threading.Monitor.Pulse%2A>時沒有任何執行緒正在等待下, 一個執行緒呼叫<xref:System.Threading.Monitor.Wait%2A>區塊如同<xref:System.Threading.Monitor.Pulse%2A>永遠不會呼叫。 如果使用兩個執行緒<xref:System.Threading.Monitor.Pulse%2A>和<xref:System.Threading.Monitor.Wait%2A>互動，這可能會造成死結。 這和行為的<xref:System.Threading.AutoResetEvent>類別： 如果您發出信號<xref:System.Threading.AutoResetEvent>藉由呼叫其<xref:System.Threading.EventWaitHandle.Set%2A>方法，而且沒有任何執行緒等候，<xref:System.Threading.AutoResetEvent>仍會留在收到信號狀態，直到執行緒呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>， <xref:System.Threading.WaitHandle.WaitAny%2A>，或<xref:System.Threading.WaitHandle.WaitAll%2A>。 <xref:System.Threading.AutoResetEvent>釋出該執行緒，並傳回未發出信號的狀態。  
  
 請注意，同步處理的物件擁有數個的參考，包括之執行緒的目前擁有鎖定，參考到就緒佇列，其中包含要取得的鎖定的執行緒，以及參考等候佇列中，參考它包含正在等候的物件的狀態變更通知的執行緒。  
  
 `Pulse`， <xref:System.Threading.Monitor.PulseAll%2A>，和<xref:System.Threading.Monitor.Wait%2A>方法必須從叫用同步處理的程式碼區塊內。  
  
 若要表示多個執行緒，使用<xref:System.Threading.Monitor.PulseAll%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼叫執行緒沒有指定物件的鎖定。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">送出 Pulse 的物件。</param>
        <summary>通知所有等候中的執行緒，物件的狀態有所變更。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前擁有指定的物件上鎖定的執行緒會叫用這個方法來通知所有等候取得物件鎖定的執行緒。 訊號傳送之後，等候中的執行緒會移到就緒佇列。 當執行緒，叫用`PulseAll`釋出鎖定就緒佇列中的下一個執行緒取得鎖定。  
  
 請注意，同步處理的物件擁有數個的參考，包括之執行緒的目前擁有鎖定，參考到就緒佇列，其中包含要取得的鎖定的執行緒，以及參考等候佇列中，參考它包含正在等候的物件的狀態變更通知的執行緒。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， `PulseAll`，和<xref:System.Threading.Monitor.Wait%2A>方法必須從叫用同步處理的程式碼區塊內。  
  
 備註<xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>時沒有任何執行緒正在等候呼叫。  
  
 若要表示的單一執行緒，使用`Pulse`方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼叫執行緒沒有指定物件的鎖定。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>嘗試取得指定物件的獨佔鎖定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <summary>嘗試取得指定物件的獨佔鎖定。</summary>
        <returns>
          如果目前執行緒取得鎖定，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成功，這個方法會取得獨佔鎖定上`obj`參數。 這個方法會立即傳回，鎖定可用。  
  
 這個方法是類似於<xref:System.Threading.Monitor.Enter%2A>，但永遠不會封鎖目前的執行緒。 如果執行緒無法輸入而不會封鎖，則方法會傳回`false,`。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定的物件 （也就是參考類型），不實值類型。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>發行項。  
  
 若要確保執行緒不進入重要區段，您應該檢查方法的傳回值和關鍵區段中執行程式碼，只有它的傳回值是`true`。 下列程式碼片段會顯示呼叫這個方法所使用的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>中`finally`區塊，以確保呼叫執行緒釋放其重要區段的鎖定，發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 下列程式碼範例會示範如何使用 `TryEnter` 方法。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <param name="lockTaken">嘗試取得鎖定的結果 (以傳址方式傳遞)。 輸入必須是 <see langword="false" />。 如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。 嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。</param>
        <summary>嘗試取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成功，這個方法會取得獨佔鎖定上`obj`參數。 這個方法會立即傳回，鎖定可用。  
  
 如果無法取得鎖定，因為發生例外狀況，該變數的指定`lockTaken`參數是`false`這個方法會結束之後。 這可讓程式能夠判斷是否需要釋出鎖定，請在所有情況下。  
  
 這個方法是類似於<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>，但永遠不會封鎖目前的執行緒。 如果執行緒無法進入而不會封鎖，`lockTaken`引數設定為`false`此方法傳回時。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定的物件 （也就是參考類型），不實值類型。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>發行項。  
  
 為確保執行緒不進入重要區段，您應該檢查的值`lockTaken`並執行程式碼在重要區段中，只有其值是`true`。 下列程式碼片段會顯示呼叫這個方法所使用的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>中`finally`區塊，以確保呼叫執行緒釋放其重要區段的鎖定，發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 下列程式碼示範基本模式使用<xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>方法多載。 這個多載一律設定為傳遞給變數的值`ref`參數 (`ByRef`在 Visual Basic 中) `lockTaken`，即使方法擲回例外狀況，因此變數的值是可靠的方式來測試是否為已鎖定已發行。  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <param name="millisecondsTimeout">等候鎖定的毫秒數。</param>
        <summary>嘗試取得指定物件的獨佔鎖定 (在指定的毫秒數時間內)。</summary>
        <returns>
          如果目前執行緒取得鎖定，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`參數等於<xref:System.Threading.Timeout.Infinite>，這個方法相當於<xref:System.Threading.Monitor.Enter%2A>。 如果`millisecondsTimeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%2A>。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定的物件 （也就是參考類型），不實值類型。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>發行項。  
  
 若要確保執行緒不進入重要區段，您應該檢查方法的傳回值和關鍵區段中執行程式碼，只有它的傳回值是`true`。 下列程式碼片段會顯示呼叫這個方法所使用的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>中`finally`區塊，以確保呼叫執行緒釋放其重要區段的鎖定，發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是負數，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表等候鎖定的時間量。 -1 毫秒的值會指定無限期等候。</param>
        <summary>嘗試取得指定物件的獨佔鎖定 (在指定的時間內)。</summary>
        <returns>
          如果目前執行緒取得鎖定，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果值`timeout`轉換成毫秒參數等於-1，此方法相當於<xref:System.Threading.Monitor.Enter%2A>。 如果值`timeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%2A>。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定的物件 （也就是參考類型），不實值類型。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>類別主題。  
  
 若要確保執行緒不進入重要區段，您應該檢查方法的傳回值和關鍵區段中執行程式碼，只有它的傳回值是`true`。 下列程式碼片段會顯示呼叫這個方法所使用的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>中`finally`區塊，以確保呼叫執行緒釋放其重要區段的鎖定，發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值 (毫秒) 為負數且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (–1 毫秒)，或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <param name="millisecondsTimeout">等候鎖定的毫秒數。</param>
        <param name="lockTaken">嘗試取得鎖定的結果 (以傳址方式傳遞)。 輸入必須是 <see langword="false" />。 如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。 嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。</param>
        <summary>嘗試在指定的毫秒數內取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`參數等於<xref:System.Threading.Timeout.Infinite>，這個方法相當於<xref:System.Threading.Monitor.Enter%28System.Object%29>。 如果`millisecondsTimeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%28System.Object%29>。  
  
 如果無法取得鎖定，因為發生例外狀況，該變數的指定`lockTaken`參數是`false`這個方法會結束之後。 這可讓程式能夠判斷是否需要釋出鎖定，請在所有情況下。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定的物件 （也就是參考類型），不實值類型。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>類別主題。  
  
 為確保執行緒不進入重要區段，您應該檢查的值`lockTaken`並執行程式碼在重要區段中，只有其值是`true`。 下列程式碼片段會顯示呼叫這個方法所使用的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>中`finally`區塊，以確保呼叫執行緒釋放其重要區段的鎖定，發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 下列程式碼示範基本模式使用<xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>方法多載。 這個多載一律設定為傳遞給變數的值`ref`參數 (`ByRef`在 Visual Basic 中) `lockTaken`，即使方法擲回例外狀況，因此變數的值是可靠的方式來測試是否為已鎖定已發行。  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是負數，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">要取得鎖定的物件。</param>
        <param name="timeout">等候鎖定的時間長度。 -1 毫秒的值會指定無限期等候。</param>
        <param name="lockTaken">嘗試取得鎖定的結果 (以傳址方式傳遞)。 輸入必須是 <see langword="false" />。 如果已取得鎖定，輸出就是 <see langword="true" />；否則輸出為 <see langword="false" />。 嘗試取得鎖定期間，即使發生例外狀況，仍然會設定輸出。</param>
        <summary>嘗試在指定的時間內取得指定之物件的獨佔鎖定，並且完整設定值，指出是否採用鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果值`timeout`轉換成毫秒參數等於-1，此方法相當於<xref:System.Threading.Monitor.Enter%28System.Object%29>。 如果值`timeout`等於 0，此方法相當於<xref:System.Threading.Monitor.TryEnter%28System.Object%29>。  
  
 如果無法取得鎖定，因為發生例外狀況，該變數的指定`lockTaken`參數是`false`這個方法會結束之後。 這可讓程式能夠判斷是否需要釋出鎖定，請在所有情況下。  
  
> [!NOTE]
>  使用<xref:System.Threading.Monitor>鎖定的物件 （也就是參考類型），不實值類型。 如需詳細資訊，請參閱<xref:System.Threading.Monitor>類別主題。  
  
 為確保執行緒不進入重要區段，您應該檢查的值`lockTaken`並執行程式碼在重要區段中，只有其值是`true`。 下列程式碼片段會顯示呼叫這個方法所使用的模式。 請注意，您應該呼叫<xref:System.Threading.Monitor.Exit%2A>中`finally`區塊，以確保呼叫執行緒釋放其重要區段的鎖定，發生例外狀況。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="lockTaken" /> 的輸入為 <see langword="true" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 的值 (毫秒) 為負數且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (–1 毫秒)，或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。</summary>
        <returns>
          如果因為呼叫端重新取得指定物件的鎖定所以呼叫被傳回，則為 <see langword="true" />。 如果鎖定不被重新取得，則這個方法不會傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，以供另一個執行緒存取。 呼叫端會在等待重新取得鎖定時遭到封鎖。 當呼叫端必須等候另一個執行緒的作業之後會發生的狀態變更時，會呼叫這個方法。  
  
 當一個執行緒呼叫`Wait`，它會釋放鎖定的物件上並進入物件的等候佇列。 物件的就緒佇列中的下一個執行緒 （如果有的話） 取得鎖定，且物件的獨佔使用。 所有呼叫的執行緒`Wait`保留在等候佇列，直到它們收到信號，以從<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>、 傳送的鎖定擁有者。 如果`Pulse`會傳送執行緒在等候中佇列的開頭會受到影響。 如果`PulseAll`傳送時，會影響所有的執行緒正在等候的物件。 當收到信號時，一或多個執行緒離開等候佇列，並進入就緒佇列。 允許就緒佇列中的執行緒重新取得鎖定。  
  
 這個方法傳回時呼叫的執行緒重新取得鎖定的物件。 請注意，這個方法會無限期地封鎖的鎖定擁有者不會呼叫如果`Pulse`或`PulseAll`。  
  
 呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。 就概念而言，`Wait`方法儲存的呼叫端叫用的次數`Enter`物件上，並叫用`Exit`任意多次，視需要以完全釋放鎖定的物件。 等候重新取得物件時再封鎖呼叫端。 當呼叫端重新取得鎖定時，系統就會呼叫`Enter`視需要還原已儲存的次數`Enter`呼叫端的計數。 呼叫`Wait`釋放的鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，這些鎖定不會被釋放。  
  
 請注意，同步處理的物件擁有數個的參考，包括之執行緒的目前擁有鎖定，參考到就緒佇列，其中包含要取得的鎖定的執行緒，以及參考等候佇列中，參考它包含正在等候的物件的狀態變更通知的執行緒。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊內。  
  
 備註<xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>時沒有任何執行緒正在等候呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼叫執行緒沒有指定物件的鎖定。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。 當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <param name="millisecondsTimeout">在執行緒進入就緒佇列之前要等候的毫秒數。</param>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。 如果超過指定的逾時間隔時間，執行緒會進入就緒序列。</summary>
        <returns>
          如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。 要等到重新取得鎖定之後，此方法才會傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會傳回它在鎖的獨佔鎖定直到`obj`參數。  
  
 目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，以供另一個執行緒存取。 呼叫端會在等待重新取得鎖定時遭到封鎖。 當呼叫端必須等候另一個執行緒的作業之後會發生的狀態變更時，會呼叫這個方法。  
  
 逾時可確保在目前的執行緒在如果另一個執行緒釋放的鎖定，而不會第一個呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 它也會將執行緒移至就緒佇列，並略過比較早等候佇列中的其他執行緒，使它可以更快取得鎖定。 執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新在逾時前的鎖定。執行緒可以評估的條件，導致它進入等候，而且如果必要的呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。  
  
 當一個執行緒呼叫`Wait`，它會釋放鎖定的物件上並進入物件的等候佇列。 物件的就緒佇列中的下一個執行緒 （如果有的話） 取得鎖定，且物件的獨佔使用。 叫用執行緒`Wait`仍會留在等候佇列，直到擁有鎖定的執行緒會叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保持鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。 不過，如果`millisecondsTimeout`另一個執行緒叫用這個物件之前經過<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移至就緒佇列上，才能重新取得鎖定。  
  
> [!NOTE]
>  如果<xref:System.Threading.Timeout.Infinite>指定`millisecondsTimeout`參數，這個方法會封鎖無限期除非鎖定的擁有者呼叫<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`millisecondsTimeout`等於 0，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。  
  
 呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。 就概念而言，`Wait`方法儲存的呼叫端叫用的次數<xref:System.Threading.Monitor.Enter%2A>物件上，並叫用<xref:System.Threading.Monitor.Exit%2A>任意多次，視需要以完全釋放鎖定的物件。 等候重新取得物件時再封鎖呼叫端。 當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>視需要還原已儲存的次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。 呼叫`Wait`釋放的鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，這些鎖定不會被釋放。  
  
> [!NOTE]
>  同步處理的物件擁有數個參考，包括之執行緒的目前擁有鎖定，參考到就緒佇列，其中包含要取得的鎖定的執行緒，以及參考等候佇列，其中包含的參考正在等候的物件的狀態變更通知的執行緒。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊內。  
  
 備註<xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>時沒有任何執行緒正在等候呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼叫執行緒沒有指定物件的鎖定。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。 當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 參數的值為負，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表在執行緒進入就緒佇列之前要等候的時間量。</param>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。 如果超過指定的逾時間隔時間，執行緒會進入就緒序列。</summary>
        <returns>
          如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。 要等到重新取得鎖定之後，此方法才會傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會傳回它在鎖的獨佔鎖定直到`obj`參數。  
  
 目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，以供另一個執行緒存取。 呼叫端會在等待重新取得鎖定時遭到封鎖。 當呼叫端必須等候另一個執行緒的作業之後會發生的狀態變更時，會呼叫這個方法。  
  
 逾時可確保在目前的執行緒在如果另一個執行緒釋放的鎖定，而不會第一個呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 它也會將執行緒移至就緒佇列，並略過比較早等候佇列中的其他執行緒，使它可以更快取得鎖定。 執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新在逾時前的鎖定。執行緒可以評估的條件，導致它進入等候，而且如果必要的呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。  
  
 當一個執行緒呼叫`Wait`，它會釋放鎖定的物件上並進入物件的等候佇列。 物件的就緒佇列中的下一個執行緒 （如果有的話） 取得鎖定，且物件的獨佔使用。 叫用執行緒`Wait`仍會留在等候佇列，直到擁有鎖定的執行緒會叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保持鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。 不過，如果`timeout`另一個執行緒叫用這個物件之前經過<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移至就緒佇列上，才能重新取得鎖定。  
  
> [!NOTE]
>  如果<xref:System.TimeSpan>代表-1 毫秒指定`timeout`參數，這個方法會封鎖無限期除非鎖定的擁有者呼叫<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`timeout`為 0 毫秒，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。  
  
 呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。 就概念而言，`Wait`方法儲存的呼叫端叫用的次數<xref:System.Threading.Monitor.Enter%2A>物件上，並叫用<xref:System.Threading.Monitor.Exit%2A>任意多次，視需要以完全釋放鎖定的物件。 等候重新取得物件時再封鎖呼叫端。 當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>視需要還原已儲存的次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。 呼叫`Wait`釋放的鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，這些鎖定不會被釋放。  
  
> [!NOTE]
>  同步處理的物件擁有數個參考，包括之執行緒的目前擁有鎖定，參考到就緒佇列，其中包含要取得的鎖定的執行緒，以及參考等候佇列，其中包含的參考正在等候的物件的狀態變更通知的執行緒。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊內。  
  
 備註<xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>時沒有任何執行緒正在等候呼叫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼叫執行緒沒有指定物件的鎖定。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。 當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 參數的毫秒值為負，且不表示 <see cref="F:System.Threading.Timeout.Infinite" /> (-1 毫秒)，或大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <param name="millisecondsTimeout">在執行緒進入就緒佇列之前要等候的毫秒數。</param>
        <param name="exitContext">
          在等候前離開內容的同步化領域 (如果在同步化內容中) 並重新取得它，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。 如果超過指定的逾時間隔時間，執行緒會進入就緒序列。 這個方法也會指定等候之前和重新取得之後，是否要離開內容 (Context) 的同步處理領域 (如果在同步化內容中的話)。</summary>
        <returns>
          如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。 要等到重新取得鎖定之後，此方法才會傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會傳回它在鎖的獨佔鎖定直到`obj`參數。  
  
 目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，以供另一個執行緒存取。 呼叫端會在等待重新取得鎖定時遭到封鎖。 當呼叫端必須等候另一個執行緒的作業之後會發生的狀態變更時，會呼叫這個方法。  
  
 逾時可確保在目前的執行緒在如果另一個執行緒釋放的鎖定，而不會第一個呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 它也會將執行緒移至就緒佇列，並略過比較早等候佇列中的其他執行緒，使它可以更快取得鎖定。 執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新在逾時前的鎖定。執行緒可以評估的條件，導致它進入等候，而且如果必要的呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。  
  
 當一個執行緒呼叫`Wait`，它會釋放鎖定，並進入等候佇列。 此時，就緒佇列中的下一個執行緒 （如果有的話） 可取得其控制權的鎖定。 叫用執行緒`Wait`仍會留在等候佇列，直到擁有鎖定的執行緒會叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保持鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。 不過，如果`millisecondsTimeout`另一個執行緒叫用這個物件之前經過<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移至就緒佇列上，才能重新取得鎖定。  
  
> [!NOTE]
>  如果<xref:System.Threading.Timeout.Infinite>指定`millisecondsTimeout`參數，這個方法會封鎖無限期除非鎖定的擁有者呼叫<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`millisecondsTimeout`等於 0，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。  
  
 呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。 就概念而言，`Wait`方法儲存的呼叫端叫用的次數<xref:System.Threading.Monitor.Enter%2A>物件上，並叫用<xref:System.Threading.Monitor.Exit%2A>任意多次，視需要以完全釋放鎖定的物件。 等候重新取得物件時再封鎖呼叫端。 當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>視需要還原已儲存的次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。 呼叫`Wait`釋放的鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，這些鎖定不會被釋放。  
  
> [!NOTE]
>  同步處理的物件擁有數個參考，包括之執行緒的目前擁有鎖定，參考到就緒佇列，其中包含要取得的鎖定的執行緒，以及參考等候佇列，其中包含的參考正在等候的物件的狀態變更通知的執行緒。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊內。  
  
 備註<xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>時沒有任何執行緒正在等候呼叫。  
  
## <a name="notes-on-exiting-the-context"></a>結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.Monitor.Wait%2A>方法從非預設的 managed 內容內呼叫。 如果執行緒位呼叫內部的衍生自類別的執行個體此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不衍生自的類別上<xref:System.ContextBoundObject>、 like <xref:System.String>，您可以在非預設的內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 當您的程式碼在非預設的內容中執行時，指定`true`如`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換至預設內容) 執行之前<xref:System.Threading.Monitor.Wait%2A>方法。 它會傳回原始的非預設內容呼叫之後<xref:System.Threading.Monitor.Wait%2A>方法完成。  
  
 這有助於進行此內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>套用的屬性。 在此情況下，類別的成員的所有呼叫都會自動同步都處理，且同步處理網域為類別的程式碼的整個本文。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.Monitor.Wait%2A>方法，並指定`true`如`exitContext`，執行緒結束的同步處理網域，讓呼叫物件的任何成員，以繼續進行遭到封鎖的執行緒。 當<xref:System.Threading.Monitor.Wait%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入同步處理網域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> 不是從同步處理的程式碼區塊中呼叫。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">叫用 <see langword="Wait" /> 的執行緒稍後會從等候狀態被插斷。 當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 參數的值為負，且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">要等候的物件。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表在執行緒進入就緒佇列之前要等候的時間量。</param>
        <param name="exitContext">
          在等候前離開內容的同步化領域 (如果在同步化內容中) 並重新取得它，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>釋出物件的鎖並且封鎖目前的執行緒，直到這個執行緒重新取得鎖定為止。 如果超過指定的逾時間隔時間，執行緒會進入就緒序列。 在等候之前和重新取得領域之後，可選擇性地結束同步化內容的同步處理領域。</summary>
        <returns>
          如果在經過指定的時間之前重新取得鎖定，則為 <see langword="true" />；如果在經過指定的時間之後重新取得鎖定，則為 <see langword="false" />。 要等到重新取得鎖定之後，此方法才會傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法不會傳回它在鎖的獨佔鎖定直到`obj`參數。  
  
 目前擁有指定的物件上鎖定的執行緒叫用此方法，以便釋出物件，以供另一個執行緒存取。 呼叫端會在等待重新取得鎖定時遭到封鎖。 當呼叫端必須等候另一個執行緒的作業之後會發生的狀態變更時，會呼叫這個方法。  
  
 逾時可確保在目前的執行緒在如果另一個執行緒釋放的鎖定，而不會第一個呼叫不會無限期地封鎖<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法。 它也會將執行緒移至就緒佇列，並略過比較早等候佇列中的其他執行緒，使它可以更快取得鎖定。 執行緒可以測試的傳回值<xref:System.Threading.Monitor.Wait%2A>方法，以判斷它是否重新在逾時前的鎖定。執行緒可以評估的條件，導致它進入等候，而且如果必要的呼叫<xref:System.Threading.Monitor.Wait%2A>方法一次。  
  
 當一個執行緒呼叫`Wait`，它會釋放鎖定，並進入等候佇列。 此時，就緒佇列中的下一個執行緒 （如果有的話） 可取得其控制權的鎖定。 叫用執行緒`Wait`仍會留在等候佇列，直到擁有鎖定的執行緒會叫用<xref:System.Threading.Monitor.PulseAll%2A>，或它是在佇列中的下一步，並保持鎖定的執行緒叫用<xref:System.Threading.Monitor.Pulse%2A>。 不過，如果`timeout`另一個執行緒叫用此物件經過毫秒<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>方法，原始執行緒時，會移至就緒佇列上，才能重新取得鎖定。  
  
> [!NOTE]
>  如果<xref:System.TimeSpan>代表-1 毫秒指定`timeout`參數，這個方法會封鎖無限期除非鎖定的擁有者呼叫<xref:System.Threading.Monitor.Pulse%2A>或<xref:System.Threading.Monitor.PulseAll%2A>。 如果`timeout`為 0 毫秒，呼叫的執行緒`Wait`釋出鎖定，然後才能重新取得鎖定立即進入就緒佇列。  
  
 呼叫端執行`Wait`一次，不論次數<xref:System.Threading.Monitor.Enter%2A>已叫用指定的物件。 就概念而言，`Wait`方法儲存的呼叫端叫用的次數<xref:System.Threading.Monitor.Enter%2A>物件上，並叫用<xref:System.Threading.Monitor.Exit%2A>任意多次，視需要以完全釋放鎖定的物件。 等候重新取得物件時再封鎖呼叫端。 當呼叫端重新取得鎖定時，系統就會呼叫<xref:System.Threading.Monitor.Enter%2A>視需要還原已儲存的次數<xref:System.Threading.Monitor.Enter%2A>呼叫端的計數。 呼叫`Wait`釋放的鎖定指定的物件; 如果呼叫端的其他物件的鎖定擁有者，這些鎖定不會被釋放。  
  
> [!NOTE]
>  同步處理的物件擁有數個參考，包括之執行緒的目前擁有鎖定，參考到就緒佇列，其中包含要取得的鎖定的執行緒，以及參考等候佇列，其中包含的參考正在等候的物件的狀態變更通知的執行緒。  
  
 <xref:System.Threading.Monitor.Pulse%2A>， <xref:System.Threading.Monitor.PulseAll%2A>，和`Wait`方法必須從叫用同步處理的程式碼區塊內。  
  
 備註<xref:System.Threading.Monitor.Pulse%2A>方法說明發生什麼事如果<xref:System.Threading.Monitor.Pulse%2A>時沒有任何執行緒正在等候呼叫。  
  
## <a name="notes-on-exiting-the-context"></a>結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.Monitor.Wait%2A>方法從非預設的 managed 內容內呼叫。 如果執行緒位呼叫內部的衍生自類別的執行個體此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不衍生自的類別上<xref:System.ContextBoundObject>、 like <xref:System.String>，您可以在非預設的內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 當您的程式碼在非預設的內容中執行時，指定`true`如`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換至預設內容) 執行之前<xref:System.Threading.Monitor.Wait%2A>方法。 它會傳回原始的非預設內容呼叫之後<xref:System.Threading.Monitor.Wait%2A>方法完成。  
  
 這有助於進行此內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>套用的屬性。 在此情況下，類別的成員的所有呼叫都會自動同步都處理，且同步處理網域為類別的程式碼的整個本文。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.Monitor.Wait%2A>方法，並指定`true`如`exitContext`，執行緒結束的同步處理網域，讓呼叫物件的任何成員，以繼續進行遭到封鎖的執行緒。 當<xref:System.Threading.Monitor.Wait%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入同步處理網域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> 不是從同步處理的程式碼區塊中呼叫。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">叫用 Wait 的執行緒稍後會從等候狀態中斷。 當另一個執行緒呼叫此執行緒的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法時，就會發生此狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 參數是負值且不代表 <see cref="F:System.Threading.Timeout.Infinite" /> (–1 毫秒)，或是大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
  </Members>
</Type>