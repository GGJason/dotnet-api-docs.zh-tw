<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3b2fdb41b1e5f8614494e0d69b0a97131cab338e" /><Meta Name="ms.sourcegitcommit" Value="662f143e6be46d519ff8ab4451d543d91e651478" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/18/2018" /><Meta Name="ms.locfileid" Value="53567026" /></Metadata><TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b0b64-101">為多重執行緒共用的變數提供不可部分完成的作業 (Atomic Operation)。</span><span class="sxs-lookup"><span data-stu-id="b0b64-101">Provides atomic operations for variables that are shared by multiple threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-102">這個類別的方法來協助防止當排程器會切換內容，直到有執行緒在更新的變數，可由其他執行緒，或在不同的處理器上同時執行兩個執行緒可能會發生的錯誤。</span><span class="sxs-lookup"><span data-stu-id="b0b64-102">The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</span></span> <span data-ttu-id="b0b64-103">這個類別的成員不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b0b64-103">The members of this class do not throw exceptions.</span></span>  
  
 <span data-ttu-id="b0b64-104"><xref:System.Threading.Interlocked.Increment%2A>和<xref:System.Threading.Interlocked.Decrement%2A>方法遞增或遞減變數，並將產生的值儲存在單一作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-104">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation.</span></span> <span data-ttu-id="b0b64-105">在大部分的電腦上遞增變數不是不可部分完成的作業，需要下列步驟：</span><span class="sxs-lookup"><span data-stu-id="b0b64-105">On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</span></span>  
  
1.  <span data-ttu-id="b0b64-106">將值從執行個體變數載入暫存器。</span><span class="sxs-lookup"><span data-stu-id="b0b64-106">Load a value from an instance variable into a register.</span></span>  
  
2.  <span data-ttu-id="b0b64-107">遞增或遞減的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-107">Increment or decrement the value.</span></span>  
  
3.  <span data-ttu-id="b0b64-108">將值儲存在執行個體變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-108">Store the value in the instance variable.</span></span>  
  
 <span data-ttu-id="b0b64-109">如果您不要使用<xref:System.Threading.Interlocked.Increment%2A>和<xref:System.Threading.Interlocked.Decrement%2A>，執行緒可以在執行前兩個步驟之後被優先佔用。</span><span class="sxs-lookup"><span data-stu-id="b0b64-109">If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps.</span></span> <span data-ttu-id="b0b64-110">接著，另一個執行緒可執行所有的三個步驟。</span><span class="sxs-lookup"><span data-stu-id="b0b64-110">Another thread can then execute all three steps.</span></span> <span data-ttu-id="b0b64-111">當第一個執行緒繼續執行時，它會覆寫執行個體變數中的值，而且遞增或遞減的第二個執行緒所執行的效果會遺失。</span><span class="sxs-lookup"><span data-stu-id="b0b64-111">When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</span></span>  

 <span data-ttu-id="b0b64-112"><xref:System.Threading.Interlocked.Add%2A>方法以不可分割方式將整數值新增至整數變數，並傳回新的變數值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-112">The <xref:System.Threading.Interlocked.Add%2A> method atomically adds an integer value to an integer variable and returns the new value of the variable.</span></span>  
  
 <span data-ttu-id="b0b64-113"><xref:System.Threading.Interlocked.Exchange%2A>方法會以不可分割方式交換指定變數的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-113">The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables.</span></span> <span data-ttu-id="b0b64-114"><xref:System.Threading.Interlocked.CompareExchange%2A>方法結合了兩項作業： 比較兩個值，並儲存第三個值其中一個變數，並根據比較結果。</span><span class="sxs-lookup"><span data-stu-id="b0b64-114">The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span> <span data-ttu-id="b0b64-115">比較和交換作業成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-115">The compare and exchange operations are performed as an atomic operation.</span></span>  

 <span data-ttu-id="b0b64-116">請確定任何寫入或讀取權限共用的變數是不可部分完成。</span><span class="sxs-lookup"><span data-stu-id="b0b64-116">Ensure that any write or read access to a shared variable is atomic.</span></span> <span data-ttu-id="b0b64-117">否則，資料可能會損毀，或載入的值可能不正確。</span><span class="sxs-lookup"><span data-stu-id="b0b64-117">Otherwise, the data might be corrupted or the loaded value might be incorrect.</span></span>    
   
  
## Examples  
 <span data-ttu-id="b0b64-118">下列程式碼範例會示範具備執行緒安全資源的鎖定機制。</span><span class="sxs-lookup"><span data-stu-id="b0b64-118">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="b0b64-119">此型別具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="b0b64-119">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-120">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-120">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-121">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-121">Overview of synchronization primitives</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b0b64-122">將兩個整數相加，並以總和取代第一個整數，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-122">Adds two integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-123">包含要加入的第一個值的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-123">A variable containing the first value to be added.</span></span> <span data-ttu-id="b0b64-124">這兩個值的總和會存放在 <paramref name="location1" /> 中。</span><span class="sxs-lookup"><span data-stu-id="b0b64-124">The sum of the two values is stored in <paramref name="location1" />.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-125">要加入 <paramref name="location1" /> 的整數的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-125">The value to be added to the integer at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="b0b64-126">將兩個 32 位元整數加相，並以總和取代第一個整數，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-126">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-127">新值儲存於 <paramref name="location1" />。</span><span class="sxs-lookup"><span data-stu-id="b0b64-127">The new value stored at <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-128">這個方法會藉由包裝來處理溢位狀況： 如果處的值`location1`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>並`value`為 1，結果是<xref:System.Int32.MinValue?displayProperty=nameWithType>; 如果`value`為 2，則結果為 (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); 等等。</span><span class="sxs-lookup"><span data-stu-id="b0b64-128">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int32.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="b0b64-129">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="b0b64-129">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-130"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-130">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-131">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-131">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-132">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-132">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-133">包含要加入的第一個值的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-133">A variable containing the first value to be added.</span></span> <span data-ttu-id="b0b64-134">這兩個值的總和會存放在 <paramref name="location1" /> 中。</span><span class="sxs-lookup"><span data-stu-id="b0b64-134">The sum of the two values is stored in <paramref name="location1" />.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-135">要加入 <paramref name="location1" /> 的整數的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-135">The value to be added to the integer at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="b0b64-136">將兩個 64 位元整數加相，並以總和取代第一個整數，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-136">Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-137">新值儲存於 <paramref name="location1" />。</span><span class="sxs-lookup"><span data-stu-id="b0b64-137">The new value stored at <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-138">這個方法會藉由包裝來處理溢位狀況： 如果處的值`location1`是<xref:System.Int64.MaxValue?displayProperty=nameWithType>並`value`為 1，結果是<xref:System.Int64.MinValue?displayProperty=nameWithType>; 如果`value`為 2，則結果為 (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); 等等。</span><span class="sxs-lookup"><span data-stu-id="b0b64-138">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int64.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="b0b64-139">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="b0b64-139">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-140"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-140">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-141">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-141">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-142">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-142">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b0b64-143">比較兩個值是否相等，如果相等，則取代第一個值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-143">Compares two values for equality and, if they are equal, replaces the first value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-144">目的端，其值會與 <paramref name="comparand" /> 進行比較且可能會被取代。</span><span class="sxs-lookup"><span data-stu-id="b0b64-144">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-145">當比較的結果相等時，會取代目的端值的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-145">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="b0b64-146">與 <paramref name="location1" /> 的值比較的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-146">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="b0b64-147">比較兩個雙精確度浮點數是否相等；如果相等，則取代第一個值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-147">Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="b0b64-148"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-148">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-149">如果`comparand`中的值`location1`相等，則`value`會儲存在`location1`。</span><span class="sxs-lookup"><span data-stu-id="b0b64-149">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="b0b64-150">否則，不會執行任何作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-150">Otherwise, no operation is performed.</span></span> <span data-ttu-id="b0b64-151">比較和交換作業成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-151">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="b0b64-152">傳回值<xref:System.Threading.Interlocked.CompareExchange%2A>是中的原始值`location1`無論交換發生。</span><span class="sxs-lookup"><span data-stu-id="b0b64-152">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b0b64-153">下列程式碼範例示範會累積的累計值的安全執行緒方法<xref:System.Double>值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-153">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values.</span></span> <span data-ttu-id="b0b64-154">兩個執行緒新增一系列的<xref:System.Double>值 使用安全執行緒方法和一般的加法，和當執行緒完成時，會比較總計。</span><span class="sxs-lookup"><span data-stu-id="b0b64-154">Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="b0b64-155">雙處理器的電腦上，沒有顯著的差異總計。</span><span class="sxs-lookup"><span data-stu-id="b0b64-155">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="b0b64-156">在使用安全執行緒方法時，會儲存計算加總的初始值，然後<xref:System.Threading.Interlocked.CompareExchange%2A>方法用來交換新計算的總和，最舊的總計。</span><span class="sxs-lookup"><span data-stu-id="b0b64-156">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="b0b64-157">如果傳回的值不等於儲存的值的加總，然後另一個執行緒已經更新總同時。</span><span class="sxs-lookup"><span data-stu-id="b0b64-157">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="b0b64-158">在此情況下，您必須重複嘗試更新計算加總。</span><span class="sxs-lookup"><span data-stu-id="b0b64-158">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-159"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-159">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-160">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-160">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-161">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-161">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-162">目的端，其值會與 <paramref name="comparand" /> 進行比較且可能會被取代。</span><span class="sxs-lookup"><span data-stu-id="b0b64-162">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-163">當比較的結果相等時，會取代目的端值的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-163">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="b0b64-164">與 <paramref name="location1" /> 的值比較的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-164">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="b0b64-165">比較兩個 32 位元帶正負號的整數是否相等，如果相等，則取代第一個值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-165">Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="b0b64-166"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-166">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-167">如果`comparand`中的值`location1`相等，則`value`會儲存在`location1`。</span><span class="sxs-lookup"><span data-stu-id="b0b64-167">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="b0b64-168">否則，不會執行任何作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-168">Otherwise, no operation is performed.</span></span> <span data-ttu-id="b0b64-169">比較和交換作業成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-169">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="b0b64-170">傳回值<xref:System.Threading.Interlocked.CompareExchange%2A>是中的原始值`location1`無論交換發生。</span><span class="sxs-lookup"><span data-stu-id="b0b64-170">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b0b64-171">下列程式碼範例示範會加總累積的安全執行緒的方法。</span><span class="sxs-lookup"><span data-stu-id="b0b64-171">The following code example demonstrates a thread-safe method that accumulates a running total.</span></span> <span data-ttu-id="b0b64-172">計算加總的初始值會儲存，然後<xref:System.Threading.Interlocked.CompareExchange%2A>方法用來交換新計算的總和，最舊的總計。</span><span class="sxs-lookup"><span data-stu-id="b0b64-172">The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="b0b64-173">如果傳回的值不等於儲存的值的加總，然後另一個執行緒已經更新總同時。</span><span class="sxs-lookup"><span data-stu-id="b0b64-173">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="b0b64-174">在此情況下，您必須重複嘗試更新計算加總。</span><span class="sxs-lookup"><span data-stu-id="b0b64-174">In that case, the attempt to update the running total must be repeated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b0b64-175"><xref:System.Threading.Interlocked.Add%2A>的.NET Framework 2.0 版中引入的方法提供更便利的方式，累積安全執行緒累計總數的整數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-175">The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-176"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-176">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-177">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-177">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-178">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-178">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-179">目的端，其值會與 <paramref name="comparand" /> 進行比較且可能會被取代。</span><span class="sxs-lookup"><span data-stu-id="b0b64-179">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-180">當比較的結果相等時，會取代目的端值的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-180">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="b0b64-181">與 <paramref name="location1" /> 的值比較的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-181">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="b0b64-182">比較兩個 64 位元帶正負號的整數是否相等，如果相等，則取代第一個值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-182">Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="b0b64-183"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-183">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-184">如果`comparand`中的值`location1`相等，則`value`會儲存在`location1`。</span><span class="sxs-lookup"><span data-stu-id="b0b64-184">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="b0b64-185">否則，不會執行任何作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-185">Otherwise, no operation is performed.</span></span> <span data-ttu-id="b0b64-186">比較和交換作業成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-186">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="b0b64-187">傳回值<xref:System.Threading.Interlocked.CompareExchange%2A>是中的原始值`location1`無論交換發生。</span><span class="sxs-lookup"><span data-stu-id="b0b64-187">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-188"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-188">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-189">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-189">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-190">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-190">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-191"><see cref="T:System.IntPtr" /> 目的端，其值會與 <paramref name="comparand" /> 的值進行比較，且可能被 <paramref name="value" /> 所取代。</span><span class="sxs-lookup"><span data-stu-id="b0b64-191">The destination <see cref="T:System.IntPtr" />, whose value is compared with the value of <paramref name="comparand" /> and possibly replaced by <paramref name="value" />.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-192"><see cref="T:System.IntPtr" />，當比較的結果相等時會取代目的端值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-192">The <see cref="T:System.IntPtr" /> that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="b0b64-193"><see cref="T:System.IntPtr" />，會與 <paramref name="location1" /> 的值相比較。</span><span class="sxs-lookup"><span data-stu-id="b0b64-193">The <see cref="T:System.IntPtr" /> that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="b0b64-194">比較兩個平台特定的控制代碼或指標是否相等；如果相等，則取代第一個。</span><span class="sxs-lookup"><span data-stu-id="b0b64-194">Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</span></span></summary>
        <returns><span data-ttu-id="b0b64-195"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-195">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-196">如果`comparand`中的值`location1`相等，則`value`會儲存在`location1`。</span><span class="sxs-lookup"><span data-stu-id="b0b64-196">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="b0b64-197">否則，不會執行任何作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-197">Otherwise, no operation is performed.</span></span> <span data-ttu-id="b0b64-198">比較和交換作業成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-198">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="b0b64-199">這個方法的傳回值是中的原始值`location1`無論交換發生。</span><span class="sxs-lookup"><span data-stu-id="b0b64-199">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b0b64-200"><xref:System.IntPtr> 是特定平台類型。</span><span class="sxs-lookup"><span data-stu-id="b0b64-200"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-201"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-201">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-202">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-202">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-203">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-203">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-204">以傳址方式與 <paramref name="comparand" /> 比較的目的地物件，且可能被取代。</span><span class="sxs-lookup"><span data-stu-id="b0b64-204">The destination object that is compared by reference with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-205">若參考比較結果相等，此物件會取代目的地物件。</span><span class="sxs-lookup"><span data-stu-id="b0b64-205">The object that replaces the destination object if the reference comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="b0b64-206">以傳址方式與位於<paramref name="location1" /> 之物件比較的物件。</span><span class="sxs-lookup"><span data-stu-id="b0b64-206">The object that is compared by reference to the object at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="b0b64-207">比較兩個物件的參考是否相等；如果相等，則取代第一個物件。</span><span class="sxs-lookup"><span data-stu-id="b0b64-207">Compares two objects for reference equality and, if they are equal, replaces the first object.</span></span></summary>
        <returns><span data-ttu-id="b0b64-208"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-208">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="b0b64-209">從 .NET Framework 2.0 開始，<xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> 方法多載會為參考型別提供型別安全的替代方法。</span><span class="sxs-lookup"><span data-stu-id="b0b64-209">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="b0b64-210">我們建議您呼叫它而不是這個多載。</span><span class="sxs-lookup"><span data-stu-id="b0b64-210">We recommend that you call it instead of this overload.</span></span>

<span data-ttu-id="b0b64-211">如果`comparand`和中的物件`location1`上是相等的參考，然後`value`會儲存在`location1`。</span><span class="sxs-lookup"><span data-stu-id="b0b64-211">If `comparand` and the object in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="b0b64-212">否則，不會執行任何作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-212">Otherwise, no operation is performed.</span></span> <span data-ttu-id="b0b64-213">比較和交換作業成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-213">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="b0b64-214">傳回值<xref:System.Threading.Interlocked.CompareExchange%2A>是中的原始值`location1`無論交換發生。</span><span class="sxs-lookup"><span data-stu-id="b0b64-214">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  

> [!NOTE]
>  <span data-ttu-id="b0b64-215">參考相等，而不是實值相等比較的物件。</span><span class="sxs-lookup"><span data-stu-id="b0b64-215">The objects are compared for reference equality rather than value equality.</span></span> <span data-ttu-id="b0b64-216">如此一來，兩個經過 boxing 處理的執行個體相同的實值型別 （例如，整數值 3） 永遠看起來是不相等，而且會執行任何作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-216">As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal and no operation is performed.</span></span> <span data-ttu-id="b0b64-217">請勿使用這個多載具有實值類型。</span><span class="sxs-lookup"><span data-stu-id="b0b64-217">Do not use this overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b0b64-218"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-218">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-219">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-219">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-220">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-220">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-221">目的端，其值會與 <paramref name="comparand" /> 進行比較且可能會被取代。</span><span class="sxs-lookup"><span data-stu-id="b0b64-221">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-222">當比較的結果相等時，會取代目的端值的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-222">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="b0b64-223">與 <paramref name="location1" /> 的值比較的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-223">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="b0b64-224">比較兩個單精確度浮點數是否相等；如果相等，則取代第一個值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-224">Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="b0b64-225"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-225">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-226">如果`comparand`中的值`location1`相等，則`value`會儲存在`location1`。</span><span class="sxs-lookup"><span data-stu-id="b0b64-226">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="b0b64-227">否則，不會執行任何作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-227">Otherwise, no operation is performed.</span></span> <span data-ttu-id="b0b64-228">比較和交換作業成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-228">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="b0b64-229">傳回值<xref:System.Threading.Interlocked.CompareExchange%2A>是中的原始值`location1`無論交換發生。</span><span class="sxs-lookup"><span data-stu-id="b0b64-229">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b0b64-230">下列程式碼範例示範會累積的累計值的安全執行緒方法<xref:System.Single>值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-230">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values.</span></span> <span data-ttu-id="b0b64-231">兩個執行緒新增一系列的<xref:System.Single>值 使用安全執行緒方法和一般的加法，和當執行緒完成時，會比較總計。</span><span class="sxs-lookup"><span data-stu-id="b0b64-231">Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="b0b64-232">雙處理器的電腦上，沒有顯著的差異總計。</span><span class="sxs-lookup"><span data-stu-id="b0b64-232">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="b0b64-233">在使用安全執行緒方法時，會儲存計算加總的初始值，然後<xref:System.Threading.Interlocked.CompareExchange%2A>方法用來交換新計算的總和，最舊的總計。</span><span class="sxs-lookup"><span data-stu-id="b0b64-233">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="b0b64-234">如果傳回的值不等於儲存的值的加總，然後另一個執行緒已經更新總同時。</span><span class="sxs-lookup"><span data-stu-id="b0b64-234">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="b0b64-235">在此情況下，您必須重複嘗試更新計算加總。</span><span class="sxs-lookup"><span data-stu-id="b0b64-235">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-236"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-236">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-237">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-237">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-238">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-238">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="b0b64-239">要用於 <paramref name="location1" />、<paramref name="value" /> 和 <paramref name="comparand" /> 的型別。</span><span class="sxs-lookup"><span data-stu-id="b0b64-239">The type to be used for <paramref name="location1" />, <paramref name="value" />, and <paramref name="comparand" />.</span></span> <span data-ttu-id="b0b64-240">此類型必須是參考類型。</span><span class="sxs-lookup"><span data-stu-id="b0b64-240">This type must be a reference type.</span></span></typeparam>
        <param name="location1"><span data-ttu-id="b0b64-241">以傳址方式與 <paramref name="comparand" /> 比較其值的目的地，且可能被取代。</span><span class="sxs-lookup"><span data-stu-id="b0b64-241">The destination, whose value is compared by reference with <paramref name="comparand" /> and possibly replaced.</span></span> <span data-ttu-id="b0b64-242">此為參考參數 (在 C# 中為 <see langword="ref" />，在 Visual Basic 中為 <see langword="ByRef" />)。</span><span class="sxs-lookup"><span data-stu-id="b0b64-242">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-243">當以傳址方式比較的結果相等時，會取代目的地的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-243">The value that replaces the destination value if the comparison by reference results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="b0b64-244">以傳址方式與位於 <paramref name="location1" /> 之值比較的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-244">The value that is compared by reference to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="b0b64-245">比較指定參考型別 <paramref name="T" /> 的兩個執行個體是否參考相等；如果相等，則取代第一個。</span><span class="sxs-lookup"><span data-stu-id="b0b64-245">Compares two instances of the specified reference type <paramref name="T" /> for reference equality and, if they are equal, replaces the first one.</span></span></summary>
        <returns><span data-ttu-id="b0b64-246"><paramref name="location1" /> 中的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-246">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-247">如果`comparand`中的值`location1`上是相等的參考，然後`value`會儲存在`location1`。</span><span class="sxs-lookup"><span data-stu-id="b0b64-247">If `comparand` and the value in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="b0b64-248">否則，不會執行任何作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-248">Otherwise, no operation is performed.</span></span> <span data-ttu-id="b0b64-249">比較和交換將會以不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-249">The comparison and the exchange are performed as an atomic operation.</span></span> <span data-ttu-id="b0b64-250">這個方法的傳回值是中的原始值`location1`無論交換發生。</span><span class="sxs-lookup"><span data-stu-id="b0b64-250">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="b0b64-251">這個方法只支援參考型別。</span><span class="sxs-lookup"><span data-stu-id="b0b64-251">This method only supports reference types.</span></span> <span data-ttu-id="b0b64-252">有多載<xref:System.Threading.Interlocked.CompareExchange%2A>方法，實值型別<xref:System.Int32>， <xref:System.Int64>， <xref:System.IntPtr>， <xref:System.Single>，和<xref:System.Double>，但不支援其他實值型別。</span><span class="sxs-lookup"><span data-stu-id="b0b64-252">There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b0b64-253">最好是使用這個方法多載<xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29>方法多載，因為後者需要要存取晚期繫結的目的地物件。</span><span class="sxs-lookup"><span data-stu-id="b0b64-253">This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-254"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-254">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b0b64-255">遞減特定變數並將結果儲存起來，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-255">Decrements a specified variable and stores the result, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="b0b64-256">值會被遞減的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-256">The variable whose value is to be decremented.</span></span></param>
        <summary><span data-ttu-id="b0b64-257">遞減特定變數並將結果儲存起來，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-257">Decrements a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-258">遞減後的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-258">The decremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-259">這個方法會藉由包裝處理溢位狀況：如果`location`  =  <xref:System.Int32.MinValue?displayProperty=nameWithType>， `location` -1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b0b64-259">This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b0b64-260">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="b0b64-260">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b0b64-261">下列範例會判斷多少的隨機數字，範圍從 0 到 1000，才能產生 1,000 的隨機數字的中點值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-261">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="b0b64-262">若要追蹤的中點值，變數中，數`midpointCount`，是亂數產生器傳回中點值，每次設定等於 1,000 和遞減。</span><span class="sxs-lookup"><span data-stu-id="b0b64-262">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</span></span> <span data-ttu-id="b0b64-263">有三個執行緒產生隨機的數字，因為<xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29>方法會呼叫以確保多個執行緒未更新`midpointCount`同時。</span><span class="sxs-lookup"><span data-stu-id="b0b64-263">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="b0b64-264">請注意，鎖定也會用來保護隨機號碼產生器，而且<xref:System.Threading.CountdownEvent>物件用來確保`Main`方法未完成執行前三個執行緒。</span><span class="sxs-lookup"><span data-stu-id="b0b64-264">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 <span data-ttu-id="b0b64-265">下列範例是類似於前一個位置，不同之處在於它會使用<xref:System.Threading.Tasks.Task>類別而不是執行緒程序來產生隨機的中點 50,000 的整數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-265">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="b0b64-266">在此範例中，lambda 運算式來取代`GenerateNumbers`執行緒程序，並呼叫<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法就不需要<xref:System.Threading.CountdownEvent>物件。</span><span class="sxs-lookup"><span data-stu-id="b0b64-266">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b0b64-267"><paramref name="location" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-267">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-268">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-268">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-269">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-269">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="b0b64-270">值會被遞減的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-270">The variable whose value is to be decremented.</span></span></param>
        <summary><span data-ttu-id="b0b64-271">遞減特定變數並將結果儲存起來，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-271">Decrements the specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-272">遞減後的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-272">The decremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-273">這個方法會藉由包裝來處理溢位狀況： 如果`location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType>， `location` -1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b0b64-273">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b0b64-274">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="b0b64-274">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b0b64-275"><paramref name="location" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-275">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-276">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-276">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-277">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-277">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b0b64-278">把變數設定為特定值，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-278">Sets a variable to a specified value as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-279">要設定為特定值的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-279">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-280"><paramref name="location1" /> 參數要設定的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-280">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="b0b64-281">將雙精確度浮點數設定為指定值，然後傳回原始值，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-281">Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-282"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-282">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-283"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-283">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-284">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-284">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-285">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-285">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-286">要設定為特定值的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-286">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-287"><paramref name="location1" /> 參數要設定的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-287">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="b0b64-288">將 32 位元帶正負號的整數設定為指定值，然後傳回原始值，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-288">Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-289"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-289">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b0b64-290">下列程式碼範例會示範具備執行緒安全資源的鎖定機制。</span><span class="sxs-lookup"><span data-stu-id="b0b64-290">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b0b64-291"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-291">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-292">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-292">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-293">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-293">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-294">要設定為特定值的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-294">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-295"><paramref name="location1" /> 參數要設定的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-295">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="b0b64-296">將 64 位元帶正負號的整數設定為指定值，然後傳回原始值，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-296">Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-297"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-297">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-298"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-298">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-299">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-299">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-300">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-300">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-301">要設定為特定值的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-301">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-302"><paramref name="location1" /> 參數要設定的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-302">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="b0b64-303">將平台特定的控制代碼或指標設定為指定值，然後傳回原始值，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-303">Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-304"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-304">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-305"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-305">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-306">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-306">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-307">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-307">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-308">要設定為特定值的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-308">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-309"><paramref name="location1" /> 參數要設定的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-309">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="b0b64-310">將物件設定為指定值，然後傳回原始物件的參考，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-310">Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-311"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-311">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="b0b64-312">從 .NET Framework 2.0 開始，<xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> 方法多載會為參考型別提供型別安全的替代方法。</span><span class="sxs-lookup"><span data-stu-id="b0b64-312">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="b0b64-313">我們建議您呼叫它而不是這個多載。</span><span class="sxs-lookup"><span data-stu-id="b0b64-313">We recommend that you call it instead of this overload.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b0b64-314"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-314">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-315">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-315">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-316">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-316">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="b0b64-317">要設定為特定值的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-317">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-318"><paramref name="location1" /> 參數要設定的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-318">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="b0b64-319">將單精確度浮點數設定為指定值，然後傳回原始值，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-319">Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-320"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-320">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-321"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-321">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-322">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-322">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-323">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-323">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="b0b64-324">要用於 <paramref name="location1" /> 和 <paramref name="value" /> 的類型。</span><span class="sxs-lookup"><span data-stu-id="b0b64-324">The type to be used for <paramref name="location1" /> and <paramref name="value" />.</span></span> <span data-ttu-id="b0b64-325">此類型必須是參考類型。</span><span class="sxs-lookup"><span data-stu-id="b0b64-325">This type must be a reference type.</span></span></typeparam>
        <param name="location1"><span data-ttu-id="b0b64-326">要設定為特定值的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-326">The variable to set to the specified value.</span></span> <span data-ttu-id="b0b64-327">此為參考參數 (在 C# 中為 <see langword="ref" />，在 Visual Basic 中為 <see langword="ByRef" />)。</span><span class="sxs-lookup"><span data-stu-id="b0b64-327">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span></span></param>
        <param name="value"><span data-ttu-id="b0b64-328"><paramref name="location1" /> 參數要設定的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-328">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="b0b64-329">將指定類型 <paramref name="T" /> 的變數設定為指定值，然後傳回原始值，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-329">Sets a variable of the specified type <paramref name="T" /> to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-330"><paramref name="location1" /> 的原始值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-330">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-331">這個方法只支援參考型別。</span><span class="sxs-lookup"><span data-stu-id="b0b64-331">This method only supports reference types.</span></span> <span data-ttu-id="b0b64-332">有多載<xref:System.Threading.Interlocked.Exchange%2A>方法<xref:System.Int32>， <xref:System.Int64>， <xref:System.IntPtr>， <xref:System.Single>，和<xref:System.Double>實值型別，但不支援其他實值型別。</span><span class="sxs-lookup"><span data-stu-id="b0b64-332">There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b0b64-333">最好是使用這個方法多載<xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29>方法多載，因為後者需要晚期繫結到目的地物件的存取。</span><span class="sxs-lookup"><span data-stu-id="b0b64-333">This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-334"><paramref name="location1" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-334">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b0b64-335">遞增特定變數並將結果儲存起來，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-335">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="b0b64-336">值會被遞增的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-336">The variable whose value is to be incremented.</span></span></param>
        <summary><span data-ttu-id="b0b64-337">遞增特定變數並將結果儲存起來，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-337">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-338">遞增後的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-338">The incremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-339">這個方法會藉由包裝來處理溢位狀況： 如果`location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType>， `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b0b64-339">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b0b64-340">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="b0b64-340">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b0b64-341">下列範例會判斷多少的隨機數字，範圍從 0 到 1000，才能產生 1,000 的隨機數字的中點值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-341">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="b0b64-342">若要追蹤的中點值，變數中，數`midpointCount`設定為等於 0，是亂數產生器傳回中點值，直到達到 10,000 每次遞增。</span><span class="sxs-lookup"><span data-stu-id="b0b64-342">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</span></span> <span data-ttu-id="b0b64-343">有三個執行緒產生隨機的數字，因為<xref:System.Threading.Interlocked.Increment%28System.Int32%40%29>方法會呼叫以確保多個執行緒未更新`midpointCount`同時。</span><span class="sxs-lookup"><span data-stu-id="b0b64-343">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="b0b64-344">請注意，鎖定也會用來保護隨機號碼產生器，而且<xref:System.Threading.CountdownEvent>物件用來確保`Main`方法未完成執行前三個執行緒。</span><span class="sxs-lookup"><span data-stu-id="b0b64-344">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 <span data-ttu-id="b0b64-345">下列範例是類似於前一個位置，不同之處在於它會使用<xref:System.Threading.Tasks.Task>類別而不是執行緒程序來產生隨機的中點 50,000 的整數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-345">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="b0b64-346">在此範例中，lambda 運算式來取代`GenerateNumbers`執行緒程序，並呼叫<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法就不需要<xref:System.Threading.CountdownEvent>物件。</span><span class="sxs-lookup"><span data-stu-id="b0b64-346">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-347"><paramref name="location" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-347">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-348">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-348">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-349">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-349">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="b0b64-350">值會被遞增的變數。</span><span class="sxs-lookup"><span data-stu-id="b0b64-350">The variable whose value is to be incremented.</span></span></param>
        <summary><span data-ttu-id="b0b64-351">遞增特定變數並將結果儲存起來，成為不可部分完成的作業。</span><span class="sxs-lookup"><span data-stu-id="b0b64-351">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-352">遞增後的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-352">The incremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-353">這個方法會藉由包裝來處理溢位狀況： 如果`location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType>， `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b0b64-353">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b0b64-354">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="b0b64-354">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="b0b64-355"><paramref name="location" /> 的位址為 null 指標。</span><span class="sxs-lookup"><span data-stu-id="b0b64-355">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-356">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-356">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-357">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-357">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b0b64-358">同步記憶體存取，如下所示：執行目前執行緒的處理器無法用這種方式重新排列指令：呼叫 <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> 前的記憶體存取在呼叫 <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> 後的記憶體存取之後執行。</span><span class="sxs-lookup"><span data-stu-id="b0b64-358">Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-359">這個方法加入至<xref:System.Threading.Interlocked>類別內[!INCLUDE[net_v45](~/includes/net-v45-md.md)]為求方便; 它是包裝函式<xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b0b64-359">This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b0b64-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> 只能在具有弱式記憶體順序 （例如，採用多個 Intel Itanium 處理器的系統） 的多處理器系統上需要。</span><span class="sxs-lookup"><span data-stu-id="b0b64-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="b0b64-361">大部分的用途而言，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，或<xref:System.Threading.Monitor>類別提供簡單的方式同步處理資料。</span><span class="sxs-lookup"><span data-stu-id="b0b64-361">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b0b64-362">提供整個處理序範圍的記憶體屏障，以確保來自任何 CPU 的讀取和寫入都無法穿越屏障。</span><span class="sxs-lookup"><span data-stu-id="b0b64-362">Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.</span></span></summary>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="b0b64-363">`MemoryBarrierProcessWide`方法不同於 「 正常 」<xref:System.Threading.Interlocked.MemoryBarrier%2A>方法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="b0b64-363">The `MemoryBarrierProcessWide` method differs from the "normal" <xref:System.Threading.Interlocked.MemoryBarrier%2A> method as follows:</span></span>

- <span data-ttu-id="b0b64-364">一般記憶體屏障可確保讀取和寫入從目前的 CPU 不能在屏障之間移動。</span><span class="sxs-lookup"><span data-stu-id="b0b64-364">The normal memory barrier ensures that the reads and writes from the current CPU can't move across the barrier.</span></span> <span data-ttu-id="b0b64-365">整個處理序記憶體屏障可確保任何讀取或寫入從任何 CPU 用於處理程序無法跨移動屏障。</span><span class="sxs-lookup"><span data-stu-id="b0b64-365">The process-wide memory barrier ensures that any read or write from any CPU being used in the process can't move across the barrier.</span></span>

- <span data-ttu-id="b0b64-366">一般記憶體屏障允許合理的共用的存取，如果*每個*執行緒存取的資料使用的障礙。</span><span class="sxs-lookup"><span data-stu-id="b0b64-366">The normal memory barrier allows reasonable shared access if *every* thread accessing the data uses barriers.</span></span> <span data-ttu-id="b0b64-367">整個處理序記憶體屏障強制*其他 Cpu*與處理序記憶體 （例如，若要清除寫入緩衝區，並同步處理讀取的緩衝區） 進行同步處理。</span><span class="sxs-lookup"><span data-stu-id="b0b64-367">The process-wide memory barrier forces *other CPUs* to synchronize with process memory (for example, to flush write buffers and synchronize read buffers).</span></span> <span data-ttu-id="b0b64-368">這可讓非連鎖的作業，在某些執行緒上，並且仍有合理共用存取權。</span><span class="sxs-lookup"><span data-stu-id="b0b64-368">This allows for non-interlocked operations on some threads and still have reasonable shared access.</span></span> 

- <span data-ttu-id="b0b64-369">一般記憶體屏障加諸的極少額外負荷;一般的連鎖的作業可能會耗用超過一百個週期。</span><span class="sxs-lookup"><span data-stu-id="b0b64-369">The normal memory barrier imposes very little overhead; normal interlocked operations probably cost fewer than a hundred cycles.</span></span> <span data-ttu-id="b0b64-370">整個處理序記憶體屏障是非常耗費資源。</span><span class="sxs-lookup"><span data-stu-id="b0b64-370">The process-wide memory barrier is very expensive.</span></span> <span data-ttu-id="b0b64-371">它必須強制程序中的每個 CPU 值，可能成本的數千個循環的執行。</span><span class="sxs-lookup"><span data-stu-id="b0b64-371">It has to force every CPU in the process do to something, at a probable cost of thousands of cycles.</span></span> 

<span data-ttu-id="b0b64-372">`MemoryBarrierProcessWide`方法也會受到的無鎖程式設計的所有細微差異。</span><span class="sxs-lookup"><span data-stu-id="b0b64-372">The `MemoryBarrierProcessWide` method also suffers from all the subtleties of lock-free programming.</span></span> <span data-ttu-id="b0b64-373">不過，這個方法會非常有用時，實際上，您需要呼叫它，這應該很少見。</span><span class="sxs-lookup"><span data-stu-id="b0b64-373">Nevertheless, this method can be extremely useful when you actually need to call it, which should be rare.</span></span>

<span data-ttu-id="b0b64-374">這個方法會包裝在呼叫[FlushProcessWriteBuffers](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers)在 Windows 上並[sys_membarrier](https://lore.kernel.org/patchwork/patch/188708/) Linux 上。</span><span class="sxs-lookup"><span data-stu-id="b0b64-374">This method wraps a call to [FlushProcessWriteBuffers](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers) on Windows and [sys_membarrier](https://lore.kernel.org/patchwork/patch/188708/) on Linux.</span></span>

         ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read :  -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="b0b64-375">要載入的 64 位元值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-375">The 64-bit value to be loaded.</span></span></param>
        <summary><span data-ttu-id="b0b64-376">傳回 64 位元的值 (載入為不可部分完成的作業)。</span><span class="sxs-lookup"><span data-stu-id="b0b64-376">Returns a 64-bit value, loaded as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="b0b64-377">載入的值。</span><span class="sxs-lookup"><span data-stu-id="b0b64-377">The loaded value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b0b64-378"><xref:System.Threading.Interlocked.Read%2A>方法是在 64 位元系統上沒有必要的因為 64 位元讀取的作業已經是不可部分完成。</span><span class="sxs-lookup"><span data-stu-id="b0b64-378">The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</span></span> <span data-ttu-id="b0b64-379">32 位元系統上，64 位元讀取的作業不是不可部分完成，除非使用執行<xref:System.Threading.Interlocked.Read%2A>。</span><span class="sxs-lookup"><span data-stu-id="b0b64-379">On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="b0b64-380">Managed 執行緒處理</span><span class="sxs-lookup"><span data-stu-id="b0b64-380">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="b0b64-381">同步處理原始物件概觀</span><span class="sxs-lookup"><span data-stu-id="b0b64-381">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SpeculationBarrier">
      <MemberSignature Language="C#" Value="public static void SpeculationBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpeculationBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.SpeculationBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpeculationBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpeculationBarrier();" />
      <MemberSignature Language="F#" Value="static member SpeculationBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.SpeculationBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
