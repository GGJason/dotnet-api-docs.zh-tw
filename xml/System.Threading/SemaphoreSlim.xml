<Type Name="SemaphoreSlim" FullName="System.Threading.SemaphoreSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="268af4ec18ef9780af942f18f0369318755e0b83" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061738" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SemaphoreSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SemaphoreSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.SemaphoreSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class SemaphoreSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSlim : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Current Count = {m_currentCount}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表 <see cref="T:System.Threading.Semaphore" /> 的輕量型替代品，限制可同時存取一項資源或資源集區的執行緒數目。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 號誌有兩種類型： 本機號誌和具名的系統號誌。 前者是本機應用程式。 後者是在作業系統各處，適用於處理序間的同步處理。 <xref:System.Threading.SemaphoreSlim>輕量級替代方案<xref:System.Threading.Semaphore>不會使用 Windows 核心號誌的類別。 不同於<xref:System.Threading.Semaphore>類別<xref:System.Threading.SemaphoreSlim>類別不支援具名的系統號誌。 您可以將它當做本機信號。 <xref:System.Threading.SemaphoreSlim>類別是建議的號誌，單一應用程式中的同步處理。  
  
 輕量型號誌，控制對資源集區的應用程式的本機存取。 當您具現化某個號誌時，您可以指定可以同時進入號誌的執行緒最大數目。 您也可以指定執行緒可以同時進入號誌的初始的數目。 這會定義將旗號的計數。  
  
 計數遞減執行緒進入號誌，每次，且每次遞增執行緒釋放號誌。 若要進入號誌，執行緒會呼叫其中一個<xref:System.Threading.SemaphoreSlim.Wait%2A>或<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>多載。 若要釋放號誌，它會呼叫其中一個<xref:System.Threading.SemaphoreSlim.Release%2A>多載。 當計數到達零時，其中的後續呼叫`Wait`方法封鎖，直到其他的執行緒釋放號誌。 如果多個執行緒會被封鎖，則無法保證的順序，例如 FIFO 或 LIFO，可控制當執行緒進入號誌。  
  
 用來保護資源的號誌的程式碼的基本結構是：  
  
```vb  
  
' Enter semaphore by calling one of the Wait or WaitAsync methods.  
SemaphoreSlim.Wait()  
'   
' Execute code protected by the semaphore.   
'  
SemaphoreSlim.Release()  
  
```  
  
 所有執行緒都釋放號誌，計數為最大值時指定已建立號誌。 號誌計數是可從<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性。  
  
> [!IMPORTANT]
>  <xref:System.Threading.SemaphoreSlim>類別不會強制要求上呼叫的執行緒或工作識別<xref:System.Threading.SemaphoreSlim.Wait%2A>， <xref:System.Threading.SemaphoreSlim.WaitAsync%2A>，和<xref:System.Threading.SemaphoreSlim.Release%2A>方法。 此外，如果<xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29>建構函式用來具現化<xref:System.Threading.SemaphoreSlim>物件<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性可以增加超過設定的建構函式的值。 程式設計人員必須負責確保要呼叫<xref:System.Threading.SemaphoreSlim.Wait%2A>或<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>方法適當地搭配呼叫<xref:System.Threading.SemaphoreSlim.Release%2A>方法。  
  
   
  
## Examples  
 下列範例會建立一個號誌的三個執行緒的最大計數與初始計數為零的執行緒。 此範例會啟動有五個工作，全部都是封鎖而等待號誌。 主執行緒呼叫<xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29>號誌計數增加至其最大值，允許進入號誌的三個工作的多載。 已釋放號誌，每次會顯示先前的號誌計數。 主控台訊息追蹤號誌的使用。 模擬的工作間隔會稍微增加每個執行緒，可讓輸出更容易閱讀。  
  
 [!code-csharp[System.Threading.SemaphoreSlim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.semaphoreslim/cs/example.cs#1)]
 [!code-vb[System.Threading.SemaphoreSlim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.semaphoreslim/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>所有公用和受保護成員<see cref="T:System.Threading.SemaphoreSlim" />是安全執行緒，而且可用來同時從多個執行緒，但<see cref="M:System.Threading.SemaphoreSlim.Dispose" />，必須使用它時，才在所有其他作業<see cref="T:System.Threading.SemaphoreSlim" />已完成。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.SemaphoreSlim" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">可同時授與給號誌的初始要求數目。</param>
        <summary>指定可同時授與的初始要求數目，初始化 <see cref="T:System.Threading.SemaphoreSlim" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `initialCount`參數定義輸入可被授與之號誌的並行要求數目。 不過，它不會定義可以同時授與的要求數目上限。 A<xref:System.Threading.SemaphoreSlim>藉由呼叫這個建構函式具現化的物件不會擲回<xref:System.Threading.SemaphoreFullException>例外狀況，如果呼叫<xref:System.Threading.SemaphoreSlim.Release%2A>方法增加的值<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性超出`initialCount`。 會發生這個錯誤有多個呼叫<xref:System.Threading.SemaphoreSlim.Release%2A>方法比很<xref:System.Threading.SemaphoreSlim.Wait%2A>或<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>方法。 若要設定的輸入可以授與之號誌的並行要求數目上限，請呼叫<xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%2CSystem.Int32%29>建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCount" /> 小於 0。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount, int maxCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maxCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maxCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount, int maxCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maxCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">可同時授與給號誌的初始要求數目。</param>
        <param name="maxCount">可以同時授與之號誌要求的最大數目。</param>
        <summary>指定可同時授與的初始要求數目及最大數目，初始化 <see cref="T:System.Threading.SemaphoreSlim" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCount" /> 小於 0，或者 <paramref name="initialCount" /> 大於 <paramref name="maxCount" />，或者 <paramref name="maxCount" /> 等於或小於 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="AvailableWaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle AvailableWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle AvailableWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.AvailableWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableWaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ AvailableWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>傳回可用來等候號誌的 <see cref="T:System.Threading.WaitHandle" />。</summary>
        <value>可用來等候號誌的 <see cref="T:System.Threading.WaitHandle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須等候 SemaphoreSlim 連同其他核心為基礎的同步處理的物件與相同的等候控制代碼時，才使用這個屬性。 成功等候<xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A>並不表示成功的等候上<xref:System.Threading.SemaphoreSlim>本身，也不會遞減旗號的計數。 使用等候控制代碼會收到信號之後，您應該等候<xref:System.Threading.SemaphoreSlim>特別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.SemaphoreSlim" /> 已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentCount">
      <MemberSignature Language="C#" Value="public int CurrentCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.CurrentCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 物件的剩餘執行緒數目。</summary>
        <value>可以進入號誌的剩餘執行緒數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 初始值<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性由呼叫設定<xref:System.Threading.SemaphoreSlim.%23ctor%2A>類別建構函式。 它也會減少每次呼叫<xref:System.Threading.SemaphoreSlim.Wait%2A>或<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>方法，而且每次呼叫遞增<xref:System.Threading.SemaphoreSlim.Release%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 <see cref="T:System.Threading.SemaphoreSlim" /> 類別的目前執行個體所使用的資源釋出。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將 <see cref="T:System.Threading.SemaphoreSlim" /> 類別目前的執行個體所使用的資源全部釋出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dispose` 使用完畢時，請呼叫 <xref:System.Threading.SemaphoreSlim>。 `Dispose` 方法會將 <xref:System.Threading.SemaphoreSlim> 保留在無法使用的狀態。 在呼叫`Dispose`，您必須釋放所有參考<xref:System.Threading.SemaphoreSlim>讓記憶體回收行程可以回收記憶體的<xref:System.Threading.SemaphoreSlim>所佔用。  
  
 如需詳細資訊，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)和[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  在您釋放最後一個 `Dispose` 參考之前，請務必呼叫 <xref:System.Threading.SemaphoreSlim>。 否則工作窗格所使用的資源不會釋放，直到記憶體回收行程呼叫 <xref:System.Threading.SemaphoreSlim> 物件的 `Finalize` 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.Threading.SemaphoreSlim" /> 所使用的 Unmanaged 資源，並選擇性釋放 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於大部分的成員<xref:System.Threading.SemaphoreSlim>，<xref:System.Threading.SemaphoreSlim.Dispose%2A>不具備執行緒安全，而且不能與這個執行個體的其他成員同時使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>釋出 <see cref="T:System.Threading.SemaphoreSlim" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋出 <see cref="T:System.Threading.SemaphoreSlim" /> 物件一次。</summary>
        <returns>
          <see cref="T:System.Threading.SemaphoreSlim" /> 的先前計數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Threading.SemaphoreSlim.Release>方法遞增<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>一個屬性。 如果值<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性為零，會在呼叫這個方法之前，此方法也可讓一個執行緒或呼叫被封鎖的工作<xref:System.Threading.SemaphoreSlim.Wait%2A>或<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>進入號誌的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <see cref="T:System.Threading.SemaphoreSlim" /> 已經達到其大小上限。</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">結束號誌的次數。</param>
        <summary>釋出 <see cref="T:System.Threading.SemaphoreSlim" /> 物件指定的次數。</summary>
        <returns>
          <see cref="T:System.Threading.SemaphoreSlim" /> 的先前計數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29>方法遞增<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性`releaseCount`。 如果值<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性為零，會在呼叫這個方法之前，此方法也可讓`releaseCount`執行緒或呼叫被封鎖的工作<xref:System.Threading.SemaphoreSlim.Wait%2A>或<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>進入號誌的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> 小於 1。</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <see cref="T:System.Threading.SemaphoreSlim" /> 已經達到其大小上限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>一個屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，<see cref="F:System.Threading.Timeout.Infinite" />(-1) 表示永遠等候，零表示測試等候控制代碼的狀態並立即傳回。</param>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止，並使用 32 位元帶正負號的整數來指定逾時。</summary>
        <returns>
          如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 
如果在逾時設定為-1 毫秒，方法將會無限期等候。
 
如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試的狀態，等候控制代碼，並立即傳回。

如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>一個屬性。  
  
如果呼叫時遭到封鎖的執行緒或工作<xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%29>和所指定的逾時間隔`millisecondsTimeout`到期：

- 執行緒或工作不會進入號誌。
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性不可遞減。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" /> 語彙基元。</param>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>一個屬性。  
  
 如果`cancellationToken`已取消，執行緒或工作不會進入號誌，而<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性不可遞減。 相反地，方法會擲回<xref:System.OperationCanceledException>例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。  
  
 -或-  
  
 已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表要等候的毫秒數；<see cref="T:System.TimeSpan" /> 為 -1 毫秒表示永遠等候，<see cref="T:System.TimeSpan" /> 為 0 毫秒表示測試等候控制代碼並立即傳回。</param>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止，並使用 <see cref="T:System.TimeSpan" /> 來指定逾時。</summary>
        <returns>
          如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
如果在逾時設定為-1 毫秒，方法將會無限期等候。
 
如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試的狀態，等候控制代碼，並立即傳回。 
 
如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>一個屬性。  
  
如果呼叫時遭到封鎖的執行緒或工作<xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%29>和所指定的逾時間隔`millisecondsTimeout`到期：

- 執行緒或工作不會進入號誌。
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性不可遞減。   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
        <exception cref="T:System.ObjectDisposedException">semaphoreSlim 執行個體已經處置 <paramref name="." /></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，<see cref="F:System.Threading.Timeout.Infinite" />(-1) 表示永遠等候，零表示測試等候控制代碼的狀態並立即傳回。</param>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止，並使用 32 位元帶正負號的整數來指定逾時，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <returns>
          如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
如果在逾時設定為-1 毫秒，方法將會無限期等候。
 
如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試的狀態，等候控制代碼，並立即傳回。

如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>一個屬性。  
  
如果`cancellationToken`已取消，或如果呼叫時遭到封鎖的執行緒或工作<xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>和所指定的逾時間隔`millisecondsTimeout`到期：

- 執行緒或工作不會進入號誌。
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性不可遞減。  
 
如果`cancellationToken`已取消，方法會擲回<xref:System.OperationCanceledException>例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置 <see cref="T:System.Threading.SemaphoreSlim" /> 執行個體，或是已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表要等候的毫秒數；<see cref="T:System.TimeSpan" /> 為 -1 毫秒表示永遠等候，<see cref="T:System.TimeSpan" /> 為 0 毫秒表示測試等候控制代碼並立即傳回。</param>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止，並使用 <see cref="T:System.TimeSpan" /> 來指定逾時，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <returns>
          如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
如果在逾時設定為-1 毫秒，方法將會無限期等候。
 
如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試的狀態，等候控制代碼，並立即傳回。 

如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>一個屬性。  
  
如果`cancellationToken`已取消，或如果呼叫時遭到封鎖的執行緒或工作<xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>和所指定的逾時間隔`millisecondsTimeout`到期：

- 執行緒或工作不會進入號誌。
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性不可遞減。  

如果`cancellationToken`已取消，方法會擲回<xref:System.OperationCanceledException>例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
        <exception cref="T:System.ObjectDisposedException">semaphoreSlim 執行個體已經處置 <paramref name="." /><paramref name="-or-" />  
  
 已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />。</summary>
        <returns>將會在號誌 (Semaphore) 輸入後完成的工作。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (millisecondsTimeout As Integer) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，<see cref="F:System.Threading.Timeout.Infinite" /> (-1) 表示永遠等候，零表示測試等候控制代碼的狀態並立即傳回。</param>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />，並使用 32 位元帶正負號的整數來測量時間間隔。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則工作會完成且結果為 <see langword="true" />，否則結果為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在逾時設定為-1 毫秒，方法將會無限期等候。
 
 如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試的狀態，等候控制代碼，並立即傳回。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" /> 語彙基元。</param>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <returns>將會在號誌 (Semaphore) 輸入後完成的工作。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (timeout As TimeSpan) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表要等候的毫秒數；<see cref="T:System.TimeSpan" /> 為 -1 毫秒表示永遠等候，<see cref="T:System.TimeSpan" /> 為 0 毫秒表示測試等候控制代碼並立即傳回。</param>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />，並使用 <see cref="T:System.TimeSpan" /> 來測量時間間隔。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則工作會完成且結果為 <see langword="true" />，否則結果為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在逾時設定為-1 毫秒，方法將會無限期等候。
 
 如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試的狀態，等候控制代碼，並立即傳回。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，<see cref="F:System.Threading.Timeout.Infinite" /> (-1) 表示永遠等候，零表示測試等候控制代碼的狀態並立即傳回。</param>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />，並使用 32 位元帶正負號的整數來測量時間間隔，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則工作會完成且結果為 <see langword="true" />，否則結果為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在逾時設定為-1 毫秒，方法將會無限期等候。
 
 如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試的狀態，等候控制代碼，並立即傳回。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的數值，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表要等候的毫秒數；<see cref="T:System.TimeSpan" /> 為 -1 毫秒表示永遠等候，<see cref="T:System.TimeSpan" /> 為 0 毫秒表示測試等候控制代碼並立即傳回。</param>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" /> 語彙基元。</param>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />，並使用 <see cref="T:System.TimeSpan" /> 來測量時間間隔，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則工作會完成且結果為 <see langword="true" />，否則結果為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在逾時設定為-1 毫秒，方法將會無限期等候。

 如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試的狀態，等候控制代碼，並立即傳回。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
      </Docs>
    </Member>
  </Members>
</Type>