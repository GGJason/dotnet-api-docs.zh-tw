<Type Name="SemaphoreSlim" FullName="System.Threading.SemaphoreSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="28a8b6a13da8fe2363454359670ae82fc47c4f19" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39759137" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SemaphoreSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SemaphoreSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.SemaphoreSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class SemaphoreSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemaphoreSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type SemaphoreSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Current Count = {m_currentCount}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>代表 <see cref="T:System.Threading.Semaphore" /> 的輕量型替代品，限制可同時存取一項資源或資源集區的執行緒數目。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 號誌有兩種類型： 本機號誌和具名的系統號誌。 前者是本機應用程式。 後者會顯示整個作業系統，適合處理序間的同步處理。 <xref:System.Threading.SemaphoreSlim>是輕量級替代方案<xref:System.Threading.Semaphore>不會使用 Windows 核心號誌的類別。 不同於<xref:System.Threading.Semaphore>類別，<xref:System.Threading.SemaphoreSlim>類別不支援具名的系統號誌。 您可以使用它作為本機信號。 <xref:System.Threading.SemaphoreSlim>類別是建議的號誌，單一應用程式內的同步處理。  
  
 輕量型號誌，可控制存取權的資源集區的本機應用程式。 當您具現化的號誌時，您可以指定可以同時進入號誌的執行緒最大數目。 您也會指定可以同時進入號誌的執行緒的初始數目。 這會定義將旗號的計數。  
  
 計數會遞減執行緒進入號誌，每次，每次遞增執行緒釋放號誌。 若要進入號誌，執行緒會呼叫其中一個<xref:System.Threading.SemaphoreSlim.Wait%2A>或<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>多載。 若要釋放號誌，它會呼叫其中一個<xref:System.Threading.SemaphoreSlim.Release%2A>多載。 當計數到達零時，後續呼叫其中一個`Wait`方法封鎖，直到其他執行緒釋放號誌。 如果多個執行緒遭到封鎖，並沒有任何保證的順序，例如 FIFO 或 LIFO，可控制當執行緒進入號誌。  
  
 使用來保護資源的號誌的程式碼的基本結構是：  
  
```vb  
  
' Enter semaphore by calling one of the Wait or WaitAsync methods.  
SemaphoreSlim.Wait()  
'   
' Execute code protected by the semaphore.   
'  
SemaphoreSlim.Release()  
  
```  
  
 所有執行緒都釋放號誌，計數會達到最大值時指定已建立的號誌。 將旗號的計數是可從<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性。  
  
> [!IMPORTANT]
>  <xref:System.Threading.SemaphoreSlim>類別並不會強制呼叫的執行緒或工作身分識別<xref:System.Threading.SemaphoreSlim.Wait%2A>， <xref:System.Threading.SemaphoreSlim.WaitAsync%2A>，和<xref:System.Threading.SemaphoreSlim.Release%2A>方法。 此外，如果<xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%29>建構函式用來具現化<xref:System.Threading.SemaphoreSlim>物件，<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性可以增加超過建構函式所設定的值。 它是以確保呼叫的程式設計師的責任<xref:System.Threading.SemaphoreSlim.Wait%2A>或是<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>方法適當地搭配呼叫<xref:System.Threading.SemaphoreSlim.Release%2A>方法。  
  
   
  
## Examples  
 下列範例會建立一個號誌的三個執行緒的最大計數與初始計數為零的執行緒。 此範例會啟動五個工作，其中都封鎖等候號誌。 主執行緒呼叫<xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29>號誌計數增加至其最大值，允許進入號誌的三個工作的多載。 已釋放號誌，每次會顯示先前的號誌計數。 主控台訊息追蹤號誌的使用。 模擬的工作間隔會稍微增加，每個執行緒，可讓輸出更容易閱讀。  
  
 [!code-csharp[System.Threading.SemaphoreSlim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.semaphoreslim/cs/example.cs#1)]
 [!code-vb[System.Threading.SemaphoreSlim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.semaphoreslim/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>所有 public 和 protected 成員<see cref="T:System.Threading.SemaphoreSlim" />是安全執行緒，而且用於同時從多個執行緒，但不包括<see cref="M:System.Threading.SemaphoreSlim.Dispose" />，必須使用它時，才在所有其他作業<see cref="T:System.Threading.SemaphoreSlim" />已完成。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.SemaphoreSlim" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.SemaphoreSlim : int -&gt; System.Threading.SemaphoreSlim" Usage="new System.Threading.SemaphoreSlim initialCount" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">可同時授與給號誌的初始要求數目。</param>
        <summary>指定可同時授與的初始要求數目，初始化 <see cref="T:System.Threading.SemaphoreSlim" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `initialCount`參數會定義進入號誌可以授與的並行要求數目。 不過，它不會定義可以同時授與的要求的數目上限。 A<xref:System.Threading.SemaphoreSlim>藉由呼叫這個建構函式具現化物件不會擲回<xref:System.Threading.SemaphoreFullException>例外狀況，如果呼叫<xref:System.Threading.SemaphoreSlim.Release%2A>方法會增加的值<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>以外的屬性`initialCount`。 如果有多個呼叫，發生這種的情況<xref:System.Threading.SemaphoreSlim.Release%2A>方法，比<xref:System.Threading.SemaphoreSlim.Wait%2A>或<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>方法。 若要設定的進入號誌可以授與的並行要求數目上限，請呼叫<xref:System.Threading.SemaphoreSlim.%23ctor%28System.Int32%2CSystem.Int32%29>建構函式。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCount" /> 小於 0。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSlim (int initialCount, int maxCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maxCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maxCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemaphoreSlim(int initialCount, int maxCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.SemaphoreSlim : int * int -&gt; System.Threading.SemaphoreSlim" Usage="new System.Threading.SemaphoreSlim (initialCount, maxCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maxCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">可同時授與給號誌的初始要求數目。</param>
        <param name="maxCount">可以同時授與之號誌要求的最大數目。</param>
        <summary>指定可同時授與的初始要求數目及最大數目，初始化 <see cref="T:System.Threading.SemaphoreSlim" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="initialCount" /> 小於 0，或者 <paramref name="initialCount" /> 大於 <paramref name="maxCount" />，或者 <paramref name="maxCount" /> 等於或小於 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="AvailableWaitHandle">
      <MemberSignature Language="C#" Value="public System.Threading.WaitHandle AvailableWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle AvailableWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.AvailableWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableWaitHandle As WaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::WaitHandle ^ AvailableWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableWaitHandle : System.Threading.WaitHandle" Usage="System.Threading.SemaphoreSlim.AvailableWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>傳回可用來等候號誌的 <see cref="T:System.Threading.WaitHandle" />。</summary>
        <value>可用來等候號誌的 <see cref="T:System.Threading.WaitHandle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必須等候 SemaphoreSlim 搭配其他使用相同的等候控制代碼的核心為基礎的同步處理物件時，才，請使用這個屬性。 成功等候<xref:System.Threading.SemaphoreSlim.AvailableWaitHandle%2A>並不表示成功的等候上<xref:System.Threading.SemaphoreSlim>本身，也不會遞減將旗號的計數。 可用的等候控制代碼會收到信號之後，您應該等候<xref:System.Threading.SemaphoreSlim>特別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.SemaphoreSlim" /> 已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentCount">
      <MemberSignature Language="C#" Value="public int CurrentCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.SemaphoreSlim.CurrentCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCount : int" Usage="System.Threading.SemaphoreSlim.CurrentCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 物件的剩餘執行緒數目。</summary>
        <value>可以進入號誌的剩餘執行緒數目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 初始值<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性由呼叫設定<xref:System.Threading.SemaphoreSlim.%23ctor%2A>類別建構函式。 它也會減少每次呼叫<xref:System.Threading.SemaphoreSlim.Wait%2A>或是<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>方法，並以每個呼叫來遞增<xref:System.Threading.SemaphoreSlim.Release%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 <see cref="T:System.Threading.SemaphoreSlim" /> 類別的目前執行個體所使用的資源釋出。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="semaphoreSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將 <see cref="T:System.Threading.SemaphoreSlim" /> 類別目前的執行個體所使用的資源全部釋出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dispose` 使用完畢時，請呼叫 <xref:System.Threading.SemaphoreSlim>。 `Dispose` 方法會將 <xref:System.Threading.SemaphoreSlim> 保留在無法使用的狀態。 之後呼叫`Dispose`，您必須釋放所有的參考<xref:System.Threading.SemaphoreSlim>讓記憶體回收行程可以回收記憶體，<xref:System.Threading.SemaphoreSlim>所佔用。  
  
 如需詳細資訊，請參閱 <<c0> [ 清除 Unmanaged 資源向上](~/docs/standard/garbage-collection/unmanaged.md)並[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
> [!NOTE]
>  在您釋放最後一個 `Dispose` 參考之前，請務必呼叫 <xref:System.Threading.SemaphoreSlim>。 否則工作窗格所使用的資源不會釋放，直到記憶體回收行程呼叫 <xref:System.Threading.SemaphoreSlim> 物件的 `Finalize` 方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="semaphoreSlim.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.Threading.SemaphoreSlim" /> 所使用的 Unmanaged 資源，並選擇性釋放 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不同於大部分的成員清單<xref:System.Threading.SemaphoreSlim>，<xref:System.Threading.SemaphoreSlim.Dispose%2A>不具備執行緒安全，而且不能使用與這個執行個體的其他成員同時。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>釋出 <see cref="T:System.Threading.SemaphoreSlim" /> 物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphoreSlim.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋出 <see cref="T:System.Threading.SemaphoreSlim" /> 物件一次。</summary>
        <returns>
          <see cref="T:System.Threading.SemaphoreSlim" /> 的先前計數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Threading.SemaphoreSlim.Release>方法會遞增<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>其中一個屬性。 如果值<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性為零，會在呼叫這個方法之前，方法也可讓一個執行緒或工作被封鎖的呼叫所<xref:System.Threading.SemaphoreSlim.Wait%2A>或<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>進入號誌的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <see cref="T:System.Threading.SemaphoreSlim" /> 已經達到其大小上限。</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphoreSlim.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">結束號誌的次數。</param>
        <summary>釋出 <see cref="T:System.Threading.SemaphoreSlim" /> 物件指定的次數。</summary>
        <returns>
          <see cref="T:System.Threading.SemaphoreSlim" /> 的先前計數。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29>方法會遞增<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性`releaseCount`。 如果值<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性為零，會在呼叫這個方法之前，此方法也可讓`releaseCount`執行緒或工作被封鎖的呼叫所<xref:System.Threading.SemaphoreSlim.Wait%2A>或<xref:System.Threading.SemaphoreSlim.WaitAsync%2A>進入號誌的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> 小於 1。</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <see cref="T:System.Threading.SemaphoreSlim" /> 已經達到其大小上限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="semaphoreSlim.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>其中一個屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="semaphoreSlim.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，<see cref="F:System.Threading.Timeout.Infinite" />(-1) 表示永遠等候，零表示測試等候控制代碼的狀態並立即傳回。</param>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止，並使用 32 位元帶正負號的整數來指定逾時。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 
如果在逾時設定為-1 毫秒，方法就會無限期地等候。
 
如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。

如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>其中一個屬性。  
  
如果呼叫時遭到封鎖的執行緒或工作<xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%29>及所指定的逾時間隔`millisecondsTimeout`到期：

- 執行緒或工作不進入號誌。
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性不會遞減。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.SemaphoreSlim" /> 已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="semaphoreSlim.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" /> 語彙基元。</param>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>其中一個屬性。  
  
 如果`cancellationToken`已取消，執行緒或工作不進入號誌，而<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性不會遞減。 相反地，方法會擲回<xref:System.OperationCanceledException>例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。  
  
-或- 
已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="semaphoreSlim.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表要等候的毫秒數；<see cref="T:System.TimeSpan" /> 為 -1 毫秒表示永遠等候，<see cref="T:System.TimeSpan" /> 為 0 毫秒表示測試等候控制代碼並立即傳回。</param>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止，並使用 <see cref="T:System.TimeSpan" /> 來指定逾時。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
如果在逾時設定為-1 毫秒，方法就會無限期地等候。
 
如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。 
 
如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>其中一個屬性。  
  
如果呼叫時遭到封鎖的執行緒或工作<xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%29>及所指定的逾時間隔`millisecondsTimeout`到期：

- 執行緒或工作不進入號誌。
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性不會遞減。   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
        <exception cref="T:System.ObjectDisposedException">semaphoreSlim 執行個體已經處置 <paramref name="." /></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="semaphoreSlim.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，<see cref="F:System.Threading.Timeout.Infinite" />(-1) 表示永遠等候，零表示測試等候控制代碼的狀態並立即傳回。</param>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止，並使用 32 位元帶正負號的整數來指定逾時，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
如果在逾時設定為-1 毫秒，方法就會無限期地等候。
 
如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。

如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>其中一個屬性。  
  
如果`cancellationToken`遭到取消，或如果呼叫時遭到封鎖的執行緒或工作<xref:System.Threading.SemaphoreSlim.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>和所指定的逾時間隔`millisecondsTimeout`到期：

- 執行緒或工作不進入號誌。
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性不會遞減。  
 
如果`cancellationToken`已取消，則方法會擲回<xref:System.OperationCanceledException>例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置 <see cref="T:System.Threading.SemaphoreSlim" /> 執行個體，或是已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan * System.Threading.CancellationToken -&gt; bool" Usage="semaphoreSlim.Wait (timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表要等候的毫秒數；<see cref="T:System.TimeSpan" /> 為 -1 毫秒表示永遠等候，<see cref="T:System.TimeSpan" /> 為 0 毫秒表示測試等候控制代碼並立即傳回。</param>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>封鎖目前的執行緒，直到這個執行緒可以進入 <see cref="T:System.Threading.SemaphoreSlim" /> 為止，並使用 <see cref="T:System.TimeSpan" /> 來指定逾時，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
如果在逾時設定為-1 毫秒，方法就會無限期地等候。
 
如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。 

如果能夠進入號誌，執行緒或工作它遞減<xref:System.Threading.SemaphoreSlim.CurrentCount%2A>其中一個屬性。  
  
如果`cancellationToken`遭到取消，或如果呼叫時遭到封鎖的執行緒或工作<xref:System.Threading.SemaphoreSlim.Wait%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>和所指定的逾時間隔`millisecondsTimeout`到期：

- 執行緒或工作不進入號誌。
- <xref:System.Threading.SemaphoreSlim.CurrentCount%2A>屬性不會遞減。  

如果`cancellationToken`已取消，則方法會擲回<xref:System.OperationCanceledException>例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
        <exception cref="T:System.ObjectDisposedException">semaphoreSlim 執行個體已經處置 <paramref name="." /><paramref name="-or-" />  
  
已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync();" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : unit -&gt; System.Threading.Tasks.Task" Usage="semaphoreSlim.WaitAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />。</summary>
        <returns>將會在號誌 (Semaphore) 輸入後完成的工作。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.SemaphoreSlim" /> 已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (millisecondsTimeout As Integer) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : int -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，<see cref="F:System.Threading.Timeout.Infinite" /> (-1) 表示永遠等候，零表示測試等候控制代碼的狀態並立即傳回。</param>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />，並使用 32 位元帶正負號的整數來測量時間間隔。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則工作會完成且結果為 <see langword="true" />，否則結果為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在逾時設定為-1 毫秒，方法就會無限期地等候。
 
 如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WaitAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WaitAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ WaitAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="semaphoreSlim.WaitAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" /> 語彙基元。</param>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <returns>將會在號誌 (Semaphore) 輸入後完成的工作。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitAsync (timeout As TimeSpan) As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : TimeSpan -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表要等候的毫秒數；<see cref="T:System.TimeSpan" /> 為 -1 毫秒表示永遠等候，<see cref="T:System.TimeSpan" /> 為 0 毫秒表示測試等候控制代碼並立即傳回。</param>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />，並使用 <see cref="T:System.TimeSpan" /> 來測量時間間隔。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則工作會完成且結果為 <see langword="true" />，否則結果為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在逾時設定為-1 毫秒，方法就會無限期地等候。
 
 如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，<see cref="F:System.Threading.Timeout.Infinite" /> (-1) 表示永遠等候，零表示測試等候控制代碼的狀態並立即傳回。</param>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />，並使用 32 位元帶正負號的整數來測量時間間隔，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則工作會完成且結果為 <see langword="true" />，否則結果為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在逾時設定為-1 毫秒，方法就會無限期地等候。
 
 如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的數值，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; WaitAsync (TimeSpan timeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; WaitAsync(valuetype System.TimeSpan timeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;bool&gt; ^ WaitAsync(TimeSpan timeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.WaitAsync : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="semaphoreSlim.WaitAsync (timeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表要等候的毫秒數；<see cref="T:System.TimeSpan" /> 為 -1 毫秒表示永遠等候，<see cref="T:System.TimeSpan" /> 為 0 毫秒表示測試等候控制代碼並立即傳回。</param>
        <param name="cancellationToken">要觀察的 <see cref="T:System.Threading.CancellationToken" /> 語彙基元。</param>
        <summary>以非同步方式等候進入 <see cref="T:System.Threading.SemaphoreSlim" />，並使用 <see cref="T:System.TimeSpan" /> 來測量時間間隔，同時觀察 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <returns>如果目前的執行緒成功進入 <see cref="T:System.Threading.SemaphoreSlim" />，則工作會完成且結果為 <see langword="true" />，否則結果為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在逾時設定為-1 毫秒，方法就會無限期地等候。

 如果在逾時設定為零毫秒，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 是除了 -1 以外的負數，表示無限逾時，或是大於 <see cref="F:System.Int32.MaxValue" /> 的逾時。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.SemaphoreSlim" /> 已經處置。</exception>
      </Docs>
    </Member>
  </Members>
</Type>