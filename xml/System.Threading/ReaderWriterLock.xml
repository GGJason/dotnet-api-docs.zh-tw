<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fc1a0c88765040869d8ad919aeb575e304c71bde" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531032" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock&#xA;Inherits CriticalFinalizerObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定義鎖定，它支援單一寫入器和多重讀取器。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 擁有 <xref:System.Threading.ReaderWriterLockSlim> 和 <xref:System.Threading.ReaderWriterLock> 這兩個 Reader-Writer 鎖定。 建議針對所有新的開發使用 <xref:System.Threading.ReaderWriterLockSlim>。 <xref:System.Threading.ReaderWriterLockSlim> 類似於 <xref:System.Threading.ReaderWriterLock>，但是它有遞迴以及升級和降級鎖定狀態的簡化規則。 <xref:System.Threading.ReaderWriterLockSlim> 可避免可能發生死結的許多情況。 此外，<xref:System.Threading.ReaderWriterLockSlim> 的效能明顯優於 <xref:System.Threading.ReaderWriterLock>。  
  
 <xref:System.Threading.ReaderWriterLock> 用來同步處理資源的存取權。 在任何時候，它可讓多重執行緒的並行讀取權限，或是單一執行緒的寫入權限。 資源不常變更的情況下`ReaderWriterLock`提供更佳的輸送量，比簡單的其中一個-一次鎖定，例如<xref:System.Threading.Monitor>。  
  
 `ReaderWriterLock` 其中大部分的存取，則讀取、 寫入不頻繁和短時間內，效果最好。 多個讀取器的替代與單一寫入器，因此會讀取器或寫入器會封鎖長時間。  
  
> [!NOTE]
>  長期保留讀取鎖定或寫入器鎖定會影響其他執行緒。 為了達到最佳效能，請考慮重建您的應用程式寫入的持續時間降至最低。  
  
 執行緒可以保留讀取鎖定或寫入器鎖定，但不可同時在相同的時間。 而不是為了取得寫入器鎖定釋放讀取器的鎖定，您可以使用<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>和<xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>。  
  
 遞迴的鎖定要求增加上鎖定的鎖定計數。  
  
 是個別佇列讀取器和寫入器。 當執行緒釋放寫入器的鎖定時，那時讀取器佇列中等待的所有執行緒授都與讀取器鎖定。當這些讀取器鎖定的所有已發行下, 一個執行緒等候寫入器中排入佇列，如果任何，授與寫入器的鎖定，等等。 換句話說，`ReaderWriterLock`交替讀取器，集合和一個寫入器。  
  
 當寫入器佇列中的執行緒正在等候讀取器鎖定釋出時，要求新的讀取器鎖定的執行緒會累積讀取器佇列中。 要求未獲授予，即使它們無法與現有的讀取器鎖定持有者; 共用的並行存取這有助於保護針對讀取者無限期發生封鎖情形等的寫入器。  
  
 大部分的方法上取得鎖定`ReaderWriterLock`接受逾時值。 若要避免死結，應用程式中的使用逾時。 比方說，執行緒可能會取得一個資源寫入器鎖定，而且然後要求第二個資源; 讀取器鎖定在此同時，另一個執行緒可能取得寫入器鎖定，第二個資源，並要求在第一個讀取器的鎖定。 除非使用逾時，執行緒會鎖死。  
  
 如果逾時間隔到期且未被授與鎖定要求，方法會傳回控制項至呼叫的執行緒所擲回<xref:System.ApplicationException>。 執行緒可以捕捉此例外狀況，並判斷要採取的後續動作。  
  
 逾時值被以毫秒為單位。 如果您使用<xref:System.TimeSpan?displayProperty=nameWithType>指定逾時，所使用的值是由表示整數毫秒總數<xref:System.TimeSpan>。 下表顯示有效的逾時值以毫秒為單位。  
  
|值|描述|  
|-----------|-----------------|  
|-1|執行緒等候，直到鎖定，則不論花費的時間。 指定的整數逾時、 常數的方法<xref:System.Threading.Timeout.Infinite>可用。|  
|0|執行緒不會等候取得鎖定。 如果無法立即取得鎖定，則方法傳回。|  
|>0|要等候的毫秒數。|  
  
 -1，除了不允許負值。 如果您指定-1 以外的負數的整數，改為使用零的逾時值。 （亦即，方法會傳回而不要等候，如果無法立即取得鎖定。）如果您指定<xref:System.TimeSpan>表示毫秒-1，以外的負數<xref:System.ArgumentOutOfRangeException>就會擲回。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.ReaderWriterLock>若要保護的共用的資源，整數值，名為`resource`，也就是同時讀取和寫入專屬的多個執行緒。 請注意，<xref:System.Threading.ReaderWriterLock>宣告類別層級，因此它會顯示所有執行緒。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.ReaderWriterLock" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何建立 <xref:System.Threading.ReaderWriterLock> 類別的新執行個體。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLock>類別。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireReaderLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得讀取器的鎖定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">逾時以毫秒為單位。</param>
        <summary>使用逾時值 <see cref="T:System.Int32" /> 取得讀取器的鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> 如果在不同的執行緒寫入器的鎖定，或至少一個執行緒正在等候寫入器的鎖定封鎖。  
  
> [!NOTE]
>  如果目前執行緒已寫入器的鎖定，沒有讀取器鎖定。 相反地，寫入器的鎖定上的鎖定計數會遞增。 這可防止在其本身的寫入器鎖定上封鎖執行緒。 結果是完全呼叫相同<xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>，以及額外的呼叫<xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>釋放寫入器鎖定時，就需要。  
  
 `AcquireReaderLock` 支援遞迴的讀取器鎖定要求。 也就是說，執行緒可以呼叫 AcquireReaderLock 多次，這在每次增加的鎖定計數。 您必須呼叫<xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>一次針對每次呼叫`AcquireReaderLock`。 或者，您可以呼叫<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>減少鎖定計數為零立即。  
  
 遞迴的鎖定要求會一律立即授與，而不會讓讀取器佇列中要求的執行緒。 遞迴鎖定謹慎使用，以避免長時間封鎖寫入器鎖定要求。  
  
 有效的逾時值，請參閱<xref:System.Threading.ReaderWriterLock>。  
  
   
  
## Examples  
 下列程式碼範例示範如何取得及釋放讀取器的鎖定，以及如何處理時要求逾時擲回的例外狀況。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLock>類別。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="millisecondsTimeout" /> 在授與鎖定要求前過期。</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see langword="TimeSpan" />，指定逾時期間。</param>
        <summary>使用逾時值 <see cref="T:System.TimeSpan" /> 取得讀取器的鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> 如果在不同的執行緒寫入器的鎖定，或至少一個執行緒正在等候寫入器的鎖定封鎖。  
  
> [!NOTE]
>  如果目前執行緒已寫入器的鎖定，沒有讀取器鎖定。 相反地，寫入器的鎖定上的鎖定計數會遞增。 這可防止在其本身的寫入器鎖定上封鎖執行緒。 結果是完全呼叫相同<xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>，以及額外的呼叫<xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>釋放寫入器鎖定時，就需要。  
  
 `AcquireReaderLock` 支援遞迴的讀取器鎖定要求。 也就是說，執行緒可以呼叫 AcquireReaderLock 多次，這在每次增加的鎖定計數。 您必須呼叫<xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>一次針對每次呼叫`AcquireReaderLock`。 或者，您可以呼叫<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>減少鎖定計數為零立即。  
  
 遞迴的鎖定要求會一律立即授與，而不會讓讀取器佇列中要求的執行緒。 遞迴鎖定謹慎使用，以避免長時間封鎖寫入器鎖定要求。  
  
 有效的逾時值，請參閱<xref:System.Threading.ReaderWriterLock>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> 在授與鎖定要求前過期。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 可以指定 -1 毫秒以外的負值。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得寫入器的鎖定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">逾時以毫秒為單位。</param>
        <summary>使用逾時值 <see cref="T:System.Int32" /> 取得寫入器的鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會封鎖，如果另一個執行緒讀取器的鎖定或寫入器鎖定。 如需寫入器的鎖定會與多個並行讀取器鎖定交替出現的方式的說明，請參閱<xref:System.Threading.ReaderWriterLock>類別。  
  
 已讀取器的鎖定的執行緒可以取得寫入器鎖定在兩種方式之一： 釋放讀取鎖定，然後再呼叫<xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>，或藉由呼叫<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>。  
  
> [!CAUTION]
>  如果呼叫執行緒`AcquireWriterLock`時仍有讀取器的鎖定，它會封鎖讀取器鎖定上; 如果指定無限逾時，就會鎖死的執行緒。 若要避免這類死結，請使用<xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>來判斷目前的執行緒是否已有讀取器的鎖定。  
  
 `AcquireWriterLock` 支援遞迴的寫入器鎖定要求。 也就是說，執行緒可以呼叫`AcquireWriterLock`許多次，其中的鎖定計數遞增每一次。 您必須呼叫<xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>一次針對每次呼叫`AcquireWriterLock`。 或者，您可以呼叫<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>減少鎖定計數為零立即。  
  
 遞迴的鎖定要求會一律立即授與，而不會讓寫入器佇列中要求的執行緒。  
  
 有效的逾時值，請參閱<xref:System.Threading.ReaderWriterLock>。  
  
   
  
## Examples  
 下列程式碼範例示範如何取得並發行寫入器鎖定，以及如何處理時要求逾時擲回的例外狀況。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLock>類別。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> 在授與鎖定要求前過期。</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see langword="TimeSpan" />，指定逾時期間。</param>
        <summary>使用逾時值 <see cref="T:System.TimeSpan" /> 取得寫入器的鎖定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會封鎖，如果另一個執行緒讀取器的鎖定或寫入器鎖定。 如需寫入器的鎖定會與多個並行讀取器鎖定交替出現的方式的說明，請參閱<xref:System.Threading.ReaderWriterLock>類別。  
  
 已讀取器的鎖定的執行緒可以取得寫入器鎖定在兩種方式之一： 釋放讀取鎖定，然後再呼叫<xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>，或藉由呼叫<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>。  
  
> [!CAUTION]
>  如果呼叫執行緒`AcquireWriterLock`時仍有讀取器的鎖定，它會封鎖讀取器鎖定上; 如果指定無限逾時，就會鎖死的執行緒。 若要避免這類死結，請使用<xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>來判斷目前的執行緒是否已有讀取器的鎖定。  
  
 `AcquireWriterLock` 支援遞迴的寫入器鎖定要求。 也就是說，執行緒可以呼叫`AcquireWriterLock`許多次，其中的鎖定計數遞增每一次。 您必須呼叫<xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>一次針對每次呼叫`AcquireWriterLock`。 或者，您可以呼叫<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>減少鎖定計數為零立即。  
  
 遞迴的鎖定要求會一律立即授與，而不會讓寫入器佇列中要求的執行緒。  
  
 有效的逾時值，請參閱<xref:System.Threading.ReaderWriterLock>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> 在授與鎖定要求前過期。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 可以指定 -1 毫秒以外的負值。</exception>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AnyWritersSince (seqNum As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AnyWritersSince(int seqNum);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum">序號。</param>
        <summary>指示取得序號之後有無將寫入器鎖定授與至任何執行緒。</summary>
        <returns>
          如果取得序號之後有將寫入器鎖定授與至任何執行緒，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>和`AnyWritersSince`改善應用程式效能。 例如，執行緒可能會快取保留讀取鎖定時取得的資訊。 釋出和更新版本重新取得鎖定之後, 可以使用執行緒`AnyWritersSince`來判斷是否其他執行緒的資源寫入暫時; 如果沒有，可以使用快取的資訊。 這個技術非常有用是高度耗費資源; 讀取鎖定所保護的資訊例如，執行資料庫查詢。  
  
 呼叫端必須寫入器鎖定或讀取器鎖定保留順序，序號才能發揮作用。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>方法和<xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>屬性來判斷另一個執行緒是否已受保護的資源寫入器鎖定，因為目前的執行緒上一次保留寫入器的鎖定。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLock>類別。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DowngradeFromWriterLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DowngradeFromWriterLock(System::Threading::LockCookie % lockCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">
          <see cref="T:System.Threading.LockCookie" /> 所傳回的 <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />。</param>
        <summary>將執行緒的鎖定狀態還原到呼叫 <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> 之前的狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> 釋放寫入器的鎖定，不論遞迴鎖定計數，並還原已由執行緒持有然後再升級至寫入器鎖定的讀取器鎖定。 在讀取器鎖定的鎖定計數就會還原。  
  
> [!NOTE]
>  `DowngradeFromWriterLock` 接受<xref:System.Threading.LockCookie>藉由呼叫取得<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>。 請勿使用`LockCookie`傳回<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>。  
  
 執行緒不會封鎖寫入器的鎖定，從降級時，即使其他執行緒正在等候寫入器的鎖定，因為當使用者放開寫入器鎖定授與所有的讀取器鎖定要求。  
  
   
  
## Examples  
 下列程式碼範例示範如何要求讀取器的鎖定、 將讀取器鎖定升級至寫入器鎖定，以及一次降級為讀取器的鎖定。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLock>類別。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">執行緒沒有寫入器鎖定。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="lockCookie" /> 的位址為 null 指標。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReaderWriterLock ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>確認釋出資源，並在記憶體回收行程再利用 <see cref="T:System.Threading.ReaderWriterLock" /> 物件時執行其他清除作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 記憶體回收行程呼叫<xref:System.Threading.ReaderWriterLock.Finalize%2A>時目前<xref:System.Threading.ReaderWriterLock>物件已經準備完成。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReaderLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReaderLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前的執行緒是否掌握讀取器的鎖定。</summary>
        <value>
          如果目前的執行緒掌握讀取器的鎖定，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何使用`IsReaderLockHeld`若要避免死結。  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriterLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriterLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前的執行緒是否掌握寫入器的鎖定。</summary>
        <value>
          如果目前的執行緒掌握寫入器的鎖定，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範當嘗試取得具有寫入器鎖定，在執行緒上的讀取器鎖定`ReaderWriterLock`不授與讀取器鎖定，但改為遞增寫入器的鎖定上的鎖定計數。  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseLock () As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie ReleaseLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>無論執行緒取得鎖定的次數為多少，都會釋放鎖定。</summary>
        <returns>
          <see cref="T:System.Threading.LockCookie" /> 值，代表釋放的鎖定。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> 釋放讀取器鎖定或寫入器鎖定，不論遞迴鎖定計數。 若要還原狀態的鎖定，包括的鎖定計數，將傳遞<xref:System.Threading.LockCookie>至<xref:System.Threading.ReaderWriterLock.RestoreLock%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>方法，以釋出鎖定，不論多少次它已經取得的執行緒，以及如何還原的更新版本的鎖定狀態。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLock>類別。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseReaderLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseReaderLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>減量鎖定計數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> 減量鎖定計數。 當計數到達零時，會釋放鎖定。  
  
> [!NOTE]
>  如果執行緒有將寫入器鎖定，則呼叫`ReleaseReaderLock`具有相同的效果與呼叫<xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>。 如果執行緒不有任何鎖定，則呼叫`ReleaseReaderLock`會擲回<xref:System.ApplicationException>。  
  
   
  
## Examples  
 下列程式碼範例示範如何取得及釋放讀取器的鎖定，以及如何處理時要求逾時擲回的例外狀況。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLock>類別。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">執行緒沒有任何讀取器或寫入器鎖定。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseWriterLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseWriterLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>減量寫入器鎖定上的鎖定計數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> 減量寫入器的鎖定計數。 當計數到達零時，就會寫入器鎖定釋放。  
  
> [!NOTE]
>  如果執行緒有讀取器的鎖定或沒有鎖定，則呼叫`ReleaseWriterLock`會擲回<xref:System.ApplicationException>。  
  
   
  
## Examples  
 下列程式碼範例示範如何取得並發行寫入器鎖定，以及如何處理時要求逾時擲回的例外狀況。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLock>類別。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">執行緒沒有寫入器鎖定。</exception>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RestoreLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RestoreLock(System::Threading::LockCookie % lockCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">
          <see cref="T:System.Threading.LockCookie" /> 所傳回的 <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />。</param>
        <summary>將執行緒的鎖定狀態還原到呼叫 <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /> 之前的狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 還原狀態`RestoreLock`包含遞迴鎖定計數。  
  
 如果它嘗試還原另一個執行緒取得寫入器鎖定之後，或如果它嘗試還原另一個執行緒取得讀取器鎖定或寫入器鎖定之後的寫入器鎖定的讀取器的鎖定的執行緒封鎖。 因為`RestoreLock`不接受逾時，您應謹慎避免可能的死結。  
  
> [!CAUTION]
>  然後再呼叫`RestoreLock`，請確定在您釋放所有的呼叫取得的鎖定<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>。 例如，執行緒死結若取得讀取器的鎖定，然後再嘗試還原較早的寫入器鎖定。 使用<xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>和<xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A>偵測這類額外的鎖定。  
  
 請勿使用<xref:System.Threading.LockCookie>從傳回<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>方法，以釋出鎖定，不論多少次它已經取得的執行緒，以及如何還原的更新版本的鎖定狀態。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLock>類別。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="lockCookie" /> 的位址為 null 指標。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpgradeToWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讀取器鎖定升級至寫入器鎖定。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (millisecondsTimeout As Integer) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">逾時以毫秒為單位。</param>
        <summary>使用逾時值 <see langword="Int32" />，將讀取器鎖定升級至寫入器鎖定。</summary>
        <returns>
          <see cref="T:System.Threading.LockCookie" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當一個執行緒呼叫`UpgradeToWriterLock`釋放讀取器鎖定，鎖定計數，不管和執行緒進行的寫入器鎖定的佇列結尾。 因此，其他執行緒可能會寫入之前要求升級會授與寫入器鎖定的執行緒資源。  
  
> [!IMPORTANT]
>  逾時例外狀況不會擲回呼叫執行緒直到<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>方法可以取得讀取器鎖定。 如果沒有其他執行緒等候寫入器鎖定，此事件會立即發生。 不過，如果另一個執行緒在佇列中等候寫入器的鎖定，執行緒的呼叫<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>方法不能重新取得讀取器鎖定，直到所有目前的讀取器已釋放其鎖定，以及一個執行緒具有取得和釋放寫入器的鎖定。 這是 true，即使要求寫入器鎖定的執行緒在目前的執行緒呼叫之後要求<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>方法。  
  
 若要還原的鎖定狀態，請呼叫<xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>使用<xref:System.Threading.LockCookie>傳回`UpgradeToWriterLock`。 不使用這個`LockCookie`與<xref:System.Threading.ReaderWriterLock.RestoreLock%2A>。  
  
 當執行緒必須沒有讀取器的鎖定時，請勿使用`UpgradeToWriterLock`。 請改用 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>。  
  
 有效的逾時值，請參閱<xref:System.Threading.ReaderWriterLock>。  
  
   
  
## Examples  
 下列程式碼範例示範如何要求讀取器的鎖定、 將讀取器鎖定升級至寫入器鎖定，以及一次降級為讀取器的鎖定。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLock>類別。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="millisecondsTimeout" /> 在授與鎖定要求前過期。</exception>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (timeout As TimeSpan) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see langword="TimeSpan" />，指定逾時期間。</param>
        <summary>使用逾時值 <see langword="TimeSpan" />，將讀取器鎖定升級至寫入器鎖定。</summary>
        <returns>
          <see cref="T:System.Threading.LockCookie" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當一個執行緒呼叫`UpgradeToWriterLock`釋放讀取器鎖定，鎖定計數，不管和執行緒進行的寫入器鎖定的佇列結尾。 因此，其他執行緒可能會寫入之前要求升級會授與寫入器鎖定的執行緒資源。  
  
> [!IMPORTANT]
>  逾時例外狀況不會擲回呼叫執行緒直到<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>方法可以取得讀取器鎖定。 如果沒有其他執行緒等候寫入器鎖定，此事件會立即發生。 不過，如果另一個執行緒在佇列中等候寫入器的鎖定，執行緒的呼叫<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>方法不能重新取得讀取器鎖定，直到所有目前的讀取器已釋放其鎖定，以及一個執行緒具有取得和釋放寫入器的鎖定。 這是 true，即使要求寫入器鎖定的執行緒在目前的執行緒呼叫之後要求<xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>方法。  
  
 若要還原的鎖定狀態，請呼叫<xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>使用<xref:System.Threading.LockCookie>傳回`UpgradeToWriterLock`。 不使用這個`LockCookie`與<xref:System.Threading.ReaderWriterLock.RestoreLock%2A>。  
  
 當執行緒必須沒有讀取器的鎖定時，請勿使用`UpgradeToWriterLock`。 請改用 <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>。  
  
 有效的逾時值，請參閱<xref:System.Threading.ReaderWriterLock>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <paramref name="timeout" /> 在授與鎖定要求前過期。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 可以指定 -1 毫秒以外的負值。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriterSeqNum As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriterSeqNum { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前的序號。</summary>
        <value>目前的序號。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此順序數字會增加每當執行緒取得寫入器的鎖定。 您可以儲存的序號，並將它傳遞給<xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>稍後，如果您想要判斷是否其他執行緒已取得寫入器鎖定同時。  
  
 您可以使用`WriterSeqNum`改善應用程式效能。 例如，執行緒可能會快取保留讀取鎖定時取得的資訊。 之後釋出和更新版本重新取得鎖定，執行緒可以判斷其他的執行緒是否已寫入至資源藉由呼叫`AnyWritersSince`; 如果沒有，可以使用快取的資訊。 讀取鎖定所保護的資訊是高度耗費資源; 時，這項技術非常有用例如，執行資料庫查詢。  
  
 呼叫端必須寫入器鎖定或讀取器鎖定保留順序，序號才能發揮作用。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>屬性和<xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>方法來判斷另一個執行緒是否已受保護的資源寫入器鎖定，因為目前的執行緒上一次保留寫入器的鎖定。  
  
 這段程式碼是針對所提供之較大範例的一部分<xref:System.Threading.ReaderWriterLock>類別。  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>