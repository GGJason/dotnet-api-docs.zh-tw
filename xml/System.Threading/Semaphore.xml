<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="312a73b1d0f299dfb59a7dcba73d3cf9dbc2bb2c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609192" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="e9a37-101">Limits the number of threads that can access a resource or pool of resources concurrently.</span>
      <span class="sxs-lookup">
        <span data-stu-id="e9a37-101">Limits the number of threads that can access a resource or pool of resources concurrently.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-102">使用<xref:System.Threading.Semaphore>類別來控制存取權的資源集區。</span><span class="sxs-lookup"><span data-stu-id="e9a37-102">Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources.</span></span> <span data-ttu-id="e9a37-103">執行緒藉由呼叫進入號誌<xref:System.Threading.WaitHandle.WaitOne%2A>方法，它繼承自<xref:System.Threading.WaitHandle>類別，並藉由呼叫釋放號誌<xref:System.Threading.Semaphore.Release%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-103">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="e9a37-104">號誌計數會每次在執行緒進入號誌，及執行緒釋放號誌時，遞增遞減。</span><span class="sxs-lookup"><span data-stu-id="e9a37-104">The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</span></span> <span data-ttu-id="e9a37-105">當計數為零時，後續的要求封鎖，直到其他執行緒釋放號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-105">When the count is zero, subsequent requests block until other threads release the semaphore.</span></span> <span data-ttu-id="e9a37-106">所有執行緒都釋放號誌，計數會達到最大值時指定已建立的號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-106">When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</span></span>  
  
 <span data-ttu-id="e9a37-107">沒有任何保證的順序，例如 FIFO 或 LIFO，在其中已封鎖的執行緒進入號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-107">There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-108">執行緒可以進入號誌多次，藉由呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>方法重複。</span><span class="sxs-lookup"><span data-stu-id="e9a37-108">A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly.</span></span> <span data-ttu-id="e9a37-109">若要釋放的部分或所有項目，執行緒可以呼叫無參數<xref:System.Threading.Semaphore.Release>多次，或它可以呼叫的方法多載<xref:System.Threading.Semaphore.Release%28System.Int32%29>方法多載會指定釋出的項目數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-109">To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.</span></span>  
  
 <span data-ttu-id="e9a37-110"><xref:System.Threading.Semaphore>類別不會強制呼叫的執行緒身分識別<xref:System.Threading.WaitHandle.WaitOne%2A>或<xref:System.Threading.Semaphore.Release%2A>。</span><span class="sxs-lookup"><span data-stu-id="e9a37-110">The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>.</span></span> <span data-ttu-id="e9a37-111">它是程式設計人員必須負責確保，執行緒沒有釋放號誌太多次。</span><span class="sxs-lookup"><span data-stu-id="e9a37-111">It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</span></span> <span data-ttu-id="e9a37-112">例如，假設某個號誌的最大計數為 2，且執行緒 A 和執行緒 B 都進入號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-112">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="e9a37-113">如果執行緒 B 中的程式設計錯誤導致呼叫<xref:System.Threading.Semaphore.Release%2A>兩次，這兩個呼叫會成功。</span><span class="sxs-lookup"><span data-stu-id="e9a37-113">If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed.</span></span> <span data-ttu-id="e9a37-114">此時號誌計數已滿，當執行緒 A 終於呼叫 <xref:System.Threading.Semaphore.Release%2A> 時，就會擲回 <xref:System.Threading.SemaphoreFullException>。</span><span class="sxs-lookup"><span data-stu-id="e9a37-114">The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
 <span data-ttu-id="e9a37-115">號誌有兩種類型： 本機號誌和具名的系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-115">Semaphores are of two types: local semaphores and named system semaphores.</span></span> <span data-ttu-id="e9a37-116">如果您建立<xref:System.Threading.Semaphore>物件使用的建構函式可接受名稱，它是與該名稱的作業系統號誌相關聯。</span><span class="sxs-lookup"><span data-stu-id="e9a37-116">If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</span></span> <span data-ttu-id="e9a37-117">具名的系統號誌會顯示整個作業系統，而且可用來同步處理程序的活動。</span><span class="sxs-lookup"><span data-stu-id="e9a37-117">Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="e9a37-118">您可以建立多個<xref:System.Threading.Semaphore>代表相同的物件命名系統號誌，而且您可以使用<xref:System.Threading.Semaphore.OpenExisting%2A>方法來開啟現有的具名系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-118">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-119">本機號誌只會存在於您的程序。</span><span class="sxs-lookup"><span data-stu-id="e9a37-119">A local semaphore exists only within your process.</span></span> <span data-ttu-id="e9a37-120">在處理序內，只要是參考了本機 <xref:System.Threading.Semaphore> 物件的執行緒，就可使用本機 Mutex。</span><span class="sxs-lookup"><span data-stu-id="e9a37-120">It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="e9a37-121">每個<xref:System.Threading.Semaphore>物件是否不同本機號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-121">Each <xref:System.Threading.Semaphore> object is a separate local semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9a37-122">下列程式碼範例會建立號誌的三個最大計數與初始的計數為零。</span><span class="sxs-lookup"><span data-stu-id="e9a37-122">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="e9a37-123">此範例會啟動五個執行緒，封鎖等候號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-123">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="e9a37-124">主要執行緒使用<xref:System.Threading.Semaphore.Release%28System.Int32%29>方法多載來增加為最大值，允許三個執行緒進入號誌的號誌計數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-124">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="e9a37-125">每個執行緒會使用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法等候 1 秒，以模擬工作，然後呼叫<xref:System.Threading.Semaphore.Release>方法多載來釋放號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-125">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="e9a37-126">已釋放號誌，每次會顯示先前的號誌計數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-126">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="e9a37-127">主控台訊息追蹤號誌的使用。</span><span class="sxs-lookup"><span data-stu-id="e9a37-127">Console messages track semaphore use.</span></span> <span data-ttu-id="e9a37-128">模擬的工作間隔會稍微增加，每個執行緒，以讓輸出更容易閱讀。</span><span class="sxs-lookup"><span data-stu-id="e9a37-128">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="e9a37-129">此型別具備執行緒安全。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e9a37-129">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e9a37-130">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-130">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="e9a37-131">The initial number of requests for the semaphore that can be granted concurrently.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-131">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="e9a37-132">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-132">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e9a37-133">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-133">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-134">這個建構函式會初始化未命名的號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-134">This constructor initializes an unnamed semaphore.</span></span> <span data-ttu-id="e9a37-135">使用這類的號誌的執行個體的所有執行緒都必須都有執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="e9a37-135">All threads that use an instance of such a semaphore must have references to the instance.</span></span>  
  
 <span data-ttu-id="e9a37-136">如果`initialCount`是小於`maximumCount`，效果等同視為目前的執行緒已呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>(`maximumCount`減去`initialCount`) 時間。</span><span class="sxs-lookup"><span data-stu-id="e9a37-136">If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="e9a37-137">如果您不想保留任何項目之執行緒的建立號誌，使用的相同號碼`maximumCount`和`initialCount`。</span><span class="sxs-lookup"><span data-stu-id="e9a37-137">If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9a37-138">下列範例會建立一個號誌的三個最大計數與初始的計數為零。</span><span class="sxs-lookup"><span data-stu-id="e9a37-138">The following example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="e9a37-139">此範例會啟動五個執行緒，封鎖等候號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-139">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="e9a37-140">主要執行緒使用<xref:System.Threading.Semaphore.Release%28System.Int32%29>方法多載來增加為最大值，允許三個執行緒進入號誌的號誌計數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-140">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="e9a37-141">每個執行緒會使用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法等候 1 秒，以模擬工作，然後呼叫<xref:System.Threading.Semaphore.Release>方法多載來釋放號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-141">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="e9a37-142">已釋放號誌，每次會顯示先前的號誌計數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-142">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="e9a37-143">主控台訊息追蹤號誌的使用。</span><span class="sxs-lookup"><span data-stu-id="e9a37-143">Console messages track semaphore use.</span></span> <span data-ttu-id="e9a37-144">模擬的工作間隔會稍微增加，每個執行緒，以讓輸出更容易閱讀。</span><span class="sxs-lookup"><span data-stu-id="e9a37-144">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e9a37-145">
            <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-145">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e9a37-146">
            <paramref name="maximumCount" /> is less than 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-146">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="e9a37-147">-or-  <paramref name="initialCount" /> is less than 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-147">-or-  <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="e9a37-148">The initial number of requests for the semaphore that can be granted concurrently.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-148">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="e9a37-149">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-149">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="e9a37-150">The name of a named system semaphore object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-150">The name of a named system semaphore object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e9a37-151">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-151">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-152">這個建構函式初始化<xref:System.Threading.Semaphore>代表具名的系統號誌的物件。</span><span class="sxs-lookup"><span data-stu-id="e9a37-152">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="e9a37-153">您可以建立多個<xref:System.Threading.Semaphore>代表相同的物件命名系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-153">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-154">如果不存在的具名的系統號誌，則會建立初始的計數與所指定的計數上限`initialCount`和`maximumCount`。</span><span class="sxs-lookup"><span data-stu-id="e9a37-154">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="e9a37-155">如果具名的系統號誌已存在，`initialCount`和`maximumCount`未使用，雖然無效的值仍會造成例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e9a37-155">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="e9a37-156">若要判斷是否已命名的系統號誌已建立，使用<xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29>改為建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="e9a37-156">If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e9a37-157">當您使用這個建構函式多載時，建議的作法是指定的相同號碼`initialCount`和`maximumCount`。</span><span class="sxs-lookup"><span data-stu-id="e9a37-157">When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="e9a37-158">如果`initialCount`是小於`maximumCount`，並建立具名的系統號誌，效果等同視為目前的執行緒已呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>(`maximumCount`減去`initialCount`) 時間。</span><span class="sxs-lookup"><span data-stu-id="e9a37-158">If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="e9a37-159">不過，使用這個建構函式多載沒有任何方法來判斷是否已建立具名的系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-159">However, with this constructor overload there is no way to determine whether a named system semaphore was created.</span></span>  
  
 <span data-ttu-id="e9a37-160">如果您指定`null`或空字串`name`，建立本機號誌，視為已呼叫<xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="e9a37-160">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span>  
  
 <span data-ttu-id="e9a37-161">因為整個作業系統，您看不見具名號誌，它們可用來協調跨處理序界限的資源使用。</span><span class="sxs-lookup"><span data-stu-id="e9a37-161">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
 <span data-ttu-id="e9a37-162">如果您想要了解具名的系統號誌是否存在，請使用<xref:System.Threading.Semaphore.OpenExisting%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-162">If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method.</span></span> <span data-ttu-id="e9a37-163"><xref:System.Threading.Semaphore.OpenExisting%2A>方法嘗試開啟現有的具名號誌，並擲回例外狀況，如果系統號誌不存在。</span><span class="sxs-lookup"><span data-stu-id="e9a37-163">The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9a37-164">下列程式碼範例將示範具名號誌的跨處理序行為。</span><span class="sxs-lookup"><span data-stu-id="e9a37-164">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="e9a37-165">此範例會建立具名號誌，其最大計數為 5 與初始的計數為 5。</span><span class="sxs-lookup"><span data-stu-id="e9a37-165">The example creates a named semaphore with a maximum count of five and an initial count of five.</span></span> <span data-ttu-id="e9a37-166">讓程式在三次呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-166">The program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="e9a37-167">因此，如果您是從兩個命令視窗執行編譯的範例，第二個複本將會封鎖第三個呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>。</span><span class="sxs-lookup"><span data-stu-id="e9a37-167">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="e9a37-168">發行的第一個程式，以解除封鎖第二個副本中的一或多個項目。</span><span class="sxs-lookup"><span data-stu-id="e9a37-168">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e9a37-169">
            <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-169">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="e9a37-170">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-170">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e9a37-171">
            <paramref name="maximumCount" /> is less than 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-171">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="e9a37-172">-or-  <paramref name="initialCount" /> is less than 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-172">-or-  <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e9a37-173">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-173">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e9a37-174">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-174">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="e9a37-175">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-175">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e9a37-176">呼叫 unmanaged 程式碼來建立具名的系統號誌。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-176">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="e9a37-177">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-177">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="e9a37-178">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-178">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="e9a37-179">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-179">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="e9a37-180">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-180">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="e9a37-181">The name of a named system semaphore object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-181">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="e9a37-182">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-182">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="e9a37-183">This parameter is passed uninitialized.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-183">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e9a37-184">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-184">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-185">這個建構函式初始化<xref:System.Threading.Semaphore>代表具名的系統號誌的物件。</span><span class="sxs-lookup"><span data-stu-id="e9a37-185">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="e9a37-186">您可以建立多個<xref:System.Threading.Semaphore>代表相同的物件命名系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-186">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-187">如果不存在的具名的系統號誌，則會建立初始的計數與所指定的計數上限`initialCount`和`maximumCount`。</span><span class="sxs-lookup"><span data-stu-id="e9a37-187">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="e9a37-188">如果具名的系統號誌已存在，`initialCount`和`maximumCount`未使用，雖然無效的值仍會造成例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e9a37-188">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="e9a37-189">使用`createdNew`來判斷是否已建立的系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-189">Use `createdNew` to determine whether the system semaphore was created.</span></span>  
  
 <span data-ttu-id="e9a37-190">如果`initialCount`是小於`maximumCount`，並`createdNew`是`true`，效果等同視為目前的執行緒已呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>(`maximumCount`減去`initialCount`) 時間。</span><span class="sxs-lookup"><span data-stu-id="e9a37-190">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="e9a37-191">如果您指定`null`或空字串`name`，建立本機號誌，視為已呼叫<xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="e9a37-191">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="e9a37-192">在此情況下，`createdNew`總是`true`。</span><span class="sxs-lookup"><span data-stu-id="e9a37-192">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="e9a37-193">因為整個作業系統，您看不見具名號誌，它們可用來協調跨處理序界限的資源使用。</span><span class="sxs-lookup"><span data-stu-id="e9a37-193">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9a37-194">下列程式碼範例將示範具名號誌的跨處理序行為。</span><span class="sxs-lookup"><span data-stu-id="e9a37-194">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="e9a37-195">此範例會建立具名號誌，使用其最大計數為 5，且兩個初始計數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-195">The example creates a named semaphore with a maximum count of five and an initial count of two.</span></span> <span data-ttu-id="e9a37-196">也就是說，它會保留之執行緒的呼叫建構函式的三個項目。</span><span class="sxs-lookup"><span data-stu-id="e9a37-196">That is, it reserves three entries for the thread that calls the constructor.</span></span> <span data-ttu-id="e9a37-197">如果`createNew`已`false`，讓程式在三次呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-197">If `createNew` is `false`, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="e9a37-198">因此，如果您是從兩個命令視窗執行編譯的範例，第二個複本將會封鎖第三個呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>。</span><span class="sxs-lookup"><span data-stu-id="e9a37-198">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="e9a37-199">發行的第一個程式，以解除封鎖第二個副本中的一或多個項目。</span><span class="sxs-lookup"><span data-stu-id="e9a37-199">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e9a37-200">
            <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-200">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="e9a37-201">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-201">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e9a37-202">
            <paramref name="maximumCount" /> is less than 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-202">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="e9a37-203">-or-  <paramref name="initialCount" /> is less than 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-203">-or-  <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e9a37-204">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-204">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e9a37-205">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-205">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="e9a37-206">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-206">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e9a37-207">呼叫 unmanaged 程式碼來建立具名的系統號誌。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-207">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="e9a37-208">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-208">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="e9a37-209">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-209">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="e9a37-210">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-210">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="e9a37-211">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-211">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="e9a37-212">The name of a named system semaphore object.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-212">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="e9a37-213">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-213">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="e9a37-214">This parameter is passed uninitialized.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-214">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="semaphoreSecurity">
          <span data-ttu-id="e9a37-215">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-215">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e9a37-216">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-216">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-217">您可以使用這個建構函式套用至具名的系統號誌的存取控制安全性，當它建立時，防止其他程式碼的號誌的控制。</span><span class="sxs-lookup"><span data-stu-id="e9a37-217">Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-218">這個建構函式初始化<xref:System.Threading.Semaphore>代表具名的系統號誌的物件。</span><span class="sxs-lookup"><span data-stu-id="e9a37-218">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="e9a37-219">您可以建立多個<xref:System.Threading.Semaphore>代表相同的物件命名系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-219">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-220">如果具名的系統號誌不存在，它會建立具有指定的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-220">If the named system semaphore does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="e9a37-221">如果具名的信號已存在，則會忽略指定的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-221">If the named semaphore exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e9a37-222">呼叫端具有全權掌控新建<xref:System.Threading.Semaphore>物件，即使`semaphoreSecurity`拒絕，或無法授與給目前的使用者部分存取權限。</span><span class="sxs-lookup"><span data-stu-id="e9a37-222">The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="e9a37-223">不過，如果目前的使用者嘗試取得另一個<xref:System.Threading.Semaphore>物件代表相同具名號誌，使用建構函式或<xref:System.Threading.Semaphore.OpenExisting%2A>方法，套用存取控制安全性的 Windows。</span><span class="sxs-lookup"><span data-stu-id="e9a37-223">However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="e9a37-224">如果不存在的具名的系統號誌，則會建立初始的計數與所指定的計數上限`initialCount`和`maximumCount`。</span><span class="sxs-lookup"><span data-stu-id="e9a37-224">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="e9a37-225">如果具名的系統號誌已存在，`initialCount`和`maximumCount`未使用，雖然無效的值仍會造成例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e9a37-225">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="e9a37-226">使用`createdNew`參數，來判斷是否由這個建構函式所建立的系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-226">Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.</span></span>  
  
 <span data-ttu-id="e9a37-227">如果`initialCount`是小於`maximumCount`，並`createdNew`是`true`，效果等同視為目前的執行緒已呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>(`maximumCount`減去`initialCount`) 時間。</span><span class="sxs-lookup"><span data-stu-id="e9a37-227">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="e9a37-228">如果您指定`null`或空字串`name`，建立本機號誌，視為已呼叫<xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="e9a37-228">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="e9a37-229">在此情況下，`createdNew`總是`true`。</span><span class="sxs-lookup"><span data-stu-id="e9a37-229">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="e9a37-230">因為整個作業系統，您看不見具名號誌，它們可用來協調跨處理序界限的資源使用。</span><span class="sxs-lookup"><span data-stu-id="e9a37-230">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9a37-231">下列程式碼範例會示範具名號誌的跨處理序行為具有存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-231">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="e9a37-232">此範例會使用<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>方法多載來測試是否存在的具名號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-232">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span> <span data-ttu-id="e9a37-233">如果號誌不存在，它會建立兩個最大計數與拒絕目前的使用者使用號誌的權限，但是會授與讀取和變更號誌的權限的權限的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-233">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span> <span data-ttu-id="e9a37-234">如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-234">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="e9a37-235">攔截到例外狀況時，和此範例會使用<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>方法多載來讀取和變更的權限所需的權限開啟號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-235">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e9a37-236">權限變更之後，輸入，並釋放所需的權限開啟號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-236">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="e9a37-237">如果您從第三個 [命令] 視窗中執行編譯的範例，它會執行使用新的權限。</span><span class="sxs-lookup"><span data-stu-id="e9a37-237">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e9a37-238">
            <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-238">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="e9a37-239">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-239">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e9a37-240">
            <paramref name="maximumCount" /> is less than 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-240">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="e9a37-241">-or-  <paramref name="initialCount" /> is less than 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-241">-or-  <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e9a37-242">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-242">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e9a37-243">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-243">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="e9a37-244">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-244">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e9a37-245">呼叫 unmanaged 程式碼來建立具名的系統號誌。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-245">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="e9a37-246">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-246">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="e9a37-247">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-247">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e9a37-248">Gets the access control security for a named system semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-248">Gets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e9a37-249">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-249">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-250"><xref:System.Threading.Semaphore.GetAccessControl%2A>方法會使用下列旗標 （使用位元 OR 運算結合） 的組合來搜尋權限： <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>， <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>，和<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e9a37-250">The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="e9a37-251">使用者必須擁有<xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType>呼叫這個方法和號誌的權限必須是與開啟<xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType>權限。</span><span class="sxs-lookup"><span data-stu-id="e9a37-251">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights.</span></span>  
  
 <span data-ttu-id="e9a37-252">在本機的號誌，存取控制安全性是不相關。</span><span class="sxs-lookup"><span data-stu-id="e9a37-252">On a local semaphore, access control security is irrelevant.</span></span> <span data-ttu-id="e9a37-253">如果<xref:System.Threading.Semaphore>物件不代表具名的系統號誌，則這個方法會傳回<xref:System.Security.AccessControl.SemaphoreSecurity>授與給任何使用者的所有權限的物件。</span><span class="sxs-lookup"><span data-stu-id="e9a37-253">If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9a37-254">下列程式碼範例會示範具名號誌的跨處理序行為具有存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-254">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="e9a37-255">此範例會使用<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>方法多載來測試是否存在的具名號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-255">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-256">如果號誌不存在，它會建立兩個最大計數與拒絕目前的使用者使用的號誌的權限，但是會授與讀取和變更號誌的權限的權限的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-256">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-257">如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-257">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="e9a37-258">攔截到例外狀況時，和此範例會使用<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>方法多載來讀取和變更的權限所需的權限開啟號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-258">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span> <span data-ttu-id="e9a37-259">使用取得的系統號誌的存取控制安全性<xref:System.Threading.Semaphore.GetAccessControl%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-259">The access control security for the system semaphore is obtained using the <xref:System.Threading.Semaphore.GetAccessControl%2A> method.</span></span>  
  
 <span data-ttu-id="e9a37-260">權限變更之後，輸入，並釋放所需的權限開啟號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-260">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="e9a37-261">如果您從第三個 [命令] 視窗中執行編譯的範例，它會執行使用新的權限。</span><span class="sxs-lookup"><span data-stu-id="e9a37-261">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e9a37-262">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-262">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
          <span data-ttu-id="e9a37-263">-or-  The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-263">-or-  The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="e9a37-264">Not supported for Windows 98 or Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-264">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e9a37-265">Opens a specified named semaphore, if it already exists.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-265">Opens a specified named semaphore, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="e9a37-266">The name of the system semaphore to open.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-266">The name of the system semaphore to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e9a37-267">Opens the specified named semaphore, if it already exists.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-267">Opens the specified named semaphore, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e9a37-268">An object that represents the named system semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-268">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-269"><xref:System.Threading.Semaphore.OpenExisting%2A>方法嘗試開啟指定的具名號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-269">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore.</span></span> <span data-ttu-id="e9a37-270">如果系統號誌不存在，這個方法會擲回的例外狀況，而不是建立的系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-270">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="e9a37-271">若要建立的系統號誌，已經不存在時，使用其中一種<xref:System.Threading.Semaphore.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-271">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e9a37-272">使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Semaphore>物件，即使傳回的物件都代表相同命名系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-272">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-273">這個方法多載就相當於呼叫<xref:System.Threading.Semaphore.OpenExisting%2A>方法多載，並指定<xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。</span><span class="sxs-lookup"><span data-stu-id="e9a37-273">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="e9a37-274">指定<xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒進入號誌，並指定<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.Semaphore.Release%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-274">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9a37-275">下列程式碼範例會示範具名號誌的跨處理序行為具有存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-275">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="e9a37-276">此範例會使用<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>方法多載來測試是否存在的具名號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-276">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-277">如果號誌不存在，它會建立兩個最大計數與和拒絕的目前使用者使用的號誌的權限，但這會授與讀取和變更號誌的權限的權限的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-277">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-278">如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="e9a37-278">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload.</span></span> <span data-ttu-id="e9a37-279">攔截到例外狀況時，和此範例會使用<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>方法多載來讀取和變更的權限所需的權限開啟號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-279">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e9a37-280">權限變更之後，輸入，並釋放它所需的權限開啟號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-280">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="e9a37-281">如果您從第三個 [命令] 視窗中執行編譯的範例，它會執行使用新的權限。</span><span class="sxs-lookup"><span data-stu-id="e9a37-281">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e9a37-282">
            <paramref name="name" /> is an empty string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-282">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="e9a37-283">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-283">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e9a37-284">
            <paramref name="name" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-284">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="e9a37-285">The named semaphore does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-285">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e9a37-286">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-286">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e9a37-287">The named semaphore exists, but the user does not have the security access required to use it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-287">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e9a37-288">呼叫 unmanaged 程式碼，以開啟具名的系統號誌。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-288">for calling unmanaged code to open a named system semaphore.</span>
          </span>
          <span data-ttu-id="e9a37-289">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-289">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="e9a37-290">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-290">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="e9a37-291">The name of the system semaphore to open.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-291">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="e9a37-292">A bitwise combination of the enumeration values that represent the desired security access.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-292">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e9a37-293">Opens the specified named semaphore, if it already exists, with the desired security access.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-293">Opens the specified named semaphore, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e9a37-294">An object that represents the named system semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-294">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-295">`rights`參數必須包含<xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>旗標，好讓執行緒進入號誌，而<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.Semaphore.Release%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-295">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="e9a37-296"><xref:System.Threading.Semaphore.OpenExisting%2A>方法嘗試開啟現有的具名號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-296">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore.</span></span> <span data-ttu-id="e9a37-297">如果系統號誌不存在，這個方法會擲回的例外狀況，而不是建立的系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-297">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="e9a37-298">若要建立的系統號誌，已經不存在時，使用其中一種<xref:System.Threading.Semaphore.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-298">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e9a37-299">使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Semaphore>物件，即使傳回的物件都代表相同命名系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-299">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9a37-300">下列程式碼範例會示範具名號誌的跨處理序行為具有存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-300">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="e9a37-301">此範例會使用<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>方法多載來測試是否存在的具名號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-301">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-302">如果號誌不存在，它會建立兩個最大計數與拒絕目前的使用者使用的號誌的權限，但是會授與讀取和變更號誌的權限的權限的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-302">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-303">如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-303">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="e9a37-304">攔截到例外狀況時，和此範例會使用<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>方法多載來讀取和變更的權限所需的權限開啟號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-304">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e9a37-305">權限變更之後，輸入，並釋放它所需的權限開啟號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-305">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="e9a37-306">如果您從第三個 [命令] 視窗中執行編譯的範例，它會執行使用新的權限。</span><span class="sxs-lookup"><span data-stu-id="e9a37-306">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e9a37-307">
            <paramref name="name" /> is an empty string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-307">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="e9a37-308">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-308">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e9a37-309">
            <paramref name="name" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-309">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="e9a37-310">The named semaphore does not exist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-310">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e9a37-311">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-311">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e9a37-312">The named semaphore exists, but the user does not have the desired security access rights.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-312">The named semaphore exists, but the user does not have the desired security access rights.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e9a37-313">呼叫 unmanaged 程式碼來建立具名的系統號誌。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-313">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="e9a37-314">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-314">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="e9a37-315">安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-315">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e9a37-316">Exits the semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-316">Exits the semaphore.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="e9a37-317">Exits the semaphore and returns the previous count.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-317">Exits the semaphore and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e9a37-318">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-318">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-319">執行緒通常會使用<xref:System.Threading.WaitHandle.WaitOne%2A>通常輸入信號，而且它們的方法會使用這個方法多載來結束。</span><span class="sxs-lookup"><span data-stu-id="e9a37-319">Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.</span></span>  
  
 <span data-ttu-id="e9a37-320">如果<xref:System.Threading.SemaphoreFullException>就會擲回<xref:System.Threading.Semaphore.Release%2A>方法，它不一定表示呼叫執行緒的問題。</span><span class="sxs-lookup"><span data-stu-id="e9a37-320">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="e9a37-321">另一個執行緒中的程式設計錯誤可能會造成該執行緒結束號誌，更多的時間超出其輸入。</span><span class="sxs-lookup"><span data-stu-id="e9a37-321">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="e9a37-322">如果目前<xref:System.Threading.Semaphore>物件表示具名的系統號誌，則使用者必須擁有<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>權限和號誌必須已經開啟與<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>權限。</span><span class="sxs-lookup"><span data-stu-id="e9a37-322">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9a37-323">下列程式碼範例會建立號誌的三個最大計數與初始的計數為零。</span><span class="sxs-lookup"><span data-stu-id="e9a37-323">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="e9a37-324">此範例會啟動五個執行緒，封鎖等候號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-324">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="e9a37-325">主要執行緒使用<xref:System.Threading.Semaphore.Release%28System.Int32%29>方法多載來增加為最大值，允許三個執行緒進入號誌的號誌計數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-325">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="e9a37-326">每個執行緒會使用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法等候 1 秒，以模擬工作，然後呼叫<xref:System.Threading.Semaphore.Release>方法多載來釋放號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-326">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-327">已釋放號誌，每次會顯示先前的號誌計數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-327">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="e9a37-328">主控台訊息追蹤號誌的使用。</span><span class="sxs-lookup"><span data-stu-id="e9a37-328">Console messages track semaphore use.</span></span> <span data-ttu-id="e9a37-329">模擬的工作間隔會稍微增加，每個執行緒，以讓輸出更容易閱讀。</span><span class="sxs-lookup"><span data-stu-id="e9a37-329">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="e9a37-330">The semaphore count is already at the maximum value.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-330">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e9a37-331">A Win32 error occurred with a named semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-331">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e9a37-332">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-332">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
          <span data-ttu-id="e9a37-333">-or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-333">-or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">
          <span data-ttu-id="e9a37-334">The number of times to exit the semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-334">The number of times to exit the semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e9a37-335">Exits the semaphore a specified number of times and returns the previous count.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-335">Exits the semaphore a specified number of times and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e9a37-336">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-336">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-337">如果執行緒已多次進入號誌，則這個方法多載可讓與某個呼叫還原整個的號誌計數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-337">If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</span></span>  
  
 <span data-ttu-id="e9a37-338">如果<xref:System.Threading.SemaphoreFullException>就會擲回<xref:System.Threading.Semaphore.Release%2A>方法，它不一定表示呼叫執行緒的問題。</span><span class="sxs-lookup"><span data-stu-id="e9a37-338">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="e9a37-339">另一個執行緒中的程式設計錯誤可能會造成該執行緒結束號誌，更多的時間超出其輸入。</span><span class="sxs-lookup"><span data-stu-id="e9a37-339">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="e9a37-340">如果目前<xref:System.Threading.Semaphore>物件表示具名的系統號誌，則使用者必須擁有<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>權限和號誌必須已經開啟與<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>權限。</span><span class="sxs-lookup"><span data-stu-id="e9a37-340">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9a37-341">下列程式碼範例會建立號誌的三個最大計數與初始的計數為零。</span><span class="sxs-lookup"><span data-stu-id="e9a37-341">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="e9a37-342">此範例會啟動五個執行緒，封鎖等候號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-342">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="e9a37-343">主要執行緒使用<xref:System.Threading.Semaphore.Release%28System.Int32%29>方法多載來增加為最大值，允許三個執行緒進入號誌的號誌計數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-343">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="e9a37-344">每個執行緒會使用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法等候 1 秒，以模擬工作，然後呼叫<xref:System.Threading.Semaphore.Release>方法多載來釋放號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-344">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-345">已釋放號誌，每次會顯示先前的號誌計數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-345">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="e9a37-346">主控台訊息追蹤號誌的使用。</span><span class="sxs-lookup"><span data-stu-id="e9a37-346">Console messages track semaphore use.</span></span> <span data-ttu-id="e9a37-347">模擬的工作間隔會稍微增加，每個執行緒，以讓輸出更容易閱讀。</span><span class="sxs-lookup"><span data-stu-id="e9a37-347">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e9a37-348">
            <paramref name="releaseCount" /> is less than 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-348">
              <paramref name="releaseCount" /> is less than 1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="e9a37-349">The semaphore count is already at the maximum value.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-349">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e9a37-350">A Win32 error occurred with a named semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-350">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e9a37-351">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-351">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
          <span data-ttu-id="e9a37-352">-or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-352">-or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">
          <span data-ttu-id="e9a37-353">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-353">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e9a37-354">Sets the access control security for a named system semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-354">Sets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-355">您可以只上設定存取控制安全性<xref:System.Threading.Semaphore>代表具名的系統號誌的物件。</span><span class="sxs-lookup"><span data-stu-id="e9a37-355">You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.</span></span>  
  
 <span data-ttu-id="e9a37-356">使用者必須擁有<xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType>呼叫這個方法和號誌的權限必須是與開啟<xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType>權限。</span><span class="sxs-lookup"><span data-stu-id="e9a37-356">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9a37-357">下列程式碼範例會示範具名號誌的跨處理序行為具有存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-357">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="e9a37-358">此範例會使用<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>方法多載來測試是否存在的具名號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-358">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-359">如果號誌不存在，它會建立兩個最大計數與拒絕目前的使用者使用號誌的權限，但是會授與讀取和變更號誌的權限的權限的存取控制安全性。</span><span class="sxs-lookup"><span data-stu-id="e9a37-359">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="e9a37-360">如果您從兩個命令視窗中執行編譯的範例，第二個複本將會擲回存取違規例外狀況呼叫<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-360">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="e9a37-361">攔截到例外狀況時，和此範例會使用<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>方法多載來讀取和變更的權限所需的權限開啟號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-361">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="e9a37-362">變更權限，使用後<xref:System.Threading.Semaphore.SetAccessControl%2A>來輸入，並釋放所需的權限開啟號誌的方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-362">After the permissions are changed, using the <xref:System.Threading.Semaphore.SetAccessControl%2A> method, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="e9a37-363">如果您從第三個 [命令] 視窗中執行編譯的範例，它會執行使用新的權限。</span><span class="sxs-lookup"><span data-stu-id="e9a37-363">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e9a37-364">
            <paramref name="semaphoreSecurity" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-364">
              <paramref name="semaphoreSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e9a37-365">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-365">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
          <span data-ttu-id="e9a37-366">-or-  The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-366">-or-  The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="e9a37-367">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-367">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e9a37-368">Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-368">Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="e9a37-369">The name of the system semaphore to open.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-369">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="e9a37-370">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-370">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="e9a37-371">This parameter is treated as uninitialized.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-371">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e9a37-372">Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-372">Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e9a37-373">
            <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-373">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-374">如果具名號誌不存在，這個方法不會建立它。</span><span class="sxs-lookup"><span data-stu-id="e9a37-374">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="e9a37-375">若要建立的系統號誌，已經不存在時，使用其中一種<xref:System.Threading.Semaphore.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-375">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e9a37-376">如果您不確定是否存在的具名號誌，使用這個方法多載，而不是<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>方法多載，則會擲回例外狀況，如果號誌不存在。</span><span class="sxs-lookup"><span data-stu-id="e9a37-376">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="e9a37-377">這個方法多載就相當於呼叫<xref:System.Threading.Semaphore.TryOpenExisting%2A>方法多載，並指定<xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>和<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>權限，使用位元 OR 運算結合。</span><span class="sxs-lookup"><span data-stu-id="e9a37-377">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="e9a37-378">指定<xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>旗標可讓執行緒進入號誌，並指定<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>旗標可讓呼叫執行緒<xref:System.Threading.Semaphore.Release%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-378">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e9a37-379">
            <paramref name="name" /> is an empty string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-379">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="e9a37-380">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-380">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e9a37-381">
            <paramref name="name" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-381">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e9a37-382">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-382">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e9a37-383">The named semaphore exists, but the user does not have the security access required to use it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-383">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="e9a37-384">The name of the system semaphore to open.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-384">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="e9a37-385">A bitwise combination of the enumeration values that represent the desired security access.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-385">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="e9a37-386">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-386">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="e9a37-387">This parameter is treated as uninitialized.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-387">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e9a37-388">Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-388">Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e9a37-389">
            <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-389">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9a37-390">如果具名號誌不存在，這個方法不會建立它。</span><span class="sxs-lookup"><span data-stu-id="e9a37-390">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="e9a37-391">若要建立的系統號誌，已經不存在時，使用其中一種<xref:System.Threading.Semaphore.%23ctor%2A>建構函式具有`name`參數。</span><span class="sxs-lookup"><span data-stu-id="e9a37-391">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="e9a37-392">如果您不確定是否存在的具名號誌，使用這個方法多載，而不是<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>方法多載，則會擲回例外狀況，如果號誌不存在。</span><span class="sxs-lookup"><span data-stu-id="e9a37-392">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="e9a37-393">`rights`參數必須包含<xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>旗標，好讓執行緒進入號誌，而<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>旗標以允許呼叫的執行緒<xref:System.Threading.Semaphore.Release%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="e9a37-393">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="e9a37-394">使用相同的值，這個方法的多次呼叫`name`不一定會傳回相同<xref:System.Threading.Semaphore>物件，即使傳回的物件都代表相同命名系統號誌。</span><span class="sxs-lookup"><span data-stu-id="e9a37-394">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="e9a37-395">
            <paramref name="name" /> is an empty string.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-395">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="e9a37-396">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-396">-or-  <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e9a37-397">
            <paramref name="name" /> is <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-397">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="e9a37-398">A Win32 error occurred.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-398">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="e9a37-399">The named semaphore exists, but the user does not have the security access required to use it.</span>
          <span class="sxs-lookup">
            <span data-stu-id="e9a37-399">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>