<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fd2bf7c62b10f302d95d138e19563c498a74ec5a" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52219340" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="09ed2-101">可建立和控制執行緒，設定執行緒的優先權，並取得它的狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-101">Creates and controls a thread, sets its priority, and gets its status.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-102">當處理程序啟動時，common language runtime 會自動建立單一的前景執行緒來執行應用程式程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="09ed2-103">這個主要的前景執行緒，以及處理程序可以建立一或多個執行緒來執行此程序相關聯的程式碼的一部分。</span><span class="sxs-lookup"><span data-stu-id="09ed2-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="09ed2-104">這些執行緒可以執行在前景或背景。</span><span class="sxs-lookup"><span data-stu-id="09ed2-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="09ed2-105">此外，您可以使用<xref:System.Threading.ThreadPool>common language runtime 所管理的背景工作執行緒上執行程式碼的類別。</span><span class="sxs-lookup"><span data-stu-id="09ed2-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="09ed2-106">本節內容</span><span class="sxs-lookup"><span data-stu-id="09ed2-106">In this section</span></span>  
  
 <span data-ttu-id="09ed2-107">[正在啟動的執行緒](#Starting) </span><span class="sxs-lookup"><span data-stu-id="09ed2-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="09ed2-108">[擷取執行緒物件](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="09ed2-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="09ed2-109">[前景和背景執行緒](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="09ed2-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="09ed2-110">[文化特性和執行緒](#Culture) </span><span class="sxs-lookup"><span data-stu-id="09ed2-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="09ed2-111">取得相關資訊和控制執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="09ed2-112">正在啟動的執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-112">Starting a thread</span></span>  
 <span data-ttu-id="09ed2-113">您可以啟動執行緒藉由提供委派，表示執行緒會在其類別建構函式中執行的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="09ed2-114">然後呼叫<xref:System.Threading.Thread.Start%2A>方法，開始執行。</span><span class="sxs-lookup"><span data-stu-id="09ed2-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="09ed2-115"><xref:System.Threading.Thread>建構函式可以採用兩個委派類型，取決於是否將引數傳遞至方法，以執行：</span><span class="sxs-lookup"><span data-stu-id="09ed2-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="09ed2-116">如果方法沒有引數，傳遞<xref:System.Threading.ThreadStart>委派建構函式。</span><span class="sxs-lookup"><span data-stu-id="09ed2-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="09ed2-117">其簽章：</span><span class="sxs-lookup"><span data-stu-id="09ed2-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="09ed2-118">下列範例會建立並啟動執行的執行緒`ExecuteInForeground`方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="09ed2-119">方法會顯示某些執行緒屬性的相關資訊，然後執行的迴圈，在其中方法，它可以半秒就會暫停，並顯示經過的秒數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="09ed2-120">當執行緒已執行至少 5 秒時，迴圈結束，執行緒會結束執行。</span><span class="sxs-lookup"><span data-stu-id="09ed2-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="09ed2-121">如果方法沒有引數，傳遞<xref:System.Threading.ParameterizedThreadStart>委派建構函式。</span><span class="sxs-lookup"><span data-stu-id="09ed2-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="09ed2-122">其簽章：</span><span class="sxs-lookup"><span data-stu-id="09ed2-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="09ed2-123">然後委派所執行的方法可以轉型 （在 C# 中)，或者 （在 Visual Basic) 將參數轉換成適當的類型。</span><span class="sxs-lookup"><span data-stu-id="09ed2-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="09ed2-124">下列範例等同於前一個位置，不同之處在於它會呼叫<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="09ed2-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="09ed2-125">這個版本的`ExecuteInForeground`方法具有單一參數，表示迴圈是要執行的毫秒數的近似數目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="09ed2-126">您不需要保留的參考<xref:System.Threading.Thread>物件啟動執行緒之後。</span><span class="sxs-lookup"><span data-stu-id="09ed2-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="09ed2-127">執行緒會繼續執行直到執行緒程序完成。</span><span class="sxs-lookup"><span data-stu-id="09ed2-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="09ed2-128">擷取執行緒物件</span><span class="sxs-lookup"><span data-stu-id="09ed2-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="09ed2-129">您可以使用靜態 (`Shared`在 Visual Basic 中)<xref:System.Threading.Thread.CurrentThread%2A>屬性來擷取目前執行中執行緒的執行緒正在執行的程式碼的參考。</span><span class="sxs-lookup"><span data-stu-id="09ed2-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="09ed2-130">下列範例會使用<xref:System.Threading.Thread.CurrentThread%2A>屬性來顯示主應用程式執行緒、 另一個前景執行緒，背景執行緒，以及執行緒集區執行緒相關資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="09ed2-131">前景和背景執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-131">Foreground and background threads</span></span>  
 <span data-ttu-id="09ed2-132">執行個體<xref:System.Threading.Thread>類別代表前景執行緒或背景執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="09ed2-133">背景執行緒會與相同前景執行緒有一個例外狀況： 在背景執行緒不會保存執行的處理序，如果所有前景執行緒已經都終止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="09ed2-134">一旦所有前景執行緒已都停止，則執行階段會停止所有背景執行緒，並關閉。</span><span class="sxs-lookup"><span data-stu-id="09ed2-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="09ed2-135">根據預設，下列執行緒會在前景中執行：</span><span class="sxs-lookup"><span data-stu-id="09ed2-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="09ed2-136">主要的應用程式執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="09ed2-137">藉由呼叫所建立的所有執行緒<xref:System.Threading.Thread>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="09ed2-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="09ed2-138">根據預設，在背景中執行下列的執行緒：</span><span class="sxs-lookup"><span data-stu-id="09ed2-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="09ed2-139">執行緒集區執行緒，也就是由執行階段所維護的背景工作執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="09ed2-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="09ed2-140">您也可以使用執行緒集區執行緒上設定執行緒集區和排程工作<xref:System.Threading.ThreadPool>類別。</span><span class="sxs-lookup"><span data-stu-id="09ed2-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="09ed2-141">在執行緒集區執行緒上自動執行工作為基礎的非同步作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="09ed2-142">使用以工作為基礎的非同步作業<xref:System.Threading.Tasks.Task>並<xref:System.Threading.Tasks.Task%601>類別來實作[工作架構非同步模式](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="09ed2-143">從 unmanaged 程式碼來進入 managed 的執行環境的所有執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="09ed2-144">您可以變更執行緒在背景中執行，藉由設定<xref:System.Threading.Thread.IsBackground%2A>在任何時間的屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="09ed2-145">背景執行緒可用於任何作業，只要應用程式正在執行，但應該不會防止終止，例如監視檔案系統變更或傳入的通訊端連線應用程式應該繼續。</span><span class="sxs-lookup"><span data-stu-id="09ed2-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="09ed2-146">下列範例說明前景和背景執行緒之間的差異。</span><span class="sxs-lookup"><span data-stu-id="09ed2-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="09ed2-147">就像中的第一個範例一樣[正在啟動的執行緒](#Starting)區段中，不同之處在於它會設定要在背景啟動前先執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="09ed2-148">如輸出所示，然後才執行五秒將會中斷迴圈。</span><span class="sxs-lookup"><span data-stu-id="09ed2-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="09ed2-149">文化特性和執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-149">Culture and threads</span></span>  
 <span data-ttu-id="09ed2-150">每個執行緒都所代表文化特性<xref:System.Threading.Thread.CurrentCulture%2A>屬性和 UI 文化特性，以表示<xref:System.Threading.Thread.CurrentUICulture%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="09ed2-151">目前的文化特性支援剖析和格式化、 字串比較和排序，這種區分文化特性的作業，而且也會控制執行緒所使用的行事曆與書寫系統。</span><span class="sxs-lookup"><span data-stu-id="09ed2-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="09ed2-152">目前的 UI 文化特性提供區分文化特性擷取資源檔中的資源。</span><span class="sxs-lookup"><span data-stu-id="09ed2-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="09ed2-153"><xref:System.Threading.Thread.CurrentCulture>和<xref:System.Threading.Thread.CurrentUICulture>屬性無法可靠地運作，搭配目前的執行緒以外的任何執行緒時。</span><span class="sxs-lookup"><span data-stu-id="09ed2-153">The <xref:System.Threading.Thread.CurrentCulture> and <xref:System.Threading.Thread.CurrentUICulture> properties don't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="09ed2-154">在.NET Framework 中，讀取這些屬性是可靠的但不設定這些屬性目前的執行緒以外的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-154">In .NET Framework, reading these properties is reliable, although setting these properties for a thread other than the current thread is not.</span></span> <span data-ttu-id="09ed2-155">在.NET Core 上<xref:System.InvalidOperationException>如果執行緒嘗試讀取或寫入這些屬性在不同的執行緒上擲回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-155">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write these properties on a different thread.</span></span>
> <span data-ttu-id="09ed2-156">我們建議您改用<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType>和<xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType>屬性，以擷取和設定目前的文化特性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-156">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> properties to retrieve and set the current culture.</span></span>

 <span data-ttu-id="09ed2-157">具現化新的執行緒時，其文化特性和 UI 文化特性定義的目前系統文化特性和 UI 文化特性，而不是文化特性和 UI 文化特性，從中建立新的執行緒的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-157">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="09ed2-158">這表示，例如，如果目前的系統文化特性是英文 （美國） 和主要應用程式執行緒的目前文化特性是法文 （法國），藉由呼叫所建立的新執行緒的文化特性<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>從主執行緒的建構函式英文 （美國） 和法文 （法國）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-158">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="09ed2-159">如需詳細資訊，請參閱的 < 文化特性和執行緒 」 區段<xref:System.Globalization.CultureInfo>類別主題。</span><span class="sxs-lookup"><span data-stu-id="09ed2-159">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="09ed2-160">這不是執行非同步作業的應用程式為目標的執行緒，則為 true[!INCLUDE[net_v46](~/includes/net-v46-md.md)]和更新版本中的，在此情況下，文化特性和 UI 文化特性是一部分的非同步作業的內容; 的執行緒上非同步作業執行預設繼承的文化特性和 UI 文化特性，從中啟動非同步作業的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-160">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="09ed2-161">如需詳細資訊，請參閱 <xref:System.Globalization.CultureInfo> 類別主題的＜文化特性和以工作為基礎的非同步作業＞一節。</span><span class="sxs-lookup"><span data-stu-id="09ed2-161">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="09ed2-162">您可以執行下列動作，以確保所有的執行緒執行的應用程式中共用相同的文化特性和 UI 文化特性：</span><span class="sxs-lookup"><span data-stu-id="09ed2-162">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="09ed2-163">您可以傳遞<xref:System.Globalization.CultureInfo>物件，表示該文化特性<xref:System.Threading.ParameterizedThreadStart>委派或<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-163">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="09ed2-164">在上執行的應用程式[!INCLUDE[net_v45](~/includes/net-v45-md.md)]和更新版本中，您可以定義要指派給所設定的值建立應用程式定義域中的所有執行緒 UI 文化特性與文化特性<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-164">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="09ed2-165">請注意，這是每個應用程式定義域的設定。</span><span class="sxs-lookup"><span data-stu-id="09ed2-165">Note that this is a per-application domain setting.</span></span>  

 <span data-ttu-id="09ed2-166">如需詳細資訊和範例，請參閱 「 文化特性和執行緒 > 一節<xref:System.Globalization.CultureInfo>類別主題。</span><span class="sxs-lookup"><span data-stu-id="09ed2-166">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="09ed2-167">取得相關資訊和控制執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-167">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="09ed2-168">您可以擷取提供執行緒的相關資訊的屬性值的數目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-168">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="09ed2-169">在某些情況下，您也可以設定這些屬性值，來控制執行緒的作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-169">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="09ed2-170">這些執行緒屬性包括：</span><span class="sxs-lookup"><span data-stu-id="09ed2-170">These thread properties include:</span></span>  
  
-   <span data-ttu-id="09ed2-171">名稱。</span><span class="sxs-lookup"><span data-stu-id="09ed2-171">A name.</span></span> <span data-ttu-id="09ed2-172"><xref:System.Threading.Thread.Name%2A> 已寫入-一次您可用來識別在執行緒中的屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-172"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="09ed2-173">其預設值是`null`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-173">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="09ed2-174">雜湊程式碼，您可以藉由呼叫擷取<xref:System.Threading.Thread.GetHashCode%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-174">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="09ed2-175">雜湊程式碼可以用來唯一識別執行緒;您的執行緒的存留期內，其雜湊程式碼不將與來自其他執行緒，不論您要從中取得值的應用程式定義域的值相衝突。</span><span class="sxs-lookup"><span data-stu-id="09ed2-175">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="09ed2-176">執行緒 id。</span><span class="sxs-lookup"><span data-stu-id="09ed2-176">A thread ID.</span></span> <span data-ttu-id="09ed2-177">唯讀值<xref:System.Threading.Thread.ManagedThreadId%2A>屬性由執行階段所指派，以及可唯一識別其處理序內的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-177">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="09ed2-178">作業系統的 [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) 與 Managed 執行緒之間沒有固定的關係，因為未受管理的主機可控制 Managed 執行緒與 Unmanaged 執行緒之間的關係。</span><span class="sxs-lookup"><span data-stu-id="09ed2-178">An operating-system [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="09ed2-179">具體來說，精密的主機可以使用[CLR 裝載 API](https://msdn.microsoft.com/library/ms404385.aspx)排程許多 managed 的執行緒，對相同的作業系統執行緒，或不同的作業系統執行緒之間移動 managed 的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-179">Specifically, a sophisticated host can use the [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="09ed2-180">執行緒的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-180">The thread's current state.</span></span> <span data-ttu-id="09ed2-181">其存在期間，執行緒一律是在一或多個定義的狀態<xref:System.Threading.ThreadState>屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-181">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="09ed2-182">排程的優先權層級，可定義<xref:System.Threading.ThreadPriority>屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-182">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="09ed2-183">雖然您可以設定此值，以要求執行緒的優先權，它不保證適用於作業系統。</span><span class="sxs-lookup"><span data-stu-id="09ed2-183">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="09ed2-184">唯讀<xref:System.Threading.Thread.IsThreadPoolThread%2A>屬性，指出執行緒是否在執行緒集區執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-184">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="09ed2-185"><xref:System.Threading.Thread.IsBackground%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-185">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="09ed2-186">如需詳細資訊，請參閱 <<c0> [ 前景和背景執行緒](#Foreground)一節。</span><span class="sxs-lookup"><span data-stu-id="09ed2-186">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="09ed2-187">下列範例示範簡單的執行緒處理功能。</span><span class="sxs-lookup"><span data-stu-id="09ed2-187">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="09ed2-188">此程式碼會產生類似下列的輸出：</span><span class="sxs-lookup"><span data-stu-id="09ed2-188">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="09ed2-189">此型別具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="09ed2-189">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="09ed2-190">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-190">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="09ed2-191">使用執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-191">Using Threads and Threading</span></span></related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96"><span data-ttu-id="09ed2-192">執行緒類別的參考來源</span><span class="sxs-lookup"><span data-stu-id="09ed2-192">Reference Source for the Thread Class</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="09ed2-193">初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-193">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="09ed2-194">委派，代表在這個執行緒開始執行時要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-194">A delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="09ed2-195">初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體，並指定委派，讓物件可以在執行緒啟動時傳遞到執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-195">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-196">執行緒不會開始執行時建立。</span><span class="sxs-lookup"><span data-stu-id="09ed2-196">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="09ed2-197">若要排程執行的執行緒，呼叫<xref:System.Threading.Thread.Start%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-197">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="09ed2-198">若要將資料物件傳遞給執行緒中，使用<xref:System.Threading.Thread.Start%28System.Object%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="09ed2-198">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-199">Visual Basic 使用者可以省略<xref:System.Threading.ThreadStart>建構函式建立執行緒時。</span><span class="sxs-lookup"><span data-stu-id="09ed2-199">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="09ed2-200">使用`AddressOf`運算子時傳遞您的方法，例如`Dim t As New Thread(AddressOf ThreadProc)`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-200">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="09ed2-201">Visual Basic 會自動呼叫<xref:System.Threading.ThreadStart>建構函式。</span><span class="sxs-lookup"><span data-stu-id="09ed2-201">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-202">下列範例顯示建立和使用的語法<xref:System.Threading.ParameterizedThreadStart>的靜態方法與執行個體方法的委派。</span><span class="sxs-lookup"><span data-stu-id="09ed2-202">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="09ed2-203"><paramref name="start" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-203"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="09ed2-204">建立執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-204">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="09ed2-205"><see cref="T:System.Threading.ThreadStart" /> 委派，代表在這個執行緒開始執行時要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-205">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="09ed2-206">初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-206">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-207">執行緒不會開始執行時建立。</span><span class="sxs-lookup"><span data-stu-id="09ed2-207">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="09ed2-208">若要排程執行的執行緒，呼叫<xref:System.Threading.Thread.Start%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-208">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-209">Visual Basic 使用者可以省略<xref:System.Threading.ThreadStart>建構函式建立執行緒時。</span><span class="sxs-lookup"><span data-stu-id="09ed2-209">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="09ed2-210">使用`AddressOf`運算子，例如傳遞方法時`Dim t As New Thread(AddressOf ThreadProc)`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-210">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="09ed2-211">Visual Basic 會自動呼叫<xref:System.Threading.ThreadStart>建構函式。</span><span class="sxs-lookup"><span data-stu-id="09ed2-211">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-212">下列程式碼範例示範如何建立執行的靜態方法的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-212">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="09ed2-213">下列程式碼範例示範如何建立執行執行個體方法的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-213">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="09ed2-214"><paramref name="start" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-214">The <paramref name="start" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="09ed2-215">建立執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-215">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="09ed2-216"><see cref="T:System.Threading.ParameterizedThreadStart" /> 委派，代表在這個執行緒開始執行時要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-216">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="09ed2-217">執行緒使用的最大堆疊大小 (以位元組為單位)，或是 0，使用可執行檔標頭中指定的預設最大堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="09ed2-217">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="09ed2-218">重要資訊：對於部分信任的程式碼，如果 <paramref name="maxStackSize" /> 大於預設堆疊大小，則會加以忽略。</span><span class="sxs-lookup"><span data-stu-id="09ed2-218">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="09ed2-219">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-219">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="09ed2-220">初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體，指定委派，讓物件可以在執行緒啟動時傳遞到執行緒，並指定執行緒的堆疊大小上限。</span><span class="sxs-lookup"><span data-stu-id="09ed2-220">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-221">請避免使用這個建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="09ed2-221">Avoid using this constructor overload.</span></span> <span data-ttu-id="09ed2-222">所使用的預設堆疊大小<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>建構函式多載是建議的堆疊大小的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-222">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="09ed2-223">如果執行緒發生記憶體問題，最可能的原因程式設計錯誤，例如無限遞迴。</span><span class="sxs-lookup"><span data-stu-id="09ed2-223">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="09ed2-224">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，只有完全受信任的程式碼可以設定`maxStackSize`大於預設堆疊大小 (1 mb) 的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-224">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="09ed2-225">如果指定較大的值`maxStackSize`以部分信任，請在執行程式碼時`maxStackSize`會被忽略，而且是預設的堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="09ed2-225">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="09ed2-226">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-226">No exception is thrown.</span></span> <span data-ttu-id="09ed2-227">在任何信任層級的程式碼可以設定`maxStackSize`小於預設堆疊大小的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-227">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-228">如果您正在開發的完全受信任的程式庫，可供部分信任的程式碼，而您需要啟動執行緒需要大型的堆疊，您必須先建立執行緒，判斷提示完全信任或將使用預設堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="09ed2-228">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="09ed2-229">請不要這樣除非您完全控制的執行緒執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-229">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="09ed2-230">如果`maxStackSize`小於最小的堆疊大小，比使用的最小的堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="09ed2-230">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="09ed2-231">如果`maxStackSize`不多的頁面大小，則會四捨五入到的頁面大小的下一個較大倍數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-231">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="09ed2-232">比方說，如果您在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262,144 個位元組） 是最小的堆疊大小和頁面大小為 64 KB （65536 個位元組）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-232">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-233">Microsoft Windows Windows XP 和 Windows Server 2003 之前的版本上`maxStackSize`會被忽略，並使用時可執行檔的標頭中指定的堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="09ed2-233">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="09ed2-234">如果您指定非常小的堆疊大小，您可能需要停用堆疊探查。</span><span class="sxs-lookup"><span data-stu-id="09ed2-234">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="09ed2-235">在堆疊嚴重受限，探查可以本身可能會造成堆疊溢位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-235">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="09ed2-236">若要停用堆疊探查，將下列加入您的應用程式組態檔。</span><span class="sxs-lookup"><span data-stu-id="09ed2-236">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="09ed2-237"><paramref name="start" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-237"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="09ed2-238"><paramref name="maxStackSize" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="09ed2-238"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="09ed2-239"><see cref="T:System.Threading.ThreadStart" /> 委派，代表在這個執行緒開始執行時要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-239">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="09ed2-240">執行緒使用的最大堆疊大小 (以位元組為單位)，或是 0，使用可執行檔標頭中指定的預設最大堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="09ed2-240">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="09ed2-241">重要資訊：對於部分信任的程式碼，如果 <paramref name="maxStackSize" /> 大於預設堆疊大小，則會加以忽略。</span><span class="sxs-lookup"><span data-stu-id="09ed2-241">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="09ed2-242">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-242">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="09ed2-243">初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體，並指定執行緒的堆疊大小上限。</span><span class="sxs-lookup"><span data-stu-id="09ed2-243">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-244">請避免使用這個建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="09ed2-244">Avoid using this constructor overload.</span></span> <span data-ttu-id="09ed2-245">所使用的預設堆疊大小<xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>建構函式多載是建議的堆疊大小的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-245">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="09ed2-246">如果執行緒發生記憶體問題，最可能的原因程式設計錯誤，例如無限遞迴。</span><span class="sxs-lookup"><span data-stu-id="09ed2-246">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="09ed2-247">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，只有完全受信任的程式碼可以設定`maxStackSize`大於預設堆疊大小 (1 mb) 的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-247">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="09ed2-248">如果指定較大的值`maxStackSize`以部分信任，請在執行程式碼時`maxStackSize`會被忽略，而且是預設的堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="09ed2-248">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="09ed2-249">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-249">No exception is thrown.</span></span> <span data-ttu-id="09ed2-250">在任何信任層級的程式碼可以設定`maxStackSize`小於預設堆疊大小的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-250">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-251">如果您正在開發的完全受信任的程式庫，可供部分信任的程式碼，而您需要啟動執行緒需要大型的堆疊，您必須先建立執行緒，判斷提示完全信任或將使用預設堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="09ed2-251">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="09ed2-252">請不要這樣除非您完全控制的執行緒執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-252">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="09ed2-253">如果`maxStackSize`小於最小的堆疊大小，比使用的最小的堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="09ed2-253">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="09ed2-254">如果`maxStackSize`不多的頁面大小，則會四捨五入到的頁面大小的下一個較大倍數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-254">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="09ed2-255">比方說，如果您在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262,144 個位元組） 是最小的堆疊大小和頁面大小為 64 KB （65536 個位元組）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-255">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-256">Microsoft Windows Windows XP 和 Windows Server 2003 之前的版本上`maxStackSize`會被忽略，並使用時可執行檔的標頭中指定的堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="09ed2-256">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="09ed2-257">如果您指定非常小的堆疊大小，您可能需要停用堆疊探查。</span><span class="sxs-lookup"><span data-stu-id="09ed2-257">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="09ed2-258">在堆疊嚴重受限，探查可以本身可能會造成堆疊溢位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-258">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="09ed2-259">若要停用堆疊探查，將下列加入您的應用程式組態檔。</span><span class="sxs-lookup"><span data-stu-id="09ed2-259">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="09ed2-260"><paramref name="start" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-260"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="09ed2-261"><paramref name="maxStackSize" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="09ed2-261"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="09ed2-262">於被叫用的所在執行緒中引發 <see cref="T:System.Threading.ThreadAbortException" />，開始處理執行緒的結束作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-262">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="09ed2-263">呼叫這個方法通常會結束執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-263">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="09ed2-264">`Thread.Abort`方法應該謹慎使用。</span><span class="sxs-lookup"><span data-stu-id="09ed2-264">The `Thread.Abort` method should be used with caution.</span></span> <span data-ttu-id="09ed2-265">特別是當您呼叫以中止目前的執行緒以外的執行緒，您不知道哪些程式碼已執行或失敗時，要執行<xref:System.Threading.ThreadAbortException>擲回時，也不可以是特定的應用程式的狀態或任何應用程式和使用者狀態負責保留。</span><span class="sxs-lookup"><span data-stu-id="09ed2-265">Particularly when you call it to abort a thread other than the current thread, you do not know what code has executed or failed to execute when the <xref:System.Threading.ThreadAbortException> is thrown, nor can you be certain of the state of your application or any application and user state that it is responsible for preserving.</span></span> <span data-ttu-id="09ed2-266">例如，呼叫`Thread.Abort`可能防止執行靜態建構函式或免除的 unmanaged 資源釋放。</span><span class="sxs-lookup"><span data-stu-id="09ed2-266">For example, calling `Thread.Abort` may prevent static constructors from executing or prevent the release of unmanaged resources.</span></span> 
>
> <span data-ttu-id="09ed2-267">請注意，`Thread.Abort`在.NET Core 上不支援方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-267">Note that the `Thread.Abort` method is not supported on .NET Core.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-268">於被叫用的所在執行緒中引發 <see cref="T:System.Threading.ThreadAbortException" />，開始處理執行緒的結束作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-268">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="09ed2-269">呼叫這個方法通常會結束執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-269">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-270">在執行緒上叫用這個方法時，系統會擲回<xref:System.Threading.ThreadAbortException>中將它中止執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-270">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="09ed2-271">`ThreadAbortException` 是特殊的應用程式程式碼，就可以攔截的例外狀況，但會在結尾處重新擲回`catch`封鎖除非<xref:System.Threading.Thread.ResetAbort%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="09ed2-271">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="09ed2-272">`ResetAbort` 取消要求中止，並防止`ThreadAbortException`無法終止執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-272">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="09ed2-273">未執行`finally`區塊會執行已中止的執行緒之前。</span><span class="sxs-lookup"><span data-stu-id="09ed2-273">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-274">當執行緒呼叫`Abort`本身，效果會類似於擲回例外狀況;<xref:System.Threading.ThreadAbortException>時會立即，且結果為可預測。</span><span class="sxs-lookup"><span data-stu-id="09ed2-274">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="09ed2-275">不過，如果一個執行緒呼叫`Abort`另一個執行緒中止會中斷任何程式碼執行。</span><span class="sxs-lookup"><span data-stu-id="09ed2-275">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="09ed2-276">此外，也有可能已中止的靜態建構函式的機會。</span><span class="sxs-lookup"><span data-stu-id="09ed2-276">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="09ed2-277">在罕見的情況下，這可能導致無法建立應用程式定義域中的該類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-277">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="09ed2-278">在.NET framework 1.0 和 1.1 版中，很有可能在中止執行緒時`finally`執行的區塊，在此情況下`finally`區塊就會中止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-278">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="09ed2-279">不保證立即執行，或完全中止執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-279">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="09ed2-280">如果執行緒沒有無限量的空間中的計算，可能會發生這種情況下`finally`區塊呼叫中止程序，藉此無限期延遲中止的一部分。</span><span class="sxs-lookup"><span data-stu-id="09ed2-280">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="09ed2-281">若要等候，直到執行緒已經中止，您可以呼叫<xref:System.Threading.Thread.Join%2A>方法之後呼叫的執行緒上<xref:System.Threading.Thread.Abort%2A>方法，但不保證會結束等待。</span><span class="sxs-lookup"><span data-stu-id="09ed2-281">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-282">呼叫的執行緒<xref:System.Threading.Thread.Abort%2A>是否正在中止的執行緒在受保護的程式碼區域，例如，可能會封鎖`catch`區塊中，`finally`區塊或限制的執行區域。</span><span class="sxs-lookup"><span data-stu-id="09ed2-282">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="09ed2-283">如果執行緒呼叫<xref:System.Threading.Thread.Abort%2A>掌握需要中止的執行緒，便會發生死結的鎖定。</span><span class="sxs-lookup"><span data-stu-id="09ed2-283">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="09ed2-284">如果`Abort`稱為尚未啟動執行緒的執行緒將會中止時<xref:System.Threading.Thread.Start%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="09ed2-284">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="09ed2-285">如果`Abort`呼叫會封鎖或睡眠中的執行緒上的執行緒中斷，然後中止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-285">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="09ed2-286">如果`Abort`已暫停的執行緒上呼叫<xref:System.Threading.ThreadStateException>呼叫的執行緒中擲回<xref:System.Threading.Thread.Abort%2A>，以及<xref:System.Threading.ThreadState.AbortRequested>新增至<xref:System.Threading.Thread.ThreadState%2A>正在中止的執行緒屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-286">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="09ed2-287">A<xref:System.Threading.ThreadAbortException>不會擲回在暫止的執行緒，直到<xref:System.Threading.Thread.Resume%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="09ed2-287">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="09ed2-288">如果`Abort`執行 unmanaged 程式碼時，會將受管理的執行緒上呼叫`ThreadAbortException`直到執行緒返回受控碼不會擲回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-288">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="09ed2-289">如果兩個呼叫來`Abort`出現在此同時，就可以一次呼叫設定的狀態資訊和其他執行的呼叫`Abort`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-289">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="09ed2-290">不過，應用程式無法偵測這種情況。</span><span class="sxs-lookup"><span data-stu-id="09ed2-290">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="09ed2-291">在後`Abort`叫用在執行緒的執行緒狀態包括<xref:System.Threading.ThreadState.AbortRequested>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-291">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="09ed2-292">執行緒已經終止結果成功呼叫之後`Abort`，執行緒的狀態變更為<xref:System.Threading.ThreadState.Stopped>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-292">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="09ed2-293">具有足夠的權限的執行緒，做為目標的`Abort`可以取消中止使用`ResetAbort`方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-293">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="09ed2-294">如需範例，示範如何呼叫`ResetAbort`方法，請參閱`ThreadAbortException`類別。</span><span class="sxs-lookup"><span data-stu-id="09ed2-294">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="09ed2-295">僅限 .NET Core：不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="09ed2-295">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="09ed2-296">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="09ed2-296">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-297">要中止的執行緒目前已暫止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-297">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="09ed2-298">在執行緒上的進階作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-298">for advanced operations on threads.</span></span> <span data-ttu-id="09ed2-299">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-299">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="09ed2-300">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-300">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="09ed2-301">使用執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-301">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="09ed2-302">終結執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-302">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo"><span data-ttu-id="09ed2-303">包含特定應用程式資訊 (例如狀態) 的物件，正在中止的執行緒可以使用這個物件。</span><span class="sxs-lookup"><span data-stu-id="09ed2-303">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span></span></param>
        <summary><span data-ttu-id="09ed2-304">於被叫用的所在執行緒中引發 <see cref="T:System.Threading.ThreadAbortException" />，開始結束執行緒的處理作業，同時也提供執行緒結束的相關例外狀況資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-304">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span></span> <span data-ttu-id="09ed2-305">呼叫這個方法通常會結束執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-305">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-306">在執行緒上叫用這個方法時，系統會擲回<xref:System.Threading.ThreadAbortException>中將它中止執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-306">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="09ed2-307">`ThreadAbortException` 是特殊的應用程式程式碼，就可以攔截的例外狀況，但會在結尾處重新擲回`catch`封鎖除非<xref:System.Threading.Thread.ResetAbort%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="09ed2-307">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="09ed2-308">`ResetAbort` 取消要求中止，並防止`ThreadAbortException`無法終止執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-308">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="09ed2-309">未執行`finally`區塊會執行已中止的執行緒之前。</span><span class="sxs-lookup"><span data-stu-id="09ed2-309">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-310">當執行緒呼叫`Abort`本身，效果會類似於擲回例外狀況;<xref:System.Threading.ThreadAbortException>時會立即，且結果為可預測。</span><span class="sxs-lookup"><span data-stu-id="09ed2-310">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="09ed2-311">不過，如果一個執行緒呼叫`Abort`另一個執行緒中止會中斷任何程式碼執行。</span><span class="sxs-lookup"><span data-stu-id="09ed2-311">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="09ed2-312">沒有機會，靜態建構函式可能會中止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-312">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="09ed2-313">在罕見的情況下，這可能導致無法建立應用程式定義域中的該類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-313">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="09ed2-314">在.NET framework 1.0 和 1.1 版中，很有可能在中止執行緒時`finally`執行的區塊，在此情況下`finally`區塊就會中止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-314">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="09ed2-315">不保證立即執行，或完全中止執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-315">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="09ed2-316">如果執行緒沒有無限量的空間中的計算，可能會發生這種情況下`finally`區塊呼叫中止程序，藉此無限期延遲中止的一部分。</span><span class="sxs-lookup"><span data-stu-id="09ed2-316">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="09ed2-317">若要等候，直到執行緒已經中止，您可以呼叫<xref:System.Threading.Thread.Join%2A>方法之後呼叫的執行緒上<xref:System.Threading.Thread.Abort%2A>方法，但不保證會結束等待。</span><span class="sxs-lookup"><span data-stu-id="09ed2-317">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-318">呼叫的執行緒<xref:System.Threading.Thread.Abort%2A>是否正在中止的執行緒在受保護的程式碼區域，例如，可能會封鎖`catch`區塊中，`finally`區塊或限制的執行區域。</span><span class="sxs-lookup"><span data-stu-id="09ed2-318">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="09ed2-319">如果執行緒呼叫<xref:System.Threading.Thread.Abort%2A>掌握需要中止的執行緒，便會發生死結的鎖定。</span><span class="sxs-lookup"><span data-stu-id="09ed2-319">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="09ed2-320">如果`Abort`稱為尚未啟動執行緒的執行緒將會中止時<xref:System.Threading.Thread.Start%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="09ed2-320">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="09ed2-321">如果`Abort`呼叫會封鎖或睡眠中的執行緒上的執行緒中斷，然後中止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-321">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="09ed2-322">如果`Abort`已暫停的執行緒上呼叫<xref:System.Threading.ThreadStateException>呼叫的執行緒中擲回<xref:System.Threading.Thread.Abort%2A>，以及<xref:System.Threading.ThreadState.AbortRequested>新增至<xref:System.Threading.Thread.ThreadState%2A>正在中止的執行緒屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-322">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="09ed2-323">A<xref:System.Threading.ThreadAbortException>不會擲回在暫止的執行緒，直到<xref:System.Threading.Thread.Resume%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="09ed2-323">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="09ed2-324">如果`Abort`執行 unmanaged 程式碼時，會將受管理的執行緒上呼叫`ThreadAbortException`直到執行緒返回受控碼不會擲回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-324">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="09ed2-325">如果兩個呼叫來`Abort`出現在此同時，就可以一次呼叫設定的狀態資訊和其他執行的呼叫`Abort`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-325">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="09ed2-326">不過，應用程式無法偵測這種情況。</span><span class="sxs-lookup"><span data-stu-id="09ed2-326">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="09ed2-327">在後`Abort`叫用在執行緒的執行緒狀態包括<xref:System.Threading.ThreadState.AbortRequested>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-327">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="09ed2-328">執行緒已經終止結果成功呼叫之後`Abort`，執行緒的狀態變更為<xref:System.Threading.ThreadState.Stopped>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-328">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="09ed2-329">具有足夠的權限的執行緒，做為目標的`Abort`可以取消中止使用`ResetAbort`方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-329">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="09ed2-330">如需範例，示範如何呼叫`ResetAbort`方法，請參閱`ThreadAbortException`類別。</span><span class="sxs-lookup"><span data-stu-id="09ed2-330">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-331">下列程式碼範例示範如何將資訊傳遞給正在中止的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-331">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="09ed2-332">僅限 .NET Core：不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="09ed2-332">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="09ed2-333">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="09ed2-333">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-334">要中止的執行緒目前已暫止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-334">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="09ed2-335">在執行緒上的進階作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-335">for advanced operations on threads.</span></span> <span data-ttu-id="09ed2-336">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-336">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="09ed2-337">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-337">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="09ed2-338">使用執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-338">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="09ed2-339">終結執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-339">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-340">在所有的執行緒上配置未命名的資料位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-340">Allocates an unnamed data slot on all the threads.</span></span> <span data-ttu-id="09ed2-341">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-341">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="09ed2-342">在所有執行緒上已配置的具名資料位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-342">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="09ed2-343">.NET Framework 會提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關靜態欄位 (也就是標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-343">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="09ed2-344">執行緒相關靜態欄位提供比資料插槽更好的效能，並可編譯時期類型檢查。</span><span class="sxs-lookup"><span data-stu-id="09ed2-344">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="09ed2-345">如需使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-345">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="09ed2-346">在所有執行緒上配置的位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-346">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="09ed2-347">執行緒會使用本機存放區記憶體機制來儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-347">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="09ed2-348">建立時，common language runtime 會配置到每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="09ed2-348">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="09ed2-349">執行緒可以配置的資料存放區中的資料位置、 儲存及擷取資料中的位置、 值和免費供重複使用的位置之後在執行緒逾時。</span><span class="sxs-lookup"><span data-stu-id="09ed2-349">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="09ed2-350">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="09ed2-350">Data slots are unique per thread.</span></span> <span data-ttu-id="09ed2-351">沒有任何其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-351">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-352">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="09ed2-352">This section contains two code examples.</span></span> <span data-ttu-id="09ed2-353">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性來保留執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-353">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-354">第二個範例示範如何使用資料插槽來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-354">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="09ed2-355">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-355">**First Example**</span></span>  
  
 <span data-ttu-id="09ed2-356">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>來儲存執行緒特定資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-356">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-357">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="09ed2-357">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="09ed2-358">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-358">**Second Example**</span></span>  
  
 <span data-ttu-id="09ed2-359">下列程式碼範例示範如何使用資料的位置來儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-359">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="09ed2-360">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-360">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="09ed2-361">執行緒區域儲存區：執行緒相關的靜態欄位和資料位置</span><span class="sxs-lookup"><span data-stu-id="09ed2-361">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="09ed2-362">要配置之資料插槽的名稱。</span><span class="sxs-lookup"><span data-stu-id="09ed2-362">The name of the data slot to be allocated.</span></span></param>
        <summary><span data-ttu-id="09ed2-363">在所有的執行緒上配置命名的資料位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-363">Allocates a named data slot on all threads.</span></span> <span data-ttu-id="09ed2-364">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-364">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="09ed2-365">在所有執行緒上已配置的具名資料位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-365">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="09ed2-366">.NET Framework 會提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關靜態欄位 (也就是標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-366">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="09ed2-367">執行緒相關靜態欄位提供比資料插槽更好的效能，並可編譯時期類型檢查。</span><span class="sxs-lookup"><span data-stu-id="09ed2-367">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="09ed2-368">如需使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-368">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="09ed2-369">執行緒會使用本機存放區記憶體機制來儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-369">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="09ed2-370">建立時，common language runtime 會配置到每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="09ed2-370">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="09ed2-371">執行緒可以配置的資料存放區中的資料位置、 儲存及擷取資料中的位置、 值和免費供重複使用的位置之後在執行緒逾時。</span><span class="sxs-lookup"><span data-stu-id="09ed2-371">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="09ed2-372">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="09ed2-372">Data slots are unique per thread.</span></span> <span data-ttu-id="09ed2-373">沒有任何其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-373">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="09ed2-374">您不需要使用<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法來配置具名的資料插槽，因為<xref:System.Threading.Thread.GetNamedDataSlot%2A>方法配置的位置，如果它沒有已配置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-374">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-375">如果<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法，它應該呼叫在主執行緒在程式啟動時，因為它會擲回例外狀況，如果已配置具有指定名稱的位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-375">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="09ed2-376">沒有任何方法來測試是否已配置的位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-376">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="09ed2-377">以這個方法所配置的位置必須與釋放<xref:System.Threading.Thread.FreeNamedDataSlot%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-377">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-378">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="09ed2-378">This section contains two code examples.</span></span> <span data-ttu-id="09ed2-379">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性來保留執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-379">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-380">第二個範例示範如何使用資料插槽來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-380">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="09ed2-381">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-381">**First Example**</span></span>  
  
 <span data-ttu-id="09ed2-382">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>來儲存執行緒特定資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-382">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-383">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="09ed2-383">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="09ed2-384">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-384">**Second Example**</span></span>  
  
 <span data-ttu-id="09ed2-385">下列範例示範如何使用來儲存執行緒特定資訊的具名的資料插槽。</span><span class="sxs-lookup"><span data-stu-id="09ed2-385">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-386">範例程式碼不會使用<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法，因為<xref:System.Threading.Thread.GetNamedDataSlot%2A>方法配置的位置，如果它沒有已配置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-386">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="09ed2-387">如果<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法時，應該在程式啟動時於主執行緒中呼叫它。</span><span class="sxs-lookup"><span data-stu-id="09ed2-387">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="09ed2-388">具有指定名稱的具名資料位置已存在。</span><span class="sxs-lookup"><span data-stu-id="09ed2-388">A named data slot with the specified name already exists.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="09ed2-389">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-389">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="09ed2-390">執行緒區域儲存區：執行緒相關的靜態欄位和資料位置</span><span class="sxs-lookup"><span data-stu-id="09ed2-390">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-391">取得或設定這個執行緒的 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-391">Gets or sets the apartment state of this thread.</span></span></summary>
        <value><span data-ttu-id="09ed2-392">其中一個 <see cref="T:System.Threading.ApartmentState" /> 值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-392">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span></span> <span data-ttu-id="09ed2-393">初始值為 <see langword="Unknown" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-393">The initial value is <see langword="Unknown" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-394">**<xref:System.Threading.Thread.ApartmentState%2A>屬性已經過時。**</span><span class="sxs-lookup"><span data-stu-id="09ed2-394">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="09ed2-395">非過時的替代方式為<xref:System.Threading.Thread.GetApartmentState%2A>方法來擷取的 apartment 狀態和<xref:System.Threading.Thread.SetApartmentState%2A>方法來設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-395">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="09ed2-396">在.NET framework 1.0 和 1.1 版，`ApartmentState`屬性標記的執行緒，以指出它會在單一執行緒或多執行緒 apartment 中執行。</span><span class="sxs-lookup"><span data-stu-id="09ed2-396">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="09ed2-397">可以設定這個屬性，當執行緒處於`Unstarted`或`Running`執行緒狀態; 不過，它可以 ji nastavit pouze jednou 執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-397">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="09ed2-398">如果尚未設定屬性，它會傳回`Unknown`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-398">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="09ed2-399">嘗試使用<xref:System.Threading.Thread.ApartmentState%2A>屬性來設定其 apartment 狀態已設定執行緒的 apartment 狀態會被忽略。</span><span class="sxs-lookup"><span data-stu-id="09ed2-399">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="09ed2-400">不過，<xref:System.Threading.Thread.SetApartmentState%2A>方法會擲回<xref:System.InvalidOperationException>在此情況下。</span><span class="sxs-lookup"><span data-stu-id="09ed2-400">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="09ed2-401">在.NET Framework 2.0 版中，新的執行緒都會初始化成<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果其 apartment 狀態尚未設定之前啟動。</span><span class="sxs-lookup"><span data-stu-id="09ed2-401">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="09ed2-402">主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>預設。</span><span class="sxs-lookup"><span data-stu-id="09ed2-402">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="09ed2-403">您可以不再將設定主應用程式執行緒<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>藉由設定<xref:System.Threading.ApartmentState?displayProperty=nameWithType>第一行程式碼上的屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-403">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="09ed2-404">使用<xref:System.STAThreadAttribute>改。</span><span class="sxs-lookup"><span data-stu-id="09ed2-404">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="09ed2-405">在.NET Framework 2.0 版中，您可以指定的 COM 執行緒模型，來使用 c + + 應用程式[/CLRTHREADATTRIBUTE （設定 CLR 執行緒屬性）](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)連結器選項。</span><span class="sxs-lookup"><span data-stu-id="09ed2-405">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-406">下列程式碼範例示範如何設定執行緒的 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-406">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="09ed2-407">已嘗試將此屬性狀態設定為無效 Apartment 狀態 (單一執行緒 Apartment (<see langword="STA" />) 或多執行緒 Apartment (<see langword="MTA" />) 以外的狀態)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-407">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-408">通知主機在即將執行的程式碼區域中，執行緒中止或未處理例外狀況的影響，可能會危及應用程式定義域中的其他工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-408">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-409">主控件，例如 Microsoft SQL Server 2005，common language runtime (CLR)，可以建立不同的原則中的程式碼的重大和非關鍵區域的失敗。</span><span class="sxs-lookup"><span data-stu-id="09ed2-409">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="09ed2-410">關鍵區域是在其執行緒中止或未處理的例外狀況的影響可能不會限制為目前的工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-410">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="09ed2-411">相較之下，中止或非關鍵的程式碼區域中的失敗會影響只有工作發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="09ed2-411">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="09ed2-412">例如，請考慮嘗試配置記憶體的鎖定時的工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-412">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="09ed2-413">如果記憶體配置失敗，正在中止目前的工作並不足以確保穩定性<xref:System.AppDomain>，因為在等候相同鎖定的網域中可以有其他工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-413">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="09ed2-414">如果終止目前的工作，就可能發生死結其他工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-414">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="09ed2-415">發生失敗時的關鍵區域中，主應用程式可能會決定要卸載整個<xref:System.AppDomain>而不是花在可能不穩定的狀態繼續執行的風險。</span><span class="sxs-lookup"><span data-stu-id="09ed2-415">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="09ed2-416">若要向主應用程式通知，您的程式碼正在進入關鍵區域，呼叫<xref:System.Threading.Thread.BeginCriticalRegion%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-416">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="09ed2-417">呼叫<xref:System.Threading.Thread.EndCriticalRegion%2A>當執行會返回到非關鍵的程式碼區域。</span><span class="sxs-lookup"><span data-stu-id="09ed2-417">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="09ed2-418">在 SQL Server 2005 中執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-418">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-419">下列範例示範如何使用<xref:System.Threading.Thread.BeginCriticalRegion%2A>和<xref:System.Threading.Thread.EndCriticalRegion%2A>分成重大和非重大的區域中的程式碼區塊的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-419">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-420">通知主機 Managed 程式碼即將執行指令，而這些指令相依於目前實體作業系統執行緒的識別 (Identity)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-420">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-421">某些主機的 common language runtime，例如 Microsoft SQL Server 2005，提供自己的執行緒管理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-421">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="09ed2-422">提供它自己的執行緒管理的主機正在執行的工作從一個實體作業系統執行緒之間移動在任何時間。</span><span class="sxs-lookup"><span data-stu-id="09ed2-422">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="09ed2-423">大部分的工作不會影響此切換。</span><span class="sxs-lookup"><span data-stu-id="09ed2-423">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="09ed2-424">不過，某些工作具有執行緒相似性-也就是相依實體作業系統執行緒的身分識別。</span><span class="sxs-lookup"><span data-stu-id="09ed2-424">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="09ed2-425">這些工作必須通知主應用程式，當他們執行應該沒問題的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-425">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="09ed2-426">例如，如果應用程式會呼叫系統 API 取得作業系統鎖定具有執行緒親和性，例如 Win32 critical_section 做，您必須呼叫<xref:System.Threading.Thread.BeginThreadAffinity%2A>之前取得鎖定，以及<xref:System.Threading.Thread.EndThreadAffinity%2A>之後釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="09ed2-426">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="09ed2-427">在 SQL Server 2005 中執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-427">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-428">下列範例示範如何使用<xref:System.Threading.Thread.BeginThreadAffinity%2A>和<xref:System.Threading.Thread.EndThreadAffinity%2A>方法，以通知程式碼區塊，取決於實體作業系統執行緒的身分識別的主機。</span><span class="sxs-lookup"><span data-stu-id="09ed2-428">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="09ed2-429">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="09ed2-429">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="09ed2-430">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="09ed2-430">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="09ed2-431">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-431">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-432">取得執行緒正在執行的目前內容。</span><span class="sxs-lookup"><span data-stu-id="09ed2-432">Gets the current context in which the thread is executing.</span></span></summary>
        <value><span data-ttu-id="09ed2-433"><see cref="T:System.Runtime.Remoting.Contexts.Context" />，代表目前的執行緒內容。</span><span class="sxs-lookup"><span data-stu-id="09ed2-433">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="09ed2-434">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="09ed2-434">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="09ed2-435">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="09ed2-435">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="09ed2-436">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-436">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-437">取得或設定目前執行緒的文化特性 (Culture)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-437">Gets or sets the culture for the current thread.</span></span></summary>
        <value><span data-ttu-id="09ed2-438">表示目前執行緒之文化特性的物件。</span><span class="sxs-lookup"><span data-stu-id="09ed2-438">An object that represents the culture for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-439"><xref:System.Globalization.CultureInfo>搭配其相關聯的物件，這個屬性所傳回的物件判斷預設格式的日期、 時間、 數字、 貨幣值，排序順序的文字、 大小寫慣例，以及字串比較。</span><span class="sxs-lookup"><span data-stu-id="09ed2-439">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="09ed2-440">請參閱<xref:System.Globalization.CultureInfo>類別若要了解文化特性名稱和識別碼，而異、 中性和特定文化特性之間的差異，並方式文化特性資訊影響執行緒和應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="09ed2-440">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="09ed2-441">請參閱<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>屬性，以了解如何決定執行緒的預設文化特性，以及使用者設定其電腦的文化特性資訊的方式。</span><span class="sxs-lookup"><span data-stu-id="09ed2-441">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="09ed2-442"><xref:System.Threading.Thread.CurrentCulture>屬性無法可靠地運作，搭配目前的執行緒以外的任何執行緒時。</span><span class="sxs-lookup"><span data-stu-id="09ed2-442">The <xref:System.Threading.Thread.CurrentCulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="09ed2-443">在.NET Framework 中，讀取內容的可靠性，不過將它設定為目前的執行緒以外的執行緒並不是。</span><span class="sxs-lookup"><span data-stu-id="09ed2-443">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="09ed2-444">在.NET Core<xref:System.InvalidOperationException>就會擲回，如果執行緒嘗試讀取或寫入<xref:System.Threading.Thread.CurrentCulture>不同的執行緒上的屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-444">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentCulture> property on a different thread.</span></span>
> <span data-ttu-id="09ed2-445">我們建議您改用<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType>擷取或設定目前的文化特性屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-445">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="09ed2-446">開頭[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，您可以設定<xref:System.Threading.Thread.CurrentCulture%2A>中性文化特性的屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-446">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="09ed2-447">這是因為的行為<xref:System.Globalization.CultureInfo>類別已變更： 當它代表中性文化特性，其屬性值 (特別是， <xref:System.Globalization.CultureInfo.Calendar%2A>， <xref:System.Globalization.CultureInfo.CompareInfo%2A>， <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>， <xref:System.Globalization.CultureInfo.NumberFormat%2A>，和<xref:System.Globalization.CultureInfo.TextInfo%2A>屬性) 現在反映是中性文化特性相關聯的特定文化特性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-447">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="09ed2-448">在舊版的.NET Framework 中，<xref:System.Threading.Thread.CurrentCulture%2A>屬性會擲回<xref:System.NotSupportedException>中性文化特性已指派時發生的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="09ed2-448">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
## Examples  
 <span data-ttu-id="09ed2-449">下列範例示範可讓要顯示在 [控制台] 中設定的文化特性中的 Windows Forms 應用程式的使用者介面執行緒陳述式。</span><span class="sxs-lookup"><span data-stu-id="09ed2-449">The following example shows the threading statement that allows the user interface of a Windows Forms application to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="09ed2-450">需要額外的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-450">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="09ed2-451">該屬性設定為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-451">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="09ed2-452">僅限 .NET Core：不支援從另一個執行緒讀取或寫入執行緒的文化特性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-452">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="09ed2-453">用來設定屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-453">for setting the property.</span></span> <span data-ttu-id="09ed2-454">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="09ed2-454">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-455">取得或設定執行緒目前的原則 (角色架構安全性之用)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-455">Gets or sets the thread's current principal (for role-based security).</span></span></summary>
        <value><span data-ttu-id="09ed2-456"><see cref="T:System.Security.Principal.IPrincipal" /> 值，代表安全性的內容。</span><span class="sxs-lookup"><span data-stu-id="09ed2-456">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="09ed2-457">下列程式碼範例示範如何設定和擷取執行緒的主體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-457">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="09ed2-458">呼叫端沒有設定主體的必要權限。</span><span class="sxs-lookup"><span data-stu-id="09ed2-458">The caller does not have the permission required to set the principal.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="09ed2-459">若要操作之主體物件。</span><span class="sxs-lookup"><span data-stu-id="09ed2-459">to manipulate the principal object.</span></span> <span data-ttu-id="09ed2-460">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-460">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-461">取得目前執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-461">Gets the currently running thread.</span></span></summary>
        <value><span data-ttu-id="09ed2-462"><see cref="T:System.Threading.Thread" />，是目前執行之執行緒的表示。</span><span class="sxs-lookup"><span data-stu-id="09ed2-462">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="09ed2-463">下列範例會建立接著會建立 20 個子任務的工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-463">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="09ed2-464">應用程式本身，以及每項工作中，呼叫`ShowThreadInformation`方法，它會使用<xref:System.Threading.Thread.CurrentThread%2A>屬性，以顯示在其執行之執行緒的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-464">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="09ed2-465">每項子工作會產生 1 百萬個隨機數字，介於 1 到 1 百萬個，並傳回其平均值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-465">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="09ed2-466">父工作呼叫<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法，以確保子工作已完成之前顯示每項工作所傳回的平均值和計算方式的平均值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-466">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="09ed2-467">請注意應用程式在前景執行緒上執行，而在執行緒集區執行緒上執行每項工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-467">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-468">取得或設定資源管理員目前用以在執行階段查詢特定文化特性資源所用的文化特性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-468">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span></span></summary>
        <value><span data-ttu-id="09ed2-469">表示目前文化特性的物件。</span><span class="sxs-lookup"><span data-stu-id="09ed2-469">An object that represents the current culture.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-470">UI 文化特性會指定應用程式所需的資源來支援使用者輸入和輸出，並依預設是作業系統的文化特性相同。</span><span class="sxs-lookup"><span data-stu-id="09ed2-470">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="09ed2-471">請參閱<xref:System.Globalization.CultureInfo>類別若要了解文化特性名稱和識別碼，而異、 中性和特定文化特性之間的差異，並方式文化特性資訊影響執行緒和應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="09ed2-471">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="09ed2-472">請參閱<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>若要了解如何判斷執行緒的預設 UI 文化特性的屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-472">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="09ed2-473"><xref:System.Threading.Thread.CurrentUICulture>屬性無法可靠地運作，搭配目前的執行緒以外的任何執行緒時。</span><span class="sxs-lookup"><span data-stu-id="09ed2-473">The <xref:System.Threading.Thread.CurrentUICulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="09ed2-474">在.NET Framework 中，讀取內容的可靠性，不過將它設定為目前的執行緒以外的執行緒並不是。</span><span class="sxs-lookup"><span data-stu-id="09ed2-474">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="09ed2-475">在.NET Core<xref:System.InvalidOperationException>就會擲回，如果執行緒嘗試讀取或寫入<xref:System.Threading.Thread.CurrentUICulture>不同的執行緒上的屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-475">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentUICulture> property on a different thread.</span></span>
> <span data-ttu-id="09ed2-476">我們建議您改用<xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType>擷取或設定目前的文化特性屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-476">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="09ed2-477"><xref:System.Globalization.CultureInfo>傳回這個屬性可以是中性文化特性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-477">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="09ed2-478">中性文化特性不應以格式化方法，例如<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>， <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>，和<xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-478">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09ed2-479">使用 <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>方法來取得特定的文化特性，或使用<xref:System.Threading.Thread.CurrentCulture%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-479">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-480"><xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>方法會擲回<xref:System.ArgumentException>中性文化特性 」 Zh-hant"("ZH-CHT") 和 「-Zh-hans"("ZH-CHS 」)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-480">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-481">下列範例會判斷目前的執行緒 UI 文化特性的語言是否與法文。</span><span class="sxs-lookup"><span data-stu-id="09ed2-481">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="09ed2-482">如果不是，它會設定目前執行緒的 UI 文化特性設為 英文 （美國）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-482">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="09ed2-483">下列程式碼範例會顯示執行緒的陳述式，可讓 Windows Form，以顯示在 [控制台] 中設定的文化特性的使用者介面。</span><span class="sxs-lookup"><span data-stu-id="09ed2-483">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="09ed2-484">需要額外的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-484">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="09ed2-485">該屬性設定為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-485">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="09ed2-486">此屬性設為無法用來尋找資源檔的文化特性名稱。</span><span class="sxs-lookup"><span data-stu-id="09ed2-486">The property is set to a culture name that cannot be used to locate a resource file.</span></span> <span data-ttu-id="09ed2-487">資源檔名稱只可以包含字母、數字、連字號或底線。</span><span class="sxs-lookup"><span data-stu-id="09ed2-487">Resource filenames must include only letters, numbers, hyphens or underscores.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="09ed2-488">僅限 .NET Core：不支援從另一個執行緒讀取或寫入執行緒的文化特性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-488">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-489">關閉目前執行緒之執行階段可呼叫包裝函式 (RCW) 的自動清除功能。</span><span class="sxs-lookup"><span data-stu-id="09ed2-489">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-490">根據預設，common language runtime (CLR) 會清除執行階段可呼叫包裝函式自動。</span><span class="sxs-lookup"><span data-stu-id="09ed2-490">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="09ed2-491">CLR 幫浦內訊息的清除，這可能會造成一些符合下列準則不尋常的應用程式的重新進入問題：</span><span class="sxs-lookup"><span data-stu-id="09ed2-491">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="09ed2-492">應用程式會自己訊息幫浦作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-492">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="09ed2-493">應用程式需要訊息幫浦，就會發生時，精確地控制。</span><span class="sxs-lookup"><span data-stu-id="09ed2-493">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="09ed2-494">這類應用程式可以使用<xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A>會造成 CLR 無法進行自動回收的執行階段可呼叫包裝函式的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-494">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="09ed2-495">已呼叫這個方法在執行緒上時自動清除無法重新啟用該執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-495">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="09ed2-496">您的應用程式準備好要清除執行階段可呼叫包裝函式時，請使用<xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType>方法來指示要清除所有執行階段可呼叫包裝函式在目前內容中的執行階段。</span><span class="sxs-lookup"><span data-stu-id="09ed2-496">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="09ed2-497">此方法執行時，就會發生訊息幫浦作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-497">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="09ed2-498">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="09ed2-498">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="09ed2-499">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-499">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-500">通知主機在即將執行的程式碼區域中，執行緒中止或未處理例外狀況影響的對象只限於目前的工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-500">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-501">主控件，例如 Microsoft SQL Server 2005，common language runtime (CLR)，可以建立不同的原則中的程式碼的重大和非關鍵區域的失敗。</span><span class="sxs-lookup"><span data-stu-id="09ed2-501">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="09ed2-502">關鍵區域是在其執行緒中止或未處理的例外狀況的影響可能不會限制為目前的工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-502">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="09ed2-503">相較之下，中止或非關鍵的程式碼區域中的失敗會影響只有工作發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="09ed2-503">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="09ed2-504">例如，請考慮嘗試配置記憶體的鎖定時的工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-504">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="09ed2-505">如果記憶體配置失敗，正在中止目前的工作並不足以確保穩定性<xref:System.AppDomain>，因為在等候相同鎖定的網域中可以有其他工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-505">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="09ed2-506">如果終止目前的工作，就可能發生死結其他工作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-506">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="09ed2-507">發生失敗時的關鍵區域中，主應用程式可能會決定要卸載整個<xref:System.AppDomain>而不是花在可能不穩定的狀態繼續執行的風險。</span><span class="sxs-lookup"><span data-stu-id="09ed2-507">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="09ed2-508">若要向主應用程式通知，您的程式碼正在進入關鍵區域，呼叫<xref:System.Threading.Thread.BeginCriticalRegion%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-508">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="09ed2-509">呼叫<xref:System.Threading.Thread.EndCriticalRegion%2A>當執行會返回到非關鍵的程式碼區域。</span><span class="sxs-lookup"><span data-stu-id="09ed2-509">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="09ed2-510">在 SQL Server 2005 中執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-510">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-511">下列範例示範如何使用<xref:System.Threading.Thread.BeginCriticalRegion%2A>和<xref:System.Threading.Thread.EndCriticalRegion%2A>分成重大和非重大的區域中的程式碼區塊的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-511">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-512">通知主機 Managed 程式碼已完成執行指令，而這些指令相依於目前實體作業系統執行緒的識別。</span><span class="sxs-lookup"><span data-stu-id="09ed2-512">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-513">某些主機的 common language runtime，例如 Microsoft SQL Server 2005，提供自己的執行緒管理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-513">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="09ed2-514">提供它自己的執行緒管理的主機正在執行的工作從一個實體作業系統執行緒之間移動在任何時間。</span><span class="sxs-lookup"><span data-stu-id="09ed2-514">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="09ed2-515">大部分的工作不會影響此切換。</span><span class="sxs-lookup"><span data-stu-id="09ed2-515">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="09ed2-516">不過，某些工作具有執行緒相似性-也就是相依實體作業系統執行緒的身分識別。</span><span class="sxs-lookup"><span data-stu-id="09ed2-516">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="09ed2-517">這些工作必須通知主應用程式，當他們執行應該沒問題的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-517">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="09ed2-518">例如，如果應用程式會呼叫系統 API 取得作業系統鎖定具有執行緒親和性，例如 Win32 critical_section 做，您必須呼叫<xref:System.Threading.Thread.BeginThreadAffinity%2A>之前取得鎖定，以及<xref:System.Threading.Thread.EndThreadAffinity%2A>之後釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="09ed2-518">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="09ed2-519">在 SQL Server 2005 中執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-519">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-520">下列範例示範如何使用<xref:System.Threading.Thread.BeginThreadAffinity%2A>和<xref:System.Threading.Thread.EndThreadAffinity%2A>方法，以通知程式碼區塊，取決於實體作業系統執行緒的身分識別的主機。</span><span class="sxs-lookup"><span data-stu-id="09ed2-520">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="09ed2-521">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="09ed2-521">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="09ed2-522">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="09ed2-522">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="09ed2-523">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-523">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-524">取得 <see cref="T:System.Threading.ExecutionContext" /> 物件，包含目前執行緒各種內容的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-524">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span></span></summary>
        <value><span data-ttu-id="09ed2-525"><see cref="T:System.Threading.ExecutionContext" /> 物件，合併目前執行緒的內容資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-525">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-526"><xref:System.Threading.ExecutionContext>類別會提供所有的相關資訊的邏輯執行緒的執行中的單一容器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-526">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="09ed2-527">這包括安全性內容，呼叫內容、 同步處理內容、 當地語系化內容和交易內容。</span><span class="sxs-lookup"><span data-stu-id="09ed2-527">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-528">確認釋出資源，並在記憶體回收行程回收 <see cref="T:System.Threading.Thread" /> 物件時執行其他清除作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-528">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-529">記憶體回收行程呼叫<xref:System.Threading.Thread.Finalize%2A>時準備好完成目前的物件。</span><span class="sxs-lookup"><span data-stu-id="09ed2-529">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="09ed2-530">要釋放之資料插槽的名稱。</span><span class="sxs-lookup"><span data-stu-id="09ed2-530">The name of the data slot to be freed.</span></span></param>
        <summary><span data-ttu-id="09ed2-531">排除處理程序中所有執行緒的名稱和位置之間的關聯。</span><span class="sxs-lookup"><span data-stu-id="09ed2-531">Eliminates the association between a name and a slot, for all threads in the process.</span></span> <span data-ttu-id="09ed2-532">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-532">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="09ed2-533">.NET Framework 會提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關靜態欄位 (也就是標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-533">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="09ed2-534">執行緒相關靜態欄位提供比資料插槽更好的效能，並可編譯時期類型檢查。</span><span class="sxs-lookup"><span data-stu-id="09ed2-534">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="09ed2-535">如需使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-535">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="09ed2-536">任何執行緒呼叫之後`FreeNamedDataSlot`，呼叫的任何其他執行緒<xref:System.Threading.Thread.GetNamedDataSlot%2A>具有相同名稱將會配置新的位置與名稱相關聯。</span><span class="sxs-lookup"><span data-stu-id="09ed2-536">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="09ed2-537">後續呼叫`GetNamedDataSlot`由任何執行緒將會傳回新的位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-537">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="09ed2-538">不過，任何執行緒，還有<xref:System.LocalDataStoreSlot?displayProperty=nameWithType>由先前呼叫所傳回`GetNamedDataSlot`可以繼續使用舊的位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-538">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="09ed2-539">發行已與名稱相關聯的位置時，才每`LocalDataStoreSlot`呼叫之前取得`FreeNamedDataSlot`釋放及回收。</span><span class="sxs-lookup"><span data-stu-id="09ed2-539">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="09ed2-540">執行緒會使用本機存放區記憶體機制來儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-540">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="09ed2-541">建立時，common language runtime 會配置到每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="09ed2-541">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="09ed2-542">執行緒可以配置的資料存放區中的資料位置、 儲存及擷取資料中的位置、 值和免費供重複使用的位置之後在執行緒逾時。</span><span class="sxs-lookup"><span data-stu-id="09ed2-542">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="09ed2-543">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="09ed2-543">Data slots are unique per thread.</span></span> <span data-ttu-id="09ed2-544">沒有任何其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-544">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-545">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="09ed2-545">This section contains two code examples.</span></span> <span data-ttu-id="09ed2-546">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性來保留執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-546">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-547">第二個範例示範如何使用資料插槽來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-547">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="09ed2-548">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-548">**First Example**</span></span>  
  
 <span data-ttu-id="09ed2-549">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>來儲存執行緒特定資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-549">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-550">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="09ed2-550">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="09ed2-551">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-551">**Second Example**</span></span>  
  
 <span data-ttu-id="09ed2-552">下列範例示範如何使用來儲存執行緒特定資訊的具名的資料插槽。</span><span class="sxs-lookup"><span data-stu-id="09ed2-552">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="09ed2-553">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-553">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="09ed2-554">執行緒區域儲存區：執行緒相關的靜態欄位和資料位置</span><span class="sxs-lookup"><span data-stu-id="09ed2-554">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-555">傳回表示 Apartment 狀態的 <see cref="T:System.Threading.ApartmentState" /> 值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-555">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span></span></summary>
        <returns><span data-ttu-id="09ed2-556">其中一個 <see cref="T:System.Threading.ApartmentState" /> 值，表示 Managed 執行緒的 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-556">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span></span> <span data-ttu-id="09ed2-557">預設值為 <see cref="F:System.Threading.ApartmentState.Unknown" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-557">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-558">這種方法，連同<xref:System.Threading.Thread.SetApartmentState%2A>方法和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-558">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-559">下列程式碼範例示範<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-559">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="09ed2-560">在程式碼範例會建立執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-560">The code example creates a thread.</span></span> <span data-ttu-id="09ed2-561">在執行緒啟動之前，<xref:System.Threading.Thread.GetApartmentState%2A>會顯示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>狀態並<xref:System.Threading.Thread.SetApartmentState%2A>狀態變更為<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-561">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09ed2-562"><xref:System.Threading.Thread.TrySetApartmentState%2A>方法接著會傳回`false`當您嘗試將狀態變更時<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因為已設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-562">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="09ed2-563">如果相同的作業已嘗試使用了<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>就已擲回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-563">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="09ed2-564">在執行緒啟動之後，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法會再次使用。</span><span class="sxs-lookup"><span data-stu-id="09ed2-564">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="09ed2-565">這次會擲回<xref:System.Threading.ThreadStateException>因為尚未啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-565">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-566">傳回 <see cref="T:System.Threading.CompressedStack" /> 物件，可以用來擷取目前執行緒的堆疊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-566">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span></span></summary>
        <returns><span data-ttu-id="09ed2-567">無。</span><span class="sxs-lookup"><span data-stu-id="09ed2-567">None.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-568">不再支援這個方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-568">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="09ed2-569">在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="09ed2-569">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="09ed2-570">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="09ed2-570">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="09ed2-571">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-571">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="09ed2-572">要從其中取得值的 <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-572">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span></span></param>
        <summary><span data-ttu-id="09ed2-573">從目前執行緒上、目前執行緒之目前定義域中的指定位置擷取數值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-573">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span></span> <span data-ttu-id="09ed2-574">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-574">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="09ed2-575">擷取的數值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-575">The retrieved value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="09ed2-576">.NET Framework 會提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關靜態欄位 (也就是標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-576">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="09ed2-577">執行緒相關靜態欄位提供比資料插槽更好的效能，並可編譯時期類型檢查。</span><span class="sxs-lookup"><span data-stu-id="09ed2-577">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="09ed2-578">如需使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-578">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="09ed2-579">執行緒會使用本機存放區記憶體機制來儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-579">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="09ed2-580">建立時，common language runtime 會配置到每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="09ed2-580">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="09ed2-581">執行緒可以配置的資料存放區中的資料位置、 儲存及擷取資料中的位置、 值和免費供重複使用的位置之後在執行緒逾時。</span><span class="sxs-lookup"><span data-stu-id="09ed2-581">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="09ed2-582">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="09ed2-582">Data slots are unique per thread.</span></span> <span data-ttu-id="09ed2-583">沒有任何其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-583">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-584"><xref:System.Threading.Thread.GetData%2A> 是`Shared`一律會套用到目前正在執行的執行緒，即使您使用的變數，指的是另一個執行緒呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-584"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="09ed2-585">若要避免混淆，請使用類別名稱呼叫時`Shared`方法： `Dim test As Object = Thread.GetData(testSlot)`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-585">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-586">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="09ed2-586">This section contains two code examples.</span></span> <span data-ttu-id="09ed2-587">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性來保留執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-587">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-588">第二個範例示範如何使用資料插槽來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-588">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="09ed2-589">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-589">**First Example**</span></span>  
  
 <span data-ttu-id="09ed2-590">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>來儲存執行緒特定資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-590">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-591">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="09ed2-591">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="09ed2-592">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-592">**Second Example**</span></span>  
  
 <span data-ttu-id="09ed2-593">下列範例示範如何使用資料的位置來儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-593">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="09ed2-594">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-594">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="09ed2-595">執行緒區域儲存區：執行緒相關的靜態欄位和資料位置</span><span class="sxs-lookup"><span data-stu-id="09ed2-595">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-596">傳回目前執行緒正在其中執行的目前定義域。</span><span class="sxs-lookup"><span data-stu-id="09ed2-596">Returns the current domain in which the current thread is running.</span></span></summary>
        <returns><span data-ttu-id="09ed2-597"><see cref="T:System.AppDomain" />，代表執行中的執行緒目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="09ed2-597">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="09ed2-598">下列程式碼範例示範如何擷取名稱和識別碼`AppDomain`中的執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="09ed2-598">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-599">傳回唯一的應用程式定義域識別項。</span><span class="sxs-lookup"><span data-stu-id="09ed2-599">Returns a unique application domain identifier.</span></span></summary>
        <returns><span data-ttu-id="09ed2-600">唯一識別應用程式定義域的 32 位元帶正負號的整數 (Signed Integer)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-600">A 32-bit signed integer uniquely identifying the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="09ed2-601">下列程式碼範例示範如何擷取名稱和識別碼`AppDomain`中的執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="09ed2-601">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-602">傳回目前執行緒的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-602">Returns a hash code for the current thread.</span></span></summary>
        <returns><span data-ttu-id="09ed2-603">整數雜湊碼值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-603">An integer hash code value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-604">不保證是唯一的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-604">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="09ed2-605">使用<xref:System.Threading.Thread.ManagedThreadId%2A>屬性，如果您需要 managed 執行緒的唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-605">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="09ed2-606">本機資料位置的名稱。</span><span class="sxs-lookup"><span data-stu-id="09ed2-606">The name of the local data slot.</span></span></param>
        <summary><span data-ttu-id="09ed2-607">尋找具名的資料位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-607">Looks up a named data slot.</span></span> <span data-ttu-id="09ed2-608">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-608">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="09ed2-609">為這個執行緒配置的 <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-609">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="09ed2-610">.NET Framework 會提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關靜態欄位 (也就是標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-610">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="09ed2-611">執行緒相關靜態欄位提供比資料插槽更好的效能，並可編譯時期類型檢查。</span><span class="sxs-lookup"><span data-stu-id="09ed2-611">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="09ed2-612">如需使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-612">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="09ed2-613">執行緒會使用本機存放區記憶體機制來儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-613">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="09ed2-614">建立時，common language runtime 會配置到每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="09ed2-614">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="09ed2-615">執行緒可以配置的資料存放區中的資料位置、 儲存及擷取資料中的位置、 值和免費供重複使用的位置之後在執行緒逾時。</span><span class="sxs-lookup"><span data-stu-id="09ed2-615">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="09ed2-616">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="09ed2-616">Data slots are unique per thread.</span></span> <span data-ttu-id="09ed2-617">沒有任何其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-617">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="09ed2-618">如果具名的位置不存在，則會配置新的位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-618">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="09ed2-619">具名的資料插槽是公用的任何人都可以管理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-619">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-620">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="09ed2-620">This section contains two code examples.</span></span> <span data-ttu-id="09ed2-621">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性來保留執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-621">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-622">第二個範例示範如何使用資料插槽來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-622">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="09ed2-623">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-623">**First Example**</span></span>  
  
 <span data-ttu-id="09ed2-624">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>來儲存執行緒特定資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-624">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-625">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="09ed2-625">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="09ed2-626">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-626">**Second Example**</span></span>  
  
 <span data-ttu-id="09ed2-627">下列範例示範如何使用來儲存執行緒特定資訊的具名的資料插槽。</span><span class="sxs-lookup"><span data-stu-id="09ed2-627">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="09ed2-628">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-628">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="09ed2-629">執行緒區域儲存區：執行緒相關的靜態欄位和資料位置</span><span class="sxs-lookup"><span data-stu-id="09ed2-629">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-630">中斷處於 <see langword="WaitSleepJoin" /> 執行緒狀態的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-630">Interrupts a thread that is in the <see langword="WaitSleepJoin" /> thread state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-631">如果這個執行緒目前未遭到封鎖在等候、 睡眠或聯結狀態，它將會中斷時它接下來會開始封鎖。</span><span class="sxs-lookup"><span data-stu-id="09ed2-631">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="09ed2-632"><xref:System.Threading.ThreadInterruptedException> 在插斷的執行緒中，但會在執行緒會封鎖，就會擲回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-632"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="09ed2-633">如果執行緒永不封鎖，永遠不會擲回例外狀況，並因此執行緒可能會完成，而不被插斷。</span><span class="sxs-lookup"><span data-stu-id="09ed2-633">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-634">中斷和後續已遭到封鎖時，下列程式碼範例會顯示執行中執行緒的行為。</span><span class="sxs-lookup"><span data-stu-id="09ed2-634">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="09ed2-635">呼叫端沒有合適的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-635">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="09ed2-636">在執行緒上的進階作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-636">for advanced operations on threads.</span></span> <span data-ttu-id="09ed2-637">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-637">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="09ed2-638">暫停和中斷執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-638">Pausing and interrupting threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="09ed2-639">Managed 執行緒狀態</span><span class="sxs-lookup"><span data-stu-id="09ed2-639">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-640">取得值，指出目前執行緒的執行狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-640">Gets a value indicating the execution status of the current thread.</span></span></summary>
        <value><span data-ttu-id="09ed2-641">如果這個執行緒已經啟動但還沒有正常終止或者中止，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-641"><see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-642">取得或設定值，指出執行緒是不是背景執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-642">Gets or sets a value indicating whether or not a thread is a background thread.</span></span></summary>
        <value><span data-ttu-id="09ed2-643">如果這個執行緒是背景執行緒或者會成為背景執行緒，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-643"><see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-644">執行緒是背景執行緒或前景執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-644">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="09ed2-645">背景執行緒會前景執行緒完全相同的不同之處在於背景執行緒不會防止處理程序終止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-645">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="09ed2-646">一旦屬於處理程序的所有前景執行緒已經都終止，common language runtime 就會結束處理程序。</span><span class="sxs-lookup"><span data-stu-id="09ed2-646">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="09ed2-647">任何剩餘的背景執行緒會停止，而且不會完成。</span><span class="sxs-lookup"><span data-stu-id="09ed2-647">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="09ed2-648">根據預設，下列的執行緒則是在前景中執行 (也就是他們<xref:System.Threading.Thread.IsBackground%2A>屬性會傳回`false`):</span><span class="sxs-lookup"><span data-stu-id="09ed2-648">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="09ed2-649">主執行緒 （或主應用程式執行緒）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-649">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="09ed2-650">藉由呼叫所建立的所有執行緒<xref:System.Threading.Thread>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="09ed2-650">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="09ed2-651">根據預設，下列的執行緒則是在背景中執行 (也就是他們<xref:System.Threading.Thread.IsBackground%2A>屬性會傳回`true`):</span><span class="sxs-lookup"><span data-stu-id="09ed2-651">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="09ed2-652">執行緒集區執行緒，也就是由執行階段所維護的背景工作執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="09ed2-652">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="09ed2-653">您也可以使用執行緒集區執行緒上設定執行緒集區和排程工作<xref:System.Threading.ThreadPool>類別。</span><span class="sxs-lookup"><span data-stu-id="09ed2-653">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="09ed2-654">在執行緒集區執行緒上自動執行工作為基礎的非同步作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-654">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="09ed2-655">從 unmanaged 程式碼來進入 managed 的執行環境的所有執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-655">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-656">下列範例會比對前景和背景執行緒的行為。</span><span class="sxs-lookup"><span data-stu-id="09ed2-656">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="09ed2-657">它會建立幕前執行緒與背景執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-657">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="09ed2-658">在前景執行緒會執行，直到處理程序完成其`for`迴圈，並終止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-658">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="09ed2-659">不過，如範例輸出所示，因為前景執行緒完成執行，程序會終止，背景執行緒完成執行之前。</span><span class="sxs-lookup"><span data-stu-id="09ed2-659">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-660">執行緒已無作用</span><span class="sxs-lookup"><span data-stu-id="09ed2-660">The thread is dead.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md"><span data-ttu-id="09ed2-661">前景和背景執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-661">Foreground and Background Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-662">取得值，指出執行緒是否屬於 Managed 執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="09ed2-662">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span></span></summary>
        <value><span data-ttu-id="09ed2-663"><see langword="true" />，表示這個執行緒屬於 Managed 執行緒集區，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-663"><see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-664">如需詳細資訊，請參閱[managed 的執行緒集區](~/docs/standard/threading/the-managed-thread-pool.md)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-664">For more information see [The managed thread pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-665">下列程式碼範例示範如何判斷執行緒是否在執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="09ed2-665">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="09ed2-666">Managed 執行緒集區</span><span class="sxs-lookup"><span data-stu-id="09ed2-666">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="09ed2-667">封鎖呼叫執行緒，直到此執行個體所代表的執行緒終止為止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-667">Blocks the calling thread until the thread represented by this instance terminates.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-668">封鎖呼叫執行緒，直到此執行個體所代表的執行緒終止為止，但仍會繼續執行標準的 COM 與 <see langword="SendMessage" /> 提取作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-668">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-669"><xref:System.Threading.Thread.Join%2A> 封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到執行緒的同步處理方法的<xref:System.Threading.Thread.Join%2A>方法會呼叫已完成。</span><span class="sxs-lookup"><span data-stu-id="09ed2-669"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="09ed2-670">使用這個方法，以確保執行緒已終止。</span><span class="sxs-lookup"><span data-stu-id="09ed2-670">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="09ed2-671">如果執行緒不會終止時，將會無限期地封鎖呼叫端。</span><span class="sxs-lookup"><span data-stu-id="09ed2-671">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="09ed2-672">在下列範例中，`Thread1`執行緒呼叫<xref:System.Threading.Thread.Join>方法`Thread2`，會造成`Thread1`要區塊，直到`Thread2`已完成。</span><span class="sxs-lookup"><span data-stu-id="09ed2-672">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="09ed2-673">如果執行緒已經終止時<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-673">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="09ed2-674">您應該永遠不會呼叫<xref:System.Threading.Thread.Join%2A>方法的<xref:System.Threading.Thread>物件，表示目前的執行緒從目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-674">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="09ed2-675">這會導致您的應用程式停止回應，因為目前的執行緒時本身會無限期等候，</span><span class="sxs-lookup"><span data-stu-id="09ed2-675">This causes your app to hang because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="09ed2-676">這個方法會變更的狀態呼叫的執行緒，以包含<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-676">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09ed2-677">您無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-677">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-678">呼叫端嘗試聯結處於 <see cref="F:System.Threading.ThreadState.Unstarted" /> 狀態的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-678">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="09ed2-679">執行緒在等待時中斷。</span><span class="sxs-lookup"><span data-stu-id="09ed2-679">The thread is interrupted while waiting.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="09ed2-680">Managed 執行緒狀態</span><span class="sxs-lookup"><span data-stu-id="09ed2-680">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="09ed2-681">等候執行緒終止的毫秒數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-681">The number of milliseconds to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="09ed2-682">封鎖呼叫執行緒，直到此執行個體代表的執行緒終止或超過指定的時間為止，但仍繼續執行標準的 COM 與 SendMessage 提取作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-682">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="09ed2-683">如果執行緒已經終止，為 <see langword="true" />；如果 <see langword="false" /> 參數指定的時間量已經過去，而執行緒還沒有終止，則為 <paramref name="millisecondsTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-683"><see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-684"><xref:System.Threading.Thread.Join%28System.Int32%29> 封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到其中一個執行緒的同步處理方法的<xref:System.Threading.Thread.Join%2A>方法會呼叫已完成或經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="09ed2-684"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="09ed2-685">在下列範例中，`Thread1`執行緒呼叫<xref:System.Threading.Thread.Join>方法`Thread2`，會造成`Thread1`封鎖直到其中一個`Thread2`已完成或經過 2 秒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-685">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="09ed2-686">如果<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>指定了`millisecondsTimeout`參數，這個方法的行為相同<xref:System.Threading.Thread.Join>方法多載，除了傳回的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-686">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="09ed2-687">如果執行緒已經終止時<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-687">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="09ed2-688">這個方法會變更的狀態呼叫的執行緒，以包含<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-688">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09ed2-689">您無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-689">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="09ed2-690"><paramref name="millisecondsTimeout" /> 的值為負數，且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (以毫秒為單位)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-690">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-691">無法啟動此執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-691">The thread has not been started.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="09ed2-692">Managed 執行緒狀態</span><span class="sxs-lookup"><span data-stu-id="09ed2-692">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="09ed2-693"><see cref="T:System.TimeSpan" />，設定為等候執行緒終止的時間量。</span><span class="sxs-lookup"><span data-stu-id="09ed2-693">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="09ed2-694">封鎖呼叫執行緒，直到此執行個體代表的執行緒終止或超過指定的時間為止，但仍繼續執行標準的 COM 與 SendMessage 提取作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-694">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="09ed2-695">如果執行緒終止了，為 <see langword="true" />；如果 <see langword="false" /> 參數指定的時間量已經過去，而執行緒還沒有終止，則為 <paramref name="timeout" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-695"><see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-696"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> 封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到其中一個執行緒的同步處理方法的<xref:System.Threading.Thread.Join%2A>方法會呼叫已完成或經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="09ed2-696"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="09ed2-697">在下列範例中，`Thread1`執行緒呼叫<xref:System.Threading.Thread.Join>方法`Thread2`，會造成`Thread1`封鎖直到其中一個`Thread2`已完成或經過 2 秒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-697">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="09ed2-698">如果<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>指定了`timeout`，這個方法的行為相同<xref:System.Threading.Thread.Join>方法多載，除了傳回的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-698">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="09ed2-699">如果執行緒已經終止時<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-699">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="09ed2-700">這個方法會變更目前的執行緒，可包含的狀態<xref:System.Threading.ThreadState.WaitSleepJoin>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-700">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="09ed2-701">您無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-701">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-702">下列程式碼範例示範如何使用`TimeSpan`具有值`Join`方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-702">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="09ed2-703">值 <paramref name="timeout" /> 為負數且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> 毫秒，或大於 <see cref="F:System.Int32.MaxValue" /> 毫秒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-703">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-704">呼叫端嘗試聯結處於 <see cref="F:System.Threading.ThreadState.Unstarted" /> 狀態的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-704">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="09ed2-705">Managed 執行緒狀態</span><span class="sxs-lookup"><span data-stu-id="09ed2-705">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-706">取得目前 Managed 執行緒的唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="09ed2-706">Gets a unique identifier for the current managed thread.</span></span></summary>
        <value><span data-ttu-id="09ed2-707">整數，表示這個 Managed 執行緒的唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="09ed2-707">An integer that represents a unique identifier for this managed thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-708">執行緒的<xref:System.Threading.Thread.ManagedThreadId%2A>屬性值是用來唯一識別該執行緒在其處理序。</span><span class="sxs-lookup"><span data-stu-id="09ed2-708">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="09ed2-709">值<xref:System.Threading.Thread.ManagedThreadId%2A>屬性不會每一段時間，即使裝載 common language runtime 的 unmanaged 程式碼實作的執行緒與 fiber。</span><span class="sxs-lookup"><span data-stu-id="09ed2-709">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-710">同步處理記憶體存取，如下所示：執行目前執行緒的處理器無法以下列方式重新排列指示：呼叫 <see cref="M:System.Threading.Thread.MemoryBarrier" /> 之前的記憶體存取在呼叫 <see cref="M:System.Threading.Thread.MemoryBarrier" /> 後的記憶體存取之後執行。</span><span class="sxs-lookup"><span data-stu-id="09ed2-710">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-711"><xref:System.Threading.Thread.MemoryBarrier%2A> 需要只在多處理器系統上具有弱式排序 （例如，採用多個 Intel Itanium 處理器的系統） 的記憶體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-711"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="09ed2-712">大部分的用途而言，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，或<xref:System.Threading.Monitor>類別提供簡單的方式同步處理資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-712">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-713">取得或設定執行緒的名稱。</span><span class="sxs-lookup"><span data-stu-id="09ed2-713">Gets or sets the name of the thread.</span></span></summary>
        <value><span data-ttu-id="09ed2-714">含有執行緒名稱的字串；如果沒有設定名稱，則為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-714">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-715">這個屬性是寫-之後。</span><span class="sxs-lookup"><span data-stu-id="09ed2-715">This property is write-once.</span></span> <span data-ttu-id="09ed2-716">因為執行緒的預設值<xref:System.Threading.Thread.Name%2A>屬性是`null`，您可以判斷是否名稱已明確指派給執行緒藉由比較它與`null`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-716">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="09ed2-717">將字串指派到<xref:System.Threading.Thread.Name%2A>屬性可以包含任何 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="09ed2-717">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-718">下列範例顯示如何命名的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-718">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="09ed2-719">要求了一組作業，但是早已設定了 <see langword="Name" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-719">A set operation was requested, but the <see langword="Name" /> property has already been set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-720">取得或設定值，指出執行緒的排程優先權。</span><span class="sxs-lookup"><span data-stu-id="09ed2-720">Gets or sets a value indicating the scheduling priority of a thread.</span></span></summary>
        <value><span data-ttu-id="09ed2-721">其中一個 <see cref="T:System.Threading.ThreadPriority" /> 值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-721">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span></span> <span data-ttu-id="09ed2-722">預設值是 <see cref="F:System.Threading.ThreadPriority.Normal" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-722">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-723">下列優先順序的任何一個可以指派一個執行緒<xref:System.Threading.ThreadPriority>值：</span><span class="sxs-lookup"><span data-stu-id="09ed2-723">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="09ed2-724">作業系統不需要接受執行緒的優先權。</span><span class="sxs-lookup"><span data-stu-id="09ed2-724">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-725">下列範例顯示的執行緒優先順序變更的結果。</span><span class="sxs-lookup"><span data-stu-id="09ed2-725">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="09ed2-726">建立三個執行緒，一個執行緒的優先順序會設為<xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>，而第二個優先權會設定為<xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-726">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09ed2-727">每個執行緒遞增變數中的`while`迴圈，並在一段時間的執行。</span><span class="sxs-lookup"><span data-stu-id="09ed2-727">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-728">此執行緒已達到最終狀態，例如 <see cref="F:System.Threading.ThreadState.Aborted" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-728">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="09ed2-729">針對設定作業指定的值不是有效的 <see cref="T:System.Threading.ThreadPriority" /> 值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-729">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md"><span data-ttu-id="09ed2-730">排程執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-730">Scheduling threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-731">取消為目前執行緒要求的 <see cref="M:System.Threading.Thread.Abort(System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-731">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-732">只有具有適當的權限的程式碼可以呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-732">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="09ed2-733">若要進行呼叫，當`Abort`來終止執行緒，系統會擲回<xref:System.Threading.ThreadAbortException>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-733">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="09ed2-734">`ThreadAbortException` 是特殊的例外狀況的應用程式程式碼，就可以攔截但重新擲回的 catch 區塊的結尾除非`ResetAbort`呼叫。</span><span class="sxs-lookup"><span data-stu-id="09ed2-734">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="09ed2-735">`ResetAbort` 取消要求中止，並防止`ThreadAbortException`無法終止執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-735">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="09ed2-736">請參閱<xref:System.Threading.ThreadAbortException>的範例，示範如何呼叫`ResetAbort`方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-736">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="09ed2-737">僅限 .NET Core：不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="09ed2-737">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-738"><see langword="Abort" /> 不是在目前執行緒上所叫用。</span><span class="sxs-lookup"><span data-stu-id="09ed2-738"><see langword="Abort" /> was not invoked on the current thread.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="09ed2-739">呼叫端沒有目前執行緒的必要安全性權限。</span><span class="sxs-lookup"><span data-stu-id="09ed2-739">The caller does not have the required security permission for the current thread.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="09ed2-740">在執行緒上的進階作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-740">for advanced operations on threads.</span></span> <span data-ttu-id="09ed2-741">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-741">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="09ed2-742">終結執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-742">Destroying threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="09ed2-743">Managed 執行緒狀態</span><span class="sxs-lookup"><span data-stu-id="09ed2-743">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-744">繼續已暫止的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-744">Resumes a thread that has been suspended.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="09ed2-745">請勿使用<xref:System.Threading.Thread.Suspend%2A>和<xref:System.Threading.Thread.Resume%2A>方法來同步處理執行緒活動。</span><span class="sxs-lookup"><span data-stu-id="09ed2-745">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="09ed2-746">您有沒有辦法知道哪些程式碼的執行緒正在執行，當您暫停它。</span><span class="sxs-lookup"><span data-stu-id="09ed2-746">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="09ed2-747">如果安全性權限評估期間保留鎖定時，您就會暫停執行緒，其他執行緒在<xref:System.AppDomain>可能會遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="09ed2-747">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="09ed2-748">如果您暫停執行緒，當它執行時的類別建構函式，其他執行緒在<xref:System.AppDomain>，嘗試使用封鎖的類別。</span><span class="sxs-lookup"><span data-stu-id="09ed2-748">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="09ed2-749">很容易發生死結。</span><span class="sxs-lookup"><span data-stu-id="09ed2-749">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="09ed2-750">僅限 .NET Core：不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="09ed2-750">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-751">執行緒未啟動、已無作用，或不是處於暫停狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-751">The thread has not been started, is dead, or is not in the suspended state.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="09ed2-752">呼叫端沒有合適的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-752">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="09ed2-753">在執行緒上的進階作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-753">for advanced operations on threads.</span></span> <span data-ttu-id="09ed2-754">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="09ed2-754">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="09ed2-755">暫停和中斷執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-755">Pausing and interrupting threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="09ed2-756">Managed 執行緒狀態</span><span class="sxs-lookup"><span data-stu-id="09ed2-756">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="09ed2-757">新的 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-757">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="09ed2-758">在執行緒啟動之前設定其 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-758">Sets the apartment state of a thread before it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-759">新的執行緒都會初始化成<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果其 apartment 狀態尚未設定之前啟動。</span><span class="sxs-lookup"><span data-stu-id="09ed2-759">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="09ed2-760">在執行緒啟動之前，必須設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-760">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-761">主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>預設。</span><span class="sxs-lookup"><span data-stu-id="09ed2-761">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="09ed2-762">設定主要應用程式執行緒的 apartment 狀態的唯一辦法<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>是套用<xref:System.STAThreadAttribute>屬性的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-762">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="09ed2-763"><xref:System.Threading.Thread.SetApartmentState%2A>方法，連同<xref:System.Threading.Thread.GetApartmentState%2A>方法並<xref:System.Threading.Thread.TrySetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-763">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-764">下列程式碼範例示範<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-764">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="09ed2-765">在程式碼範例會建立執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-765">The code example creates a thread.</span></span> <span data-ttu-id="09ed2-766">在執行緒啟動之前，<xref:System.Threading.Thread.GetApartmentState%2A>會顯示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>狀態並<xref:System.Threading.Thread.SetApartmentState%2A>狀態變更為<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-766">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09ed2-767"><xref:System.Threading.Thread.TrySetApartmentState%2A>方法接著會傳回`false`當您嘗試將狀態變更時<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因為已設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-767">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="09ed2-768">如果相同的作業已嘗試使用了<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>就已擲回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-768">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="09ed2-769">在執行緒啟動之後，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法會再次使用。</span><span class="sxs-lookup"><span data-stu-id="09ed2-769">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="09ed2-770">這次會擲回<xref:System.Threading.ThreadStateException>因為尚未啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-770">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="09ed2-771">僅限 .NET Core：macOS 和 Linux 平台不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="09ed2-771">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="09ed2-772"><paramref name="state" /> 的 Apartment 狀態無效。</span><span class="sxs-lookup"><span data-stu-id="09ed2-772"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-773">已經啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-773">The thread has already been started.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="09ed2-774">Apartment 狀態已經初始化。</span><span class="sxs-lookup"><span data-stu-id="09ed2-774">The apartment state has already been initialized.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack"><span data-ttu-id="09ed2-775">要套用到目前執行緒的 <see cref="T:System.Threading.CompressedStack" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="09ed2-775">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span></span></param>
        <summary><span data-ttu-id="09ed2-776">將擷取的 <see cref="T:System.Threading.CompressedStack" /> 套用到目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-776">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-777">不再支援這個方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-777">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="09ed2-778">在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="09ed2-778">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="09ed2-779">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="09ed2-779">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="09ed2-780">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-780">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="09ed2-781">要在其中設定數值的 <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-781">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span></span></param>
        <param name="data"><span data-ttu-id="09ed2-782">要設定的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-782">The value to be set.</span></span></param>
        <summary><span data-ttu-id="09ed2-783">針對那個執行緒目前的定義域，在目前執行之執行緒上的指定位置中設定資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-783">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span></span> <span data-ttu-id="09ed2-784">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-784">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="09ed2-785">.NET Framework 會提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關靜態欄位 (也就是標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-785">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="09ed2-786">執行緒相關靜態欄位提供比資料插槽更好的效能，並可編譯時期類型檢查。</span><span class="sxs-lookup"><span data-stu-id="09ed2-786">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="09ed2-787">如需使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-787">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="09ed2-788">執行緒會使用本機存放區記憶體機制來儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-788">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="09ed2-789">建立時，common language runtime 會配置到每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="09ed2-789">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="09ed2-790">執行緒可以配置的資料存放區中的資料位置、 儲存及擷取資料中的位置、 值和釋放執行緒程序結束後的重複使用的位置和<xref:System.Threading.Thread>已經由記憶體回收回收物件。</span><span class="sxs-lookup"><span data-stu-id="09ed2-790">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="09ed2-791">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="09ed2-791">Data slots are unique per thread.</span></span> <span data-ttu-id="09ed2-792">沒有任何其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-792">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-793"><xref:System.Threading.Thread.SetData%2A> 是`Shared`一律會套用到目前正在執行的執行緒，即使您使用的變數，指的是另一個執行緒呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-793"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="09ed2-794">若要避免混淆，請使用類別名稱呼叫時`Shared`方法： `Thread.SetData(testSlot, "test data")`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-794">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-795">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="09ed2-795">This section contains two code examples.</span></span> <span data-ttu-id="09ed2-796">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性來保留執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-796">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-797">第二個範例示範如何使用資料插槽來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="09ed2-797">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="09ed2-798">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-798">**First Example**</span></span>  
  
 <span data-ttu-id="09ed2-799">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>來儲存執行緒特定資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-799">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="09ed2-800">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="09ed2-800">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="09ed2-801">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="09ed2-801">**Second Example**</span></span>  
  
 <span data-ttu-id="09ed2-802">下列範例示範如何使用來儲存執行緒特定資訊的具名的資料插槽。</span><span class="sxs-lookup"><span data-stu-id="09ed2-802">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="09ed2-803">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-803">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="09ed2-804">執行緒區域儲存區：執行緒相關的靜態欄位和資料位置</span><span class="sxs-lookup"><span data-stu-id="09ed2-804">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="09ed2-805">在指定長度的時間內暫止目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-805">Suspends the current thread for the specified amount of time.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="09ed2-806">暫止執行緒的毫秒數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-806">The number of milliseconds for which the thread is suspended.</span></span> <span data-ttu-id="09ed2-807">如果 <paramref name="millisecondsTimeout" /> 引數的值為零，則執行緒會將其剩餘的時間配量讓與準備好要執行的任何同等優先權執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-807">If the value of the <paramref name="millisecondsTimeout" /> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="09ed2-808">如果沒有其他準備好要執行的同等優先權執行緒，則目前執行緒的執行不會暫停。</span><span class="sxs-lookup"><span data-stu-id="09ed2-808">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="09ed2-809">在指定的毫秒數內暫止目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-809">Suspends the current thread for the specified number of milliseconds.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-810">執行緒將不會排定執行所指定的時間量的作業系統。</span><span class="sxs-lookup"><span data-stu-id="09ed2-810">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="09ed2-811">這個方法會變更要包含執行緒的狀態<xref:System.Threading.ThreadState.WaitSleepJoin>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-811">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="09ed2-812">您可以指定<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>針對`millisecondsTimeout`無限期地暫止這個執行緒的參數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-812">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="09ed2-813">不過，我們建議使用其他<xref:System.Threading?displayProperty=nameWithType>這類類別<xref:System.Threading.Mutex>， <xref:System.Threading.Monitor>， <xref:System.Threading.EventWaitHandle>，或<xref:System.Threading.Semaphore>改為同步處理執行緒或管理資源。</span><span class="sxs-lookup"><span data-stu-id="09ed2-813">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="09ed2-814">在特定速率的系統時鐘刻度呼叫時鐘的解析度。</span><span class="sxs-lookup"><span data-stu-id="09ed2-814">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="09ed2-815">實際逾時可能不完全指定的逾時，因為指定的逾時將會調整以符合時脈週期。</span><span class="sxs-lookup"><span data-stu-id="09ed2-815">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="09ed2-816">如需有關時鐘的解析度和等候時間的詳細資訊，請參閱[睡眠函式](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)主題。</span><span class="sxs-lookup"><span data-stu-id="09ed2-816">For more information on clock resolution and the waiting time, see the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) topic.</span></span> <span data-ttu-id="09ed2-817">這個方法會呼叫[睡眠函式](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)從 Windows 系統的 Api。</span><span class="sxs-lookup"><span data-stu-id="09ed2-817">This method calls the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="09ed2-818">這個方法不會執行標準的 COM 與 SendMessage 幫浦作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-818">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-819">如果您需要有執行緒睡眠<xref:System.STAThreadAttribute>，但您想要執行標準的 COM 與 SendMessage 幫浦作業，請考慮使用其中一個多載<xref:System.Threading.Thread.Join%2A>方法所指定的逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="09ed2-819">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-820">下列範例會使用<xref:System.Threading.Thread.Sleep%2A>封鎖應用程式的主執行緒的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-820">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="09ed2-821">逾時值為負且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-821">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="09ed2-822">暫止執行緒的時間長度。</span><span class="sxs-lookup"><span data-stu-id="09ed2-822">The amount of time for which the thread is suspended.</span></span> <span data-ttu-id="09ed2-823">如果 <paramref name="millisecondsTimeout" /> 引數的值為 <see cref="F:System.TimeSpan.Zero" />，則執行緒會將其剩餘的時間配量讓與準備好要執行的任何同等優先權執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-823">If the value of the <paramref name="millisecondsTimeout" /> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="09ed2-824">如果沒有其他準備好要執行的同等優先權執行緒，則目前執行緒的執行不會暫停。</span><span class="sxs-lookup"><span data-stu-id="09ed2-824">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="09ed2-825">在指定長度的時間內暫止目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-825">Suspends the current thread for the specified amount of time.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-826">執行緒將不會排定執行所指定的時間量的作業系統。</span><span class="sxs-lookup"><span data-stu-id="09ed2-826">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="09ed2-827">這個方法會變更要包含執行緒的狀態<xref:System.Threading.ThreadState.WaitSleepJoin>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-827">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="09ed2-828">您可以指定<xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType>針對`timeout`無限期地暫止這個執行緒的參數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-828">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="09ed2-829">不過，我們建議使用其他<xref:System.Threading?displayProperty=nameWithType>這類類別<xref:System.Threading.Mutex>， <xref:System.Threading.Monitor>， <xref:System.Threading.EventWaitHandle>，或<xref:System.Threading.Semaphore>改為同步處理執行緒或管理資源。</span><span class="sxs-lookup"><span data-stu-id="09ed2-829">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="09ed2-830">這個多載<xref:System.Threading.Thread.Sleep%2A>使用中的整數毫秒總數`timeout`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-830">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="09ed2-831">小數部分的毫秒都會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="09ed2-831">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="09ed2-832">這個方法不會執行標準的 COM 與 SendMessage 幫浦作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-832">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-833">如果您需要有執行緒睡眠<xref:System.STAThreadAttribute>，但您想要執行標準的 COM 與 SendMessage 幫浦作業，請考慮使用其中一個多載<xref:System.Threading.Thread.Join%2A>方法所指定的逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="09ed2-833">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-834">下列範例會使用<xref:System.Threading.Thread.Sleep%28System.TimeSpan%29>兩秒每次五次，封鎖應用程式的主執行緒的方法多載。</span><span class="sxs-lookup"><span data-stu-id="09ed2-834">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="09ed2-835">值 <paramref name="timeout" /> 為負數且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> 毫秒，或大於 <see cref="F:System.Int32.MaxValue" /> 毫秒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-835">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations"><span data-ttu-id="09ed2-836">32 位元帶正負號的整數，定義執行緒要等候多久。</span><span class="sxs-lookup"><span data-stu-id="09ed2-836">A 32-bit signed integer that defines how long a thread is to wait.</span></span></param>
        <summary><span data-ttu-id="09ed2-837">造成執行緒等候 <paramref name="iterations" /> 參數定義的次數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-837">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-838"><xref:System.Threading.Thread.SpinWait%2A>方法適合用來實作鎖定。</span><span class="sxs-lookup"><span data-stu-id="09ed2-838">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="09ed2-839">在.NET Framework 中，這類類別<xref:System.Threading.Monitor>和<xref:System.Threading.ReaderWriterLock>，這個方法會在內部使用。</span><span class="sxs-lookup"><span data-stu-id="09ed2-839">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="09ed2-840"><xref:System.Threading.Thread.SpinWait%2A> 基本上是放在處理器非常緊密迴圈中，與所指定的迴圈計數`iterations`參數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-840"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="09ed2-841">在等待期間因此取決於處理器的速度。</span><span class="sxs-lookup"><span data-stu-id="09ed2-841">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="09ed2-842">使用與此相反<xref:System.Threading.Thread.Sleep%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-842">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="09ed2-843">呼叫的執行緒<xref:System.Threading.Thread.Sleep%2A>會產生其目前的配量的處理器時間的其餘部分，即使指定的間隔為零。</span><span class="sxs-lookup"><span data-stu-id="09ed2-843">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="09ed2-844">指定非零間隔<xref:System.Threading.Thread.Sleep%2A>經過的時間間隔之前執行緒移除執行緒排程器的考量。</span><span class="sxs-lookup"><span data-stu-id="09ed2-844">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="09ed2-845"><xref:System.Threading.Thread.SpinWait%2A> 不通常適用於一般的應用程式。</span><span class="sxs-lookup"><span data-stu-id="09ed2-845"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="09ed2-846">在大部分情況下，您應該使用.NET Framework; 所提供的同步處理類別例如，呼叫<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>或陳述式包裝<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>(`lock`在 C# 或`SyncLock`Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-846">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="09ed2-847">在少數情況下，很有幫助避免內容切換，例如當您知道狀態變更會馬上發生，請呼叫<xref:System.Threading.Thread.SpinWait%2A>在迴圈中的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-847">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="09ed2-848">程式碼<xref:System.Threading.Thread.SpinWait%2A>執行設計是為了防止在多個處理器的電腦上可能發生的問題。</span><span class="sxs-lookup"><span data-stu-id="09ed2-848">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="09ed2-849">例如，在多個採用超執行緒技術的 Intel 處理器的電腦上<xref:System.Threading.Thread.SpinWait%2A>可防止在某些情況下的處理器資源用盡。</span><span class="sxs-lookup"><span data-stu-id="09ed2-849">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="09ed2-850">使執行緒進行執行排程。</span><span class="sxs-lookup"><span data-stu-id="09ed2-850">Causes a thread to be scheduled for execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-851">造成作業系統將目前執行個體的狀態變更為 <see cref="F:System.Threading.ThreadState.Running" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-851">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-852">一旦執行緒處於<xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>狀態時，作業系統可以將它排程執行。</span><span class="sxs-lookup"><span data-stu-id="09ed2-852">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="09ed2-853">在執行緒開始執行所表示之方法的第一行<xref:System.Threading.ThreadStart>或<xref:System.Threading.ParameterizedThreadStart>執行緒建構函式所提供的委派。</span><span class="sxs-lookup"><span data-stu-id="09ed2-853">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="09ed2-854">請注意，呼叫<xref:System.Threading.Thread.Start%2A>不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-854">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-855">如果這個多載搭配使用所建立的執行緒<xref:System.Threading.ParameterizedThreadStart>委派，`null`傳遞至執行緒所執行的方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-855">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="09ed2-856">一旦執行緒結束時，它無法重新啟動再呼叫一次`Start`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-856">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-857">下列範例會建立並啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-857">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-858">已經啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-858">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="09ed2-859">沒有足夠的記憶體可用來啟動這個執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-859">There is not enough memory available to start this thread.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="09ed2-860">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="09ed2-860">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="09ed2-861">建立執行緒並在啟動時間傳遞資料</span><span class="sxs-lookup"><span data-stu-id="09ed2-861">Creating Threads and Passing Data at Start Time</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter"><span data-ttu-id="09ed2-862">物件，包含執行緒執行之方法所要使用的資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-862">An object that contains data to be used by the method the thread executes.</span></span></param>
        <summary><span data-ttu-id="09ed2-863">使作業系統將目前執行個體的狀態改成 <see cref="F:System.Threading.ThreadState.Running" />，並選擇性地提供物件，在物件中包含執行緒執行之方法所要使用的資料。</span><span class="sxs-lookup"><span data-stu-id="09ed2-863">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-864">一旦執行緒處於<xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>狀態時，作業系統可以將它排程執行。</span><span class="sxs-lookup"><span data-stu-id="09ed2-864">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="09ed2-865">在執行緒開始執行所表示之方法的第一行<xref:System.Threading.ThreadStart>或<xref:System.Threading.ParameterizedThreadStart>執行緒建構函式所提供的委派。</span><span class="sxs-lookup"><span data-stu-id="09ed2-865">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="09ed2-866">請注意，呼叫<xref:System.Threading.Thread.Start%2A>不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-866">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="09ed2-867">一旦執行緒結束時，它無法重新啟動再呼叫一次`Start`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-867">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="09ed2-868">這個多載和<xref:System.Threading.ParameterizedThreadStart>委派讓您輕鬆地將資料傳遞至執行緒程序，但技術不安全的型別因為任何物件可以傳遞至這個多載。</span><span class="sxs-lookup"><span data-stu-id="09ed2-868">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="09ed2-869">更穩固的方式，將資料傳遞至執行緒程序是進入背景工作物件中的執行緒程序和資料欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-869">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="09ed2-870">如需詳細資訊，請參閱 <<c0> [ 建立的執行緒和開始時間傳遞資料](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-870">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-871">下列範例會建立<xref:System.Threading.ParameterizedThreadStart>的靜態方法與執行個體方法的委派。</span><span class="sxs-lookup"><span data-stu-id="09ed2-871">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-872">已經啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-872">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="09ed2-873">沒有足夠的記憶體可用來啟動這個執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-873">There is not enough memory available to start this thread.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="09ed2-874">這個執行緒是使用 <see cref="T:System.Threading.ThreadStart" /> 委派建立，而非 <see cref="T:System.Threading.ParameterizedThreadStart" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="09ed2-874">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="09ed2-875">建立執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-875">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-876">將執行緒暫止；或者如果執行緒已經暫止，則沒有影響。</span><span class="sxs-lookup"><span data-stu-id="09ed2-876">Either suspends the thread, or if the thread is already suspended, has no effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-877">如果執行緒已經暫止，這個方法沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="09ed2-877">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="09ed2-878">請勿使用<xref:System.Threading.Thread.Suspend%2A>和<xref:System.Threading.Thread.Resume%2A>方法來同步處理執行緒活動。</span><span class="sxs-lookup"><span data-stu-id="09ed2-878">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="09ed2-879">您有沒有辦法知道哪些程式碼的執行緒正在執行，當您暫停它。</span><span class="sxs-lookup"><span data-stu-id="09ed2-879">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="09ed2-880">如果安全性權限評估期間保留鎖定時，您就會暫停執行緒，其他執行緒在<xref:System.AppDomain>可能會遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="09ed2-880">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="09ed2-881">如果您暫停執行緒，當它執行時的類別建構函式，其他執行緒在<xref:System.AppDomain>，嘗試使用封鎖的類別。</span><span class="sxs-lookup"><span data-stu-id="09ed2-881">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="09ed2-882">很容易發生死結。</span><span class="sxs-lookup"><span data-stu-id="09ed2-882">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="09ed2-883">僅限 .NET Core：不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="09ed2-883">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-884">執行緒未啟動或無作用。</span><span class="sxs-lookup"><span data-stu-id="09ed2-884">The thread has not been started or is dead.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="09ed2-885">呼叫端沒有合適的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-885">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="09ed2-886">在執行緒上的進階作業。</span><span class="sxs-lookup"><span data-stu-id="09ed2-886">for advanced operations on threads.</span></span> <span data-ttu-id="09ed2-887">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-887">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="09ed2-888">暫停和中斷執行緒</span><span class="sxs-lookup"><span data-stu-id="09ed2-888">Pausing and interrupting threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="09ed2-889">Managed 執行緒狀態</span><span class="sxs-lookup"><span data-stu-id="09ed2-889">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="09ed2-890">保留供未來使用。</span><span class="sxs-lookup"><span data-stu-id="09ed2-890">Reserved for future use.</span></span> <span data-ttu-id="09ed2-891">必須是 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="09ed2-891">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="09ed2-892">要對應之傳入的名稱陣列。</span><span class="sxs-lookup"><span data-stu-id="09ed2-892">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="09ed2-893">要對應的名稱計數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-893">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="09ed2-894">用於解譯名稱的地區設定內容。</span><span class="sxs-lookup"><span data-stu-id="09ed2-894">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="09ed2-895">呼叫端配置的陣列，用於接收對應於名稱的 ID。</span><span class="sxs-lookup"><span data-stu-id="09ed2-895">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="09ed2-896">將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-896">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-897">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-897">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="09ed2-898">如需詳細資訊`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="09ed2-898">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="09ed2-899">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-899">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="09ed2-900">要傳回的類型資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-900">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="09ed2-901">類型資訊的地區設定識別項。</span><span class="sxs-lookup"><span data-stu-id="09ed2-901">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="09ed2-902">接收要求的類型資訊物件的指標。</span><span class="sxs-lookup"><span data-stu-id="09ed2-902">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="09ed2-903">擷取物件的類型資訊，可以用來取得介面的類型資訊。</span><span class="sxs-lookup"><span data-stu-id="09ed2-903">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-904">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-904">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="09ed2-905">如需詳細資訊`IDispatch::GetTypeInfo`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="09ed2-905">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="09ed2-906">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-906">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="09ed2-907">指向接收物件提供的類型資訊介面數目的位置。</span><span class="sxs-lookup"><span data-stu-id="09ed2-907">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="09ed2-908">擷取物件提供的類型資訊介面數目 (0 或 1)。</span><span class="sxs-lookup"><span data-stu-id="09ed2-908">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-909">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-909">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="09ed2-910">如需詳細資訊`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="09ed2-910">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="09ed2-911">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-911">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="09ed2-912">辨識成員。</span><span class="sxs-lookup"><span data-stu-id="09ed2-912">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="09ed2-913">保留供未來使用。</span><span class="sxs-lookup"><span data-stu-id="09ed2-913">Reserved for future use.</span></span> <span data-ttu-id="09ed2-914">必須是 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="09ed2-914">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="09ed2-915">地區設定內容，用於解譯引數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-915">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="09ed2-916">描述呼叫之內容的旗標。</span><span class="sxs-lookup"><span data-stu-id="09ed2-916">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="09ed2-917">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</span><span class="sxs-lookup"><span data-stu-id="09ed2-917">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="09ed2-918">指向用於儲存結果之位置的指標。</span><span class="sxs-lookup"><span data-stu-id="09ed2-918">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="09ed2-919">包含例外狀況資訊的結構指標。</span><span class="sxs-lookup"><span data-stu-id="09ed2-919">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="09ed2-920">第一個有錯誤的引數索引。</span><span class="sxs-lookup"><span data-stu-id="09ed2-920">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="09ed2-921">提供物件所公開的屬性和方法的存取權。</span><span class="sxs-lookup"><span data-stu-id="09ed2-921">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-922">這個方法會從 unmanaged 程式碼，是用於存取 managed 類別，並不會呼叫從 managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="09ed2-922">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="09ed2-923">如需詳細資訊`IDispatch::Invoke`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="09ed2-923">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="09ed2-924">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-924">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09ed2-925">取得數值，包含目前執行緒的狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-925">Gets a value containing the states of the current thread.</span></span></summary>
        <value><span data-ttu-id="09ed2-926">其中一個 <see cref="T:System.Threading.ThreadState" /> 數值，指出目前執行緒的狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-926">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span></span> <span data-ttu-id="09ed2-927">初始值為 <see langword="Unstarted" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-927">The initial value is <see langword="Unstarted" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-928"><xref:System.Threading.Thread.ThreadState%2A>屬性會提供更具體資訊比<xref:System.Threading.Thread.IsAlive%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-928">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="09ed2-929">執行緒狀態只是想要偵錯案例。</span><span class="sxs-lookup"><span data-stu-id="09ed2-929">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="09ed2-930">您的程式碼絕對不應該使用執行緒狀態來同步處理執行緒活動。</span><span class="sxs-lookup"><span data-stu-id="09ed2-930">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-931">下列程式碼範例將示範如何存取`ThreadState`往來文章。</span><span class="sxs-lookup"><span data-stu-id="09ed2-931">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="09ed2-932">Managed 執行緒狀態</span><span class="sxs-lookup"><span data-stu-id="09ed2-932">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="09ed2-933">新的 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-933">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="09ed2-934">在執行緒啟動之前設定其 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-934">Sets the apartment state of a thread before it is started.</span></span></summary>
        <returns><span data-ttu-id="09ed2-935">如果已設定 Apartment 狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-935"><see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-936">新的執行緒都會初始化成<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果其 apartment 狀態尚未設定之前啟動。</span><span class="sxs-lookup"><span data-stu-id="09ed2-936">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="09ed2-937">在執行緒啟動之前，必須設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-937">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-938">主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>預設。</span><span class="sxs-lookup"><span data-stu-id="09ed2-938">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="09ed2-939">設定主要應用程式執行緒的 apartment 狀態的唯一辦法<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>是套用<xref:System.STAThreadAttribute>屬性的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-939">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="09ed2-940"><xref:System.Threading.Thread.TrySetApartmentState%2A>方法，連同<xref:System.Threading.Thread.GetApartmentState%2A>方法並<xref:System.Threading.Thread.SetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="09ed2-940">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="09ed2-941">下列程式碼範例示範<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="09ed2-941">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="09ed2-942">在程式碼範例會建立執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-942">The code example creates a thread.</span></span> <span data-ttu-id="09ed2-943">在執行緒啟動之前，<xref:System.Threading.Thread.GetApartmentState%2A>會顯示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>狀態並<xref:System.Threading.Thread.SetApartmentState%2A>狀態變更為<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-943">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="09ed2-944"><xref:System.Threading.Thread.TrySetApartmentState%2A>方法接著會傳回`false`當您嘗試將狀態變更時<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因為已設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="09ed2-944">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="09ed2-945">如果相同的作業已嘗試使用了<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>就已擲回。</span><span class="sxs-lookup"><span data-stu-id="09ed2-945">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="09ed2-946">在執行緒啟動之後，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法會再次使用。</span><span class="sxs-lookup"><span data-stu-id="09ed2-946">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="09ed2-947">這次會擲回<xref:System.Threading.ThreadStateException>因為尚未啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-947">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="09ed2-948"><paramref name="state" /> 的 Apartment 狀態無效。</span><span class="sxs-lookup"><span data-stu-id="09ed2-948"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="09ed2-949">已經啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-949">The thread has already been started.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="09ed2-950">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-950">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-951">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-951">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-952">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-952">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-953">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-953">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-954">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-954">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-955">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-955">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-956"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-956"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-957">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-957">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-958">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-958">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-959">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-959">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-960">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-960">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-961">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-961">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-962">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-962">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-963">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-963">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-964">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-964">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-965">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-965">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-966">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-966">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-967">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-967">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-968">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-968">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-969"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-969"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-970">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-970">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-971">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-971">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-972">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-972">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-973">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-973">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-974">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-974">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-975">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-975">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-976">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-976">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-977">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-977">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-978">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-978">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-979">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-979">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-980">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-980">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-981">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-981">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-982"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-982"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-983">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-983">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-984">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-984">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-985">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-985">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-986">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-986">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-987">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-987">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-988">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-988">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-989">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-989">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-990">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-990">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-991">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-991">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-992">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-992">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-993">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-993">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-994">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-994">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-995"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-995"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-996">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-996">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-997">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-997">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-998">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-998">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-999">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-999">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1000">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1000">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1001">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1001">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1002">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1002">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1003">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1003">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1004">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1004">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-1005">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1005">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-1006">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1006">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-1007">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1007">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1008"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1008"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1009">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1009">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1010">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1010">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-1011">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1011">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1012">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1012">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1013">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1013">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1014">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1014">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1015">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1015">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1016">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1016">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1017">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1017">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-1018">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1018">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-1019">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1019">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-1020">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1020">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1021"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1021"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1022">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1022">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1023">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1023">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-1024">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1024">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1025">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1025">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1026">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1026">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1027">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1027">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1028">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1028">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1029">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1029">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1030">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1030">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-1031">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1031">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-1032">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1032">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-1033">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1033">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1034"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1034"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1035">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1035">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1036">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1036">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-1037">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1037">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1038">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1038">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1039">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1039">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1040">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1040">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1041">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1041">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1042">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1042">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1043">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1043">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-1044">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1044">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-1045">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1045">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-1046">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1046">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1047"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1047"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1048">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1048">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1049">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1049">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-1050">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1050">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1051">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1051">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1052">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1052">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1053">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1053">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1054">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1054">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1055">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1055">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1056">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1056">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-1057">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1057">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-1058">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1058">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-1059">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1059">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1060"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1060"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1061">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1061">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1062">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1062">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-1063">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1063">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1064">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1064">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1065">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1065">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1066">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1066">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1067">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1067">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1068">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1068">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1069">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1069">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-1070">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1070">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-1071">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1071">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-1072">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1072">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1073"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1073"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1074">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1074">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1075">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1075">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-1076">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1076">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1077">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1077">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1078">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1078">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1079">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1079">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1080">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1080">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1081">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1081">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1082">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1082">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-1083">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1083">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-1084">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1084">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-1085">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1085">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1086"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1086"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1087">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1087">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1088">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1088">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-1089">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1089">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1090">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1090">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1091">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1091">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1092">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1092">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1093">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1093">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1094">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1094">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1095">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1095">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-1096">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1096">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-1097">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1097">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-1098">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1098">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1099"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1099"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1100">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1100">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1101">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1101">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-1102">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1102">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1103">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1103">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1104">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1104">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1105">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1105">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1106">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1106">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1107">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1107">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1108">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1108">The field to be read.</span></span></param>
        <summary><span data-ttu-id="09ed2-1109">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1109">Reads the value of a field.</span></span> <span data-ttu-id="09ed2-1110">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1110">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="09ed2-1111">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1111">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1112"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1112"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1113">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1113">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1114">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得由任意處理器寫入記憶體位置的最新值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1114">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="09ed2-1115">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1115">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1116">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1116">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1117">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1117">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1118">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1118">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1119">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1119">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1120">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1120">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="09ed2-1121">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1121">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1122">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1122">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1123">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1123">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1124">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1124">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1125"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1125"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1126">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1126">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1127">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1127">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1128">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1128">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1129">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1129">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1130">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1130">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1131">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1131">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1132">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1132">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1133">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1133">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1134">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1134">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1135">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1135">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1136">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1136">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1137"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1137"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1138">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1138">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1139">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1139">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1140">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1140">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1141">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1141">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1142">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1142">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1143">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1143">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1144">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1144">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1145">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1145">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1146">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1146">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1147">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1147">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1148">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1148">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1149"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1149"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1150">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1150">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1151">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1151">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1152">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1152">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1153">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1153">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1154">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1154">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1155">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1155">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1156">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1156">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1157">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1157">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1158">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1158">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1159">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1159">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1160">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1160">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1161"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1161"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1162">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1162">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1163">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1163">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1164">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1164">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1165">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1165">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1166">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1166">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1167">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1167">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1168">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1168">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1169">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1169">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1170">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1170">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1171">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1171">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1172">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1172">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1173"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1173"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1174">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1174">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1175">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1175">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1176">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1176">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1177">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1177">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1178">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1178">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1179">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1179">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1180">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1180">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1181">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1181">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1182">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1182">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1183">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1183">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1184">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1184">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1185"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1185"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1186">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1186">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1187">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1187">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1188">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1188">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1189">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1189">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1190">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1190">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1191">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1191">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1192">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1192">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1193">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1193">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1194">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1194">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1195">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1195">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1196">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1196">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1197"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1197"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1198">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1198">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1199">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1199">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1200">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1200">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1201">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1201">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1202">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1202">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1203">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1203">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1204">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1204">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1205">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1205">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1206">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1206">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1207">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1207">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1208">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1208">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1209"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1209"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1210">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1210">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1211">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1211">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1212">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1212">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1213">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1213">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1214">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1214">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1215">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1215">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1216">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1216">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1217">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1217">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1218">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1218">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1219">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1219">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1220">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1220">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1221"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1221"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1222">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1222">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1223">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1223">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1224">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1224">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1225">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1225">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1226">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1226">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1227">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1227">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1228">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1228">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1229">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1229">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1230">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1230">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1231">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1231">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1232">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1232">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1233"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1233"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1234">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1234">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1235">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1235">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1236">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1236">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1237">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1237">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1238">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1238">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1239">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1239">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1240">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1240">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1241">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1241">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1242">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1242">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1243">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1243">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1244">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1244">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1245"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1245"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1246">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1246">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1247">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1247">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1248">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1248">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1249">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1249">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1250">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1250">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1251">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1251">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1252">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1252">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1253">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1253">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1254">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1254">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1255">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1255">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1256">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1256">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1257"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1257"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1258">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1258">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1259">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1259">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1260">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1260">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1261">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1261">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1262">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1262">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1263">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1263">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1264">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1264">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1265">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1265">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="09ed2-1266">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1266">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="09ed2-1267">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1267">The value to be written.</span></span></param>
        <summary><span data-ttu-id="09ed2-1268">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1268">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1269"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>是特殊的情況下，同步處理。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1269"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="09ed2-1270">在正常的情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1270">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="09ed2-1271">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1271">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="09ed2-1272">這可能需要排清處理器快取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1272">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="09ed2-1273">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某個值，讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1273">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="09ed2-1274">因此，您可以使用它們來同步存取的欄位，您可以更新由另一個執行緒，或由硬體。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1274">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="09ed2-1275">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1275">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="09ed2-1276">若要提供有效的同步處理欄位，欄位的所有存取都必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1276">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09ed2-1277">在 C# 中，使用`volatile`修飾詞的欄位可保證該欄位的所有存取都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1277">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09ed2-1278">造成呼叫執行緒執行目前處理器上已就緒可執行的其他執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1278">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span></span> <span data-ttu-id="09ed2-1279">作業系統會選擇要執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1279">The operating system selects the thread to yield to.</span></span></summary>
        <returns><span data-ttu-id="09ed2-1280">如果作業系統切換為執行其他執行緒，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1280"><see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09ed2-1281">如果這個方法成功，會產生執行緒的目前時間配量的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1281">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="09ed2-1282">作業系統排程另一個時間配量，根據其優先順序和可執行其他執行緒的狀態呼叫的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1282">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="09ed2-1283">產生僅限於用來執行呼叫的執行緒的處理器。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1283">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="09ed2-1284">作業系統不會切換執行為另一個處理器，即使該處理器處於閒置狀態，或正在執行較低優先權的執行緒。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1284">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="09ed2-1285">如果有沒有其他準備好在目前的處理器上執行的執行緒、 作業系統不會產生執行，且這個方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1285">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="09ed2-1286">這個方法相當於使用平台叫用呼叫原生 Win32`SwitchToThread`函式。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1286">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="09ed2-1287">您應該呼叫<xref:System.Threading.Thread.Yield%2A>方法，而不是使用平台叫用，因為平台叫用任何自訂的執行緒行為主應用程式已要求的許可。</span><span class="sxs-lookup"><span data-stu-id="09ed2-1287">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>