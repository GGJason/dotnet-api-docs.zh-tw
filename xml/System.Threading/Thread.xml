<Type Name="Thread" FullName="System.Threading.Thread">
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="78f4c-101">可建立和控制執行緒，設定執行緒的優先權，並取得它的狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-101">Creates and controls a thread, sets its priority, and gets its status.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-102">當處理程序啟動時，common language runtime 會自動建立單一前景執行緒來執行應用程式程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="78f4c-103">這個主要前景執行緒，以及處理序可建立一或多個執行緒來執行此程序相關聯的程式碼的一部分。</span><span class="sxs-lookup"><span data-stu-id="78f4c-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="78f4c-104">這些執行緒可以執行在前景或背景。</span><span class="sxs-lookup"><span data-stu-id="78f4c-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="78f4c-105">此外，您可以使用<xref:System.Threading.ThreadPool>common language runtime 所管理的背景工作執行緒上執行程式碼的類別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="78f4c-106">本節內容</span><span class="sxs-lookup"><span data-stu-id="78f4c-106">In this section</span></span>  
  
 <span data-ttu-id="78f4c-107">[啟動執行緒](#Starting) </span><span class="sxs-lookup"><span data-stu-id="78f4c-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="78f4c-108">[擷取執行緒物件](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="78f4c-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="78f4c-109">[前景和背景執行緒](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="78f4c-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="78f4c-110">[文化特性和執行緒](#Culture) </span><span class="sxs-lookup"><span data-stu-id="78f4c-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="78f4c-111">取得相關資訊和控制執行緒</span><span class="sxs-lookup"><span data-stu-id="78f4c-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="78f4c-112">啟動執行緒</span><span class="sxs-lookup"><span data-stu-id="78f4c-112">Starting a thread</span></span>  
 <span data-ttu-id="78f4c-113">您可以啟動執行緒藉由提供委派，表示要在其類別建構函式中執行執行緒的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="78f4c-114">然後呼叫<xref:System.Threading.Thread.Start%2A>開始執行的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="78f4c-115"><xref:System.Threading.Thread>建構函式可以採用兩個委派類型，根據是否將引數傳遞至方法，以執行其中一項：</span><span class="sxs-lookup"><span data-stu-id="78f4c-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="78f4c-116">如果方法沒有引數，傳遞<xref:System.Threading.ThreadStart>委派建構函式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="78f4c-117">它的簽章：</span><span class="sxs-lookup"><span data-stu-id="78f4c-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="78f4c-118">下列範例會建立並開始執行的執行緒`ExecuteInForeground`方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="78f4c-119">方法會顯示一些執行緒屬性的相關資訊，然後執行的迴圈，它會暫停半秒並會顯示經過的秒數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="78f4c-120">當執行緒已執行至少五秒時，則迴圈結束，且在執行緒結束執行。</span><span class="sxs-lookup"><span data-stu-id="78f4c-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="78f4c-121">如果方法沒有引數，傳遞<xref:System.Threading.ParameterizedThreadStart>委派建構函式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="78f4c-122">它的簽章：</span><span class="sxs-lookup"><span data-stu-id="78f4c-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="78f4c-123">然後委派所執行的方法可以轉型 （C# 中），或者 （在 Visual Basic) 參數轉換成適當的型別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="78f4c-124">下列範例等同於前一個，不同之處在於它會呼叫<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="78f4c-125">這個版本的`ExecuteInForeground`方法具有單一參數來表示近似的迴圈是執行的毫秒數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="78f4c-126">不需要保留的參考<xref:System.Threading.Thread>物件一旦啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="78f4c-127">執行緒會繼續執行直到完成為止，執行緒程序。</span><span class="sxs-lookup"><span data-stu-id="78f4c-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="78f4c-128">擷取執行緒物件</span><span class="sxs-lookup"><span data-stu-id="78f4c-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="78f4c-129">您可以使用靜態 (`Shared`在 Visual Basic 中)<xref:System.Threading.Thread.CurrentThread%2A>屬性，以擷取目前執行中執行緒的執行緒正在執行的程式碼中的參考。</span><span class="sxs-lookup"><span data-stu-id="78f4c-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="78f4c-130">下列範例會使用<xref:System.Threading.Thread.CurrentThread%2A>屬性來顯示主應用程式執行緒、 另一個前景執行緒，背景執行緒和執行緒集區執行緒的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="78f4c-131">前景和背景執行緒</span><span class="sxs-lookup"><span data-stu-id="78f4c-131">Foreground and background threads</span></span>  
 <span data-ttu-id="78f4c-132">執行個體<xref:System.Threading.Thread>類別代表前景執行緒或背景執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="78f4c-133">背景執行緒會與相同前景執行緒有一個例外狀況： 背景執行緒不會保存執行的處理序，如果所有的前景執行緒已經終止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="78f4c-134">一旦所有的前景執行緒都已停止，執行階段會停止所有的背景執行緒，並關閉。</span><span class="sxs-lookup"><span data-stu-id="78f4c-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="78f4c-135">根據預設，下列的執行緒在前景執行：</span><span class="sxs-lookup"><span data-stu-id="78f4c-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="78f4c-136">主應用程式執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="78f4c-137">藉由呼叫建立的所有執行緒<xref:System.Threading.Thread>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="78f4c-138">根據預設，在背景中執行下列執行緒：</span><span class="sxs-lookup"><span data-stu-id="78f4c-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="78f4c-139">執行緒集區執行緒，也就是由執行階段所維護的背景工作執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="78f4c-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="78f4c-140">您也可以使用執行緒集區執行緒上設定執行緒集區和排程工作<xref:System.Threading.ThreadPool>類別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="78f4c-141">在執行緒集區執行緒上自動執行工作為基礎的非同步作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="78f4c-142">以工作為基礎的非同步作業會使用<xref:System.Threading.Tasks.Task>和<xref:System.Threading.Tasks.Task%601>類別以實作[工作架構非同步模式](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="78f4c-143">從 unmanaged 程式碼進入 managed 的執行環境的所有執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="78f4c-144">您可以變更執行緒在背景中執行，藉由設定<xref:System.Threading.Thread.IsBackground%2A>隨時屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="78f4c-145">背景執行緒可用於任何作業，應該只要應用程式正在執行，但應該不會防止應用程式終止，例如監視檔案系統變更或連入通訊端連線。</span><span class="sxs-lookup"><span data-stu-id="78f4c-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="78f4c-146">下列範例說明前景和背景執行緒之間的差異。</span><span class="sxs-lookup"><span data-stu-id="78f4c-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="78f4c-147">就像中的第一個範例[啟動執行緒](#Starting)區段中，不同之處在於它會設定執行緒在背景執行前啟動它。</span><span class="sxs-lookup"><span data-stu-id="78f4c-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="78f4c-148">如輸出所示，它會執行五秒前中斷迴圈。</span><span class="sxs-lookup"><span data-stu-id="78f4c-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="78f4c-149">文化特性和執行緒</span><span class="sxs-lookup"><span data-stu-id="78f4c-149">Culture and threads</span></span>  
 <span data-ttu-id="78f4c-150">每個執行緒有所代表的文化特性，<xref:System.Threading.Thread.CurrentCulture%2A>屬性和 UI 文化特性所表示<xref:System.Threading.Thread.CurrentUICulture%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="78f4c-151">目前的文化特性支援剖析和格式、 字串比較和排序，這類區分文化特性的作業，而且也會控制執行緒使用的行事曆與書寫系統。</span><span class="sxs-lookup"><span data-stu-id="78f4c-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="78f4c-152">目前 UI 文化特性提供區分文化特性擷取資源檔中的資源。</span><span class="sxs-lookup"><span data-stu-id="78f4c-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  
  
 <span data-ttu-id="78f4c-153">新的執行緒會具現化，其文化特性和 UI 文化特性定義的目前系統文化特性和 UI 文化特性，而不是文化特性和 UI 文化特性建立新的執行緒的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-153">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="78f4c-154">這表示，例如，如果目前的系統文化特性是英文 （美國） 和主要的應用程式執行緒的目前文化特性為法文 （法國），藉由呼叫建立新執行緒的文化特性<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>從主執行緒的建構函式是英文 （美國） 和法文 （法國）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-154">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="78f4c-155">如需詳細資訊，請參閱 < 文化特性和執行緒 」 一節<xref:System.Globalization.CultureInfo>類別主題。</span><span class="sxs-lookup"><span data-stu-id="78f4c-155">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f4c-156">這不是執行非同步作業的應用程式為目標的執行緒，則為 true[!INCLUDE[net_v46](~/includes/net-v46-md.md)]和更新版本中的，在此情況下，文化特性和 UI 文化特性是一部分的非同步作業的內容; 在執行緒上的非同步作業執行的預設繼承的文化特性和 UI 文化特性的非同步作業已啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-156">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="78f4c-157">如需詳細資訊，請參閱 <xref:System.Globalization.CultureInfo> 類別主題的＜文化特性和以工作為基礎的非同步作業＞一節。</span><span class="sxs-lookup"><span data-stu-id="78f4c-157">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="78f4c-158">您可以執行下列動作，以確保所有的執行緒執行的應用程式中共用相同的文化特性和 UI 文化特性：</span><span class="sxs-lookup"><span data-stu-id="78f4c-158">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="78f4c-159">您可以傳遞<xref:System.Globalization.CultureInfo>物件，代表該文化特性<xref:System.Threading.ParameterizedThreadStart>委派或<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-159">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="78f4c-160">在上執行的應用程式[!INCLUDE[net_v45](~/includes/net-v45-md.md)]和更新版本中，您可以定義的文化特性和 UI 文化特性所要指派給所設定的值建立應用程式定義域中的所有執行緒<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-160">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="78f4c-161">請注意，這是每個應用程式網域設定。</span><span class="sxs-lookup"><span data-stu-id="78f4c-161">Note that this is a per-application domain setting.</span></span>  
  
 <span data-ttu-id="78f4c-162">如需詳細資訊與範例，請參閱 < 文化特性和執行緒 > 一節<xref:System.Globalization.CultureInfo>類別主題。</span><span class="sxs-lookup"><span data-stu-id="78f4c-162">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="78f4c-163">取得相關資訊和控制執行緒</span><span class="sxs-lookup"><span data-stu-id="78f4c-163">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="78f4c-164">您可以擷取提供執行緒的相關資訊的屬性值的數目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-164">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="78f4c-165">在某些情況下，您也可以設定這些屬性值來控制執行緒的作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-165">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="78f4c-166">這些執行緒屬性包括：</span><span class="sxs-lookup"><span data-stu-id="78f4c-166">These thread properties include:</span></span>  
  
-   <span data-ttu-id="78f4c-167">名稱。</span><span class="sxs-lookup"><span data-stu-id="78f4c-167">A name.</span></span> <span data-ttu-id="78f4c-168"><xref:System.Threading.Thread.Name%2A> 會寫入-一次可用來識別在執行緒中的屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-168"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="78f4c-169">預設值是`null`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-169">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="78f4c-170">雜湊程式碼，您可以藉由呼叫擷取<xref:System.Threading.Thread.GetHashCode%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-170">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="78f4c-171">雜湊程式碼可以用來唯一識別執行緒;在執行緒的存留期間，其雜湊程式碼不會與任何其他執行緒，不論應用程式定義域取得此值的值相衝突。</span><span class="sxs-lookup"><span data-stu-id="78f4c-171">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="78f4c-172">執行緒識別碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-172">A thread ID.</span></span> <span data-ttu-id="78f4c-173">唯讀值<xref:System.Threading.Thread.ManagedThreadId%2A>屬性由執行階段所指派，並且唯一地識別其處理程序中的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-173">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="78f4c-174">作業系統的 [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) 與 Managed 執行緒之間沒有固定的關係，因為未受管理的主機可控制 Managed 執行緒與 Unmanaged 執行緒之間的關係。</span><span class="sxs-lookup"><span data-stu-id="78f4c-174">An operating-system [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="78f4c-175">具體來說，精密的主機可以使用[CLR 裝載 API](https://msdn.microsoft.com/library/ms404385.aspx)排程許多 managed 的執行緒，對相同的作業系統執行緒，或是不同的作業系統執行緒之間移動 managed 的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-175">Specifically, a sophisticated host can use the [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="78f4c-176">執行緒的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-176">The thread's current state.</span></span> <span data-ttu-id="78f4c-177">它的存在時間，執行緒一律是在一或多個定義的狀態<xref:System.Threading.ThreadState>屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-177">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="78f4c-178">排程的優先權層級，定義<xref:System.Threading.ThreadPriority>屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-178">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="78f4c-179">雖然您可以設定此值，以要求執行緒的優先權，其不一定適用於作業系統。</span><span class="sxs-lookup"><span data-stu-id="78f4c-179">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="78f4c-180">唯讀<xref:System.Threading.Thread.IsThreadPoolThread%2A>屬性，指出執行緒是否是在執行緒集區執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-180">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="78f4c-181"><xref:System.Threading.Thread.IsBackground%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-181">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="78f4c-182">如需詳細資訊，請參閱[前景和背景執行緒](#Foreground)> 一節。</span><span class="sxs-lookup"><span data-stu-id="78f4c-182">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="78f4c-183">下列範例會示範簡單的執行緒功能。</span><span class="sxs-lookup"><span data-stu-id="78f4c-183">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="78f4c-184">此程式碼會產生類似下面的輸出：</span><span class="sxs-lookup"><span data-stu-id="78f4c-184">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="78f4c-185">此型別具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="78f4c-185">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="78f4c-186">初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="78f4c-186">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="78f4c-187">委派，代表在這個執行緒開始執行時要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-187">A delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="78f4c-188">初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體，並指定委派，讓物件可以在執行緒啟動時傳遞到執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-188">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-189">執行緒不會開始執行時建立。</span><span class="sxs-lookup"><span data-stu-id="78f4c-189">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="78f4c-190">若要排程執行的執行緒，呼叫<xref:System.Threading.Thread.Start%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-190">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="78f4c-191">若要將資料物件傳遞到執行緒，使用<xref:System.Threading.Thread.Start%28System.Object%29>方法多載。</span><span class="sxs-lookup"><span data-stu-id="78f4c-191">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-192">Visual Basic 使用者可以省略<xref:System.Threading.ThreadStart>建構函式建立執行緒時。</span><span class="sxs-lookup"><span data-stu-id="78f4c-192">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="78f4c-193">使用`AddressOf`運算子時傳遞您的方法，例如`Dim t As New Thread(AddressOf ThreadProc)`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-193">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="78f4c-194">Visual Basic 會自動呼叫<xref:System.Threading.ThreadStart>建構函式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-194">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-195">下列範例顯示建立和使用的語法<xref:System.Threading.ParameterizedThreadStart>具有靜態方法和執行個體方法的委派。</span><span class="sxs-lookup"><span data-stu-id="78f4c-195">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="78f4c-196"><paramref name="start" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-196"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="78f4c-197"><see cref="T:System.Threading.ThreadStart" /> 委派，代表在這個執行緒開始執行時要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-197">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="78f4c-198">初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="78f4c-198">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-199">執行緒不會開始執行時建立。</span><span class="sxs-lookup"><span data-stu-id="78f4c-199">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="78f4c-200">若要排程執行的執行緒，呼叫<xref:System.Threading.Thread.Start%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-200">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-201">Visual Basic 使用者可以省略<xref:System.Threading.ThreadStart>建構函式建立執行緒時。</span><span class="sxs-lookup"><span data-stu-id="78f4c-201">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="78f4c-202">使用`AddressOf`運算子，例如傳遞方法時`Dim t As New Thread(AddressOf ThreadProc)`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-202">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="78f4c-203">Visual Basic 會自動呼叫<xref:System.Threading.ThreadStart>建構函式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-203">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-204">下列程式碼範例示範如何建立執行靜態方法的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-204">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="78f4c-205">下列程式碼範例示範如何建立執行個體方法的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-205">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="78f4c-206"><paramref name="start" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-206">The <paramref name="start" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="78f4c-207"><see cref="T:System.Threading.ParameterizedThreadStart" /> 委派，代表在這個執行緒開始執行時要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-207">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="78f4c-208">執行緒使用的最大堆疊大小 (以位元組為單位)，或是 0，使用可執行檔標頭中指定的預設最大堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="78f4c-208">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
 <span data-ttu-id="78f4c-209">重要資訊：對於部分信任的程式碼，如果 <c>maxStackSize</c> 大於預設堆疊大小，則會加以忽略。</span><span class="sxs-lookup"><span data-stu-id="78f4c-209">Important   For partially trusted code, <c>maxStackSize</c> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="78f4c-210">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-210">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="78f4c-211">初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體，指定委派，讓物件可以在執行緒啟動時傳遞到執行緒，並指定執行緒的堆疊大小上限。</span><span class="sxs-lookup"><span data-stu-id="78f4c-211">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-212">請避免使用這個建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="78f4c-212">Avoid using this constructor overload.</span></span> <span data-ttu-id="78f4c-213">所使用的預設堆疊大小<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>建構函式多載是建議的堆疊大小執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-213">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="78f4c-214">如果執行緒有記憶體問題，最可能的原因程式設計錯誤，例如無限遞迴。</span><span class="sxs-lookup"><span data-stu-id="78f4c-214">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f4c-215">開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、 只有完全受信任的程式碼可以設定`maxStackSize`大於預設堆疊大小 (1 mb) 的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-215">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="78f4c-216">如果指定較大的值`maxStackSize`以部分信任，請在執行程式碼時`maxStackSize`會被忽略，而且是預設堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="78f4c-216">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="78f4c-217">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-217">No exception is thrown.</span></span> <span data-ttu-id="78f4c-218">任何信任層級的程式碼可以設定`maxStackSize`小於預設堆疊大小的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-218">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-219">如果您開發部分信任的程式碼，將使用完全信任程式庫，而且您要啟動的執行緒需要大型堆疊，您必須先建立執行緒，判斷提示完全信任或將使用預設堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="78f4c-219">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="78f4c-220">不要這樣除非您完全控制的執行緒執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-220">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="78f4c-221">如果`maxStackSize`小於最小的堆疊大小，使用最小的堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="78f4c-221">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="78f4c-222">如果`maxStackSize`不多的頁面大小會四捨五入為下一個較大頁面大小的倍數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-222">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="78f4c-223">例如，如果您在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262144 位元組） 是最小的堆疊大小，和頁面大小是 64 KB （65536 個位元組）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-223">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-224">Microsoft Windows Windows XP 和 Windows Server 2003 之前, 的版本上`maxStackSize`會被忽略，而且是可執行檔的標頭中指定的堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="78f4c-224">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="78f4c-225">如果您指定非常小的堆疊大小，您可能需要停用堆疊探查。</span><span class="sxs-lookup"><span data-stu-id="78f4c-225">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="78f4c-226">在堆疊嚴重受限，探查可以本身可能會造成堆疊溢位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-226">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="78f4c-227">若要停用堆疊探查，加入下列應用程式組態檔。</span><span class="sxs-lookup"><span data-stu-id="78f4c-227">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="78f4c-228"><paramref name="start" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-228"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="78f4c-229"><paramref name="maxStackSize" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="78f4c-229"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="78f4c-230"><see cref="T:System.Threading.ThreadStart" /> 委派，代表在這個執行緒開始執行時要叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-230">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="78f4c-231">執行緒使用的最大堆疊大小 (以位元組為單位)，或是 0，使用可執行檔標頭中指定的預設最大堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="78f4c-231">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
 <span data-ttu-id="78f4c-232">重要資訊：對於部分信任的程式碼，如果 <c>maxStackSize</c> 大於預設堆疊大小，則會加以忽略。</span><span class="sxs-lookup"><span data-stu-id="78f4c-232">Important   For partially trusted code, <c>maxStackSize</c> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="78f4c-233">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-233">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="78f4c-234">初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體，並指定執行緒的堆疊大小上限。</span><span class="sxs-lookup"><span data-stu-id="78f4c-234">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-235">請避免使用這個建構函式多載。</span><span class="sxs-lookup"><span data-stu-id="78f4c-235">Avoid using this constructor overload.</span></span> <span data-ttu-id="78f4c-236">所使用的預設堆疊大小<xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>建構函式多載是建議的堆疊大小執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-236">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="78f4c-237">如果執行緒有記憶體問題，最可能的原因程式設計錯誤，例如無限遞迴。</span><span class="sxs-lookup"><span data-stu-id="78f4c-237">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f4c-238">開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、 只有完全受信任的程式碼可以設定`maxStackSize`大於預設堆疊大小 (1 mb) 的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-238">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="78f4c-239">如果指定較大的值`maxStackSize`以部分信任，請在執行程式碼時`maxStackSize`會被忽略，而且是預設堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="78f4c-239">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="78f4c-240">不會有例外狀況擲回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-240">No exception is thrown.</span></span> <span data-ttu-id="78f4c-241">任何信任層級的程式碼可以設定`maxStackSize`小於預設堆疊大小的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-241">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-242">如果您開發部分信任的程式碼，將使用完全信任程式庫，而且您要啟動的執行緒需要大型堆疊，您必須先建立執行緒，判斷提示完全信任或將使用預設堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="78f4c-242">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="78f4c-243">不要這樣除非您完全控制的執行緒執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-243">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="78f4c-244">如果`maxStackSize`小於最小的堆疊大小，使用最小的堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="78f4c-244">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="78f4c-245">如果`maxStackSize`不多的頁面大小會四捨五入為下一個較大頁面大小的倍數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-245">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="78f4c-246">例如，如果您在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262144 位元組） 是最小的堆疊大小，和頁面大小是 64 KB （65536 個位元組）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-246">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-247">Microsoft Windows Windows XP 和 Windows Server 2003 之前, 的版本上`maxStackSize`會被忽略，而且是可執行檔的標頭中指定的堆疊大小。</span><span class="sxs-lookup"><span data-stu-id="78f4c-247">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="78f4c-248">如果您指定非常小的堆疊大小，您可能需要停用堆疊探查。</span><span class="sxs-lookup"><span data-stu-id="78f4c-248">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="78f4c-249">在堆疊嚴重受限，探查可以本身可能會造成堆疊溢位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-249">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="78f4c-250">若要停用堆疊探查，加入下列應用程式組態檔。</span><span class="sxs-lookup"><span data-stu-id="78f4c-250">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="78f4c-251"><paramref name="start" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-251"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="78f4c-252"><paramref name="maxStackSize" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="78f4c-252"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="78f4c-253">於被叫用的所在執行緒中引發 <see cref="T:System.Threading.ThreadAbortException" />，開始處理執行緒的結束作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-253">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="78f4c-254">呼叫這個方法通常會結束執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-254">Calling this method usually terminates the thread.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-255">於被叫用的所在執行緒中引發 <see cref="T:System.Threading.ThreadAbortException" />，開始處理執行緒的結束作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-255">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="78f4c-256">呼叫這個方法通常會結束執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-256">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-257">在執行緒上叫用這個方法時，系統會擲回<xref:System.Threading.ThreadAbortException>中將它中止的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-257">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="78f4c-258">`ThreadAbortException` 是特殊的例外狀況可以攔截的應用程式程式碼，但是會重新擲回的結尾`catch`封鎖除非<xref:System.Threading.Thread.ResetAbort%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="78f4c-258">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="78f4c-259">`ResetAbort` 取消要求中止，並防止`ThreadAbortException`終止執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-259">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="78f4c-260">未執行`finally`區塊會執行已中止的執行緒之前。</span><span class="sxs-lookup"><span data-stu-id="78f4c-260">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-261">當一個執行緒呼叫`Abort`效果是類似於擲回例外狀況; 本身，<xref:System.Threading.ThreadAbortException>時會立即，且結果為可預測。</span><span class="sxs-lookup"><span data-stu-id="78f4c-261">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="78f4c-262">不過，如果一個執行緒呼叫`Abort`，另一個執行緒上中斷執行任何程式碼中止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-262">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="78f4c-263">此外，也可能已中止的靜態建構函式有機會。</span><span class="sxs-lookup"><span data-stu-id="78f4c-263">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="78f4c-264">在罕見的情況下，這可能導致無法建立應用程式定義域中的類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="78f4c-264">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="78f4c-265">在.NET framework 1.0 和 1.1 版中，的可能會無法中止執行緒時`finally`執行的區塊，在此情況下`finally`區塊就會中止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-265">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="78f4c-266">執行緒中止立即，或完全不保證。</span><span class="sxs-lookup"><span data-stu-id="78f4c-266">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="78f4c-267">如果執行緒沒有無限量的空間中的計算，可能會發生這種情況下`finally`稱為中止程序，藉此無限延遲中止的區塊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-267">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="78f4c-268">若要等候，直到執行緒已中止，您可以呼叫<xref:System.Threading.Thread.Join%2A>方法之後呼叫的執行緒上<xref:System.Threading.Thread.Abort%2A>方法，但不保證將會結束等待。</span><span class="sxs-lookup"><span data-stu-id="78f4c-268">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-269">呼叫的執行緒<xref:System.Threading.Thread.Abort%2A>是否要中止的執行緒中受保護的區域，程式碼，例如，可能會封鎖`catch`區塊，`finally`區塊或限制的執行區域。</span><span class="sxs-lookup"><span data-stu-id="78f4c-269">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="78f4c-270">如果執行緒呼叫<xref:System.Threading.Thread.Abort%2A>鎖定要求已中止的執行緒，便會發生死結。</span><span class="sxs-lookup"><span data-stu-id="78f4c-270">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="78f4c-271">如果`Abort`稱為上尚未啟動的執行緒，執行緒將會中止時<xref:System.Threading.Thread.Start%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="78f4c-271">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="78f4c-272">如果`Abort`呼叫執行緒時遭到封鎖或睡眠中的執行緒上中斷，並再中止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-272">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="78f4c-273">如果`Abort`已暫停的執行緒上呼叫<xref:System.Threading.ThreadStateException>呼叫的執行緒中擲回<xref:System.Threading.Thread.Abort%2A>，和<xref:System.Threading.ThreadState.AbortRequested>加入至<xref:System.Threading.Thread.ThreadState%2A>正在中止的執行緒屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-273">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="78f4c-274">A<xref:System.Threading.ThreadAbortException>才會擲回在暫停的執行緒，直到<xref:System.Threading.Thread.Resume%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="78f4c-274">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="78f4c-275">如果`Abort`執行 unmanaged 程式碼時，在 managed 執行緒上呼叫`ThreadAbortException`傳回給 managed 程式碼的執行緒之前不會擲回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-275">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="78f4c-276">如果兩個呼叫會以`Abort`出現在相同的時間，它是一個設定的狀態資訊的呼叫和其他執行的呼叫可能`Abort`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-276">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="78f4c-277">不過，應用程式無法偵測這種情況。</span><span class="sxs-lookup"><span data-stu-id="78f4c-277">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="78f4c-278">之後`Abort`叫用執行緒上、 執行緒的狀態包括<xref:System.Threading.ThreadState.AbortRequested>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-278">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="78f4c-279">執行緒已經終止由於成功呼叫之後`Abort`，執行緒的狀態變更為<xref:System.Threading.ThreadState.Stopped>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-279">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="78f4c-280">具有足夠的權限的執行緒，做為目標的`Abort`可以取消中止使用`ResetAbort`方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-280">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="78f4c-281">如需範例，示範如何呼叫`ResetAbort`方法，請參閱`ThreadAbortException`類別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-281">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="78f4c-282">僅限 .NET Core：不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="78f4c-282">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="78f4c-283">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="78f4c-283">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-284">要中止的執行緒目前已暫止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-284">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="78f4c-285">進階的執行緒上作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-285">for advanced operations on threads.</span></span> <span data-ttu-id="78f4c-286">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-286">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo"><span data-ttu-id="78f4c-287">包含特定應用程式資訊 (例如狀態) 的物件，正在中止的執行緒可以使用這個物件。</span><span class="sxs-lookup"><span data-stu-id="78f4c-287">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span></span></param>
        <summary><span data-ttu-id="78f4c-288">於被叫用的所在執行緒中引發 <see cref="T:System.Threading.ThreadAbortException" />，開始結束執行緒的處理作業，同時也提供執行緒結束的相關例外狀況資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-288">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span></span> <span data-ttu-id="78f4c-289">呼叫這個方法通常會結束執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-289">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-290">在執行緒上叫用這個方法時，系統會擲回<xref:System.Threading.ThreadAbortException>中將它中止的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-290">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="78f4c-291">`ThreadAbortException` 是特殊的例外狀況可以攔截的應用程式程式碼，但是會重新擲回的結尾`catch`封鎖除非<xref:System.Threading.Thread.ResetAbort%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="78f4c-291">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="78f4c-292">`ResetAbort` 取消要求中止，並防止`ThreadAbortException`終止執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-292">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="78f4c-293">未執行`finally`區塊會執行已中止的執行緒之前。</span><span class="sxs-lookup"><span data-stu-id="78f4c-293">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-294">當一個執行緒呼叫`Abort`效果是類似於擲回例外狀況; 本身，<xref:System.Threading.ThreadAbortException>時會立即，且結果為可預測。</span><span class="sxs-lookup"><span data-stu-id="78f4c-294">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="78f4c-295">不過，如果一個執行緒呼叫`Abort`，另一個執行緒上中斷執行任何程式碼中止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-295">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="78f4c-296">沒有靜態建構函式可能會中止的機率。</span><span class="sxs-lookup"><span data-stu-id="78f4c-296">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="78f4c-297">在罕見的情況下，這可能導致無法建立應用程式定義域中的類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="78f4c-297">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="78f4c-298">在.NET framework 1.0 和 1.1 版中，的可能會無法中止執行緒時`finally`執行的區塊，在此情況下`finally`區塊就會中止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-298">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="78f4c-299">執行緒中止立即，或完全不保證。</span><span class="sxs-lookup"><span data-stu-id="78f4c-299">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="78f4c-300">如果執行緒沒有無限量的空間中的計算，可能會發生這種情況下`finally`稱為中止程序，藉此無限延遲中止的區塊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-300">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="78f4c-301">若要等候，直到執行緒已中止，您可以呼叫<xref:System.Threading.Thread.Join%2A>方法之後呼叫的執行緒上<xref:System.Threading.Thread.Abort%2A>方法，但不保證會結束等待。</span><span class="sxs-lookup"><span data-stu-id="78f4c-301">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-302">呼叫的執行緒<xref:System.Threading.Thread.Abort%2A>是否要中止的執行緒中受保護的區域，程式碼，例如，可能會封鎖`catch`區塊，`finally`區塊或限制的執行區域。</span><span class="sxs-lookup"><span data-stu-id="78f4c-302">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="78f4c-303">如果執行緒呼叫<xref:System.Threading.Thread.Abort%2A>鎖定要求已中止的執行緒，便會發生死結。</span><span class="sxs-lookup"><span data-stu-id="78f4c-303">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="78f4c-304">如果`Abort`稱為上尚未啟動的執行緒，執行緒將會中止時<xref:System.Threading.Thread.Start%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="78f4c-304">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="78f4c-305">如果`Abort`呼叫執行緒時遭到封鎖或睡眠中的執行緒上中斷，並再中止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-305">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="78f4c-306">如果`Abort`已暫停的執行緒上呼叫<xref:System.Threading.ThreadStateException>呼叫的執行緒中擲回<xref:System.Threading.Thread.Abort%2A>，和<xref:System.Threading.ThreadState.AbortRequested>加入至<xref:System.Threading.Thread.ThreadState%2A>正在中止的執行緒屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-306">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="78f4c-307">A<xref:System.Threading.ThreadAbortException>才會擲回在暫停的執行緒，直到<xref:System.Threading.Thread.Resume%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="78f4c-307">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="78f4c-308">如果`Abort`執行 unmanaged 程式碼時，在 managed 執行緒上呼叫`ThreadAbortException`傳回給 managed 程式碼的執行緒之前不會擲回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-308">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="78f4c-309">如果兩個呼叫會以`Abort`出現在相同的時間，它是一個設定的狀態資訊的呼叫和其他執行的呼叫可能`Abort`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-309">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="78f4c-310">不過，應用程式無法偵測這種情況。</span><span class="sxs-lookup"><span data-stu-id="78f4c-310">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="78f4c-311">之後`Abort`叫用執行緒上、 執行緒的狀態包括<xref:System.Threading.ThreadState.AbortRequested>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-311">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="78f4c-312">執行緒已經終止由於成功呼叫之後`Abort`，執行緒的狀態變更為<xref:System.Threading.ThreadState.Stopped>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-312">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="78f4c-313">具有足夠的權限的執行緒，做為目標的`Abort`可以取消中止使用`ResetAbort`方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-313">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="78f4c-314">如需範例，示範如何呼叫`ResetAbort`方法，請參閱`ThreadAbortException`類別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-314">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-315">下列程式碼範例示範如何將資訊傳遞給要中止的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-315">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="78f4c-316">僅限 .NET Core：不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="78f4c-316">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="78f4c-317">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="78f4c-317">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-318">要中止的執行緒目前已暫止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-318">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="78f4c-319">進階的執行緒上作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-319">for advanced operations on threads.</span></span> <span data-ttu-id="78f4c-320">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-320">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-321">在所有的執行緒上配置未命名的資料位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-321">Allocates an unnamed data slot on all the threads.</span></span> <span data-ttu-id="78f4c-322">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-322">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="78f4c-323">在所有執行緒上已配置的具名資料位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-323">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f4c-324">.NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-324">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="78f4c-325">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-325">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="78f4c-326">如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-326">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="78f4c-327">在所有執行緒上配置的位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-327">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="78f4c-328">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-328">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="78f4c-329">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="78f4c-329">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="78f4c-330">執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。</span><span class="sxs-lookup"><span data-stu-id="78f4c-330">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="78f4c-331">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="78f4c-331">Data slots are unique per thread.</span></span> <span data-ttu-id="78f4c-332">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-332">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-333">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-333">This section contains two code examples.</span></span> <span data-ttu-id="78f4c-334">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-334">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-335">第二個範例示範如何使用資料位置來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-335">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="78f4c-336">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-336">**First Example**</span></span>  
  
 <span data-ttu-id="78f4c-337">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-337">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-338">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="78f4c-338">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="78f4c-339">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-339">**Second Example**</span></span>  
  
 <span data-ttu-id="78f4c-340">下列程式碼範例示範如何使用資料位置來儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-340">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="78f4c-341">要配置之資料插槽的名稱。</span><span class="sxs-lookup"><span data-stu-id="78f4c-341">The name of the data slot to be allocated.</span></span></param>
        <summary><span data-ttu-id="78f4c-342">在所有的執行緒上配置命名的資料位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-342">Allocates a named data slot on all threads.</span></span> <span data-ttu-id="78f4c-343">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-343">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="78f4c-344">在所有執行緒上已配置的具名資料位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-344">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f4c-345">.NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-345">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="78f4c-346">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-346">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="78f4c-347">如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-347">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="78f4c-348">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-348">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="78f4c-349">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="78f4c-349">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="78f4c-350">執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。</span><span class="sxs-lookup"><span data-stu-id="78f4c-350">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="78f4c-351">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="78f4c-351">Data slots are unique per thread.</span></span> <span data-ttu-id="78f4c-352">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-352">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="78f4c-353">不需要使用<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法來配置命名的資料位置，因為<xref:System.Threading.Thread.GetNamedDataSlot%2A>方法配置位置，如果它不已配置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-353">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-354">如果<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法時，它應該呼叫在主執行緒在程式啟動時，因為它會擲回例外狀況，如果已配置具有指定名稱的位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-354">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="78f4c-355">沒有任何方法來測試是否已配置的位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-355">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="78f4c-356">以這個方法所配置的位置必須釋放與<xref:System.Threading.Thread.FreeNamedDataSlot%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-356">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-357">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-357">This section contains two code examples.</span></span> <span data-ttu-id="78f4c-358">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-358">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-359">第二個範例示範如何使用資料位置來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-359">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="78f4c-360">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-360">**First Example**</span></span>  
  
 <span data-ttu-id="78f4c-361">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-361">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-362">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="78f4c-362">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="78f4c-363">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-363">**Second Example**</span></span>  
  
 <span data-ttu-id="78f4c-364">下列範例會示範如何使用具名的資料位置來儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-364">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-365">範例程式碼不會使用<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法，因為<xref:System.Threading.Thread.GetNamedDataSlot%2A>方法配置位置，如果它不已配置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-365">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="78f4c-366">如果<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法時，應該在程式啟動時在主執行緒中呼叫它。</span><span class="sxs-lookup"><span data-stu-id="78f4c-366">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="78f4c-367">具有指定名稱的具名資料位置已存在。</span><span class="sxs-lookup"><span data-stu-id="78f4c-367">A named data slot with the specified name already exists.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-368">取得或設定這個執行緒的 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-368">Gets or sets the apartment state of this thread.</span></span></summary>
        <value><span data-ttu-id="78f4c-369">其中一個 <see cref="T:System.Threading.ApartmentState" /> 值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-369">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span></span> <span data-ttu-id="78f4c-370">初始值為 <see langword="Unknown" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-370">The initial value is <see langword="Unknown" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-371">**<xref:System.Threading.Thread.ApartmentState%2A>屬性已經過時。**</span><span class="sxs-lookup"><span data-stu-id="78f4c-371">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="78f4c-372">非過時的替代方式為<xref:System.Threading.Thread.GetApartmentState%2A>方法來擷取的 apartment 狀態和<xref:System.Threading.Thread.SetApartmentState%2A>方法，以設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-372">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="78f4c-373">在.NET framework 1.0 和 1.1 版，`ApartmentState`屬性標記，表示它會在單一執行緒或多執行緒 apartment 中執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-373">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="78f4c-374">可以設定這個屬性，當執行緒處於`Unstarted`或`Running`執行緒狀態; 不過，它可以只能設定一次的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-374">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="78f4c-375">如果尚未設定屬性，它會傳回`Unknown`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-375">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="78f4c-376">嘗試使用<xref:System.Threading.Thread.ApartmentState%2A>屬性來設定其 apartment 狀態已設定執行緒的 apartment 狀態會被忽略。</span><span class="sxs-lookup"><span data-stu-id="78f4c-376">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="78f4c-377">不過，<xref:System.Threading.Thread.SetApartmentState%2A>方法會擲回<xref:System.InvalidOperationException>在此情況下。</span><span class="sxs-lookup"><span data-stu-id="78f4c-377">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f4c-378">在.NET Framework 2.0 版中，新的執行緒初始化為<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果會在啟動之前不已設定其 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-378">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="78f4c-379">主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>預設。</span><span class="sxs-lookup"><span data-stu-id="78f4c-379">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="78f4c-380">您可以不再將設定主應用程式執行緒<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>藉由設定<xref:System.Threading.ApartmentState?displayProperty=nameWithType>第一行程式碼上的屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-380">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="78f4c-381">使用<xref:System.STAThreadAttribute>改為。</span><span class="sxs-lookup"><span data-stu-id="78f4c-381">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="78f4c-382">在.NET Framework 2.0 版中，您可以指定的 COM 執行緒模型為 c + + 應用程式使用[/CLRTHREADATTRIBUTE （設定 CLR 執行緒屬性）](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)連結器選項。</span><span class="sxs-lookup"><span data-stu-id="78f4c-382">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-383">下列程式碼範例示範如何設定執行緒的 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-383">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="78f4c-384">已嘗試將此屬性狀態設定為無效 Apartment 狀態 (單一執行緒 Apartment (<see langword="STA" />) 或多執行緒 Apartment (<see langword="MTA" />) 以外的狀態)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-384">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-385">通知主機在即將執行的程式碼區域中，執行緒中止或未處理例外狀況的影響，可能會危及應用程式定義域中的其他工作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-385">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-386">主控件，例如 Microsoft SQL Server 2005，common language runtime (CLR)，可以建立不同的原則中的程式碼的重大和非關鍵區域的失敗。</span><span class="sxs-lookup"><span data-stu-id="78f4c-386">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="78f4c-387">在其中執行緒中止或未處理的例外狀況的影響可能不是目前的工作是關鍵區域。</span><span class="sxs-lookup"><span data-stu-id="78f4c-387">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="78f4c-388">相反地，中止或非關鍵的程式碼區域中的失敗會影響只有工作發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="78f4c-388">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="78f4c-389">例如，假設有嘗試配置記憶體時保留鎖定工作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-389">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="78f4c-390">如果記憶體配置失敗，正在中止目前的工作並不足以確保穩定性<xref:System.AppDomain>，因為在等候相同的鎖定網域中可以有其他工作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-390">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="78f4c-391">如果目前的工作已中止，其他工作可能發生死結。</span><span class="sxs-lookup"><span data-stu-id="78f4c-391">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="78f4c-392">發生失敗時的關鍵區域中，主機可能會決定卸載整個<xref:System.AppDomain>而不需要繼續執行，可能會不穩定的狀態中的風險。</span><span class="sxs-lookup"><span data-stu-id="78f4c-392">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="78f4c-393">若要通知您的程式碼正在進入關鍵區域的主機，呼叫<xref:System.Threading.Thread.BeginCriticalRegion%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-393">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="78f4c-394">呼叫<xref:System.Threading.Thread.EndCriticalRegion%2A>當執行會傳回非關鍵的程式碼區域。</span><span class="sxs-lookup"><span data-stu-id="78f4c-394">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="78f4c-395">SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-395">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-396">下列範例示範如何使用<xref:System.Threading.Thread.BeginCriticalRegion%2A>和<xref:System.Threading.Thread.EndCriticalRegion%2A>分成重大和非重大地區的程式碼區塊的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-396">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-397">通知主機 Managed 程式碼即將執行指令，而這些指令相依於目前實體作業系統執行緒的識別 (Identity)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-397">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-398">某些主機的 common language runtime，例如 Microsoft SQL Server 2005，提供它們自己的執行緒管理。</span><span class="sxs-lookup"><span data-stu-id="78f4c-398">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="78f4c-399">提供它自己的執行緒管理的主機執行的工作從一個實體作業系統執行緒之間移動在任何時間。</span><span class="sxs-lookup"><span data-stu-id="78f4c-399">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="78f4c-400">大部分的工作不會受到這個切換。</span><span class="sxs-lookup"><span data-stu-id="78f4c-400">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="78f4c-401">不過，某些工作執行緒相似性，也就是相依實體作業系統執行緒的識別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-401">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="78f4c-402">這些工作必須通知主應用程式時執行程式碼，不會切換。</span><span class="sxs-lookup"><span data-stu-id="78f4c-402">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="78f4c-403">例如，如果您的應用程式呼叫系統 API，以取得作業系統鎖定具有執行緒相似性，例如 Win32 CRITICAL_SECTION，您必須呼叫<xref:System.Threading.Thread.BeginThreadAffinity%2A>之前取得鎖定，以及<xref:System.Threading.Thread.EndThreadAffinity%2A>之後釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="78f4c-403">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="78f4c-404">SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-404">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-405">下列範例示範如何使用<xref:System.Threading.Thread.BeginThreadAffinity%2A>和<xref:System.Threading.Thread.EndThreadAffinity%2A>方法，以通知主機一段程式碼相依於實體作業系統執行緒的識別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-405">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="78f4c-406">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="78f4c-406">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="78f4c-407">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="78f4c-407">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="78f4c-408">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-408">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-409">取得執行緒正在執行的目前內容。</span><span class="sxs-lookup"><span data-stu-id="78f4c-409">Gets the current context in which the thread is executing.</span></span></summary>
        <value><span data-ttu-id="78f4c-410"><see cref="T:System.Runtime.Remoting.Contexts.Context" />，代表目前的執行緒內容。</span><span class="sxs-lookup"><span data-stu-id="78f4c-410">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="78f4c-411">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="78f4c-411">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="78f4c-412">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="78f4c-412">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="78f4c-413">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-413">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-414">取得或設定目前執行緒的文化特性 (Culture)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-414">Gets or sets the culture for the current thread.</span></span></summary>
        <value><span data-ttu-id="78f4c-415">表示目前執行緒之文化特性的物件。</span><span class="sxs-lookup"><span data-stu-id="78f4c-415">An object that represents the culture for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-416"><xref:System.Globalization.CultureInfo>物件，這個屬性，以及其相關聯的物件，就會傳回判斷預設格式的日期、 時間、 數字、 貨幣值，排序順序的文字、 大小寫慣例，以及字串比較。</span><span class="sxs-lookup"><span data-stu-id="78f4c-416">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="78f4c-417">請參閱<xref:System.Globalization.CultureInfo>類別若要了解有關的文化特性名稱和識別碼，而異，中性和特定文化特性之間的差異，以及方法的文化特性資訊影響執行緒和應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="78f4c-417">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="78f4c-418">請參閱<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>屬性若要了解如何決定執行緒的預設文化特性，以及使用者如何設定電腦的文化特性資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-418">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  
  
 <span data-ttu-id="78f4c-419">開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，您可以設定<xref:System.Threading.Thread.CurrentCulture%2A>中性文化特性的屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-419">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="78f4c-420">這是因為的行為<xref:System.Globalization.CultureInfo>類別已變更： 當它代表中性文化特性，其屬性值 (特別是， <xref:System.Globalization.CultureInfo.Calendar%2A>， <xref:System.Globalization.CultureInfo.CompareInfo%2A>， <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>， <xref:System.Globalization.CultureInfo.NumberFormat%2A>，和<xref:System.Globalization.CultureInfo.TextInfo%2A>屬性) 現在反映中性文化特性相關聯的特定文化特性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-420">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="78f4c-421">在舊版的.NET Framework 中，<xref:System.Threading.Thread.CurrentCulture%2A>屬性擲回<xref:System.NotSupportedException>時中性文化特性已指派的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="78f4c-421">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-422">下列程式碼範例顯示可讓 Windows Form 顯示在 [控制台] 中設定的文化特性的使用者介面執行緒陳述式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-422">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="78f4c-423">需要額外的程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-423">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="78f4c-424">該屬性設定為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-424">The property is set to <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="78f4c-425">設定屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-425">for setting the property.</span></span> <span data-ttu-id="78f4c-426">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="78f4c-426">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-427">取得或設定執行緒目前的原則 (角色架構安全性之用)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-427">Gets or sets the thread's current principal (for role-based security).</span></span></summary>
        <value><span data-ttu-id="78f4c-428"><see cref="T:System.Security.Principal.IPrincipal" /> 值，代表安全性的內容。</span><span class="sxs-lookup"><span data-stu-id="78f4c-428">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="78f4c-429">下列程式碼範例示範如何設定及擷取執行緒的主體。</span><span class="sxs-lookup"><span data-stu-id="78f4c-429">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="78f4c-430">呼叫端沒有設定主體的必要權限。</span><span class="sxs-lookup"><span data-stu-id="78f4c-430">The caller does not have the permission required to set the principal.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="78f4c-431">操作主體物件。</span><span class="sxs-lookup"><span data-stu-id="78f4c-431">to manipulate the principal object.</span></span> <span data-ttu-id="78f4c-432">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-432">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-433">取得目前執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-433">Gets the currently running thread.</span></span></summary>
        <value><span data-ttu-id="78f4c-434"><see cref="T:System.Threading.Thread" />，是目前執行之執行緒的表示。</span><span class="sxs-lookup"><span data-stu-id="78f4c-434">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="78f4c-435">下列範例會建立輪流建立 20 個子任務的工作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-435">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="78f4c-436">應用程式本身，以及每項工作中，以呼叫`ShowThreadInformation`方法，會使用<xref:System.Threading.Thread.CurrentThread%2A>屬性來顯示它正在執行之執行緒的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-436">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="78f4c-437">每項子工作會產生介於 1 到 1 百萬個 1 百萬個隨機的數字，並傳回其平均值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-437">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="78f4c-438">父工作呼叫<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法，以確保子工作已完成之後，顯示每項工作所傳回的平均值，計算平均數的方式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-438">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="78f4c-439">請注意，應用程式在前景執行緒上執行，而在執行緒集區執行緒上執行每項工作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-439">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-440">取得或設定資源管理員目前用以在執行階段查詢特定文化特性資源所用的文化特性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-440">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span></span></summary>
        <value><span data-ttu-id="78f4c-441">表示目前文化特性的物件。</span><span class="sxs-lookup"><span data-stu-id="78f4c-441">An object that represents the current culture.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-442">UI 文化特性會指定應用程式需要支援使用者輸入和輸出，而且預設為作業系統的文化特性相同的資源。</span><span class="sxs-lookup"><span data-stu-id="78f4c-442">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="78f4c-443">請參閱<xref:System.Globalization.CultureInfo>類別若要了解有關的文化特性名稱和識別碼，而異，中性和特定文化特性之間的差異，以及方法的文化特性資訊影響執行緒和應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="78f4c-443">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="78f4c-444">請參閱<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>若要了解如何判斷執行緒的預設 UI 文化特性的屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-444">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  
  
 <span data-ttu-id="78f4c-445"><xref:System.Globalization.CultureInfo>傳回這個屬性可以是中性文化特性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-445">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="78f4c-446">中性文化特性不應以格式化方法，例如<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>， <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>，和<xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-446">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78f4c-447">使用<xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>方法來取得特定文化特性，或使用<xref:System.Threading.Thread.CurrentCulture%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-447">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-448"><xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>方法會擲回<xref:System.ArgumentException>中性文化特性"zh-chs 和-Hant"("zh-chs 和 ZH-CHT") 和 「 zh-chs 和-Hans"("ZH-CHS")。</span><span class="sxs-lookup"><span data-stu-id="78f4c-448">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-449">下列範例會判斷是否在目前執行緒的 UI 文化特性的語言為法文。</span><span class="sxs-lookup"><span data-stu-id="78f4c-449">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="78f4c-450">若不存在，則會設定為英文 （美國） 的目前執行緒的 UI 文化特性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-450">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="78f4c-451">下列程式碼範例顯示可讓 Windows Form 顯示在 [控制台] 中設定的文化特性的使用者介面執行緒陳述式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-451">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="78f4c-452">需要額外的程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-452">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="78f4c-453">該屬性設定為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-453">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="78f4c-454">此屬性設為無法用來尋找資源檔的文化特性名稱。</span><span class="sxs-lookup"><span data-stu-id="78f4c-454">The property is set to a culture name that cannot be used to locate a resource file.</span></span> <span data-ttu-id="78f4c-455">資源檔名稱只可以包含字母、數字、連字號或底線。</span><span class="sxs-lookup"><span data-stu-id="78f4c-455">Resource filenames must include only letters, numbers, hyphens or underscores.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-456">關閉目前執行緒之執行階段可呼叫包裝函式 (RCW) 的自動清除功能。</span><span class="sxs-lookup"><span data-stu-id="78f4c-456">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-457">根據預設，common language runtime (CLR) 會清除執行階段可呼叫包裝函式自動。</span><span class="sxs-lookup"><span data-stu-id="78f4c-457">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="78f4c-458">CLR 幫浦內訊息的清除，這可能會造成一些符合下列準則不尋常的應用程式的重新進入問題：</span><span class="sxs-lookup"><span data-stu-id="78f4c-458">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="78f4c-459">應用程式會自己訊息幫浦作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-459">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="78f4c-460">應用程式需要訊息幫浦作業發生時，精確地控制。</span><span class="sxs-lookup"><span data-stu-id="78f4c-460">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="78f4c-461">這類應用程式可以使用<xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A>方法，以防止 CLR 做自動回收執行階段可呼叫包裝函式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-461">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="78f4c-462">如果在執行緒上呼叫此方法，就無法重新啟用該執行緒自動清除。</span><span class="sxs-lookup"><span data-stu-id="78f4c-462">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="78f4c-463">您的應用程式準備好要清除執行階段可呼叫包裝函式時，請使用<xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType>方法，以指示清除所有執行階段可呼叫包裝函式在目前內容中執行階段。</span><span class="sxs-lookup"><span data-stu-id="78f4c-463">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="78f4c-464">當方法執行時，就會發生訊息幫浦作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-464">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="78f4c-465">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="78f4c-465">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="78f4c-466">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-466">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-467">通知主機在即將執行的程式碼區域中，執行緒中止或未處理例外狀況影響的對象只限於目前的工作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-467">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-468">主控件，例如 Microsoft SQL Server 2005，common language runtime (CLR)，可以建立不同的原則中的程式碼的重大和非關鍵區域的失敗。</span><span class="sxs-lookup"><span data-stu-id="78f4c-468">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="78f4c-469">在其中執行緒中止或未處理的例外狀況的影響可能不是目前的工作是關鍵區域。</span><span class="sxs-lookup"><span data-stu-id="78f4c-469">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="78f4c-470">相反地，中止或非關鍵的程式碼區域中的失敗會影響只有工作發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="78f4c-470">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="78f4c-471">例如，假設有嘗試配置記憶體時保留鎖定工作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-471">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="78f4c-472">如果記憶體配置失敗，正在中止目前的工作並不足以確保穩定性<xref:System.AppDomain>，因為在等候相同的鎖定網域中可以有其他工作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-472">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="78f4c-473">如果目前的工作已中止，其他工作可能發生死結。</span><span class="sxs-lookup"><span data-stu-id="78f4c-473">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="78f4c-474">發生失敗時的關鍵區域中，主機可能會決定卸載整個<xref:System.AppDomain>而不需要繼續執行，可能會不穩定的狀態中的風險。</span><span class="sxs-lookup"><span data-stu-id="78f4c-474">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="78f4c-475">若要通知您的程式碼正在進入關鍵區域的主機，呼叫<xref:System.Threading.Thread.BeginCriticalRegion%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-475">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="78f4c-476">呼叫<xref:System.Threading.Thread.EndCriticalRegion%2A>當執行會傳回非關鍵的程式碼區域。</span><span class="sxs-lookup"><span data-stu-id="78f4c-476">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="78f4c-477">SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-477">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-478">下列範例示範如何使用<xref:System.Threading.Thread.BeginCriticalRegion%2A>和<xref:System.Threading.Thread.EndCriticalRegion%2A>分成重大和非重大地區的程式碼區塊的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-478">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-479">通知主機 Managed 程式碼已完成執行指令，而這些指令相依於目前實體作業系統執行緒的識別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-479">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-480">某些主機的 common language runtime，例如 Microsoft SQL Server 2005，提供它們自己的執行緒管理。</span><span class="sxs-lookup"><span data-stu-id="78f4c-480">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="78f4c-481">提供它自己的執行緒管理的主機執行的工作從一個實體作業系統執行緒之間移動在任何時間。</span><span class="sxs-lookup"><span data-stu-id="78f4c-481">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="78f4c-482">大部分的工作不會受到這個切換。</span><span class="sxs-lookup"><span data-stu-id="78f4c-482">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="78f4c-483">不過，某些工作執行緒相似性，也就是相依實體作業系統執行緒的識別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-483">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="78f4c-484">這些工作必須通知主應用程式時執行程式碼，不會切換。</span><span class="sxs-lookup"><span data-stu-id="78f4c-484">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="78f4c-485">例如，如果您的應用程式呼叫系統 API，以取得作業系統鎖定具有執行緒相似性，例如 Win32 CRITICAL_SECTION，您必須呼叫<xref:System.Threading.Thread.BeginThreadAffinity%2A>之前取得鎖定，以及<xref:System.Threading.Thread.EndThreadAffinity%2A>之後釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="78f4c-485">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="78f4c-486">SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-486">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-487">下列範例示範如何使用<xref:System.Threading.Thread.BeginThreadAffinity%2A>和<xref:System.Threading.Thread.EndThreadAffinity%2A>方法，以通知主機一段程式碼相依於實體作業系統執行緒的識別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-487">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="78f4c-488">呼叫端沒有必要的權限。</span><span class="sxs-lookup"><span data-stu-id="78f4c-488">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="78f4c-489">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="78f4c-489">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="78f4c-490">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-490">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-491">取得 <see cref="T:System.Threading.ExecutionContext" /> 物件，包含目前執行緒各種內容的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-491">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span></span></summary>
        <value><span data-ttu-id="78f4c-492"><see cref="T:System.Threading.ExecutionContext" /> 物件，合併目前執行緒的內容資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-492">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-493"><xref:System.Threading.ExecutionContext>類別會提供所有的相關資訊的邏輯執行緒執行的單一容器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-493">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="78f4c-494">這包括安全性內容中，呼叫內容、 同步處理內容、 當地語系化內容和交易內容。</span><span class="sxs-lookup"><span data-stu-id="78f4c-494">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-495">確認釋出資源，並在記憶體回收行程再利用 <see cref="T:System.Threading.Thread" /> 物件時執行其他清除作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-495">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-496">記憶體回收行程呼叫<xref:System.Threading.Thread.Finalize%2A>準備最終處理而將目前的物件時。</span><span class="sxs-lookup"><span data-stu-id="78f4c-496">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="78f4c-497">要釋放之資料插槽的名稱。</span><span class="sxs-lookup"><span data-stu-id="78f4c-497">The name of the data slot to be freed.</span></span></param>
        <summary><span data-ttu-id="78f4c-498">排除處理程序中所有執行緒的名稱和位置之間的關聯。</span><span class="sxs-lookup"><span data-stu-id="78f4c-498">Eliminates the association between a name and a slot, for all threads in the process.</span></span> <span data-ttu-id="78f4c-499">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-499">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f4c-500">.NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-500">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="78f4c-501">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-501">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="78f4c-502">如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-502">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="78f4c-503">任何執行緒呼叫之後`FreeNamedDataSlot`，呼叫的其他任何執行緒<xref:System.Threading.Thread.GetNamedDataSlot%2A>相同的名稱就會配置新的位置與名稱相關聯。</span><span class="sxs-lookup"><span data-stu-id="78f4c-503">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="78f4c-504">後續呼叫`GetNamedDataSlot`任何執行緒會傳回新的位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-504">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="78f4c-505">不過，任何執行緒，仍有<xref:System.LocalDataStoreSlot?displayProperty=nameWithType>先前呼叫所傳回的`GetNamedDataSlot`可以繼續使用舊的位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-505">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="78f4c-506">釋放與名稱關聯的位置時，才每`LocalDataStoreSlot`之前呼叫取得`FreeNamedDataSlot`已釋放及回收。</span><span class="sxs-lookup"><span data-stu-id="78f4c-506">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="78f4c-507">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-507">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="78f4c-508">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="78f4c-508">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="78f4c-509">執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。</span><span class="sxs-lookup"><span data-stu-id="78f4c-509">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="78f4c-510">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="78f4c-510">Data slots are unique per thread.</span></span> <span data-ttu-id="78f4c-511">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-511">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-512">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-512">This section contains two code examples.</span></span> <span data-ttu-id="78f4c-513">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-513">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-514">第二個範例示範如何使用資料位置來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-514">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="78f4c-515">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-515">**First Example**</span></span>  
  
 <span data-ttu-id="78f4c-516">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-516">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-517">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="78f4c-517">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="78f4c-518">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-518">**Second Example**</span></span>  
  
 <span data-ttu-id="78f4c-519">下列範例會示範如何使用具名的資料位置來儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-519">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-520">傳回表示 Apartment 狀態的 <see cref="T:System.Threading.ApartmentState" /> 值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-520">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span></span></summary>
        <returns><span data-ttu-id="78f4c-521">其中一個 <see cref="T:System.Threading.ApartmentState" /> 值，表示 Managed 執行緒的 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-521">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span></span> <span data-ttu-id="78f4c-522">預設值為 <see cref="F:System.Threading.ApartmentState.Unknown" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-522">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-523">這個方法中，連同<xref:System.Threading.Thread.SetApartmentState%2A>方法和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-523">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-524">下列程式碼範例示範<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-524">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="78f4c-525">程式碼範例會建立執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-525">The code example creates a thread.</span></span> <span data-ttu-id="78f4c-526">在執行緒啟動之前，<xref:System.Threading.Thread.GetApartmentState%2A>顯示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>狀態和<xref:System.Threading.Thread.SetApartmentState%2A>將狀態變更為<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-526">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78f4c-527"><xref:System.Threading.Thread.TrySetApartmentState%2A>方法接著會傳回`false`嘗試將狀態變更時<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因為已設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-527">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="78f4c-528">如果相同的作業具有已嘗試使用<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>就已擲回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-528">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="78f4c-529">在執行緒啟動之後，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法會再次使用。</span><span class="sxs-lookup"><span data-stu-id="78f4c-529">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="78f4c-530">這次會擲回<xref:System.Threading.ThreadStateException>因為執行緒已經啟動。</span><span class="sxs-lookup"><span data-stu-id="78f4c-530">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-531">傳回 <see cref="T:System.Threading.CompressedStack" /> 物件，可以用來擷取目前執行緒的堆疊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-531">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span></span></summary>
        <returns><span data-ttu-id="78f4c-532">無。</span><span class="sxs-lookup"><span data-stu-id="78f4c-532">None.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-533">不再支援這個方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-533">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="78f4c-534">在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="78f4c-534">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="78f4c-535">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="78f4c-535">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="78f4c-536">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-536">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="78f4c-537">要從其中取得值的 <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-537">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span></span></param>
        <summary><span data-ttu-id="78f4c-538">從目前執行緒上、目前執行緒之目前定義域中的指定位置擷取數值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-538">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span></span> <span data-ttu-id="78f4c-539">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-539">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="78f4c-540">擷取的數值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-540">The retrieved value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f4c-541">.NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-541">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="78f4c-542">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-542">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="78f4c-543">如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-543">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="78f4c-544">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-544">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="78f4c-545">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="78f4c-545">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="78f4c-546">執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。</span><span class="sxs-lookup"><span data-stu-id="78f4c-546">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="78f4c-547">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="78f4c-547">Data slots are unique per thread.</span></span> <span data-ttu-id="78f4c-548">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-548">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-549"><xref:System.Threading.Thread.GetData%2A> 是`Shared`一律適用於目前執行中執行緒，即使您使用的變數，指的是另一個執行緒呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-549"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="78f4c-550">為了避免混淆，類別名稱呼叫時，使用`Shared`方法： `Dim test As Object = Thread.GetData(testSlot)`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-550">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-551">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-551">This section contains two code examples.</span></span> <span data-ttu-id="78f4c-552">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-552">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-553">第二個範例示範如何使用資料位置來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-553">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="78f4c-554">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-554">**First Example**</span></span>  
  
 <span data-ttu-id="78f4c-555">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-555">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-556">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="78f4c-556">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="78f4c-557">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-557">**Second Example**</span></span>  
  
 <span data-ttu-id="78f4c-558">下列範例示範如何使用資料位置來儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-558">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-559">傳回目前執行緒正在其中執行的目前定義域。</span><span class="sxs-lookup"><span data-stu-id="78f4c-559">Returns the current domain in which the current thread is running.</span></span></summary>
        <returns><span data-ttu-id="78f4c-560"><see cref="T:System.AppDomain" />，代表執行中的執行緒目前的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="78f4c-560">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="78f4c-561">下列程式碼範例示範如何擷取名稱和識別碼`AppDomain`中的執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="78f4c-561">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-562">傳回唯一的應用程式定義域識別項。</span><span class="sxs-lookup"><span data-stu-id="78f4c-562">Returns a unique application domain identifier.</span></span></summary>
        <returns><span data-ttu-id="78f4c-563">唯一識別應用程式定義域的 32 位元帶正負號的整數 (Signed Integer)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-563">A 32-bit signed integer uniquely identifying the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="78f4c-564">下列程式碼範例示範如何擷取名稱和識別碼`AppDomain`中的執行緒執行。</span><span class="sxs-lookup"><span data-stu-id="78f4c-564">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-565">傳回目前執行緒的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-565">Returns a hash code for the current thread.</span></span></summary>
        <returns><span data-ttu-id="78f4c-566">整數雜湊碼值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-566">An integer hash code value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-567">不保證是唯一的雜湊碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-567">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="78f4c-568">使用<xref:System.Threading.Thread.ManagedThreadId%2A>屬性，如果您需要 managed 執行緒的唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-568">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="78f4c-569">本機資料位置的名稱。</span><span class="sxs-lookup"><span data-stu-id="78f4c-569">The name of the local data slot.</span></span></param>
        <summary><span data-ttu-id="78f4c-570">尋找具名的資料位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-570">Looks up a named data slot.</span></span> <span data-ttu-id="78f4c-571">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-571">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="78f4c-572">為這個執行緒配置的 <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-572">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f4c-573">.NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-573">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="78f4c-574">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-574">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="78f4c-575">如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-575">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="78f4c-576">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-576">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="78f4c-577">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="78f4c-577">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="78f4c-578">執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。</span><span class="sxs-lookup"><span data-stu-id="78f4c-578">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="78f4c-579">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="78f4c-579">Data slots are unique per thread.</span></span> <span data-ttu-id="78f4c-580">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-580">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="78f4c-581">如果具名的位置不存在，則會配置新的位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-581">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="78f4c-582">具名的資料位置是公用的任何人都可以管理。</span><span class="sxs-lookup"><span data-stu-id="78f4c-582">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-583">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-583">This section contains two code examples.</span></span> <span data-ttu-id="78f4c-584">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-584">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-585">第二個範例示範如何使用資料位置來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-585">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="78f4c-586">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-586">**First Example**</span></span>  
  
 <span data-ttu-id="78f4c-587">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-587">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-588">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="78f4c-588">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="78f4c-589">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-589">**Second Example**</span></span>  
  
 <span data-ttu-id="78f4c-590">下列範例會示範如何使用具名的資料位置來儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-590">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-591">中斷處於 <see langword="WaitSleepJoin" /> 執行緒狀態的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-591">Interrupts a thread that is in the <see langword="WaitSleepJoin" /> thread state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-592">如果這個執行緒目前未遭到封鎖在等候、 睡眠或聯結狀態，它將會中斷接下來開始封鎖時。</span><span class="sxs-lookup"><span data-stu-id="78f4c-592">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="78f4c-593"><xref:System.Threading.ThreadInterruptedException> 在中斷之執行緒，但直到則執行緒會封鎖，就會擲回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-593"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="78f4c-594">如果執行緒永不封鎖，永遠不會擲回例外狀況，並因此執行緒可能會完成，而任何中斷。</span><span class="sxs-lookup"><span data-stu-id="78f4c-594">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-595">下列程式碼範例顯示執行中的執行緒行為時中斷，並接著已遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="78f4c-595">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="78f4c-596">呼叫端沒有適當的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-596">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="78f4c-597">進階的執行緒上作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-597">for advanced operations on threads.</span></span> <span data-ttu-id="78f4c-598">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-598">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-599">取得值，指出目前執行緒的執行狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-599">Gets a value indicating the execution status of the current thread.</span></span></summary>
        <value>
          <span data-ttu-id="78f4c-600">如果這個執行緒已經啟動但還沒有正常結束或者中止，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-600"><see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-601">取得或設定值，指出執行緒是不是背景執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-601">Gets or sets a value indicating whether or not a thread is a background thread.</span></span></summary>
        <value>
          <span data-ttu-id="78f4c-602">如果這個執行緒是背景執行緒或者會成為背景執行緒，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-602"><see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-603">執行緒是背景執行緒或前景執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-603">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="78f4c-604">背景執行緒就前景執行緒相同，不同之處在於背景執行緒不會防止處理序終止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-604">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="78f4c-605">一旦處理程序所屬的所有前景執行緒已經都終止，common language runtime 會結束處理程序。</span><span class="sxs-lookup"><span data-stu-id="78f4c-605">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="78f4c-606">任何剩餘的背景執行緒已停止，並不會完成。</span><span class="sxs-lookup"><span data-stu-id="78f4c-606">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="78f4c-607">依預設，下列執行緒則是在前景執行 (也就是其<xref:System.Threading.Thread.IsBackground%2A>屬性會傳回`false`):</span><span class="sxs-lookup"><span data-stu-id="78f4c-607">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="78f4c-608">主執行緒 （或主應用程式執行緒）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-608">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="78f4c-609">藉由呼叫建立的所有執行緒<xref:System.Threading.Thread>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-609">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="78f4c-610">依預設，下列執行緒則是在背景中執行 (也就是其<xref:System.Threading.Thread.IsBackground%2A>屬性會傳回`true`):</span><span class="sxs-lookup"><span data-stu-id="78f4c-610">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="78f4c-611">執行緒集區執行緒，也就是由執行階段所維護的背景工作執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="78f4c-611">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="78f4c-612">您也可以使用執行緒集區執行緒上設定執行緒集區和排程工作<xref:System.Threading.ThreadPool>類別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-612">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="78f4c-613">在執行緒集區執行緒上自動執行工作為基礎的非同步作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-613">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="78f4c-614">從 unmanaged 程式碼進入 managed 的執行環境的所有執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-614">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-615">下列範例會比對前景和背景執行緒的行為。</span><span class="sxs-lookup"><span data-stu-id="78f4c-615">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="78f4c-616">它會建立前景執行緒與背景執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-616">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="78f4c-617">前景執行緒會持續處理序執行，直到完成其`for`迴圈，並終止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-617">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="78f4c-618">不過，如範例輸出所示，因為前景執行緒已執行完畢，處理程序之前，終止背景執行緒完成執行。</span><span class="sxs-lookup"><span data-stu-id="78f4c-618">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-619">執行緒已無作用</span><span class="sxs-lookup"><span data-stu-id="78f4c-619">The thread is dead.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-620">取得值，指出執行緒是否屬於 Managed 執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="78f4c-620">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span></span></summary>
        <value>
          <span data-ttu-id="78f4c-621"><see langword="true" />，表示這個執行緒屬於 Managed 執行緒集區，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-621"><see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-622">如需詳細資訊，請參閱[Managed 執行緒集區](~/docs/standard/threading/the-managed-thread-pool.md)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-622">For more information see [The Managed Thread Pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-623">下列程式碼範例示範如何判斷執行緒是否是在執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="78f4c-623">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="78f4c-624">封鎖呼叫執行緒，直到此執行個體所代表的執行緒終止為止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-624">Blocks the calling thread until the thread represented by this instance terminates.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-625">封鎖呼叫執行緒，直到此執行個體所代表的執行緒終止為止，但仍會繼續執行標準的 COM 與 <see langword="SendMessage" /> 提取作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-625">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-626"><xref:System.Threading.Thread.Join%2A> 封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到執行緒的同步處理方法的<xref:System.Threading.Thread.Join%2A>方法呼叫已完成。</span><span class="sxs-lookup"><span data-stu-id="78f4c-626"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="78f4c-627">使用這個方法，以確保執行緒已終止。</span><span class="sxs-lookup"><span data-stu-id="78f4c-627">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="78f4c-628">如果執行緒不會終止，將會無限期地封鎖呼叫端。</span><span class="sxs-lookup"><span data-stu-id="78f4c-628">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="78f4c-629">在下列範例中，`Thread1`執行緒呼叫<xref:System.Threading.Thread.Join>方法`Thread2`，這會導致`Thread1`區塊，直到`Thread2`已完成。</span><span class="sxs-lookup"><span data-stu-id="78f4c-629">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="78f4c-630">如果執行緒已經終止時有<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-630">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="78f4c-631">您應該永遠不會呼叫<xref:System.Threading.Thread.Join%2A>方法<xref:System.Threading.Thread>物件，代表目前執行緒從目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-631">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="78f4c-632">這會導致您的應用程式停止回應，因為目前的執行緒本身會永遠等候，</span><span class="sxs-lookup"><span data-stu-id="78f4c-632">This causes your app to hang because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="78f4c-633">這個方法呼叫的執行緒要包含的狀態變更<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-633">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78f4c-634">無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-634">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-635">呼叫端嘗試聯結處於 <see cref="F:System.Threading.ThreadState.Unstarted" /> 狀態的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-635">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="78f4c-636">執行緒在等待時中斷。</span><span class="sxs-lookup"><span data-stu-id="78f4c-636">The thread is interrupted while waiting.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="78f4c-637">等候執行緒終止的毫秒數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-637">The number of milliseconds to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="78f4c-638">封鎖呼叫執行緒，直到此執行個體代表的執行緒終止或超過指定的時間為止，但仍繼續執行標準的 COM 與 SendMessage 提取作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-638">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns>
          <span data-ttu-id="78f4c-639">如果執行緒已經終止，為 <see langword="true" />；如果 <see langword="false" /> 參數指定的時間量已經過去，而執行緒還沒有終止，則為 <paramref name="millisecondsTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-639"><see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-640"><xref:System.Threading.Thread.Join%28System.Int32%29> 封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到其中一個執行緒的同步處理方法的<xref:System.Threading.Thread.Join%2A>方法呼叫已完成或經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="78f4c-640"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="78f4c-641">在下列範例中，`Thread1`執行緒呼叫<xref:System.Threading.Thread.Join>方法`Thread2`，這會導致`Thread1`封鎖直到 `Thread2`已完成或經過 2 秒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-641">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="78f4c-642">如果<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>指定`millisecondsTimeout`參數，此方法的行為即會相同與<xref:System.Threading.Thread.Join>方法多載，除了傳回的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-642">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="78f4c-643">如果執行緒已經終止時有<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-643">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="78f4c-644">這個方法呼叫的執行緒要包含的狀態變更<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-644">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78f4c-645">無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-645">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="78f4c-646"><paramref name="millisecondsTimeout" /> 的值為負數，且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (以毫秒為單位)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-646">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-647">無法啟動此執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-647">The thread has not been started.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="78f4c-648"><see cref="T:System.TimeSpan" />，設定為等候執行緒終止的時間量。</span><span class="sxs-lookup"><span data-stu-id="78f4c-648">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="78f4c-649">封鎖呼叫執行緒，直到此執行個體代表的執行緒終止或超過指定的時間為止，但仍繼續執行標準的 COM 與 SendMessage 提取作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-649">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns>
          <span data-ttu-id="78f4c-650">如果執行緒終止了，為 <see langword="true" />；如果 <see langword="false" /> 參數指定的時間量已經過去，而執行緒還沒有終止，則為 <paramref name="timeout" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-650"><see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-651"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> 封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到其中一個執行緒的同步處理方法的<xref:System.Threading.Thread.Join%2A>方法呼叫已完成或經過逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="78f4c-651"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="78f4c-652">在下列範例中，`Thread1`執行緒呼叫<xref:System.Threading.Thread.Join>方法`Thread2`，這會導致`Thread1`封鎖直到 `Thread2`已完成或經過 2 秒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-652">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="78f4c-653">如果<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>指定`timeout`，此方法的行為即會相同與<xref:System.Threading.Thread.Join>方法多載，除了傳回的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-653">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="78f4c-654">如果執行緒已經終止時有<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-654">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="78f4c-655">這個方法會變更目前的執行緒可包含的狀態<xref:System.Threading.ThreadState.WaitSleepJoin>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-655">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="78f4c-656">無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-656">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-657">下列程式碼範例示範如何使用`TimeSpan`值與`Join`方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-657">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="78f4c-658">值 <paramref name="timeout" /> 為負數且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> 毫秒，或大於 <see cref="F:System.Int32.MaxValue" /> 毫秒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-658">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-659">呼叫端嘗試聯結處於 <see cref="F:System.Threading.ThreadState.Unstarted" /> 狀態的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-659">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-660">取得目前 Managed 執行緒的唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="78f4c-660">Gets a unique identifier for the current managed thread.</span></span></summary>
        <value><span data-ttu-id="78f4c-661">整數，表示這個 Managed 執行緒的唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="78f4c-661">An integer that represents a unique identifier for this managed thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-662">執行緒的<xref:System.Threading.Thread.ManagedThreadId%2A>屬性值是用來唯一識別其處理程序中的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-662">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="78f4c-663">值<xref:System.Threading.Thread.ManagedThreadId%2A>屬性不會變化經過一段時間，即使裝載 common language runtime 的 unmanaged 程式碼實作在 fiber 的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-663">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-664">同步處理記憶體存取，如下所示：執行目前執行緒的處理器無法以下列方式重新排列指示：呼叫 <see cref="M:System.Threading.Thread.MemoryBarrier" /> 之前的記憶體存取在呼叫 <see cref="M:System.Threading.Thread.MemoryBarrier" /> 後的記憶體存取之後執行。</span><span class="sxs-lookup"><span data-stu-id="78f4c-664">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-665"><xref:System.Threading.Thread.MemoryBarrier%2A> 需要多處理器系統上僅使用弱式排序 （例如，採用多個將 Intel Itanium 處理器的系統） 的記憶體。</span><span class="sxs-lookup"><span data-stu-id="78f4c-665"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="78f4c-666">大部分的用途而言，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，或<xref:System.Threading.Monitor>類別提供簡單的方式同步處理資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-666">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-667">取得或設定執行緒的名稱。</span><span class="sxs-lookup"><span data-stu-id="78f4c-667">Gets or sets the name of the thread.</span></span></summary>
        <value><span data-ttu-id="78f4c-668">含有執行緒名稱的字串；如果沒有設定名稱，則為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-668">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-669">這個屬性是寫入-之後。</span><span class="sxs-lookup"><span data-stu-id="78f4c-669">This property is write-once.</span></span> <span data-ttu-id="78f4c-670">因為執行緒的預設值<xref:System.Threading.Thread.Name%2A>屬性是`null`，您可以判斷是否已明確指派名稱給執行緒藉由比較它與`null`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-670">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="78f4c-671">指派給字串<xref:System.Threading.Thread.Name%2A>屬性可包含任何 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="78f4c-671">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-672">下列範例會示範如何命名執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-672">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="78f4c-673">要求了一組作業，但是早已設定了 <see langword="Name" /> 屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-673">A set operation was requested, but the <see langword="Name" /> property has already been set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-674">取得或設定值，指出執行緒的排程優先權。</span><span class="sxs-lookup"><span data-stu-id="78f4c-674">Gets or sets a value indicating the scheduling priority of a thread.</span></span></summary>
        <value><span data-ttu-id="78f4c-675">其中一個 <see cref="T:System.Threading.ThreadPriority" /> 值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-675">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span></span> <span data-ttu-id="78f4c-676">預設值是 <see cref="F:System.Threading.ThreadPriority.Normal" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-676">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-677">下列優先順序的任何一個可以指派一個執行緒<xref:System.Threading.ThreadPriority>值：</span><span class="sxs-lookup"><span data-stu-id="78f4c-677">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="78f4c-678">作業系統不需要接受執行緒的優先權。</span><span class="sxs-lookup"><span data-stu-id="78f4c-678">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-679">下列範例顯示的結果變更執行緒的優先權。</span><span class="sxs-lookup"><span data-stu-id="78f4c-679">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="78f4c-680">系統會建立三個執行緒，一個執行緒的優先權會設定為<xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>，而第二個優先權會設定為<xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-680">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78f4c-681">每個執行緒遞增變數中的`while`迴圈和回合設定的時間。</span><span class="sxs-lookup"><span data-stu-id="78f4c-681">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-682">執行緒已達最後狀態，例如 <see cref="F:System.Threading.ThreadState.Aborted" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-682">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="78f4c-683">為 Set 作業指定的值不是有效的 <see cref="T:System.Threading.ThreadPriority" /> 值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-683">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-684">取消為目前執行緒要求的 <see cref="M:System.Threading.Thread.Abort(System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-684">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-685">只使用適當的權限的程式碼可以呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-685">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="78f4c-686">進行呼叫以`Abort`來終止執行緒，系統會擲回<xref:System.Threading.ThreadAbortException>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-686">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="78f4c-687">`ThreadAbortException` 是特殊的例外狀況，應用程式程式碼可以攔截但重新擲回的 catch 區塊的結尾除非`ResetAbort`呼叫。</span><span class="sxs-lookup"><span data-stu-id="78f4c-687">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="78f4c-688">`ResetAbort` 取消要求中止，並防止`ThreadAbortException`終止執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-688">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="78f4c-689">請參閱<xref:System.Threading.ThreadAbortException>的範例，示範如何呼叫`ResetAbort`方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-689">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="78f4c-690">僅限 .NET Core：不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="78f4c-690">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="78f4c-691"><see langword="Abort" /> 並未在目前執行緒上被叫用。</span><span class="sxs-lookup"><span data-stu-id="78f4c-691"><see langword="Abort" /> was not invoked on the current thread.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="78f4c-692">呼叫端沒有目前執行緒的必要安全性權限。</span><span class="sxs-lookup"><span data-stu-id="78f4c-692">The caller does not have the required security permission for the current thread.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="78f4c-693">進階的執行緒上作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-693">for advanced operations on threads.</span></span> <span data-ttu-id="78f4c-694">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-694">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-695">繼續已暫止的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-695">Resumes a thread that has been suspended.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="78f4c-696">請勿使用<xref:System.Threading.Thread.Suspend%2A>和<xref:System.Threading.Thread.Resume%2A>方法來同步處理執行緒活動。</span><span class="sxs-lookup"><span data-stu-id="78f4c-696">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="78f4c-697">您有無從得知哪些程式碼的執行緒正在執行，當您暫停它。</span><span class="sxs-lookup"><span data-stu-id="78f4c-697">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="78f4c-698">如果您暫停執行緒，而安全性權限評估期間保留鎖定，其他執行緒中<xref:System.AppDomain>可能封鎖。</span><span class="sxs-lookup"><span data-stu-id="78f4c-698">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="78f4c-699">如果類別建構函式執行時，您可以暫停執行緒，其他執行緒中<xref:System.AppDomain>，嘗試使用封鎖的類別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-699">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="78f4c-700">很容易發生死結。</span><span class="sxs-lookup"><span data-stu-id="78f4c-700">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="78f4c-701">僅限 .NET Core：不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="78f4c-701">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-702">執行緒未啟動、已無作用，或不是處於暫停狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-702">The thread has not been started, is dead, or is not in the suspended state.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="78f4c-703">呼叫端沒有適當的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-703">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="78f4c-704">進階的執行緒上作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-704">for advanced operations on threads.</span></span> <span data-ttu-id="78f4c-705">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="78f4c-705">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="78f4c-706">新的 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-706">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="78f4c-707">在執行緒啟動之前設定其 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-707">Sets the apartment state of a thread before it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-708">新的執行緒都會初始化成<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果會在啟動之前不已設定其 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-708">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="78f4c-709">在執行緒啟動之前，必須設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-709">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-710">主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>預設。</span><span class="sxs-lookup"><span data-stu-id="78f4c-710">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="78f4c-711">若要設定主應用程式執行緒的 apartment 狀態的唯一方式<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>是套用<xref:System.STAThreadAttribute>屬性設定為進入點方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-711">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="78f4c-712"><xref:System.Threading.Thread.SetApartmentState%2A>方法，連同<xref:System.Threading.Thread.GetApartmentState%2A>方法和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-712">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-713">下列程式碼範例示範<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-713">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="78f4c-714">程式碼範例會建立執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-714">The code example creates a thread.</span></span> <span data-ttu-id="78f4c-715">在執行緒啟動之前，<xref:System.Threading.Thread.GetApartmentState%2A>顯示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>狀態和<xref:System.Threading.Thread.SetApartmentState%2A>將狀態變更為<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-715">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78f4c-716"><xref:System.Threading.Thread.TrySetApartmentState%2A>方法接著會傳回`false`嘗試將狀態變更時<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因為已設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-716">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="78f4c-717">如果相同的作業具有已嘗試使用<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>就已擲回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-717">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="78f4c-718">在執行緒啟動之後，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法會再次使用。</span><span class="sxs-lookup"><span data-stu-id="78f4c-718">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="78f4c-719">這次會擲回<xref:System.Threading.ThreadStateException>因為執行緒已經啟動。</span><span class="sxs-lookup"><span data-stu-id="78f4c-719">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="78f4c-720">僅限 .NET Core：macOS 和 Linux 平台不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="78f4c-720">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="78f4c-721"><paramref name="state" /> 不是有效的 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-721"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-722">已經啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-722">The thread has already been started.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="78f4c-723">Apartment 狀態已經初始化。</span><span class="sxs-lookup"><span data-stu-id="78f4c-723">The apartment state has already been initialized.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack"><span data-ttu-id="78f4c-724">要套用到目前執行緒的 <see cref="T:System.Threading.CompressedStack" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="78f4c-724">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span></span></param>
        <summary><span data-ttu-id="78f4c-725">將擷取的 <see cref="T:System.Threading.CompressedStack" /> 套用到目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-725">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-726">不再支援這個方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-726">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="78f4c-727">在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="78f4c-727">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="78f4c-728">需要完全信任立即呼叫者。</span><span class="sxs-lookup"><span data-stu-id="78f4c-728">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="78f4c-729">這個成員無法供部分信任或安全性透明程式碼。</span><span class="sxs-lookup"><span data-stu-id="78f4c-729">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="78f4c-730">要在其中設定數值的 <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-730">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span></span></param>
        <param name="data"><span data-ttu-id="78f4c-731">要設定的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-731">The value to be set.</span></span></param>
        <summary><span data-ttu-id="78f4c-732">針對那個執行緒目前的定義域，在目前執行之執行緒上的指定位置中設定資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-732">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span></span> <span data-ttu-id="78f4c-733">為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-733">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f4c-734">.NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-734">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="78f4c-735">提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-735">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="78f4c-736">如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-736">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="78f4c-737">執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-737">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="78f4c-738">建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。</span><span class="sxs-lookup"><span data-stu-id="78f4c-738">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="78f4c-739">執行緒用來配置資料存放區中的資料位置，儲存和擷取資料值插槽中並在執行緒程序結束之後釋放重複使用的位置和<xref:System.Threading.Thread>已經由記憶體回收回收物件。</span><span class="sxs-lookup"><span data-stu-id="78f4c-739">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="78f4c-740">資料位置是每個執行緒的唯一的。</span><span class="sxs-lookup"><span data-stu-id="78f4c-740">Data slots are unique per thread.</span></span> <span data-ttu-id="78f4c-741">沒有其他執行緒 （甚至子執行緒） 可以取得該資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-741">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-742"><xref:System.Threading.Thread.SetData%2A> 是`Shared`一律適用於目前執行中執行緒，即使您使用的變數，指的是另一個執行緒呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-742"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="78f4c-743">為了避免混淆，類別名稱呼叫時，使用`Shared`方法： `Thread.SetData(testSlot, "test data")`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-743">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-744">本節包含兩個程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-744">This section contains two code examples.</span></span> <span data-ttu-id="78f4c-745">第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-745">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-746">第二個範例示範如何使用資料位置來執行相同的動作。</span><span class="sxs-lookup"><span data-stu-id="78f4c-746">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="78f4c-747">**第一個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-747">**First Example**</span></span>  
  
 <span data-ttu-id="78f4c-748">下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-748">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="78f4c-749">這項技術提供更佳的效能比第二個範例所示的技巧。</span><span class="sxs-lookup"><span data-stu-id="78f4c-749">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="78f4c-750">**第二個範例**</span><span class="sxs-lookup"><span data-stu-id="78f4c-750">**Second Example**</span></span>  
  
 <span data-ttu-id="78f4c-751">下列範例會示範如何使用具名的資料位置來儲存執行緒特定的資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-751">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="78f4c-752">在指定長度的時間內暫止目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-752">Suspends the current thread for the specified amount of time.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="78f4c-753">暫止執行緒的毫秒數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-753">The number of milliseconds for which the thread is suspended.</span></span> <span data-ttu-id="78f4c-754">如果 <c>millisecondsTimeout</c> 引數的值為零，則執行緒會將其剩餘的時間配量讓與準備好要執行的任何同等優先權執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-754">If the value of the <c>millisecondsTimeout</c> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="78f4c-755">如果沒有其他準備好要執行的同等優先權執行緒，則目前執行緒的執行不會暫停。</span><span class="sxs-lookup"><span data-stu-id="78f4c-755">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="78f4c-756">在指定的毫秒數內暫止目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-756">Suspends the current thread for the specified number of milliseconds.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-757">執行緒不會執行由作業系統在指定的時間排程。</span><span class="sxs-lookup"><span data-stu-id="78f4c-757">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="78f4c-758">這個方法會包含執行緒的狀態變更<xref:System.Threading.ThreadState.WaitSleepJoin>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-758">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="78f4c-759">您可以指定<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>如`millisecondsTimeout`無限期地暫止執行緒的參數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-759">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="78f4c-760">不過，我們建議您使用其他<xref:System.Threading?displayProperty=nameWithType>之類的類別<xref:System.Threading.Mutex>， <xref:System.Threading.Monitor>， <xref:System.Threading.EventWaitHandle>，或<xref:System.Threading.Semaphore>改為還執行緒或管理資源。</span><span class="sxs-lookup"><span data-stu-id="78f4c-760">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="78f4c-761">在特定速率的系統時鐘刻度呼叫時鐘的解析度。</span><span class="sxs-lookup"><span data-stu-id="78f4c-761">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="78f4c-762">實際逾時可能不完全指定的逾時，因為指定的逾時將會調整，讓時鐘刻度一致。</span><span class="sxs-lookup"><span data-stu-id="78f4c-762">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="78f4c-763">如需有關時鐘的解析度和等候時間的詳細資訊，請參閱[睡眠函式](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)主題。</span><span class="sxs-lookup"><span data-stu-id="78f4c-763">For more information on clock resolution and the waiting time, see the [Sleep function](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) topic.</span></span> <span data-ttu-id="78f4c-764">這個方法會呼叫[睡眠函式](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)Windows 系統應用程式開發介面。</span><span class="sxs-lookup"><span data-stu-id="78f4c-764">This method calls the [Sleep function](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="78f4c-765">這個方法不會執行標準的 COM 與 SendMessage 幫浦作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-765">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-766">如果您需要進入睡眠狀態已在執行緒上<xref:System.STAThreadAttribute>，但您想要執行標準的 COM 與 SendMessage 幫浦作業，請考慮使用其中一個多載的<xref:System.Threading.Thread.Join%2A>方法所指定的逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="78f4c-766">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-767">下列範例會使用<xref:System.Threading.Thread.Sleep%2A>方法來封鎖，應用程式的主執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-767">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="78f4c-768">逾時值為負且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-768">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="78f4c-769">暫止執行緒的時間長度。</span><span class="sxs-lookup"><span data-stu-id="78f4c-769">The amount of time for which the thread is suspended.</span></span> <span data-ttu-id="78f4c-770">如果 <c>millisecondsTimeout</c> 引數的值為 <see cref="F:System.TimeSpan.Zero" />，則執行緒會將其剩餘的時間配量讓與準備好要執行的任何同等優先權執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-770">If the value of the <c>millisecondsTimeout</c> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="78f4c-771">如果沒有其他準備好要執行的同等優先權執行緒，則目前執行緒的執行不會暫停。</span><span class="sxs-lookup"><span data-stu-id="78f4c-771">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="78f4c-772">在指定長度的時間內暫止目前的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-772">Suspends the current thread for the specified amount of time.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-773">執行緒不會執行由作業系統在指定的時間排程。</span><span class="sxs-lookup"><span data-stu-id="78f4c-773">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="78f4c-774">這個方法會包含執行緒的狀態變更<xref:System.Threading.ThreadState.WaitSleepJoin>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-774">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="78f4c-775">您可以指定<xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType>如`timeout`無限期地暫止執行緒的參數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-775">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="78f4c-776">不過，我們建議您使用其他<xref:System.Threading?displayProperty=nameWithType>之類的類別<xref:System.Threading.Mutex>， <xref:System.Threading.Monitor>， <xref:System.Threading.EventWaitHandle>，或<xref:System.Threading.Semaphore>改為還執行緒或管理資源。</span><span class="sxs-lookup"><span data-stu-id="78f4c-776">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="78f4c-777">這個多載<xref:System.Threading.Thread.Sleep%2A>使用中的整數毫秒總數`timeout`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-777">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="78f4c-778">小數的毫秒都會被捨棄。</span><span class="sxs-lookup"><span data-stu-id="78f4c-778">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="78f4c-779">這個方法不會執行標準的 COM 與 SendMessage 幫浦作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-779">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-780">如果您需要進入睡眠狀態已在執行緒上<xref:System.STAThreadAttribute>，但您想要執行標準的 COM 與 SendMessage 幫浦作業，請考慮使用其中一個多載的<xref:System.Threading.Thread.Join%2A>方法所指定的逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="78f4c-780">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-781">下列範例會使用<xref:System.Threading.Thread.Sleep%28System.TimeSpan%29>方法多載來封鎖應用程式的主執行緒五次，兩秒鐘每一次。</span><span class="sxs-lookup"><span data-stu-id="78f4c-781">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="78f4c-782">值 <paramref name="timeout" /> 為負數且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> 毫秒，或大於 <see cref="F:System.Int32.MaxValue" /> 毫秒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-782">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations"><span data-ttu-id="78f4c-783">32 位元帶正負號的整數，定義執行緒要等候多久。</span><span class="sxs-lookup"><span data-stu-id="78f4c-783">A 32-bit signed integer that defines how long a thread is to wait.</span></span></param>
        <summary><span data-ttu-id="78f4c-784">造成執行緒等候 <paramref name="iterations" /> 參數定義的次數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-784">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-785"><xref:System.Threading.Thread.SpinWait%2A>方法可用於實作鎖定。</span><span class="sxs-lookup"><span data-stu-id="78f4c-785">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="78f4c-786">類別在.NET Framework 中，例如<xref:System.Threading.Monitor>和<xref:System.Threading.ReaderWriterLock>，這個方法會在內部使用。</span><span class="sxs-lookup"><span data-stu-id="78f4c-786">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="78f4c-787"><xref:System.Threading.Thread.SpinWait%2A> 基本上放處理器非常緊密迴圈中，與所指定的迴圈計數`iterations`參數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-787"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="78f4c-788">等候的持續時間因此取決於處理器的速度。</span><span class="sxs-lookup"><span data-stu-id="78f4c-788">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="78f4c-789">與<xref:System.Threading.Thread.Sleep%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-789">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="78f4c-790">呼叫的執行緒<xref:System.Threading.Thread.Sleep%2A>會產生其目前的配量的處理器時間的其餘部分，即使指定的時間間隔為零。</span><span class="sxs-lookup"><span data-stu-id="78f4c-790">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="78f4c-791">指定非零間隔<xref:System.Threading.Thread.Sleep%2A>經過的時間間隔之前執行緒移除執行緒排程器的考量。</span><span class="sxs-lookup"><span data-stu-id="78f4c-791">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="78f4c-792"><xref:System.Threading.Thread.SpinWait%2A> 不通常適用於一般的應用程式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-792"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="78f4c-793">在大部分情況下，您應該使用.NET Framework; 所提供的同步處理類別例如，呼叫<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>或陳述式包裝<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>(`lock`在 C# 或`SyncLock`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-793">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="78f4c-794">在極少數的案例是幫助避免將內容切換，例如當您知道狀態變更已即將發生，請呼叫<xref:System.Threading.Thread.SpinWait%2A>在迴圈中的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-794">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="78f4c-795">程式碼<xref:System.Threading.Thread.SpinWait%2A>執行為了防止具有多個處理器的電腦上可能發生的問題。</span><span class="sxs-lookup"><span data-stu-id="78f4c-795">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="78f4c-796">例如，在多個採用超執行緒技術的 Intel 處理器的電腦上<xref:System.Threading.Thread.SpinWait%2A>可防止在某些情況下的處理器資源用盡。</span><span class="sxs-lookup"><span data-stu-id="78f4c-796">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="78f4c-797">使執行緒進行執行排程。</span><span class="sxs-lookup"><span data-stu-id="78f4c-797">Causes a thread to be scheduled for execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-798">造成作業系統將目前執行個體的狀態變更為 <see cref="F:System.Threading.ThreadState.Running" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-798">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-799">一旦執行緒處於<xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>狀態時，系統可以將它排程執行。</span><span class="sxs-lookup"><span data-stu-id="78f4c-799">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="78f4c-800">在執行緒開始執行所表示之方法的第一行<xref:System.Threading.ThreadStart>或<xref:System.Threading.ParameterizedThreadStart>委派提供給執行緒的建構函式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-800">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="78f4c-801">請注意，呼叫<xref:System.Threading.Thread.Start%2A>不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-801">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-802">這個多載會搭配使用所建立的執行緒<xref:System.Threading.ParameterizedThreadStart>委派，`null`傳遞至由執行緒執行的方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-802">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="78f4c-803">一旦在執行緒結束，無法將它重新啟動與另一個呼叫`Start`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-803">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-804">下列範例會建立並啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-804">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-805">已經啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-805">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="78f4c-806">沒有足夠的記憶體可用來啟動這個執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-806">There is not enough memory available to start this thread.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter"><span data-ttu-id="78f4c-807">物件，包含執行緒執行之方法所要使用的資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-807">An object that contains data to be used by the method the thread executes.</span></span></param>
        <summary><span data-ttu-id="78f4c-808">使作業系統將目前執行個體的狀態改成 <see cref="F:System.Threading.ThreadState.Running" />，並選擇性地提供物件，在物件中包含執行緒執行之方法所要使用的資料。</span><span class="sxs-lookup"><span data-stu-id="78f4c-808">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-809">一旦執行緒處於<xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>狀態時，系統可以將它排程執行。</span><span class="sxs-lookup"><span data-stu-id="78f4c-809">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="78f4c-810">在執行緒開始執行所表示之方法的第一行<xref:System.Threading.ThreadStart>或<xref:System.Threading.ParameterizedThreadStart>委派提供給執行緒的建構函式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-810">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="78f4c-811">請注意，呼叫<xref:System.Threading.Thread.Start%2A>不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-811">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="78f4c-812">一旦在執行緒結束，無法將它重新啟動與另一個呼叫`Start`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-812">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="78f4c-813">這個多載而<xref:System.Threading.ParameterizedThreadStart>委派即可輕易地將資料傳遞給執行緒的程序，但方法不是類型安全因為任何物件可以傳遞給這個多載。</span><span class="sxs-lookup"><span data-stu-id="78f4c-813">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="78f4c-814">將執行緒的程序與資料欄位放入背景工作物件是更穩固的方式，將資料傳遞給執行緒的程序。</span><span class="sxs-lookup"><span data-stu-id="78f4c-814">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="78f4c-815">如需詳細資訊，請參閱[建立執行緒和開始時間傳遞資料](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-815">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-816">下列範例會建立<xref:System.Threading.ParameterizedThreadStart>具有靜態方法和執行個體方法的委派。</span><span class="sxs-lookup"><span data-stu-id="78f4c-816">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-817">已經啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-817">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="78f4c-818">沒有足夠的記憶體可用來啟動這個執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-818">There is not enough memory available to start this thread.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="78f4c-819">這個執行緒是使用 <see cref="T:System.Threading.ThreadStart" /> 委派建立，而非 <see cref="T:System.Threading.ParameterizedThreadStart" /> 委派。</span><span class="sxs-lookup"><span data-stu-id="78f4c-819">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-820">將執行緒暫止；或者如果執行緒已經暫止，則沒有影響。</span><span class="sxs-lookup"><span data-stu-id="78f4c-820">Either suspends the thread, or if the thread is already suspended, has no effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-821">如果執行緒已經暫止，這個方法沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="78f4c-821">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="78f4c-822">請勿使用<xref:System.Threading.Thread.Suspend%2A>和<xref:System.Threading.Thread.Resume%2A>方法來同步處理執行緒活動。</span><span class="sxs-lookup"><span data-stu-id="78f4c-822">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="78f4c-823">您有無從得知哪些程式碼的執行緒正在執行，當您暫停它。</span><span class="sxs-lookup"><span data-stu-id="78f4c-823">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="78f4c-824">如果您暫停執行緒，而安全性權限評估期間保留鎖定，其他執行緒中<xref:System.AppDomain>可能封鎖。</span><span class="sxs-lookup"><span data-stu-id="78f4c-824">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="78f4c-825">如果類別建構函式執行時，您可以暫停執行緒，其他執行緒中<xref:System.AppDomain>，嘗試使用封鎖的類別。</span><span class="sxs-lookup"><span data-stu-id="78f4c-825">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="78f4c-826">很容易發生死結。</span><span class="sxs-lookup"><span data-stu-id="78f4c-826">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="78f4c-827">僅限 .NET Core：不支援此成員。</span><span class="sxs-lookup"><span data-stu-id="78f4c-827">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-828">執行緒未啟動或無作用。</span><span class="sxs-lookup"><span data-stu-id="78f4c-828">The thread has not been started or is dead.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="78f4c-829">呼叫端沒有適當的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-829">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="78f4c-830">進階的執行緒上作業。</span><span class="sxs-lookup"><span data-stu-id="78f4c-830">for advanced operations on threads.</span></span> <span data-ttu-id="78f4c-831">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-831">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="78f4c-832">保留供未來使用。</span><span class="sxs-lookup"><span data-stu-id="78f4c-832">Reserved for future use.</span></span> <span data-ttu-id="78f4c-833">必須是 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="78f4c-833">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="78f4c-834">要對應之傳入的名稱陣列。</span><span class="sxs-lookup"><span data-stu-id="78f4c-834">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="78f4c-835">要對應的名稱計數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-835">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="78f4c-836">用於解譯名稱的地區設定內容。</span><span class="sxs-lookup"><span data-stu-id="78f4c-836">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="78f4c-837">呼叫端配置的陣列，用於接收對應於名稱的 ID。</span><span class="sxs-lookup"><span data-stu-id="78f4c-837">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="78f4c-838">將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-838">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-839">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="78f4c-839">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="78f4c-840">如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="78f4c-840">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="78f4c-841">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-841">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="78f4c-842">要傳回的類型資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-842">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="78f4c-843">類型資訊的地區設定識別項。</span><span class="sxs-lookup"><span data-stu-id="78f4c-843">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="78f4c-844">接收要求的類型資訊物件的指標。</span><span class="sxs-lookup"><span data-stu-id="78f4c-844">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="78f4c-845">擷取物件的類型資訊，可以用來取得介面的類型資訊。</span><span class="sxs-lookup"><span data-stu-id="78f4c-845">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-846">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="78f4c-846">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="78f4c-847">如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="78f4c-847">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="78f4c-848">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-848">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="78f4c-849">指向接收物件提供的類型資訊介面數目的位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-849">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="78f4c-850">擷取物件提供的類型資訊介面數目 (0 或 1)。</span><span class="sxs-lookup"><span data-stu-id="78f4c-850">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-851">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="78f4c-851">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="78f4c-852">如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="78f4c-852">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="78f4c-853">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-853">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="78f4c-854">辨識成員。</span><span class="sxs-lookup"><span data-stu-id="78f4c-854">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="78f4c-855">保留供未來使用。</span><span class="sxs-lookup"><span data-stu-id="78f4c-855">Reserved for future use.</span></span> <span data-ttu-id="78f4c-856">必須是 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="78f4c-856">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="78f4c-857">地區設定內容，用於解譯引數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-857">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="78f4c-858">描述呼叫之內容的旗標。</span><span class="sxs-lookup"><span data-stu-id="78f4c-858">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="78f4c-859">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</span><span class="sxs-lookup"><span data-stu-id="78f4c-859">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="78f4c-860">指向用於儲存結果之位置的指標。</span><span class="sxs-lookup"><span data-stu-id="78f4c-860">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="78f4c-861">包含例外狀況資訊的結構指標。</span><span class="sxs-lookup"><span data-stu-id="78f4c-861">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="78f4c-862">第一個有錯誤的引數索引。</span><span class="sxs-lookup"><span data-stu-id="78f4c-862">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="78f4c-863">提供物件所公開的屬性和方法的存取權。</span><span class="sxs-lookup"><span data-stu-id="78f4c-863">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-864">這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="78f4c-864">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="78f4c-865">如需有關`IDispatch::Invoke`，請參閱 MSDN Library。</span><span class="sxs-lookup"><span data-stu-id="78f4c-865">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="78f4c-866">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-866">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78f4c-867">取得數值，包含目前執行緒的狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-867">Gets a value containing the states of the current thread.</span></span></summary>
        <value><span data-ttu-id="78f4c-868">其中一個 <see cref="T:System.Threading.ThreadState" /> 數值，指出目前執行緒的狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-868">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span></span> <span data-ttu-id="78f4c-869">初始值為 <see langword="Unstarted" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-869">The initial value is <see langword="Unstarted" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-870"><xref:System.Threading.Thread.ThreadState%2A>屬性會提供更具體的資訊比<xref:System.Threading.Thread.IsAlive%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-870">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="78f4c-871">執行緒狀態只是想要偵錯案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-871">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="78f4c-872">您的程式碼絕對不應該使用執行緒狀態來同步處理執行緒活動。</span><span class="sxs-lookup"><span data-stu-id="78f4c-872">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-873">下列程式碼範例將示範如何存取`ThreadState`的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-873">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="78f4c-874">新的 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-874">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="78f4c-875">在執行緒啟動之前設定其 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-875">Sets the apartment state of a thread before it is started.</span></span></summary>
        <returns>
          <span data-ttu-id="78f4c-876">如果已設定 Apartment 狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-876"><see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-877">新的執行緒都會初始化成<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果會在啟動之前不已設定其 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-877">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="78f4c-878">在執行緒啟動之前，必須設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-878">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-879">主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>預設。</span><span class="sxs-lookup"><span data-stu-id="78f4c-879">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="78f4c-880">若要設定主應用程式執行緒的 apartment 狀態的唯一方式<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>是套用<xref:System.STAThreadAttribute>屬性設定為進入點方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-880">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="78f4c-881"><xref:System.Threading.Thread.TrySetApartmentState%2A>方法，連同<xref:System.Threading.Thread.GetApartmentState%2A>方法和<xref:System.Threading.Thread.SetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="78f4c-881">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78f4c-882">下列程式碼範例示範<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="78f4c-882">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="78f4c-883">程式碼範例會建立執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-883">The code example creates a thread.</span></span> <span data-ttu-id="78f4c-884">在執行緒啟動之前，<xref:System.Threading.Thread.GetApartmentState%2A>顯示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>狀態和<xref:System.Threading.Thread.SetApartmentState%2A>將狀態變更為<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-884">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78f4c-885"><xref:System.Threading.Thread.TrySetApartmentState%2A>方法接著會傳回`false`嘗試將狀態變更時<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因為已設定 apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-885">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="78f4c-886">如果相同的作業具有已嘗試使用<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>就已擲回。</span><span class="sxs-lookup"><span data-stu-id="78f4c-886">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="78f4c-887">在執行緒啟動之後，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法會再次使用。</span><span class="sxs-lookup"><span data-stu-id="78f4c-887">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="78f4c-888">這次會擲回<xref:System.Threading.ThreadStateException>因為執行緒已經啟動。</span><span class="sxs-lookup"><span data-stu-id="78f4c-888">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="78f4c-889"><paramref name="state" /> 不是有效的 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-889"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="78f4c-890">已經啟動執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-890">The thread has already been started.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="78f4c-891">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-891">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-892">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-892">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-893">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-893">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-894">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-894">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-895">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-895">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-896">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-896">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-897"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-897"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-898">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-898">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-899">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-899">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-900">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-900">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-901">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-901">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-902">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-902">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-903">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-903">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-904">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-904">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-905">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-905">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-906">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-906">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-907">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-907">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-908">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-908">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-909">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-909">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-910"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-910"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-911">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-911">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-912">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-912">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-913">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-913">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-914">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-914">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-915">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-915">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-916">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-916">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-917">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-917">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-918">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-918">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-919">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-919">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-920">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-920">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-921">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-921">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-922">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-922">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-923"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-923"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-924">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-924">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-925">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-925">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-926">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-926">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-927">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-927">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-928">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-928">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-929">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-929">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-930">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-930">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-931">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-931">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-932">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-932">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-933">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-933">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-934">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-934">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-935">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-935">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-936"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-936"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-937">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-937">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-938">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-938">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-939">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-939">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-940">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-940">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-941">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-941">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-942">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-942">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-943">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-943">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-944">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-944">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-945">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-945">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-946">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-946">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-947">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-947">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-948">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-948">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-949"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-949"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-950">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-950">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-951">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-951">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-952">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-952">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-953">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-953">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-954">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-954">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-955">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-955">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-956">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-956">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-957">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-957">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-958">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-958">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-959">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-959">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-960">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-960">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-961">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-961">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-962"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-962"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-963">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-963">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-964">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-964">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-965">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-965">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-966">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-966">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-967">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-967">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-968">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-968">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-969">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-969">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-970">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-970">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-971">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-971">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-972">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-972">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-973">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-973">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-974">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-974">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-975"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-975"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-976">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-976">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-977">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-977">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-978">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-978">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-979">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-979">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-980">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-980">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-981">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-981">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-982">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-982">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-983">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-983">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-984">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-984">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-985">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-985">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-986">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-986">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-987">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-987">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-988"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-988"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-989">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-989">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-990">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-990">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-991">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-991">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-992">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-992">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-993">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-993">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-994">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-994">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-995">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-995">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-996">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-996">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-997">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-997">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-998">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-998">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-999">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-999">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-1000">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1000">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1001"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1001"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1002">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1002">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1003">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1003">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-1004">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1004">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1005">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1005">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1006">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1006">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1007">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1007">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1008">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1008">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1009">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1009">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1010">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1010">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-1011">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1011">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-1012">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1012">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-1013">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1013">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1014"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1014"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1015">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1015">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1016">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1016">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-1017">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1017">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1018">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1018">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1019">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1019">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1020">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1020">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1021">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1021">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1022">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1022">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1023">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1023">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-1024">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1024">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-1025">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1025">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-1026">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1026">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1027"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1027"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1028">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1028">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1029">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1029">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-1030">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1030">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1031">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1031">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1032">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1032">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1033">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1033">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1034">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1034">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1035">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1035">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1036">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1036">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-1037">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1037">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-1038">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1038">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-1039">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1039">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1040"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1040"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1041">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1041">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1042">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1042">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-1043">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1043">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1044">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1044">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1045">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1045">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1046">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1046">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1047">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1047">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1048">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1048">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1049">要讀取的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1049">The field to be read.</span></span></param>
        <summary><span data-ttu-id="78f4c-1050">讀取欄位值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1050">Reads the value of a field.</span></span> <span data-ttu-id="78f4c-1051">值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1051">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="78f4c-1052">由任意處理器寫入欄位的最新值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1052">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1053"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1053"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1054">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1054">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1055">在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1055">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="78f4c-1056">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1056">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1057">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1057">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1058">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1058">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1059">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1059">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1060">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1060">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1061">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1061">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="78f4c-1062">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1062">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1063">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1063">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1064">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1064">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1065">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1065">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1066"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1066"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1067">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1067">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1068">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1068">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1069">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1069">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1070">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1070">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1071">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1071">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1072">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1072">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1073">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1073">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1074">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1074">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1075">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1075">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1076">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1076">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1077">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1077">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1078"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1078"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1079">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1079">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1080">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1080">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1081">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1081">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1082">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1082">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1083">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1083">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1084">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1084">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1085">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1085">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1086">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1086">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1087">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1087">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1088">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1088">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1089">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1089">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1090"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1090"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1091">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1091">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1092">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1092">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1093">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1093">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1094">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1094">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1095">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1095">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1096">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1096">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1097">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1097">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1098">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1098">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1099">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1099">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1100">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1100">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1101">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1101">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1102"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1102"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1103">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1103">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1104">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1104">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1105">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1105">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1106">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1106">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1107">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1107">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1108">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1108">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1109">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1109">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1110">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1110">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1111">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1111">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1112">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1112">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1113">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1113">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1114"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1114"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1115">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1115">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1116">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1116">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1117">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1117">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1118">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1118">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1119">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1119">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1120">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1120">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1121">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1121">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1122">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1122">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1123">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1123">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1124">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1124">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1125">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1125">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1126"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1126"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1127">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1127">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1128">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1128">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1129">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1129">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1130">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1130">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1131">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1131">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1132">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1132">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1133">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1133">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1134">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1134">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1135">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1135">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1136">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1136">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1137">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1137">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1138"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1138"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1139">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1139">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1140">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1140">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1141">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1141">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1142">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1142">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1143">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1143">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1144">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1144">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1145">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1145">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1146">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1146">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1147">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1147">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1148">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1148">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1149">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1149">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1150"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1150"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1151">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1151">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1152">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1152">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1153">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1153">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1154">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1154">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1155">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1155">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1156">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1156">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1157">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1157">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1158">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1158">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1159">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1159">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1160">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1160">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1161">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1161">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1162"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1162"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1163">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1163">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1164">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1164">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1165">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1165">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1166">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1166">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1167">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1167">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1168">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1168">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1169">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1169">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1170">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1170">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1171">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1171">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1172">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1172">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1173">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1173">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1174"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1174"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1175">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1175">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1176">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1176">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1177">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1177">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1178">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1178">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1179">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1179">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1180">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1180">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1181">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1181">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1182">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1182">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1183">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1183">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1184">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1184">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1185">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1185">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1186"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1186"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1187">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1187">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1188">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1188">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1189">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1189">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1190">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1190">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1191">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1191">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1192">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1192">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1193">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1193">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1194">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1194">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1195">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1195">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1196">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1196">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1197">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1197">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1198"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1198"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1199">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1199">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1200">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1200">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1201">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1201">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1202">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1202">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1203">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1203">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1204">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1204">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1205">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1205">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1206">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1206">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="78f4c-1207">要寫入值的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1207">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="78f4c-1208">要寫入的值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1208">The value to be written.</span></span></param>
        <summary><span data-ttu-id="78f4c-1209">立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1209">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1210"><xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1210"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="78f4c-1211">在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1211">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="78f4c-1212">在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1212">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="78f4c-1213">這可能需要清除處理器快取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1213">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="78f4c-1214">在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1214">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="78f4c-1215">因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1215">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="78f4c-1216">呼叫這個方法只會影響單一記憶體存取。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1216">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="78f4c-1217">若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1217">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="78f4c-1218">在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1218">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78f4c-1219">造成呼叫執行緒執行目前處理器上已就緒可執行的其他執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1219">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span></span> <span data-ttu-id="78f4c-1220">作業系統會選擇要執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1220">The operating system selects the thread to yield to.</span></span></summary>
        <returns>
          <span data-ttu-id="78f4c-1221">如果作業系統切換為執行其他執行緒，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1221"><see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78f4c-1222">如果此方法成功，會產生其他執行緒的目前時間配量。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1222">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="78f4c-1223">作業系統排程呼叫執行緒的另一個時間配量，根據其優先順序和可執行其他執行緒的狀態。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1223">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="78f4c-1224">產生僅限於用來執行呼叫執行緒的處理器。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1224">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="78f4c-1225">作業系統不會切換執行為另一個處理器，即使該處理器處於閒置狀態，或正在執行較低優先權的執行緒。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1225">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="78f4c-1226">如果沒有其他準備好要執行目前處理器上的執行緒、 作業系統並不會執行，產生和這個方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1226">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="78f4c-1227">這個方法相當於使用平台叫用呼叫原生 Win32`SwitchToThread`函式。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1227">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="78f4c-1228">您應該呼叫<xref:System.Threading.Thread.Yield%2A>方法，而不要使用平台叫用，因為平台叫用的任何自訂的執行緒行為主應用程式已要求略過。</span><span class="sxs-lookup"><span data-stu-id="78f4c-1228">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>