<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f908dbd04f1ed17bee04e225536a93e5e092d9d1" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061693" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>可建立和控制執行緒，設定執行緒的優先權，並取得它的狀態。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當處理程序啟動時，common language runtime 會自動建立單一前景執行緒來執行應用程式程式碼。 這個主要前景執行緒，以及處理序可建立一或多個執行緒來執行此程序相關聯的程式碼的一部分。 這些執行緒可以執行在前景或背景。 此外，您可以使用<xref:System.Threading.ThreadPool>common language runtime 所管理的背景工作執行緒上執行程式碼的類別。  
  
 本節內容  
  
 [啟動執行緒](#Starting)   
 [擷取執行緒物件](#Retrieving)   
 [前景和背景執行緒](#Foreground)   
 [文化特性和執行緒](#Culture)   
 [取得相關資訊和控制執行緒](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>啟動執行緒  
 您可以啟動執行緒藉由提供委派，表示要在其類別建構函式中執行執行緒的方法。 然後呼叫<xref:System.Threading.Thread.Start%2A>開始執行的方法。  
  
 <xref:System.Threading.Thread>建構函式可以採用兩個委派類型，根據是否將引數傳遞至方法，以執行其中一項：  
  
-   如果方法沒有引數，傳遞<xref:System.Threading.ThreadStart>委派建構函式。 它的簽章：  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     下列範例會建立並開始執行的執行緒`ExecuteInForeground`方法。 方法會顯示一些執行緒屬性的相關資訊，然後執行的迴圈，它會暫停半秒並會顯示經過的秒數。 當執行緒已執行至少五秒時，則迴圈結束，且在執行緒結束執行。  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   如果方法沒有引數，傳遞<xref:System.Threading.ParameterizedThreadStart>委派建構函式。 它的簽章：  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     然後委派所執行的方法可以轉型 （C# 中），或者 （在 Visual Basic) 參數轉換成適當的型別。  
  
     下列範例等同於前一個，不同之處在於它會呼叫<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>建構函式。 這個版本的`ExecuteInForeground`方法具有單一參數來表示近似的迴圈是執行的毫秒數。  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 不需要保留的參考<xref:System.Threading.Thread>物件一旦啟動執行緒。 執行緒會繼續執行直到完成為止，執行緒程序。  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>擷取執行緒物件  
 您可以使用靜態 (`Shared`在 Visual Basic 中)<xref:System.Threading.Thread.CurrentThread%2A>屬性，以擷取目前執行中執行緒的執行緒正在執行的程式碼中的參考。 下列範例會使用<xref:System.Threading.Thread.CurrentThread%2A>屬性來顯示主應用程式執行緒、 另一個前景執行緒，背景執行緒和執行緒集區執行緒的相關資訊。  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>前景和背景執行緒  
 執行個體<xref:System.Threading.Thread>類別代表前景執行緒或背景執行緒。 背景執行緒會與相同前景執行緒有一個例外狀況： 背景執行緒不會保存執行的處理序，如果所有的前景執行緒已經終止。 一旦所有的前景執行緒都已停止，執行階段會停止所有的背景執行緒，並關閉。  
  
 根據預設，下列的執行緒在前景執行：  
  
-   主應用程式執行緒。  
  
-   藉由呼叫建立的所有執行緒<xref:System.Threading.Thread>類別建構函式。  
  
 根據預設，在背景中執行下列執行緒：  
  
-   執行緒集區執行緒，也就是由執行階段所維護的背景工作執行緒集區。  您也可以使用執行緒集區執行緒上設定執行緒集區和排程工作<xref:System.Threading.ThreadPool>類別。  
  
    > [!NOTE]
    >  在執行緒集區執行緒上自動執行工作為基礎的非同步作業。 以工作為基礎的非同步作業會使用<xref:System.Threading.Tasks.Task>和<xref:System.Threading.Tasks.Task%601>類別以實作[工作架構非同步模式](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)。  
  
-   從 unmanaged 程式碼進入 managed 的執行環境的所有執行緒。  
  
 您可以變更執行緒在背景中執行，藉由設定<xref:System.Threading.Thread.IsBackground%2A>隨時屬性。  背景執行緒可用於任何作業，應該只要應用程式正在執行，但應該不會防止應用程式終止，例如監視檔案系統變更或連入通訊端連線。  
  
 下列範例說明前景和背景執行緒之間的差異。 就像中的第一個範例[啟動執行緒](#Starting)區段中，不同之處在於它會設定執行緒在背景執行前啟動它。 如輸出所示，它會執行五秒前中斷迴圈。  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>文化特性和執行緒  
 每個執行緒有所代表的文化特性，<xref:System.Threading.Thread.CurrentCulture%2A>屬性和 UI 文化特性所表示<xref:System.Threading.Thread.CurrentUICulture%2A>屬性。  目前的文化特性支援剖析和格式、 字串比較和排序，這類區分文化特性的作業，而且也會控制執行緒使用的行事曆與書寫系統。 目前 UI 文化特性提供區分文化特性擷取資源檔中的資源。  
  
 新的執行緒會具現化，其文化特性和 UI 文化特性定義的目前系統文化特性和 UI 文化特性，而不是文化特性和 UI 文化特性建立新的執行緒的執行緒。 這表示，例如，如果目前的系統文化特性是英文 （美國） 和主要的應用程式執行緒的目前文化特性為法文 （法國），藉由呼叫建立新執行緒的文化特性<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>從主執行緒的建構函式是英文 （美國） 和法文 （法國）。 如需詳細資訊，請參閱 < 文化特性和執行緒 」 一節<xref:System.Globalization.CultureInfo>類別主題。  
  
> [!IMPORTANT]
>  這不是執行非同步作業的應用程式為目標的執行緒，則為 true[!INCLUDE[net_v46](~/includes/net-v46-md.md)]和更新版本中的，在此情況下，文化特性和 UI 文化特性是一部分的非同步作業的內容; 在執行緒上的非同步作業執行的預設繼承的文化特性和 UI 文化特性的非同步作業已啟動執行緒。 如需詳細資訊，請參閱 <xref:System.Globalization.CultureInfo> 類別主題的＜文化特性和以工作為基礎的非同步作業＞一節。  
  
 您可以執行下列動作，以確保所有的執行緒執行的應用程式中共用相同的文化特性和 UI 文化特性：  
  
-   您可以傳遞<xref:System.Globalization.CultureInfo>物件，代表該文化特性<xref:System.Threading.ParameterizedThreadStart>委派或<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType>方法。  
  
-   在上執行的應用程式[!INCLUDE[net_v45](~/includes/net-v45-md.md)]和更新版本中，您可以定義的文化特性和 UI 文化特性所要指派給所設定的值建立應用程式定義域中的所有執行緒<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>屬性。 請注意，這是每個應用程式網域設定。  
  
 如需詳細資訊與範例，請參閱 < 文化特性和執行緒 > 一節<xref:System.Globalization.CultureInfo>類別主題。  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>取得相關資訊和控制執行緒  
 您可以擷取提供執行緒的相關資訊的屬性值的數目。 在某些情況下，您也可以設定這些屬性值來控制執行緒的作業。 這些執行緒屬性包括：  
  
-   名稱。 <xref:System.Threading.Thread.Name%2A> 會寫入-一次可用來識別在執行緒中的屬性。  預設值是`null`。  
  
-   雜湊程式碼，您可以藉由呼叫擷取<xref:System.Threading.Thread.GetHashCode%2A>方法。 雜湊程式碼可以用來唯一識別執行緒;在執行緒的存留期間，其雜湊程式碼不會與任何其他執行緒，不論應用程式定義域取得此值的值相衝突。  
  
-   執行緒識別碼。 唯讀值<xref:System.Threading.Thread.ManagedThreadId%2A>屬性由執行階段所指派，並且唯一地識別其處理程序中的執行緒。  
  
    > [!NOTE]
    >  作業系統的 [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) 與 Managed 執行緒之間沒有固定的關係，因為未受管理的主機可控制 Managed 執行緒與 Unmanaged 執行緒之間的關係。 具體來說，精密的主機可以使用[CLR 裝載 API](https://msdn.microsoft.com/library/ms404385.aspx)排程許多 managed 的執行緒，對相同的作業系統執行緒，或是不同的作業系統執行緒之間移動 managed 的執行緒。  
  
-   執行緒的目前狀態。 它的存在時間，執行緒一律是在一或多個定義的狀態<xref:System.Threading.ThreadState>屬性。  
  
-   排程的優先權層級，定義<xref:System.Threading.ThreadPriority>屬性。 雖然您可以設定此值，以要求執行緒的優先權，其不一定適用於作業系統。  
  
-   唯讀<xref:System.Threading.Thread.IsThreadPoolThread%2A>屬性，指出執行緒是否是在執行緒集區執行緒。  
  
-   <xref:System.Threading.Thread.IsBackground%2A> 屬性。 如需詳細資訊，請參閱[前景和背景執行緒](#Foreground)> 一節。  
  
## Examples  
 下列範例會示範簡單的執行緒功能。  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 此程式碼會產生類似下面的輸出：  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">委派，代表在這個執行緒開始執行時要叫用的方法。</param>
        <summary>初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體，並指定委派，讓物件可以在執行緒啟動時傳遞到執行緒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒不會開始執行時建立。 若要排程執行的執行緒，呼叫<xref:System.Threading.Thread.Start%2A>方法。 若要將資料物件傳遞到執行緒，使用<xref:System.Threading.Thread.Start%28System.Object%29>方法多載。  
  
> [!NOTE]
>  Visual Basic 使用者可以省略<xref:System.Threading.ThreadStart>建構函式建立執行緒時。 使用`AddressOf`運算子時傳遞您的方法，例如`Dim t As New Thread(AddressOf ThreadProc)`。 Visual Basic 會自動呼叫<xref:System.Threading.ThreadStart>建構函式。  
  
   
  
## Examples  
 下列範例顯示建立和使用的語法<xref:System.Threading.ParameterizedThreadStart>具有靜態方法和執行個體方法的委派。  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> 為 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">
          <see cref="T:System.Threading.ThreadStart" /> 委派，代表在這個執行緒開始執行時要叫用的方法。</param>
        <summary>初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒不會開始執行時建立。 若要排程執行的執行緒，呼叫<xref:System.Threading.Thread.Start%2A>方法。  
  
> [!NOTE]
>  Visual Basic 使用者可以省略<xref:System.Threading.ThreadStart>建構函式建立執行緒時。 使用`AddressOf`運算子，例如傳遞方法時`Dim t As New Thread(AddressOf ThreadProc)`。 Visual Basic 會自動呼叫<xref:System.Threading.ThreadStart>建構函式。  
  
   
  
## Examples  
 下列程式碼範例示範如何建立執行靜態方法的執行緒。  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 下列程式碼範例示範如何建立執行個體方法的執行緒。  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> 參數為 <see langword="null" />。</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <see cref="T:System.Threading.ParameterizedThreadStart" /> 委派，代表在這個執行緒開始執行時要叫用的方法。</param>
        <param name="maxStackSize">執行緒使用的最大堆疊大小 (以位元組為單位)，或是 0，使用可執行檔標頭中指定的預設最大堆疊大小。  
  
 重要資訊：對於部分信任的程式碼，如果 <c>maxStackSize</c> 大於預設堆疊大小，則會加以忽略。 不會有例外狀況擲回。</param>
        <summary>初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體，指定委派，讓物件可以在執行緒啟動時傳遞到執行緒，並指定執行緒的堆疊大小上限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請避免使用這個建構函式多載。 所使用的預設堆疊大小<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>建構函式多載是建議的堆疊大小執行緒。 如果執行緒有記憶體問題，最可能的原因程式設計錯誤，例如無限遞迴。  
  
> [!IMPORTANT]
>  開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、 只有完全受信任的程式碼可以設定`maxStackSize`大於預設堆疊大小 (1 mb) 的值。 如果指定較大的值`maxStackSize`以部分信任，請在執行程式碼時`maxStackSize`會被忽略，而且是預設堆疊大小。 不會有例外狀況擲回。 任何信任層級的程式碼可以設定`maxStackSize`小於預設堆疊大小的值。  
  
> [!NOTE]
>  如果您開發部分信任的程式碼，將使用完全信任程式庫，而且您要啟動的執行緒需要大型堆疊，您必須先建立執行緒，判斷提示完全信任或將使用預設堆疊大小。 不要這樣除非您完全控制的執行緒執行的程式碼。  
  
 如果`maxStackSize`小於最小的堆疊大小，使用最小的堆疊大小。 如果`maxStackSize`不多的頁面大小會四捨五入為下一個較大頁面大小的倍數。 例如，如果您在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262144 位元組） 是最小的堆疊大小，和頁面大小是 64 KB （65536 個位元組）。  
  
> [!NOTE]
>  Microsoft Windows Windows XP 和 Windows Server 2003 之前, 的版本上`maxStackSize`會被忽略，而且是可執行檔的標頭中指定的堆疊大小。  
  
 如果您指定非常小的堆疊大小，您可能需要停用堆疊探查。 在堆疊嚴重受限，探查可以本身可能會造成堆疊溢位。 若要停用堆疊探查，加入下列應用程式組態檔。  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> 小於零。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <see cref="T:System.Threading.ThreadStart" /> 委派，代表在這個執行緒開始執行時要叫用的方法。</param>
        <param name="maxStackSize">執行緒使用的最大堆疊大小 (以位元組為單位)，或是 0，使用可執行檔標頭中指定的預設最大堆疊大小。  
  
 重要資訊：對於部分信任的程式碼，如果 <c>maxStackSize</c> 大於預設堆疊大小，則會加以忽略。 不會有例外狀況擲回。</param>
        <summary>初始化 <see cref="T:System.Threading.Thread" /> 類別的新執行個體，並指定執行緒的堆疊大小上限。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請避免使用這個建構函式多載。 所使用的預設堆疊大小<xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>建構函式多載是建議的堆疊大小執行緒。 如果執行緒有記憶體問題，最可能的原因程式設計錯誤，例如無限遞迴。  
  
> [!IMPORTANT]
>  開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、 只有完全受信任的程式碼可以設定`maxStackSize`大於預設堆疊大小 (1 mb) 的值。 如果指定較大的值`maxStackSize`以部分信任，請在執行程式碼時`maxStackSize`會被忽略，而且是預設堆疊大小。 不會有例外狀況擲回。 任何信任層級的程式碼可以設定`maxStackSize`小於預設堆疊大小的值。  
  
> [!NOTE]
>  如果您開發部分信任的程式碼，將使用完全信任程式庫，而且您要啟動的執行緒需要大型堆疊，您必須先建立執行緒，判斷提示完全信任或將使用預設堆疊大小。 不要這樣除非您完全控制的執行緒執行的程式碼。  
  
 如果`maxStackSize`小於最小的堆疊大小，使用最小的堆疊大小。 如果`maxStackSize`不多的頁面大小會四捨五入為下一個較大頁面大小的倍數。 例如，如果您在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262144 位元組） 是最小的堆疊大小，和頁面大小是 64 KB （65536 個位元組）。  
  
> [!NOTE]
>  Microsoft Windows Windows XP 和 Windows Server 2003 之前, 的版本上`maxStackSize`會被忽略，而且是可執行檔的標頭中指定的堆疊大小。  
  
 如果您指定非常小的堆疊大小，您可能需要停用堆疊探查。 在堆疊嚴重受限，探查可以本身可能會造成堆疊溢位。 若要停用堆疊探查，加入下列應用程式組態檔。  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> 小於零。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>於被叫用的所在執行緒中引發 <see cref="T:System.Threading.ThreadAbortException" />，開始處理執行緒的結束作業。 呼叫這個方法通常會結束執行緒。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>於被叫用的所在執行緒中引發 <see cref="T:System.Threading.ThreadAbortException" />，開始處理執行緒的結束作業。 呼叫這個方法通常會結束執行緒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在執行緒上叫用這個方法時，系統會擲回<xref:System.Threading.ThreadAbortException>中將它中止的執行緒。 `ThreadAbortException` 是特殊的例外狀況可以攔截的應用程式程式碼，但是會重新擲回的結尾`catch`封鎖除非<xref:System.Threading.Thread.ResetAbort%2A>呼叫。 `ResetAbort` 取消要求中止，並防止`ThreadAbortException`終止執行緒。 未執行`finally`區塊會執行已中止的執行緒之前。  
  
> [!NOTE]
>  當一個執行緒呼叫`Abort`效果是類似於擲回例外狀況; 本身，<xref:System.Threading.ThreadAbortException>時會立即，且結果為可預測。 不過，如果一個執行緒呼叫`Abort`，另一個執行緒上中斷執行任何程式碼中止。 此外，也可能已中止的靜態建構函式有機會。 在罕見的情況下，這可能導致無法建立應用程式定義域中的類別的執行個體。 在.NET framework 1.0 和 1.1 版中，的可能會無法中止執行緒時`finally`執行的區塊，在此情況下`finally`區塊就會中止。  
  
 執行緒中止立即，或完全不保證。 如果執行緒沒有無限量的空間中的計算，可能會發生這種情況下`finally`稱為中止程序，藉此無限延遲中止的區塊。 若要等候，直到執行緒已中止，您可以呼叫<xref:System.Threading.Thread.Join%2A>方法之後呼叫的執行緒上<xref:System.Threading.Thread.Abort%2A>方法，但不保證將會結束等待。  
  
> [!NOTE]
>  呼叫的執行緒<xref:System.Threading.Thread.Abort%2A>是否要中止的執行緒中受保護的區域，程式碼，例如，可能會封鎖`catch`區塊，`finally`區塊或限制的執行區域。 如果執行緒呼叫<xref:System.Threading.Thread.Abort%2A>鎖定要求已中止的執行緒，便會發生死結。  
  
 如果`Abort`稱為上尚未啟動的執行緒，執行緒將會中止時<xref:System.Threading.Thread.Start%2A>呼叫。 如果`Abort`呼叫執行緒時遭到封鎖或睡眠中的執行緒上中斷，並再中止。  
  
 如果`Abort`已暫停的執行緒上呼叫<xref:System.Threading.ThreadStateException>呼叫的執行緒中擲回<xref:System.Threading.Thread.Abort%2A>，和<xref:System.Threading.ThreadState.AbortRequested>加入至<xref:System.Threading.Thread.ThreadState%2A>正在中止的執行緒屬性。 A<xref:System.Threading.ThreadAbortException>才會擲回在暫停的執行緒，直到<xref:System.Threading.Thread.Resume%2A>呼叫。  
  
 如果`Abort`執行 unmanaged 程式碼時，在 managed 執行緒上呼叫`ThreadAbortException`傳回給 managed 程式碼的執行緒之前不會擲回。  
  
 如果兩個呼叫會以`Abort`出現在相同的時間，它是一個設定的狀態資訊的呼叫和其他執行的呼叫可能`Abort`。 不過，應用程式無法偵測這種情況。  
  
 之後`Abort`叫用執行緒上、 執行緒的狀態包括<xref:System.Threading.ThreadState.AbortRequested>。 執行緒已經終止由於成功呼叫之後`Abort`，執行緒的狀態變更為<xref:System.Threading.ThreadState.Stopped>。 具有足夠的權限的執行緒，做為目標的`Abort`可以取消中止使用`ResetAbort`方法。 如需範例，示範如何呼叫`ResetAbort`方法，請參閱`ThreadAbortException`類別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：不支援此成員。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.Threading.ThreadStateException">要中止的執行緒目前已暫止。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">進階的執行緒上作業。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">包含特定應用程式資訊 (例如狀態) 的物件，正在中止的執行緒可以使用這個物件。</param>
        <summary>於被叫用的所在執行緒中引發 <see cref="T:System.Threading.ThreadAbortException" />，開始結束執行緒的處理作業，同時也提供執行緒結束的相關例外狀況資訊。 呼叫這個方法通常會結束執行緒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在執行緒上叫用這個方法時，系統會擲回<xref:System.Threading.ThreadAbortException>中將它中止的執行緒。 `ThreadAbortException` 是特殊的例外狀況可以攔截的應用程式程式碼，但是會重新擲回的結尾`catch`封鎖除非<xref:System.Threading.Thread.ResetAbort%2A>呼叫。 `ResetAbort` 取消要求中止，並防止`ThreadAbortException`終止執行緒。 未執行`finally`區塊會執行已中止的執行緒之前。  
  
> [!NOTE]
>  當一個執行緒呼叫`Abort`效果是類似於擲回例外狀況; 本身，<xref:System.Threading.ThreadAbortException>時會立即，且結果為可預測。 不過，如果一個執行緒呼叫`Abort`，另一個執行緒上中斷執行任何程式碼中止。 沒有靜態建構函式可能會中止的機率。 在罕見的情況下，這可能導致無法建立應用程式定義域中的類別的執行個體。 在.NET framework 1.0 和 1.1 版中，的可能會無法中止執行緒時`finally`執行的區塊，在此情況下`finally`區塊就會中止。  
  
 執行緒中止立即，或完全不保證。 如果執行緒沒有無限量的空間中的計算，可能會發生這種情況下`finally`稱為中止程序，藉此無限延遲中止的區塊。 若要等候，直到執行緒已中止，您可以呼叫<xref:System.Threading.Thread.Join%2A>方法之後呼叫的執行緒上<xref:System.Threading.Thread.Abort%2A>方法，但不保證會結束等待。  
  
> [!NOTE]
>  呼叫的執行緒<xref:System.Threading.Thread.Abort%2A>是否要中止的執行緒中受保護的區域，程式碼，例如，可能會封鎖`catch`區塊，`finally`區塊或限制的執行區域。 如果執行緒呼叫<xref:System.Threading.Thread.Abort%2A>鎖定要求已中止的執行緒，便會發生死結。  
  
 如果`Abort`稱為上尚未啟動的執行緒，執行緒將會中止時<xref:System.Threading.Thread.Start%2A>呼叫。 如果`Abort`呼叫執行緒時遭到封鎖或睡眠中的執行緒上中斷，並再中止。  
  
 如果`Abort`已暫停的執行緒上呼叫<xref:System.Threading.ThreadStateException>呼叫的執行緒中擲回<xref:System.Threading.Thread.Abort%2A>，和<xref:System.Threading.ThreadState.AbortRequested>加入至<xref:System.Threading.Thread.ThreadState%2A>正在中止的執行緒屬性。 A<xref:System.Threading.ThreadAbortException>才會擲回在暫停的執行緒，直到<xref:System.Threading.Thread.Resume%2A>呼叫。  
  
 如果`Abort`執行 unmanaged 程式碼時，在 managed 執行緒上呼叫`ThreadAbortException`傳回給 managed 程式碼的執行緒之前不會擲回。  
  
 如果兩個呼叫會以`Abort`出現在相同的時間，它是一個設定的狀態資訊的呼叫和其他執行的呼叫可能`Abort`。 不過，應用程式無法偵測這種情況。  
  
 之後`Abort`叫用執行緒上、 執行緒的狀態包括<xref:System.Threading.ThreadState.AbortRequested>。 執行緒已經終止由於成功呼叫之後`Abort`，執行緒的狀態變更為<xref:System.Threading.ThreadState.Stopped>。 具有足夠的權限的執行緒，做為目標的`Abort`可以取消中止使用`ResetAbort`方法。 如需範例，示範如何呼叫`ResetAbort`方法，請參閱`ThreadAbortException`類別。  
  
   
  
## Examples  
 下列程式碼範例示範如何將資訊傳遞給要中止的執行緒。  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：不支援此成員。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.Threading.ThreadStateException">要中止的執行緒目前已暫止。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">進階的執行緒上作業。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在所有的執行緒上配置未命名的資料位置。 為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</summary>
        <returns>在所有執行緒上已配置的具名資料位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 在所有執行緒上配置的位置。  
  
 執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。 第二個範例示範如何使用資料位置來執行相同的動作。  
  
 **第一個範例**  
  
 下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。 這項技術提供更佳的效能比第二個範例所示的技巧。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二個範例**  
  
 下列程式碼範例示範如何使用資料位置來儲存執行緒特定的資訊。  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要配置之資料插槽的名稱。</param>
        <summary>在所有的執行緒上配置命名的資料位置。 為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</summary>
        <returns>在所有執行緒上已配置的具名資料位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。  
  
 不需要使用<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法來配置命名的資料位置，因為<xref:System.Threading.Thread.GetNamedDataSlot%2A>方法配置位置，如果它不已配置。  
  
> [!NOTE]
>  如果<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法時，它應該呼叫在主執行緒在程式啟動時，因為它會擲回例外狀況，如果已配置具有指定名稱的位置。 沒有任何方法來測試是否已配置的位置。  
  
 以這個方法所配置的位置必須釋放與<xref:System.Threading.Thread.FreeNamedDataSlot%2A>。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。 第二個範例示範如何使用資料位置來執行相同的動作。  
  
 **第一個範例**  
  
 下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。 這項技術提供更佳的效能比第二個範例所示的技巧。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二個範例**  
  
 下列範例會示範如何使用具名的資料位置來儲存執行緒特定的資訊。  
  
> [!NOTE]
>  範例程式碼不會使用<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法，因為<xref:System.Threading.Thread.GetNamedDataSlot%2A>方法配置位置，如果它不已配置。 如果<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>方法時，應該在程式啟動時在主執行緒中呼叫它。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">具有指定名稱的具名資料位置已存在。</exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個執行緒的 Apartment 狀態。</summary>
        <value>其中一個 <see cref="T:System.Threading.ApartmentState" /> 值。 初始值為 <see langword="Unknown" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **<xref:System.Threading.Thread.ApartmentState%2A>屬性已經過時。**  非過時的替代方式為<xref:System.Threading.Thread.GetApartmentState%2A>方法來擷取的 apartment 狀態和<xref:System.Threading.Thread.SetApartmentState%2A>方法，以設定 apartment 狀態。  
  
 在.NET framework 1.0 和 1.1 版，`ApartmentState`屬性標記，表示它會在單一執行緒或多執行緒 apartment 中執行的執行緒。 可以設定這個屬性，當執行緒處於`Unstarted`或`Running`執行緒狀態; 不過，它可以只能設定一次的執行緒。 如果尚未設定屬性，它會傳回`Unknown`。  
  
 嘗試使用<xref:System.Threading.Thread.ApartmentState%2A>屬性來設定其 apartment 狀態已設定執行緒的 apartment 狀態會被忽略。 不過，<xref:System.Threading.Thread.SetApartmentState%2A>方法會擲回<xref:System.InvalidOperationException>在此情況下。  
  
> [!IMPORTANT]
>  在.NET Framework 2.0 版中，新的執行緒初始化為<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果會在啟動之前不已設定其 apartment 狀態。 主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>預設。 您可以不再將設定主應用程式執行緒<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>藉由設定<xref:System.Threading.ApartmentState?displayProperty=nameWithType>第一行程式碼上的屬性。 使用<xref:System.STAThreadAttribute>改為。  
  
 在.NET Framework 2.0 版中，您可以指定的 COM 執行緒模型為 c + + 應用程式使用[/CLRTHREADATTRIBUTE （設定 CLR 執行緒屬性）](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)連結器選項。  
  
   
  
## Examples  
 下列程式碼範例示範如何設定執行緒的 apartment 狀態。  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">已嘗試將此屬性狀態設定為無效 Apartment 狀態 (單一執行緒 Apartment (<see langword="STA" />) 或多執行緒 Apartment (<see langword="MTA" />) 以外的狀態)。</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知主機在即將執行的程式碼區域中，執行緒中止或未處理例外狀況的影響，可能會危及應用程式定義域中的其他工作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 主控件，例如 Microsoft SQL Server 2005，common language runtime (CLR)，可以建立不同的原則中的程式碼的重大和非關鍵區域的失敗。 在其中執行緒中止或未處理的例外狀況的影響可能不是目前的工作是關鍵區域。 相反地，中止或非關鍵的程式碼區域中的失敗會影響只有工作發生錯誤。  
  
 例如，假設有嘗試配置記憶體時保留鎖定工作。 如果記憶體配置失敗，正在中止目前的工作並不足以確保穩定性<xref:System.AppDomain>，因為在等候相同的鎖定網域中可以有其他工作。 如果目前的工作已中止，其他工作可能發生死結。  
  
 發生失敗時的關鍵區域中，主機可能會決定卸載整個<xref:System.AppDomain>而不需要繼續執行，可能會不穩定的狀態中的風險。 若要通知您的程式碼正在進入關鍵區域的主機，呼叫<xref:System.Threading.Thread.BeginCriticalRegion%2A>。 呼叫<xref:System.Threading.Thread.EndCriticalRegion%2A>當執行會傳回非關鍵的程式碼區域。  
  
 SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.Thread.BeginCriticalRegion%2A>和<xref:System.Threading.Thread.EndCriticalRegion%2A>分成重大和非重大地區的程式碼區塊的方法。  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知主機 Managed 程式碼即將執行指令，而這些指令相依於目前實體作業系統執行緒的識別 (Identity)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些主機的 common language runtime，例如 Microsoft SQL Server 2005，提供它們自己的執行緒管理。 提供它自己的執行緒管理的主機執行的工作從一個實體作業系統執行緒之間移動在任何時間。 大部分的工作不會受到這個切換。 不過，某些工作執行緒相似性，也就是相依實體作業系統執行緒的識別。 這些工作必須通知主應用程式時執行程式碼，不會切換。  
  
 例如，如果您的應用程式呼叫系統 API，以取得作業系統鎖定具有執行緒相似性，例如 Win32 CRITICAL_SECTION，您必須呼叫<xref:System.Threading.Thread.BeginThreadAffinity%2A>之前取得鎖定，以及<xref:System.Threading.Thread.EndThreadAffinity%2A>之後釋放鎖定。  
  
 SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.Thread.BeginThreadAffinity%2A>和<xref:System.Threading.Thread.EndThreadAffinity%2A>方法，以通知主機一段程式碼相依於實體作業系統執行緒的識別。  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得執行緒正在執行的目前內容。</summary>
        <value>
          <see cref="T:System.Runtime.Remoting.Contexts.Context" />，代表目前的執行緒內容。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定目前執行緒的文化特性 (Culture)。</summary>
        <value>表示目前執行緒之文化特性的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo>物件，這個屬性，以及其相關聯的物件，就會傳回判斷預設格式的日期、 時間、 數字、 貨幣值，排序順序的文字、 大小寫慣例，以及字串比較。 請參閱<xref:System.Globalization.CultureInfo>類別若要了解有關的文化特性名稱和識別碼，而異，中性和特定文化特性之間的差異，以及方法的文化特性資訊影響執行緒和應用程式定義域。 請參閱<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>屬性若要了解如何決定執行緒的預設文化特性，以及使用者如何設定電腦的文化特性資訊。  
  
 開頭為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]，您可以設定<xref:System.Threading.Thread.CurrentCulture%2A>中性文化特性的屬性。 這是因為的行為<xref:System.Globalization.CultureInfo>類別已變更： 當它代表中性文化特性，其屬性值 (特別是， <xref:System.Globalization.CultureInfo.Calendar%2A>， <xref:System.Globalization.CultureInfo.CompareInfo%2A>， <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>， <xref:System.Globalization.CultureInfo.NumberFormat%2A>，和<xref:System.Globalization.CultureInfo.TextInfo%2A>屬性) 現在反映中性文化特性相關聯的特定文化特性。 在舊版的.NET Framework 中，<xref:System.Threading.Thread.CurrentCulture%2A>屬性擲回<xref:System.NotSupportedException>時中性文化特性已指派的例外狀況。  
  
   
  
## Examples  
 下列程式碼範例顯示可讓 Windows Form 顯示在 [控制台] 中設定的文化特性的使用者介面執行緒陳述式。 需要額外的程式碼。  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">該屬性設定為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">設定屬性。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定執行緒目前的原則 (角色架構安全性之用)。</summary>
        <value>
          <see cref="T:System.Security.Principal.IPrincipal" /> 值，代表安全性的內容。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何設定及擷取執行緒的主體。  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有設定主體的必要權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">操作主體物件。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前執行的執行緒。</summary>
        <value>
          <see cref="T:System.Threading.Thread" />，是目前執行之執行緒的表示。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會建立輪流建立 20 個子任務的工作。 應用程式本身，以及每項工作中，以呼叫`ShowThreadInformation`方法，會使用<xref:System.Threading.Thread.CurrentThread%2A>屬性來顯示它正在執行之執行緒的相關資訊。  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 每項子工作會產生介於 1 到 1 百萬個 1 百萬個隨機的數字，並傳回其平均值。 父工作呼叫<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法，以確保子工作已完成之後，顯示每項工作所傳回的平均值，計算平均數的方式。  
  
 請注意，應用程式在前景執行緒上執行，而在執行緒集區執行緒上執行每項工作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定資源管理員目前用以在執行階段查詢特定文化特性資源所用的文化特性。</summary>
        <value>表示目前文化特性的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 UI 文化特性會指定應用程式需要支援使用者輸入和輸出，而且預設為作業系統的文化特性相同的資源。 請參閱<xref:System.Globalization.CultureInfo>類別若要了解有關的文化特性名稱和識別碼，而異，中性和特定文化特性之間的差異，以及方法的文化特性資訊影響執行緒和應用程式定義域。 請參閱<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>若要了解如何判斷執行緒的預設 UI 文化特性的屬性。  
  
 <xref:System.Globalization.CultureInfo>傳回這個屬性可以是中性文化特性。 中性文化特性不應以格式化方法，例如<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>， <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>，和<xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>。 使用<xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>方法來取得特定文化特性，或使用<xref:System.Threading.Thread.CurrentCulture%2A>屬性。  
  
> [!NOTE]
>  <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>方法會擲回<xref:System.ArgumentException>中性文化特性"zh-chs 和-Hant"("zh-chs 和 ZH-CHT") 和 「 zh-chs 和-Hans"("ZH-CHS")。  
  
   
  
## Examples  
 下列範例會判斷是否在目前執行緒的 UI 文化特性的語言為法文。 若不存在，則會設定為英文 （美國） 的目前執行緒的 UI 文化特性。  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 下列程式碼範例顯示可讓 Windows Form 顯示在 [控制台] 中設定的文化特性的使用者介面執行緒陳述式。 需要額外的程式碼。  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">該屬性設定為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">此屬性設為無法用來尋找資源檔的文化特性名稱。 資源檔名稱只可以包含字母、數字、連字號或底線。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉目前執行緒之執行階段可呼叫包裝函式 (RCW) 的自動清除功能。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，common language runtime (CLR) 會清除執行階段可呼叫包裝函式自動。 CLR 幫浦內訊息的清除，這可能會造成一些符合下列準則不尋常的應用程式的重新進入問題：  
  
-   應用程式會自己訊息幫浦作業。  
  
-   應用程式需要訊息幫浦作業發生時，精確地控制。  
  
 這類應用程式可以使用<xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A>方法，以防止 CLR 做自動回收執行階段可呼叫包裝函式。  
  
 如果在執行緒上呼叫此方法，就無法重新啟用該執行緒自動清除。 您的應用程式準備好要清除執行階段可呼叫包裝函式時，請使用<xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType>方法，以指示清除所有執行階段可呼叫包裝函式在目前內容中執行階段。 當方法執行時，就會發生訊息幫浦作業。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知主機在即將執行的程式碼區域中，執行緒中止或未處理例外狀況影響的對象只限於目前的工作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 主控件，例如 Microsoft SQL Server 2005，common language runtime (CLR)，可以建立不同的原則中的程式碼的重大和非關鍵區域的失敗。 在其中執行緒中止或未處理的例外狀況的影響可能不是目前的工作是關鍵區域。 相反地，中止或非關鍵的程式碼區域中的失敗會影響只有工作發生錯誤。  
  
 例如，假設有嘗試配置記憶體時保留鎖定工作。 如果記憶體配置失敗，正在中止目前的工作並不足以確保穩定性<xref:System.AppDomain>，因為在等候相同的鎖定網域中可以有其他工作。 如果目前的工作已中止，其他工作可能發生死結。  
  
 發生失敗時的關鍵區域中，主機可能會決定卸載整個<xref:System.AppDomain>而不需要繼續執行，可能會不穩定的狀態中的風險。 若要通知您的程式碼正在進入關鍵區域的主機，呼叫<xref:System.Threading.Thread.BeginCriticalRegion%2A>。 呼叫<xref:System.Threading.Thread.EndCriticalRegion%2A>當執行會傳回非關鍵的程式碼區域。  
  
 SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.Thread.BeginCriticalRegion%2A>和<xref:System.Threading.Thread.EndCriticalRegion%2A>分成重大和非重大地區的程式碼區塊的方法。  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知主機 Managed 程式碼已完成執行指令，而這些指令相依於目前實體作業系統執行緒的識別。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些主機的 common language runtime，例如 Microsoft SQL Server 2005，提供它們自己的執行緒管理。 提供它自己的執行緒管理的主機執行的工作從一個實體作業系統執行緒之間移動在任何時間。 大部分的工作不會受到這個切換。 不過，某些工作執行緒相似性，也就是相依實體作業系統執行緒的識別。 這些工作必須通知主應用程式時執行程式碼，不會切換。  
  
 例如，如果您的應用程式呼叫系統 API，以取得作業系統鎖定具有執行緒相似性，例如 Win32 CRITICAL_SECTION，您必須呼叫<xref:System.Threading.Thread.BeginThreadAffinity%2A>之前取得鎖定，以及<xref:System.Threading.Thread.EndThreadAffinity%2A>之後釋放鎖定。  
  
 SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.Thread.BeginThreadAffinity%2A>和<xref:System.Threading.Thread.EndThreadAffinity%2A>方法，以通知主機一段程式碼相依於實體作業系統執行緒的識別。  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Threading.ExecutionContext" /> 物件，包含目前執行緒各種內容的相關資訊。</summary>
        <value>
          <see cref="T:System.Threading.ExecutionContext" /> 物件，合併目前執行緒的內容資訊。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext>類別會提供所有的相關資訊的邏輯執行緒執行的單一容器。 這包括安全性內容中，呼叫內容、 同步處理內容、 當地語系化內容和交易內容。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>確認釋出資源，並在記憶體回收行程再利用 <see cref="T:System.Threading.Thread" /> 物件時執行其他清除作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 記憶體回收行程呼叫<xref:System.Threading.Thread.Finalize%2A>準備最終處理而將目前的物件時。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要釋放之資料插槽的名稱。</param>
        <summary>排除處理程序中所有執行緒的名稱和位置之間的關聯。 為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 任何執行緒呼叫之後`FreeNamedDataSlot`，呼叫的其他任何執行緒<xref:System.Threading.Thread.GetNamedDataSlot%2A>相同的名稱就會配置新的位置與名稱相關聯。 後續呼叫`GetNamedDataSlot`任何執行緒會傳回新的位置。 不過，任何執行緒，仍有<xref:System.LocalDataStoreSlot?displayProperty=nameWithType>先前呼叫所傳回的`GetNamedDataSlot`可以繼續使用舊的位置。  
  
 釋放與名稱關聯的位置時，才每`LocalDataStoreSlot`之前呼叫取得`FreeNamedDataSlot`已釋放及回收。  
  
 執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。 第二個範例示範如何使用資料位置來執行相同的動作。  
  
 **第一個範例**  
  
 下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。 這項技術提供更佳的效能比第二個範例所示的技巧。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二個範例**  
  
 下列範例會示範如何使用具名的資料位置來儲存執行緒特定的資訊。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回表示 Apartment 狀態的 <see cref="T:System.Threading.ApartmentState" /> 值。</summary>
        <returns>其中一個 <see cref="T:System.Threading.ApartmentState" /> 值，表示 Managed 執行緒的 Apartment 狀態。 預設值為 <see cref="F:System.Threading.ApartmentState.Unknown" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法中，連同<xref:System.Threading.Thread.SetApartmentState%2A>方法和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。 程式碼範例會建立執行緒。 在執行緒啟動之前，<xref:System.Threading.Thread.GetApartmentState%2A>顯示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>狀態和<xref:System.Threading.Thread.SetApartmentState%2A>將狀態變更為<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。 <xref:System.Threading.Thread.TrySetApartmentState%2A>方法接著會傳回`false`嘗試將狀態變更時<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因為已設定 apartment 狀態。 如果相同的作業具有已嘗試使用<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>就已擲回。  
  
 在執行緒啟動之後，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法會再次使用。 這次會擲回<xref:System.Threading.ThreadStateException>因為執行緒已經啟動。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Threading.CompressedStack" /> 物件，可以用來擷取目前執行緒的堆疊。</summary>
        <returns>無。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不再支援這個方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在所有情況下。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">要從其中取得值的 <see cref="T:System.LocalDataStoreSlot" />。</param>
        <summary>從目前執行緒上、目前執行緒之目前定義域中的指定位置擷取數值。 為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</summary>
        <returns>擷取的數值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> 是`Shared`一律適用於目前執行中執行緒，即使您使用的變數，指的是另一個執行緒呼叫的方法。 為了避免混淆，類別名稱呼叫時，使用`Shared`方法： `Dim test As Object = Thread.GetData(testSlot)`。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。 第二個範例示範如何使用資料位置來執行相同的動作。  
  
 **第一個範例**  
  
 下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。 這項技術提供更佳的效能比第二個範例所示的技巧。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二個範例**  
  
 下列範例示範如何使用資料位置來儲存執行緒特定的資訊。  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前執行緒正在其中執行的目前定義域。</summary>
        <returns>
          <see cref="T:System.AppDomain" />，代表執行中的執行緒目前的應用程式定義域。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何擷取名稱和識別碼`AppDomain`中的執行緒執行。  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回唯一的應用程式定義域識別項。</summary>
        <returns>唯一識別應用程式定義域的 32 位元帶正負號的整數 (Signed Integer)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列程式碼範例示範如何擷取名稱和識別碼`AppDomain`中的執行緒執行。  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前執行緒的雜湊碼。</summary>
        <returns>整數雜湊碼值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不保證是唯一的雜湊碼。 使用<xref:System.Threading.Thread.ManagedThreadId%2A>屬性，如果您需要 managed 執行緒的唯一識別碼。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">本機資料位置的名稱。</param>
        <summary>尋找具名的資料位置。 為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</summary>
        <returns>為這個執行緒配置的 <see cref="T:System.LocalDataStoreSlot" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。  
  
 如果具名的位置不存在，則會配置新的位置。 具名的資料位置是公用的任何人都可以管理。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。 第二個範例示範如何使用資料位置來執行相同的動作。  
  
 **第一個範例**  
  
 下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。 這項技術提供更佳的效能比第二個範例所示的技巧。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二個範例**  
  
 下列範例會示範如何使用具名的資料位置來儲存執行緒特定的資訊。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>中斷處於 <see langword="WaitSleepJoin" /> 執行緒狀態的執行緒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個執行緒目前未遭到封鎖在等候、 睡眠或聯結狀態，它將會中斷接下來開始封鎖時。  
  
 <xref:System.Threading.ThreadInterruptedException> 在中斷之執行緒，但直到則執行緒會封鎖，就會擲回。 如果執行緒永不封鎖，永遠不會擲回例外狀況，並因此執行緒可能會完成，而任何中斷。  
  
   
  
## Examples  
 下列程式碼範例顯示執行中的執行緒行為時中斷，並接著已遭到封鎖。  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有適當的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">進階的執行緒上作業。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</permission>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目前執行緒的執行狀態。</summary>
        <value>
          如果這個執行緒已經啟動但還沒有正常結束或者中止，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出執行緒是不是背景執行緒。</summary>
        <value>
          如果這個執行緒是背景執行緒或者會成為背景執行緒，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒是背景執行緒或前景執行緒。 背景執行緒就前景執行緒相同，不同之處在於背景執行緒不會防止處理序終止。 一旦處理程序所屬的所有前景執行緒已經都終止，common language runtime 會結束處理程序。 任何剩餘的背景執行緒已停止，並不會完成。  
  
 依預設，下列執行緒則是在前景執行 (也就是其<xref:System.Threading.Thread.IsBackground%2A>屬性會傳回`false`):  
  
-   主執行緒 （或主應用程式執行緒）。  
  
-   藉由呼叫建立的所有執行緒<xref:System.Threading.Thread>類別建構函式。  
  
 依預設，下列執行緒則是在背景中執行 (也就是其<xref:System.Threading.Thread.IsBackground%2A>屬性會傳回`true`):  
  
-   執行緒集區執行緒，也就是由執行階段所維護的背景工作執行緒集區。 您也可以使用執行緒集區執行緒上設定執行緒集區和排程工作<xref:System.Threading.ThreadPool>類別。  
  
    > [!NOTE]
    >  在執行緒集區執行緒上自動執行工作為基礎的非同步作業。  
  
-   從 unmanaged 程式碼進入 managed 的執行環境的所有執行緒。  
  
   
  
## Examples  
 下列範例會比對前景和背景執行緒的行為。 它會建立前景執行緒與背景執行緒。 前景執行緒會持續處理序執行，直到完成其`for`迴圈，並終止。 不過，如範例輸出所示，因為前景執行緒已執行完畢，處理程序之前，終止背景執行緒完成執行。  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">執行緒已無作用</exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出執行緒是否屬於 Managed 執行緒集區。</summary>
        <value>
          <see langword="true" />，表示這個執行緒屬於 Managed 執行緒集區，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需詳細資訊，請參閱[Managed 執行緒集區](~/docs/standard/threading/the-managed-thread-pool.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何判斷執行緒是否是在執行緒集區。  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>封鎖呼叫執行緒，直到此執行個體所代表的執行緒終止為止。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>封鎖呼叫執行緒，直到此執行個體所代表的執行緒終止為止，但仍會繼續執行標準的 COM 與 <see langword="SendMessage" /> 提取作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> 封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到執行緒的同步處理方法的<xref:System.Threading.Thread.Join%2A>方法呼叫已完成。 使用這個方法，以確保執行緒已終止。 如果執行緒不會終止，將會無限期地封鎖呼叫端。 在下列範例中，`Thread1`執行緒呼叫<xref:System.Threading.Thread.Join>方法`Thread2`，這會導致`Thread1`區塊，直到`Thread2`已完成。  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 如果執行緒已經終止時有<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。  
  
> [!WARNING]
>  您應該永遠不會呼叫<xref:System.Threading.Thread.Join%2A>方法<xref:System.Threading.Thread>物件，代表目前執行緒從目前的執行緒。 這會導致您的應用程式停止回應，因為目前的執行緒本身會永遠等候，  
  
 這個方法呼叫的執行緒要包含的狀態變更<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>。 無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>狀態。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">呼叫端嘗試聯結處於 <see cref="F:System.Threading.ThreadState.Unstarted" /> 狀態的執行緒。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">執行緒在等待時中斷。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">等候執行緒終止的毫秒數。</param>
        <summary>封鎖呼叫執行緒，直到此執行個體代表的執行緒終止或超過指定的時間為止，但仍繼續執行標準的 COM 與 SendMessage 提取作業。</summary>
        <returns>
          如果執行緒已經終止，為 <see langword="true" />；如果 <see langword="false" /> 參數指定的時間量已經過去，而執行緒還沒有終止，則為 <paramref name="millisecondsTimeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> 封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到其中一個執行緒的同步處理方法的<xref:System.Threading.Thread.Join%2A>方法呼叫已完成或經過逾時間隔。 在下列範例中，`Thread1`執行緒呼叫<xref:System.Threading.Thread.Join>方法`Thread2`，這會導致`Thread1`封鎖直到 `Thread2`已完成或經過 2 秒。  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 如果<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>指定`millisecondsTimeout`參數，此方法的行為即會相同與<xref:System.Threading.Thread.Join>方法多載，除了傳回的值。  
  
 如果執行緒已經終止時有<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。  
  
 這個方法呼叫的執行緒要包含的狀態變更<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>。 無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>狀態。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 的值為負數，且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> (以毫秒為單位)。</exception>
        <exception cref="T:System.Threading.ThreadStateException">無法啟動此執行緒。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，設定為等候執行緒終止的時間量。</param>
        <summary>封鎖呼叫執行緒，直到此執行個體代表的執行緒終止或超過指定的時間為止，但仍繼續執行標準的 COM 與 SendMessage 提取作業。</summary>
        <returns>
          如果執行緒終止了，為 <see langword="true" />；如果 <see langword="false" /> 參數指定的時間量已經過去，而執行緒還沒有終止，則為 <paramref name="timeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> 封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到其中一個執行緒的同步處理方法的<xref:System.Threading.Thread.Join%2A>方法呼叫已完成或經過逾時間隔。 在下列範例中，`Thread1`執行緒呼叫<xref:System.Threading.Thread.Join>方法`Thread2`，這會導致`Thread1`封鎖直到 `Thread2`已完成或經過 2 秒。  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 如果<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>指定`timeout`，此方法的行為即會相同與<xref:System.Threading.Thread.Join>方法多載，除了傳回的值。  
  
 如果執行緒已經終止時有<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。  
  
 這個方法會變更目前的執行緒可包含的狀態<xref:System.Threading.ThreadState.WaitSleepJoin>。 無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>狀態。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用`TimeSpan`值與`Join`方法。  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值 <paramref name="timeout" /> 為負數且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> 毫秒，或大於 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
        <exception cref="T:System.Threading.ThreadStateException">呼叫端嘗試聯結處於 <see cref="F:System.Threading.ThreadState.Unstarted" /> 狀態的執行緒。</exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 Managed 執行緒的唯一識別項。</summary>
        <value>整數，表示這個 Managed 執行緒的唯一識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒的<xref:System.Threading.Thread.ManagedThreadId%2A>屬性值是用來唯一識別其處理程序中的執行緒。  
  
 值<xref:System.Threading.Thread.ManagedThreadId%2A>屬性不會變化經過一段時間，即使裝載 common language runtime 的 unmanaged 程式碼實作在 fiber 的執行緒。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>同步處理記憶體存取，如下所示：執行目前執行緒的處理器無法以下列方式重新排列指示：呼叫 <see cref="M:System.Threading.Thread.MemoryBarrier" /> 之前的記憶體存取在呼叫 <see cref="M:System.Threading.Thread.MemoryBarrier" /> 後的記憶體存取之後執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> 需要多處理器系統上僅使用弱式排序 （例如，採用多個將 Intel Itanium 處理器的系統） 的記憶體。  
  
 大部分的用途而言，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，或<xref:System.Threading.Monitor>類別提供簡單的方式同步處理資料。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定執行緒的名稱。</summary>
        <value>含有執行緒名稱的字串；如果沒有設定名稱，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性是寫入-之後。 因為執行緒的預設值<xref:System.Threading.Thread.Name%2A>屬性是`null`，您可以判斷是否已明確指派名稱給執行緒藉由比較它與`null`。  
  
 指派給字串<xref:System.Threading.Thread.Name%2A>屬性可包含任何 Unicode 字元。  
  
   
  
## Examples  
 下列範例會示範如何命名執行緒。  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">要求了一組作業，但是早已設定了 <see langword="Name" /> 屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出執行緒的排程優先權。</summary>
        <value>其中一個 <see cref="T:System.Threading.ThreadPriority" /> 值。 預設值是 <see cref="F:System.Threading.ThreadPriority.Normal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下列優先順序的任何一個可以指派一個執行緒<xref:System.Threading.ThreadPriority>值：  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 作業系統不需要接受執行緒的優先權。  
  
   
  
## Examples  
 下列範例顯示的結果變更執行緒的優先權。 系統會建立三個執行緒，一個執行緒的優先權會設定為<xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>，而第二個優先權會設定為<xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>。 每個執行緒遞增變數中的`while`迴圈和回合設定的時間。  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">執行緒已達最後狀態，例如 <see cref="F:System.Threading.ThreadState.Aborted" />。</exception>
        <exception cref="T:System.ArgumentException">為 Set 作業指定的值不是有效的 <see cref="T:System.Threading.ThreadPriority" /> 值。</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取消為目前執行緒要求的 <see cref="M:System.Threading.Thread.Abort(System.Object)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只使用適當的權限的程式碼可以呼叫這個方法。  
  
 進行呼叫以`Abort`來終止執行緒，系統會擲回<xref:System.Threading.ThreadAbortException>。 `ThreadAbortException` 是特殊的例外狀況，應用程式程式碼可以攔截但重新擲回的 catch 區塊的結尾除非`ResetAbort`呼叫。 `ResetAbort` 取消要求中止，並防止`ThreadAbortException`終止執行緒。  
  
 請參閱<xref:System.Threading.ThreadAbortException>的範例，示範如何呼叫`ResetAbort`方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：不支援此成員。</exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <see langword="Abort" /> 並未在目前執行緒上被叫用。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有目前執行緒的必要安全性權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">進階的執行緒上作業。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>繼續已暫止的執行緒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  請勿使用<xref:System.Threading.Thread.Suspend%2A>和<xref:System.Threading.Thread.Resume%2A>方法來同步處理執行緒活動。 您有無從得知哪些程式碼的執行緒正在執行，當您暫停它。 如果您暫停執行緒，而安全性權限評估期間保留鎖定，其他執行緒中<xref:System.AppDomain>可能封鎖。 如果類別建構函式執行時，您可以暫停執行緒，其他執行緒中<xref:System.AppDomain>，嘗試使用封鎖的類別。 很容易發生死結。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：不支援此成員。</exception>
        <exception cref="T:System.Threading.ThreadStateException">執行緒未啟動、已無作用，或不是處於暫停狀態。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有適當的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">進階的執行緒上作業。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">新的 Apartment 狀態。</param>
        <summary>在執行緒啟動之前設定其 Apartment 狀態。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新的執行緒都會初始化成<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果會在啟動之前不已設定其 apartment 狀態。 在執行緒啟動之前，必須設定 apartment 狀態。  
  
> [!NOTE]
>  主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>預設。 若要設定主應用程式執行緒的 apartment 狀態的唯一方式<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>是套用<xref:System.STAThreadAttribute>屬性設定為進入點方法。  
  
 <xref:System.Threading.Thread.SetApartmentState%2A>方法，連同<xref:System.Threading.Thread.GetApartmentState%2A>方法和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。 程式碼範例會建立執行緒。 在執行緒啟動之前，<xref:System.Threading.Thread.GetApartmentState%2A>顯示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>狀態和<xref:System.Threading.Thread.SetApartmentState%2A>將狀態變更為<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。 <xref:System.Threading.Thread.TrySetApartmentState%2A>方法接著會傳回`false`嘗試將狀態變更時<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因為已設定 apartment 狀態。 如果相同的作業具有已嘗試使用<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>就已擲回。  
  
 在執行緒啟動之後，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法會再次使用。 這次會擲回<xref:System.Threading.ThreadStateException>因為執行緒已經啟動。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：macOS 和 Linux 平台不支援此成員。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> 不是有效的 Apartment 狀態。</exception>
        <exception cref="T:System.Threading.ThreadStateException">已經啟動執行緒。</exception>
        <exception cref="T:System.InvalidOperationException">Apartment 狀態已經初始化。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">要套用到目前執行緒的 <see cref="T:System.Threading.CompressedStack" /> 物件。</param>
        <summary>將擷取的 <see cref="T:System.Threading.CompressedStack" /> 套用到目前的執行緒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不再支援這個方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在所有情況下。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">要在其中設定數值的 <see cref="T:System.LocalDataStoreSlot" />。</param>
        <param name="data">要設定的值。</param>
        <summary>針對那個執行緒目前的定義域，在目前執行之執行緒上的指定位置中設定資料。 為獲得較佳的效能，請改用以 <see cref="T:System.ThreadStaticAttribute" /> 屬性標示的欄位。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework 提供兩種機制使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區： 執行緒相關的靜態欄位和資料位置](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)。  
  
 執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置，儲存和擷取資料值插槽中並在執行緒程序結束之後釋放重複使用的位置和<xref:System.Threading.Thread>已經由記憶體回收回收物件。 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> 是`Shared`一律適用於目前執行中執行緒，即使您使用的變數，指的是另一個執行緒呼叫的方法。 為了避免混淆，類別名稱呼叫時，使用`Shared`方法： `Thread.SetData(testSlot, "test data")`。  
  
   
  
## Examples  
 本節包含兩個程式碼範例。 第一個範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>屬性，以儲存執行緒特定的資訊。 第二個範例示範如何使用資料位置來執行相同的動作。  
  
 **第一個範例**  
  
 下列範例示範如何使用標示的欄位<xref:System.ThreadStaticAttribute>儲存執行緒特定的資訊。 這項技術提供更佳的效能比第二個範例所示的技巧。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **第二個範例**  
  
 下列範例會示範如何使用具名的資料位置來儲存執行緒特定的資訊。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定長度的時間內暫止目前的執行緒。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">暫止執行緒的毫秒數。 如果 <c>millisecondsTimeout</c> 引數的值為零，則執行緒會將其剩餘的時間配量讓與準備好要執行的任何同等優先權執行緒。 如果沒有其他準備好要執行的同等優先權執行緒，則目前執行緒的執行不會暫停。</param>
        <summary>在指定的毫秒數內暫止目前的執行緒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒不會執行由作業系統在指定的時間排程。 這個方法會包含執行緒的狀態變更<xref:System.Threading.ThreadState.WaitSleepJoin>。  
  
 您可以指定<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>如`millisecondsTimeout`無限期地暫止執行緒的參數。 不過，我們建議您使用其他<xref:System.Threading?displayProperty=nameWithType>之類的類別<xref:System.Threading.Mutex>， <xref:System.Threading.Monitor>， <xref:System.Threading.EventWaitHandle>，或<xref:System.Threading.Semaphore>改為還執行緒或管理資源。  
  
 在特定速率的系統時鐘刻度呼叫時鐘的解析度。 實際逾時可能不完全指定的逾時，因為指定的逾時將會調整，讓時鐘刻度一致。 如需有關時鐘的解析度和等候時間的詳細資訊，請參閱[睡眠函式](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)主題。 這個方法會呼叫[睡眠函式](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)Windows 系統應用程式開發介面。  
  
 這個方法不會執行標準的 COM 與 SendMessage 幫浦作業。  
  
> [!NOTE]
>  如果您需要進入睡眠狀態已在執行緒上<xref:System.STAThreadAttribute>，但您想要執行標準的 COM 與 SendMessage 幫浦作業，請考慮使用其中一個多載的<xref:System.Threading.Thread.Join%2A>方法所指定的逾時間隔。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Threading.Thread.Sleep%2A>方法來封鎖，應用程式的主執行緒。  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">逾時值為負且不等於 <see cref="F:System.Threading.Timeout.Infinite" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">暫止執行緒的時間長度。 如果 <c>millisecondsTimeout</c> 引數的值為 <see cref="F:System.TimeSpan.Zero" />，則執行緒會將其剩餘的時間配量讓與準備好要執行的任何同等優先權執行緒。 如果沒有其他準備好要執行的同等優先權執行緒，則目前執行緒的執行不會暫停。</param>
        <summary>在指定長度的時間內暫止目前的執行緒。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 執行緒不會執行由作業系統在指定的時間排程。 這個方法會包含執行緒的狀態變更<xref:System.Threading.ThreadState.WaitSleepJoin>。  
  
 您可以指定<xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType>如`timeout`無限期地暫止執行緒的參數。 不過，我們建議您使用其他<xref:System.Threading?displayProperty=nameWithType>之類的類別<xref:System.Threading.Mutex>， <xref:System.Threading.Monitor>， <xref:System.Threading.EventWaitHandle>，或<xref:System.Threading.Semaphore>改為還執行緒或管理資源。  
  
 這個多載<xref:System.Threading.Thread.Sleep%2A>使用中的整數毫秒總數`timeout`。 小數的毫秒都會被捨棄。  
  
 這個方法不會執行標準的 COM 與 SendMessage 幫浦作業。  
  
> [!NOTE]
>  如果您需要進入睡眠狀態已在執行緒上<xref:System.STAThreadAttribute>，但您想要執行標準的 COM 與 SendMessage 幫浦作業，請考慮使用其中一個多載的<xref:System.Threading.Thread.Join%2A>方法所指定的逾時間隔。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Threading.Thread.Sleep%28System.TimeSpan%29>方法多載來封鎖應用程式的主執行緒五次，兩秒鐘每一次。  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">值 <paramref name="timeout" /> 為負數且不等於 <see cref="F:System.Threading.Timeout.Infinite" /> 毫秒，或大於 <see cref="F:System.Int32.MaxValue" /> 毫秒。</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">32 位元帶正負號的整數，定義執行緒要等候多久。</param>
        <summary>造成執行緒等候 <paramref name="iterations" /> 參數定義的次數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.SpinWait%2A>方法可用於實作鎖定。 類別在.NET Framework 中，例如<xref:System.Threading.Monitor>和<xref:System.Threading.ReaderWriterLock>，這個方法會在內部使用。 <xref:System.Threading.Thread.SpinWait%2A> 基本上放處理器非常緊密迴圈中，與所指定的迴圈計數`iterations`參數。 等候的持續時間因此取決於處理器的速度。  
  
 與<xref:System.Threading.Thread.Sleep%2A>方法。 呼叫的執行緒<xref:System.Threading.Thread.Sleep%2A>會產生其目前的配量的處理器時間的其餘部分，即使指定的時間間隔為零。 指定非零間隔<xref:System.Threading.Thread.Sleep%2A>經過的時間間隔之前執行緒移除執行緒排程器的考量。  
  
 <xref:System.Threading.Thread.SpinWait%2A> 不通常適用於一般的應用程式。 在大部分情況下，您應該使用.NET Framework; 所提供的同步處理類別例如，呼叫<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>或陳述式包裝<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>(`lock`在 C# 或`SyncLock`在 Visual Basic 中)。  
  
> [!CAUTION]
>  在極少數的案例是幫助避免將內容切換，例如當您知道狀態變更已即將發生，請呼叫<xref:System.Threading.Thread.SpinWait%2A>在迴圈中的方法。 程式碼<xref:System.Threading.Thread.SpinWait%2A>執行為了防止具有多個處理器的電腦上可能發生的問題。 例如，在多個採用超執行緒技術的 Intel 處理器的電腦上<xref:System.Threading.Thread.SpinWait%2A>可防止在某些情況下的處理器資源用盡。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使執行緒進行執行排程。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>造成作業系統將目前執行個體的狀態變更為 <see cref="F:System.Threading.ThreadState.Running" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一旦執行緒處於<xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>狀態時，系統可以將它排程執行。 在執行緒開始執行所表示之方法的第一行<xref:System.Threading.ThreadStart>或<xref:System.Threading.ParameterizedThreadStart>委派提供給執行緒的建構函式。 請注意，呼叫<xref:System.Threading.Thread.Start%2A>不會封鎖呼叫執行緒。  
  
> [!NOTE]
>  這個多載會搭配使用所建立的執行緒<xref:System.Threading.ParameterizedThreadStart>委派，`null`傳遞至由執行緒執行的方法。  
  
 一旦在執行緒結束，無法將它重新啟動與另一個呼叫`Start`。  
  
   
  
## Examples  
 下列範例會建立並啟動執行緒。  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">已經啟動執行緒。</exception>
        <exception cref="T:System.OutOfMemoryException">沒有足夠的記憶體可用來啟動這個執行緒。</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">物件，包含執行緒執行之方法所要使用的資料。</param>
        <summary>使作業系統將目前執行個體的狀態改成 <see cref="F:System.Threading.ThreadState.Running" />，並選擇性地提供物件，在物件中包含執行緒執行之方法所要使用的資料。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一旦執行緒處於<xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>狀態時，系統可以將它排程執行。 在執行緒開始執行所表示之方法的第一行<xref:System.Threading.ThreadStart>或<xref:System.Threading.ParameterizedThreadStart>委派提供給執行緒的建構函式。 請注意，呼叫<xref:System.Threading.Thread.Start%2A>不會封鎖呼叫執行緒。  
  
 一旦在執行緒結束，無法將它重新啟動與另一個呼叫`Start`。  
  
 這個多載而<xref:System.Threading.ParameterizedThreadStart>委派即可輕易地將資料傳遞給執行緒的程序，但方法不是類型安全因為任何物件可以傳遞給這個多載。 將執行緒的程序與資料欄位放入背景工作物件是更穩固的方式，將資料傳遞給執行緒的程序。 如需詳細資訊，請參閱[建立執行緒和開始時間傳遞資料](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)。  
  
   
  
## Examples  
 下列範例會建立<xref:System.Threading.ParameterizedThreadStart>具有靜態方法和執行個體方法的委派。  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">已經啟動執行緒。</exception>
        <exception cref="T:System.OutOfMemoryException">沒有足夠的記憶體可用來啟動這個執行緒。</exception>
        <exception cref="T:System.InvalidOperationException">這個執行緒是使用 <see cref="T:System.Threading.ThreadStart" /> 委派建立，而非 <see cref="T:System.Threading.ParameterizedThreadStart" /> 委派。</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將執行緒暫止；或者如果執行緒已經暫止，則沒有影響。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果執行緒已經暫止，這個方法沒有任何作用。  
  
> [!CAUTION]
>  請勿使用<xref:System.Threading.Thread.Suspend%2A>和<xref:System.Threading.Thread.Resume%2A>方法來同步處理執行緒活動。 您有無從得知哪些程式碼的執行緒正在執行，當您暫停它。 如果您暫停執行緒，而安全性權限評估期間保留鎖定，其他執行緒中<xref:System.AppDomain>可能封鎖。 如果類別建構函式執行時，您可以暫停執行緒，其他執行緒中<xref:System.AppDomain>，嘗試使用封鎖的類別。 很容易發生死結。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">僅限 .NET Core：不支援此成員。</exception>
        <exception cref="T:System.Threading.ThreadStateException">執行緒未啟動或無作用。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有適當的 <see cref="T:System.Security.Permissions.SecurityPermission" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">進階的執行緒上作業。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="rgszNames">要對應之傳入的名稱陣列。</param>
        <param name="cNames">要對應的名稱計數。</param>
        <param name="lcid">用於解譯名稱的地區設定內容。</param>
        <param name="rgDispId">呼叫端配置的陣列，用於接收對應於名稱的 ID。</param>
        <summary>將一組名稱對應至一組對應的分派識別項 (Dispatch Identifier)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要傳回的類型資訊。</param>
        <param name="lcid">類型資訊的地區設定識別項。</param>
        <param name="ppTInfo">接收要求的類型資訊物件的指標。</param>
        <summary>擷取物件的類型資訊，可以用來取得介面的類型資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向接收物件提供的類型資訊介面數目的位置。</param>
        <summary>擷取物件提供的類型資訊介面數目 (0 或 1)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">辨識成員。</param>
        <param name="riid">保留供未來使用。 必須是 IID_NULL。</param>
        <param name="lcid">地區設定內容，用於解譯引數。</param>
        <param name="wFlags">描述呼叫之內容的旗標。</param>
        <param name="pDispParams">結構的指標，此結構包含引數陣列、指名引數之 DISPID 引數的陣列，以及陣列中項目數目的計數。</param>
        <param name="pVarResult">指向用於儲存結果之位置的指標。</param>
        <param name="pExcepInfo">包含例外狀況資訊的結構指標。</param>
        <param name="puArgErr">第一個有錯誤的引數索引。</param>
        <summary>提供物件所公開的屬性和方法的存取權。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::Invoke`，請參閱 MSDN Library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支援使用 COM <c>IDispatch</c> 介面進行晚期繫結的存取。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得數值，包含目前執行緒的狀態。</summary>
        <value>其中一個 <see cref="T:System.Threading.ThreadState" /> 數值，指出目前執行緒的狀態。 初始值為 <see langword="Unstarted" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.ThreadState%2A>屬性會提供更具體的資訊比<xref:System.Threading.Thread.IsAlive%2A>屬性。  
  
> [!IMPORTANT]
>  執行緒狀態只是想要偵錯案例。 您的程式碼絕對不應該使用執行緒狀態來同步處理執行緒活動。  
  
   
  
## Examples  
 下列程式碼範例將示範如何存取`ThreadState`的執行緒。  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">新的 Apartment 狀態。</param>
        <summary>在執行緒啟動之前設定其 Apartment 狀態。</summary>
        <returns>
          如果已設定 Apartment 狀態，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新的執行緒都會初始化成<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>如果會在啟動之前不已設定其 apartment 狀態。 在執行緒啟動之前，必須設定 apartment 狀態。  
  
> [!NOTE]
>  主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>預設。 若要設定主應用程式執行緒的 apartment 狀態的唯一方式<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>是套用<xref:System.STAThreadAttribute>屬性設定為進入點方法。  
  
 <xref:System.Threading.Thread.TrySetApartmentState%2A>方法，連同<xref:System.Threading.Thread.GetApartmentState%2A>方法和<xref:System.Threading.Thread.SetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。  
  
   
  
## Examples  
 下列程式碼範例示範<xref:System.Threading.Thread.GetApartmentState%2A>， <xref:System.Threading.Thread.SetApartmentState%2A>，和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法。 程式碼範例會建立執行緒。 在執行緒啟動之前，<xref:System.Threading.Thread.GetApartmentState%2A>顯示初始<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>狀態和<xref:System.Threading.Thread.SetApartmentState%2A>將狀態變更為<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>。 <xref:System.Threading.Thread.TrySetApartmentState%2A>方法接著會傳回`false`嘗試將狀態變更時<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>因為已設定 apartment 狀態。 如果相同的作業具有已嘗試使用<xref:System.Threading.Thread.SetApartmentState%2A>，<xref:System.InvalidOperationException>就已擲回。  
  
 在執行緒啟動之後，<xref:System.Threading.Thread.TrySetApartmentState%2A>方法會再次使用。 這次會擲回<xref:System.Threading.ThreadStateException>因為執行緒已經啟動。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> 不是有效的 Apartment 狀態。</exception>
        <exception cref="T:System.Threading.ThreadStateException">已經啟動執行緒。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">要讀取的欄位。</param>
        <summary>讀取欄位值。 值是由電腦中的任意處理器最新寫入的，與處理器的數目或處理器快取的狀態無關。</summary>
        <returns>由任意處理器寫入欄位的最新值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">要寫入值的欄位。</param>
        <param name="value">要寫入的值。</param>
        <summary>立即將值寫入欄位，讓電腦中的所有處理器都可以看到這個值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。  
  
 在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。  
  
 在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。  
  
 呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
> [!NOTE]
>  在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>造成呼叫執行緒執行目前處理器上已就緒可執行的其他執行緒。 作業系統會選擇要執行的執行緒。</summary>
        <returns>
          如果作業系統切換為執行其他執行緒，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此方法成功，會產生其他執行緒的目前時間配量。 作業系統排程呼叫執行緒的另一個時間配量，根據其優先順序和可執行其他執行緒的狀態。  
  
 產生僅限於用來執行呼叫執行緒的處理器。 作業系統不會切換執行為另一個處理器，即使該處理器處於閒置狀態，或正在執行較低優先權的執行緒。 如果沒有其他準備好要執行目前處理器上的執行緒、 作業系統並不會執行，產生和這個方法會傳回`false`。  
  
 這個方法相當於使用平台叫用呼叫原生 Win32`SwitchToThread`函式。 您應該呼叫<xref:System.Threading.Thread.Yield%2A>方法，而不要使用平台叫用，因為平台叫用的任何自訂的執行緒行為主應用程式已要求略過。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>