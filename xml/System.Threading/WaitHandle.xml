<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="046aa46d0a3da304f9348792a16e1353c5fa4596" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56403027" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="0ff5c-101">將等候共用資源獨佔存取權限的特定作業系統物件封裝起來。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-101">Encapsulates operating system-specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-102"><xref:System.Threading.WaitHandle>類別封裝原生作業系統同步處理控制代碼，而且用來代表所有在執行階段允許多個等候作業的同步處理物件。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="0ff5c-103">如需與其他同步處理物件的等候控制代碼的比較，請參閱 <<c0> [ 同步處理原始物件概觀](~/docs/standard/threading/overview-of-synchronization-primitives.md)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="0ff5c-104"><xref:System.Threading.WaitHandle>本身的類別是抽象的。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="0ff5c-105">類別衍生自<xref:System.Threading.WaitHandle>定義訊號的機制，以指示耗時或釋放存取共用資源，但是會使用繼承<xref:System.Threading.WaitHandle>方法來封鎖而等待存取共用資源。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="0ff5c-106">類別衍生自<xref:System.Threading.WaitHandle>包括：</span><span class="sxs-lookup"><span data-stu-id="0ff5c-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="0ff5c-107">
  <xref:System.Threading.Mutex> 類別。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="0ff5c-108">請參閱[Mutex](~/docs/standard/threading/mutexes.md)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="0ff5c-109"><xref:System.Threading.EventWaitHandle>類別和其衍生的類別，<xref:System.Threading.AutoResetEvent>和<xref:System.Threading.ManualResetEvent>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span>  
  
-   <span data-ttu-id="0ff5c-110">
  <xref:System.Threading.Semaphore> 類別。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-110">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="0ff5c-111">請參閱[Semaphore 和 SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-111">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="0ff5c-112">個別的等候控制代碼上封鎖執行緒，可以將它所呼叫的執行個體方法<xref:System.Threading.WaitHandle.WaitOne%2A>，其中會由衍生自的類別繼承<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-112">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="0ff5c-113">在衍生的類別<xref:System.Threading.WaitHandle>的差異在於其執行緒親和性。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-113">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="0ff5c-114">事件等候控制代碼 (<xref:System.Threading.EventWaitHandle>， <xref:System.Threading.AutoResetEvent>，和<xref:System.Threading.ManualResetEvent>)，號誌沒有執行緒相似性; 任何執行緒可以發出信號的事件等候控制代碼或號誌。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-114">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="0ff5c-115">Mutex，相反地，沒有執行緒相似性;擁有 mutex 的執行緒必須釋放它，並會擲回例外狀況，如果執行緒呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>上未擁有 mutex 的方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-115">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="0ff5c-116">因為<xref:System.Threading.WaitHandle>類別衍生自<xref:System.MarshalByRefObject>，這些類別可以用來跨應用程式定義域界限同步處理執行緒的活動。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-116">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="0ff5c-117">除了其衍生的類別，<xref:System.Threading.WaitHandle>類別具有一些靜態方法，封鎖執行緒，直到其中一個或多個同步物件收到信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-117">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="0ff5c-118">它們包括：</span><span class="sxs-lookup"><span data-stu-id="0ff5c-118">These include:</span></span>  
  
-   <span data-ttu-id="0ff5c-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>這可讓發出信號一個等候控制代碼，以及立即等候另一個執行緒。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="0ff5c-120"><xref:System.Threading.WaitHandle.WaitAll%2A>這可讓執行緒等候，直到在陣列中的所有等候控制代碼會都收到信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="0ff5c-121"><xref:System.Threading.WaitHandle.WaitAny%2A>這可讓執行緒等候，直到收到訊號的一組指定的等候控制代碼的任何一個。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled.</span></span>  
  
 <span data-ttu-id="0ff5c-122">這些方法的多載提供放棄等候，並有機會先離開同步處理內容，再進入等候，讓其他執行緒使用的同步處理內容的逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-122">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0ff5c-123">此類型會實作<xref:System.IDisposable>介面。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-123">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="0ff5c-124">當您完成使用的類型或從中衍生的類型時，您應該處置它直接或間接。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-124">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="0ff5c-125">若要直接處置型別，呼叫其<xref:System.Threading.WaitHandle.Close%2A>方法中的`try` / `catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-125">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="0ff5c-126">若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-126">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="0ff5c-127">如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-127">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="0ff5c-128"><xref:System.Threading.WaitHandle> 實作<xref:System.IDisposable.Dispose%2A>模式。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-128"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="0ff5c-129">請參閱 [實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-129">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="0ff5c-130">當您衍生自<xref:System.Threading.WaitHandle>，使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>屬性來儲存您的原生作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-130">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="0ff5c-131">您不需要覆寫保護<xref:System.Threading.WaitHandle.Dispose%2A>方法除非您使用其他的 unmanaged 的資源。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-131">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-132">下列程式碼範例示範如何在兩個執行緒可以執行背景工作，並在主要執行緒等候工作完成使用靜態<xref:System.Threading.WaitHandle.WaitAny%2A>並<xref:System.Threading.WaitHandle.WaitAll%2A>方法<xref:System.Threading.WaitHandle>類別。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-132">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="0ff5c-133">此型別具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-133">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="0ff5c-134">執行緒</span><span class="sxs-lookup"><span data-stu-id="0ff5c-134">Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="0ff5c-135">執行緒物件和功能</span><span class="sxs-lookup"><span data-stu-id="0ff5c-135">Threading Objects and Features</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="0ff5c-136">Mutex</span><span class="sxs-lookup"><span data-stu-id="0ff5c-136">Mutexes</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d"><span data-ttu-id="0ff5c-137">EventWaitHandle、AutoResetEvent 和 ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="0ff5c-137">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="0ff5c-138">號誌</span><span class="sxs-lookup"><span data-stu-id="0ff5c-138">Semaphores</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ff5c-139">初始化 <see cref="T:System.Threading.WaitHandle" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-139">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ff5c-140">釋放目前 <see cref="T:System.Threading.WaitHandle" /> 所持有的全部資源。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-140">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-141">這個方法是公用的實作<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>方法<xref:System.Threading.WaitHandle>類別和其衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-141">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="0ff5c-142">它提供標準的實作會呼叫`Dispose(Boolean)`多載`true`引數，然後呼叫<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-142">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ff5c-143">呼叫這個方法來釋放的執行個體所持有的所有資源`WaitHandle`或衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-143">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="0ff5c-144">一旦呼叫這個方法時，目前的執行個體的參考會導致未定義的行為。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-144">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ff5c-145">請務必呼叫<xref:System.Threading.WaitHandle.Close%2A>或是<xref:System.Threading.WaitHandle.Dispose>您釋放最後一個參考之前<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-145">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="0ff5c-146">否則，將不會釋放它所使用的資源。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-146">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="0ff5c-147">您應該覆寫<see langword="Dispose(Boolean)" />方法來釋放資源配置中衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-147">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="0ff5c-148">實作 Dispose 方法</span><span class="sxs-lookup"><span data-stu-id="0ff5c-148">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ff5c-149">將 <see cref="T:System.Threading.WaitHandle" /> 類別的目前執行個體所使用的資源全部釋放。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-149">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ff5c-150">釋放 <see cref="T:System.Threading.WaitHandle" /> 類別目前的執行個體所使用的全部資源。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-151">這個方法相當於<xref:System.Threading.WaitHandle.Close%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-151">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ff5c-152">請務必呼叫<xref:System.Threading.WaitHandle.Close%2A>或是<xref:System.Threading.WaitHandle.Dispose>您釋放最後一個參考之前<xref:System.Threading.WaitHandle>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-152">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="0ff5c-153">否則，將不會釋放它所使用的資源。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-153">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="0ff5c-154">清除 Unmanaged 資源</span><span class="sxs-lookup"><span data-stu-id="0ff5c-154">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><span data-ttu-id="0ff5c-155"><see langword="true" /> 表示會同時釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-155"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="0ff5c-156">當在衍生類別中覆寫時，釋放 <see cref="T:System.Threading.WaitHandle" /> 所使用的 Unmanaged 資源，並選擇性釋放 Managed 資源。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-156">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-157">這個方法會呼叫<xref:System.Threading.WaitHandle.Close%2A>而<xref:System.Threading.WaitHandle.Dispose>方法`explicitDisposing`參數設定為`true`。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-157">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="0ff5c-158">當`explicitDisposing`參數是`true`，這個方法由任何 managed 物件持有的資源全部釋出這個<xref:System.Threading.WaitHandle>物件參考。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-158">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="0ff5c-159">您應該覆寫<see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />方法來釋放資源配置中衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-159">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
<span data-ttu-id="0ff5c-160"><see cref="M:System.Threading.WaitHandle.Close" />或<see cref="M:System.Threading.WaitHandle.Dispose" />方法可以由其他物件呼叫多次。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-160">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="0ff5c-161">當覆寫此方法時，小心不要參考先前處置呼叫中的物件<see langword="Dispose" />或<see langword="Close" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-161">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="0ff5c-162">實作 Dispose 方法</span><span class="sxs-lookup"><span data-stu-id="0ff5c-162">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ff5c-163">將目前執行個體所持有的資源釋出。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-163">Releases the resources held by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> <span data-ttu-id="0ff5c-164">這個成員已經移除了.NET Framework 2.0 版與後續版本。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-164">This member has been removed from the .NET Framework version 2.0 and subsequent versions.</span></span> <span data-ttu-id="0ff5c-165">本主題只適用於本主題稍後的 「 版本資訊 」 中所列的版本。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-165">This topic applies only to the versions listed in "Version Information" later in this topic.</span></span>


<span data-ttu-id="0ff5c-166">應用程式程式碼不會呼叫這個方法。它會自動叫用記憶體回收期間，除非已停用記憶體回收行程的最終處理。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-166">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="0ff5c-167">如需詳細資訊，請參閱 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 與 <xref:System.Object.Finalize>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-167">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="0ff5c-168">這個方法覆寫 <xref:System.Object.Finalize>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-168">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ff5c-169">取得或設定原生 (Native) 的作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-169">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="0ff5c-170"><see langword="IntPtr" />，代表原生作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-170">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="0ff5c-171">預設為 <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> 欄位的值。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-171">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-172">指派新值給<xref:System.Threading.WaitHandle.Handle%2A>屬性不會關閉先前的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-172">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="0ff5c-173">這會導致遺漏的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-173">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="0ff5c-174">請勿使用這個屬性在.NET Framework 2.0 版或更新版本;使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>屬性改為。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-174">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="0ff5c-175">此屬性設定為有效的控制代碼也設定<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>屬性，但將它設定為<xref:System.Threading.WaitHandle.InvalidHandle>可能會導致遺漏的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-175">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="0ff5c-176">需要完全信任立即呼叫者，來設定屬性值。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-176">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="0ff5c-177">這個成員無法由部分信任或不透明的程式碼設定。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-177">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="0ff5c-178">在衍生的型別必須具有<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />來設定屬性值。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ff5c-179">代表無效的原生作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-179">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="0ff5c-180">此欄位為唯讀。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-180">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-181">在內部用來初始化<xref:System.Threading.WaitHandle.Handle%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-181">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="0ff5c-182">您可以使用此值來判斷是否<see cref="P:System.Threading.WaitHandle.Handle" />屬性包含有效的原生作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-182">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ff5c-183">取得或設定原生 (Native) 的作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-183">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="0ff5c-184"><see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />，代表原生作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-184">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-185">當您指派新的值，以<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>屬性，先前的控制代碼會在關閉前一個<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>物件回收。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-185">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="0ff5c-186">請勿以手動方式關閉此控制代碼，因為這會導致<xref:System.ObjectDisposedException>當<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>嘗試關閉此控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-186">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="0ff5c-187"><xref:System.Threading.WaitHandle> 實作<xref:System.IDisposable.Dispose%2A>模式。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-187"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="0ff5c-188">請參閱 [實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-188">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="0ff5c-189">當您衍生自<xref:System.Threading.WaitHandle>，使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>屬性來儲存您的原生控制代碼的作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-189">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="0ff5c-190">您不需要覆寫保護<xref:System.Threading.WaitHandle.Dispose%2A>方法除非您使用其他的 unmanaged 的資源。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-190">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="0ff5c-191">需要完全信任立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-191">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="0ff5c-192">此成員不能由部分信任或不透明的程式碼。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-192">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="0ff5c-193">在衍生的型別必須具有<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />呼叫這個成員。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-193">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ff5c-194">發出一個 <see cref="T:System.Threading.WaitHandle" /> 信號並等候另一個。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-194">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="0ff5c-195">要發出的 <see cref="T:System.Threading.WaitHandle" /> 信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-195">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="0ff5c-196">要等候的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-196">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="0ff5c-197">發出一個 <see cref="T:System.Threading.WaitHandle" /> 信號並等候另一個。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-197">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-198">如果順利完成信號發出和等候，則為 <see langword="true" />；如果未完成等候，則不會傳回這個方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-198"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-199">這項作業不保證是不可部分完成。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-199">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="0ff5c-200">在目前的執行緒訊號後`toSignal`之前等候`toWaitOn`，另一個處理器執行的執行緒可能會發出信號`toWaitOn`或等候它。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-200">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-201">下列程式碼範例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法多載來允許主執行緒發出信號已封鎖的執行緒，以及執行緒完成工作，然後等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-201">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="0ff5c-202">範例啟動五個執行緒，讓他們封鎖<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標與再發行每一個執行緒時間使用者按下 ENTER 鍵。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-202">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="0ff5c-203">此範例會排入佇列的另一個的五個執行緒，並釋放所有使用<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-203">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-204"><paramref name="toSignal" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-204"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-205">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-205">-or-</span></span> 
 <span data-ttu-id="0ff5c-206"><paramref name="toWaitOn" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-206"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-207">在擁有 <see cref="T:System.STAThreadAttribute" /> 的執行緒上呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-207">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="0ff5c-208">在 Windows 98 或 Windows Millennium Edition 上不支援這個方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-208">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-209"><paramref name="toSignal" /> 為號誌，且已經有完整計數。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-209"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-210">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-210">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-211">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-211">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="0ff5c-212">要發出的 <see cref="T:System.Threading.WaitHandle" /> 信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-212">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="0ff5c-213">要等候的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-213">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0ff5c-214">整數，表示要等候的間隔。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-214">An integer that represents the interval to wait.</span></span> <span data-ttu-id="0ff5c-215">如果值為 <see cref="F:System.Threading.Timeout.Infinite" /> (亦即 -1)，則會永遠等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-215">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="0ff5c-216"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-216"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0ff5c-217">發出一個 <see cref="T:System.Threading.WaitHandle" /> 信號並等候另一個，將逾時間隔指定為 32 位元帶正負號的整數，並指定是否要先離開內容的同步處理網域，再進入等候狀態。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-217">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-218">如果順利完成信號發出和等候，則為 <see langword="true" />；如果完成信號發出但等候逾時，則為 <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="0ff5c-218"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-219">這項作業不保證是不可部分完成。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-219">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="0ff5c-220">在目前的執行緒訊號後`toSignal`之前等候`toWaitOn`，另一個處理器執行的執行緒可能會發出信號`toWaitOn`或等候它。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-220">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="0ff5c-221">如果`millisecondsTimeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-221">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-222">它會測試的狀態`toWaitOn`並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-222">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0ff5c-223">在結束內容的資訊</span><span class="sxs-lookup"><span data-stu-id="0ff5c-223">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0ff5c-224">`exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.SignalAndWait%2A>從非預設受管理的內容中呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-224">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0ff5c-225">如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-225">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0ff5c-226">即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-226">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0ff5c-227">時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-227">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="0ff5c-228">執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-228">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="0ff5c-229">這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-229">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0ff5c-230">在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-230">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0ff5c-231">如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-231">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0ff5c-232">當<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-232">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-233"><paramref name="toSignal" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-233"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-234">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-234">-or-</span></span> 
 <span data-ttu-id="0ff5c-235"><paramref name="toWaitOn" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-235"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-236">在擁有 <see cref="T:System.STAThreadAttribute" /> 的執行緒上呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-236">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="0ff5c-237">在 Windows 98 或 Windows Millennium Edition 上不支援這個方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-237">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-238">無法對 <see cref="T:System.Threading.WaitHandle" /> 發出信號，因為它可能會超過最大計數。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-238">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-239"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-239"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-240">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-240">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-241">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-241">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="0ff5c-242">要發出的 <see cref="T:System.Threading.WaitHandle" /> 信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-242">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="0ff5c-243">要等候的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-243">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="0ff5c-244"><see cref="T:System.TimeSpan" />，代表要等候的間隔。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-244">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="0ff5c-245">如果此值為 -1，則會無限期等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-245">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="0ff5c-246"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-246"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0ff5c-247">發出一個 <see cref="T:System.Threading.WaitHandle" /> 信號並等候另一個，將逾時間隔指定為 <see cref="T:System.TimeSpan" />，並指定是否要先離開內容的同步處理網域，再進入等候狀態。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-247">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-248">如果順利完成信號發出和等候，則為 <see langword="true" />；如果完成信號發出但等候逾時，則為 <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="0ff5c-248"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-249">這項作業不保證是不可部分完成。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-249">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="0ff5c-250">在目前的執行緒訊號後`toSignal`之前等候`toWaitOn`，另一個處理器執行的執行緒可能會發出信號`toWaitOn`或等候它。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-250">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="0ff5c-251">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-251">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0ff5c-252">如果`timeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-252">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-253">它會測試的狀態`toWaitOn`並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-253">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0ff5c-254">在結束內容的資訊</span><span class="sxs-lookup"><span data-stu-id="0ff5c-254">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0ff5c-255">`exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.SignalAndWait%2A>從非預設受管理的內容中呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-255">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0ff5c-256">如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-256">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0ff5c-257">即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-257">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0ff5c-258">時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-258">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="0ff5c-259">執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-259">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="0ff5c-260">這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-260">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0ff5c-261">在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-261">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0ff5c-262">如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-262">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0ff5c-263">當<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-263">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-264"><paramref name="toSignal" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-264"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-265">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-265">-or-</span></span> 
 <span data-ttu-id="0ff5c-266"><paramref name="toWaitOn" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-266"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-267">在擁有 <see cref="T:System.STAThreadAttribute" /> 的執行緒上呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-267">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="0ff5c-268">在 Windows 98 或 Windows Millennium Edition 上不支援這個方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-268">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-269"><paramref name="toSignal" /> 為號誌，且已經有完整計數。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-269"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-270"><paramref name="timeout" /> 判定為 -1 以外的負毫秒數目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-270"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
<span data-ttu-id="0ff5c-271">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-271">-or-</span></span> 
 <span data-ttu-id="0ff5c-272"><paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-272"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-273">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-273">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-274">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-274">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ff5c-275">釋放 <see cref="T:System.Threading.WaitHandle" /> 所使用的所有資源。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-275">Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="0ff5c-276">呼叫`Dispose`可讓所使用的資源<xref:System.Threading.WaitHandle>重新配置用於其他用途。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-276">Calling `Dispose` allows the resources used by the <xref:System.Threading.WaitHandle> to be reallocated for other purposes.</span></span> <span data-ttu-id="0ff5c-277">如需詳細資訊`Dispose`，請參閱 <<c2> [ 清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-277">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ff5c-278">等候指定陣列中的所有項目都收到信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-278">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0ff5c-279"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-279">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="0ff5c-280">這個陣列不能包含相同物件的多個參考。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-280">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="0ff5c-281">等候指定陣列中的所有項目都收到信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-281">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-282">當 <paramref name="waitHandles" /> 中的所有項目都收到信號時，則為 <see langword="true" />；否則絕不會傳回這個方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-282"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-283"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-283"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0ff5c-284">在舊版中，<xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回`true`時放棄的 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-284">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0ff5c-285">已放棄的 mutex 通常表示嚴重的程式碼錯誤。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-285">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0ff5c-286">如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-286">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0ff5c-287">例外狀況包含資訊適用於偵錯。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-287">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0ff5c-288"><xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回所有控制代碼會收到信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-288">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="0ff5c-289">在某些實作中，若傳遞了 64 個以上的控制代碼，<xref:System.NotSupportedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-289">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="0ff5c-290">如果陣列包含重複的項目，則呼叫會失敗並<xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-290">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ff5c-291"><xref:System.Threading.WaitHandle.WaitAll%2A>擁有的執行緒上不支援方法<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-291">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="0ff5c-292">呼叫這個方法多載就相當於呼叫<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>方法多載，並指定-1 (或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) 的`millisecondsTimeout`並`true`如`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-292">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-293">下列程式碼範例示範如何使用執行緒集區，以非同步方式建立和寫入檔案群組。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-293">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="0ff5c-294">完成後，工作項目以及訊號每一個寫入作業已排入佇列。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-294">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="0ff5c-295">主執行緒等候發出信號的所有項目，然後結束。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-295">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-296"><paramref name="waitHandles" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-296">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="0ff5c-297">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-297">-or-</span></span> 
<span data-ttu-id="0ff5c-298"><paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-298">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-299">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-299">-or-</span></span> 
 <span data-ttu-id="0ff5c-300"><paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 2.0 或更新版本。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-300"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="0ff5c-301">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.ArgumentException" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-301">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="0ff5c-302"><paramref name="waitHandles" /> 陣列包含重複的項目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-302">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-303"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-303">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="0ff5c-304">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-304">-or-</span></span> 
<span data-ttu-id="0ff5c-305"><see cref="T:System.STAThreadAttribute" /> 屬性會套用至目前執行緒的執行緒程序，且 <paramref name="waitHandles" /> 包含多個項目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-305">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="0ff5c-306"><paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-306"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-307">由於執行緒結束時未釋放 Mutex，已結束等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-307">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-308">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-308">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-309"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-309">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0ff5c-310"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-310">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="0ff5c-311">這個陣列無法包含相同物件 (複本) 的多個參考。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-311">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0ff5c-312">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-312">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ff5c-313">等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.Int32" /> 值來指定時間間隔。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-313">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-314">當 <paramref name="waitHandles" /> 中的所有項目都收到信號時，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-314"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-315">如果`millisecondsTimeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-315">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-316">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-316">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-317"><xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回在等候終止時，這表示所有控制代碼會收到信號或逾時發生時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-317">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="0ff5c-318">在某些實作中，若傳遞了 64 個以上的控制代碼，<xref:System.NotSupportedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-318">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="0ff5c-319">如果陣列中有重複的項目，則呼叫會失敗並<xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-319">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ff5c-320"><xref:System.Threading.WaitHandle.WaitAll%2A>擁有的執行緒上不支援方法<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-320">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="0ff5c-321">呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-321">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-322"><paramref name="waitHandles" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-322">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-323">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-323">-or-</span></span> 
<span data-ttu-id="0ff5c-324"><paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-324">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-325">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-325">-or-</span></span> 
 <span data-ttu-id="0ff5c-326"><paramref name="waitHandles" /> 是不含任何項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-326"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="0ff5c-327">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.ArgumentException" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-327">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="0ff5c-328"><paramref name="waitHandles" /> 陣列包含重複的項目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-328">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-329"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-329">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="0ff5c-330">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-330">-or-</span></span> 
<span data-ttu-id="0ff5c-331"><see cref="T:System.STAThreadAttribute" /> 屬性會套用至目前執行緒的執行緒程序，且 <paramref name="waitHandles" /> 包含多個項目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-331">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-332"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-332"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-333">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-333">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-334">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-334">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-335"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-335">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0ff5c-336"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-336">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="0ff5c-337">這個陣列不能包含相同物件的多個參考。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-337">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="0ff5c-338"><see cref="T:System.TimeSpan" />，代表要等候的毫秒數；或是 <see cref="T:System.TimeSpan" />，代表永遠等候的 -1 毫秒。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-338">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ff5c-339">等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.TimeSpan" /> 值來指定時間間隔。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-339">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-340">當 <paramref name="waitHandles" /> 中的所有項目都收到信號時，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-340"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-341">如果`timeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-341">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-342">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-342">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-343"><xref:System.Threading.WaitHandle.WaitAll%2A>方法傳回時則等候會終止，這表示可能是所有控制代碼會收到信號，或發生逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-343">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="0ff5c-344">在某些實作中，若傳遞了 64 個以上的控制代碼，<xref:System.NotSupportedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-344">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="0ff5c-345">如果陣列包含重複的項目，則呼叫會失敗。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-345">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ff5c-346"><xref:System.Threading.WaitHandle.WaitAll%2A>擁有的執行緒上不支援方法<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-346">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="0ff5c-347">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-347">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0ff5c-348">呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-348">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-349"><paramref name="waitHandles" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-349">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-350">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-350">-or-</span></span> 
<span data-ttu-id="0ff5c-351"><paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-351">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-352">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-352">-or-</span></span> 
 <span data-ttu-id="0ff5c-353"><paramref name="waitHandles" /> 是不含任何項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-353"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="0ff5c-354">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況 <see cref="T:System.ArgumentException" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-354">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="0ff5c-355"><paramref name="waitHandles" /> 陣列包含重複的項目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-355">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-356"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-356">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="0ff5c-357">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-357">-or-</span></span> 
<span data-ttu-id="0ff5c-358"><see cref="T:System.STAThreadAttribute" /> 屬性會套用至目前執行緒的執行緒程序，且 <paramref name="waitHandles" /> 包含多個項目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-358">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-359"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-359"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="0ff5c-360">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-360">-or-</span></span> 
 <span data-ttu-id="0ff5c-361"><paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-361"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-362">由於執行緒結束時未釋放 Mutex，已結束等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-362">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-363">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-363">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-364"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-364">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0ff5c-365"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-365">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="0ff5c-366">這個陣列無法包含相同物件 (複本) 的多個參考。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-366">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0ff5c-367">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-367">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="0ff5c-368"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-368"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0ff5c-369">等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.Int32" /> 值來指定時間間隔，並指定是否要先離開同步處理網域，再開始等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-369">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-370">當 <paramref name="waitHandles" /> 中的所有項目都收到信號時，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-370"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-371">如果`millisecondsTimeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-371">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-372">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-372">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-373"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-373"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0ff5c-374">在舊版中，<xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回`true`時放棄的 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-374">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0ff5c-375">已放棄的 mutex 通常表示嚴重的程式碼錯誤。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-375">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0ff5c-376">如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-376">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0ff5c-377">例外狀況包含資訊適用於偵錯。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-377">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0ff5c-378"><xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回在等候終止時，這表示所有控制代碼會收到信號或逾時發生時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-378">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="0ff5c-379">在某些實作中，若傳遞了 64 個以上的控制代碼，<xref:System.NotSupportedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-379">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="0ff5c-380">如果陣列中有重複的項目，則呼叫會失敗並<xref:System.DuplicateWaitObjectException>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-380">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ff5c-381"><xref:System.Threading.WaitHandle.WaitAll%2A>擁有的執行緒上不支援方法<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-381">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0ff5c-382">在結束內容的資訊</span><span class="sxs-lookup"><span data-stu-id="0ff5c-382">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0ff5c-383">`exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitAll%2A>從非預設受管理的內容中呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-383">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0ff5c-384">如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-384">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0ff5c-385">即使您目前正在執行的方法不衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-385">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0ff5c-386">時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-386">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="0ff5c-387">執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.WaitAll%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-387">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="0ff5c-388">這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>屬性。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-388">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="0ff5c-389">在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-389">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0ff5c-390">如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitAll%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-390">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0ff5c-391">當<xref:System.Threading.WaitHandle.WaitAll%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-391">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-392">下列程式碼範例示範如何使用執行緒集區，以非同步方式建立和寫入檔案群組。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-392">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="0ff5c-393">完成後，工作項目以及訊號每一個寫入作業已排入佇列。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-393">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="0ff5c-394">主執行緒等候發出信號的所有項目，然後結束。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-394">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-395"><paramref name="waitHandles" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-395">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-396">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-396">-or-</span></span> 
<span data-ttu-id="0ff5c-397"><paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-397">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-398">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-398">-or-</span></span> 
 <span data-ttu-id="0ff5c-399"><paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 2.0 或更新版本。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-399"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="0ff5c-400"><paramref name="waitHandles" /> 陣列包含重複的項目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-400">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-401"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-401">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="0ff5c-402">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-402">-or-</span></span> 
<span data-ttu-id="0ff5c-403"><see cref="T:System.STAThreadAttribute" /> 屬性會套用至目前執行緒的執行緒程序，且 <paramref name="waitHandles" /> 包含多個項目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-403">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="0ff5c-404"><paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-404"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-405"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-405"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-406">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-406">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-407">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-407">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-408"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-408">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0ff5c-409"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-409">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="0ff5c-410">這個陣列不能包含相同物件的多個參考。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-410">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="0ff5c-411"><see cref="T:System.TimeSpan" />，代表要等候的毫秒數；或是 <see cref="T:System.TimeSpan" />，代表永遠等候的 -1 毫秒。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-411">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="0ff5c-412"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-412"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0ff5c-413">等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.TimeSpan" /> 值來指定時間間隔，並指定是否要先離開同步處理網域，再開始等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-413">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-414">當 <paramref name="waitHandles" /> 中的所有元素都收到訊號時，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-414"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-415">如果`timeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-415">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-416">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-416">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-417"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-417"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0ff5c-418">在舊版中，<xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回`true`時放棄的 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-418">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0ff5c-419">已放棄的 mutex 通常表示嚴重的程式碼錯誤。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-419">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0ff5c-420">如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-420">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0ff5c-421">例外狀況包含資訊適用於偵錯。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-421">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0ff5c-422"><xref:System.Threading.WaitHandle.WaitAll%2A>方法傳回時則等候會終止，這表示可能是所有控制代碼會收到信號，或發生逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-422">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="0ff5c-423">在某些實作中，若傳遞了 64 個以上的控制代碼，<xref:System.NotSupportedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-423">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="0ff5c-424">如果陣列包含重複的項目，則呼叫會失敗。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-424">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ff5c-425"><xref:System.Threading.WaitHandle.WaitAll%2A>擁有的執行緒上不支援方法<xref:System.STAThreadAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-425">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="0ff5c-426">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-426">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0ff5c-427">在結束內容的資訊</span><span class="sxs-lookup"><span data-stu-id="0ff5c-427">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0ff5c-428">`exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitAll%2A>從非預設受管理的內容中呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-428">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0ff5c-429">如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-429">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0ff5c-430">即使您目前正在執行的方法不衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-430">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0ff5c-431">時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-431">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="0ff5c-432">它會傳回呼叫之後為原始的非預設內容<xref:System.Threading.WaitHandle.WaitAll%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-432">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="0ff5c-433">這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-433">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0ff5c-434">在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-434">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0ff5c-435">如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitAll%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-435">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0ff5c-436">當<xref:System.Threading.WaitHandle.WaitAll%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-436">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-437">下列程式碼範例示範如何使用執行緒集區，以非同步方式建立和寫入檔案群組。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-437">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="0ff5c-438">完成後，工作項目以及訊號每一個寫入作業已排入佇列。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-438">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="0ff5c-439">主執行緒等候發出信號的所有項目，然後結束。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-439">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-440"><paramref name="waitHandles" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-440">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-441">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-441">-or-</span></span> 
<span data-ttu-id="0ff5c-442"><paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-442">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-443">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-443">-or-</span></span> 
 <span data-ttu-id="0ff5c-444"><paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 2.0 或更新版本。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-444"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="0ff5c-445"><paramref name="waitHandles" /> 陣列包含重複的項目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-445">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-446"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-446">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="0ff5c-447">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-447">-or-</span></span> 
<span data-ttu-id="0ff5c-448"><see cref="T:System.STAThreadAttribute" /> 屬性會套用至目前執行緒的執行緒程序，且 <paramref name="waitHandles" /> 包含多個項目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-448">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="0ff5c-449"><paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-449"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-450"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-450"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="0ff5c-451">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-451">-or-</span></span> 
 <span data-ttu-id="0ff5c-452"><paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-452"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-453">由於執行緒結束時未釋放 Mutex，已結束等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-453">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-454">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-454">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-455"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-455">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ff5c-456">等候指定陣列中有任何項目收到信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-456">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0ff5c-457"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-457">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="0ff5c-458">等候指定陣列中有任何項目收到信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-458">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-459">滿足等候條件之物件的陣列索引。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-459">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-460"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-460"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0ff5c-461">在舊版中，<xref:System.Threading.WaitHandle.WaitAny%2A>方法會傳回`true`如果等候完成，因為已放棄 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-461">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="0ff5c-462">已放棄的 mutex 通常表示嚴重的程式碼錯誤。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-462">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0ff5c-463">如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-463">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0ff5c-464">例外狀況包含資訊適用於偵錯。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-464">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0ff5c-465"><xref:System.Threading.WaitHandle.WaitAny%2A>方法會擲回<xref:System.Threading.AbandonedMutexException>只等待完成時因為遭到放棄的 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-465">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="0ff5c-466">如果`waitHandles`包含具有較低的索引編號，已放棄的 mutex，比釋放的 mutex<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成，並不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-466">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ff5c-467">在版本早於 2.0 版中，如果執行緒結束或中止而不需要明確地釋放的.NET framework <xref:System.Threading.Mutex>，且`Mutex`位於索引 0 （零），在`WaitAny`陣列在另一個執行緒，所傳回的索引上`WaitAny`是128 而不是 0。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-467">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="0ff5c-468">這個方法會傳回任何控制代碼會收到信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-468">This method returns when any handle is signaled.</span></span> <span data-ttu-id="0ff5c-469">如果在呼叫期間，多個物件會變成收到訊號，則傳回的值會是物件的已收到訊號具有已收到訊號的所有物件的最小的索引值的陣列索引。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-469">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="0ff5c-470">在某些實作中，如果有多個傳遞 64 的控制代碼，<xref:System.NotSupportedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-470">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="0ff5c-471">呼叫這個方法多載就相當於呼叫<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>方法多載，並指定-1 (或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) 的`millisecondsTimeout`並`true`如`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-471">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-472">下列程式碼範例示範如何呼叫<xref:System.Threading.WaitHandle.WaitAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-472">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-473"><paramref name="waitHandles" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-473">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-474">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-474">-or-</span></span> 
<span data-ttu-id="0ff5c-475"><paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-475">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-476"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-476">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="0ff5c-477"><paramref name="waitHandles" /> 是不具有項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-477"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-478">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-478">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-479">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-479">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ff5c-480"><paramref name="waitHandles" /> 是不具有元素的陣列，且 .NET Framework 版本為 2.0 (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-480"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-481"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-481">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0ff5c-482"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-482">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0ff5c-483">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-483">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ff5c-484">等候指定之陣列中有任何項目收到信號，使用 32 位元帶正負號的整數以指定時間間隔。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-484">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-485">滿足等候條件之物件的陣列索引；如果沒有物件滿足等候條件，而且已經過相當於 <paramref name="millisecondsTimeout" /> 的時間間隔，則為 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-485">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-486">如果`millisecondsTimeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-486">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-487">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-487">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-488"><xref:System.Threading.WaitHandle.WaitAny%2A>方法會擲回<xref:System.Threading.AbandonedMutexException>只等待完成時因為遭到放棄的 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-488">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="0ff5c-489">如果`waitHandles`包含具有較低的索引編號，已放棄的 mutex，比釋放的 mutex<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成，並不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-489">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="0ff5c-490">這個方法傳回時則等候會終止，任何控制代碼會收到信號或發生逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-490">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="0ff5c-491">如果在呼叫期間，多個物件會變成收到訊號，則傳回的值會是物件的已收到訊號具有已收到訊號的所有物件的最小的索引值的陣列索引。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-491">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="0ff5c-492">在某些實作中，如果有多個傳遞 64 的控制代碼，<xref:System.NotSupportedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-492">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="0ff5c-493">呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-493">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-494"><paramref name="waitHandles" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-494">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-495">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-495">-or-</span></span> 
<span data-ttu-id="0ff5c-496"><paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-496">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-497"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-497">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-498"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-498"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-499">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-499">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-500">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-500">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ff5c-501"><paramref name="waitHandles" /> 是不含任何項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-501"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-502"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-502">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0ff5c-503"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-503">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="0ff5c-504"><see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-504">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ff5c-505">等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.TimeSpan" /> 來指定時間間隔。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-505">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-506">滿足等候條件之物件的陣列索引；如果沒有物件滿足等候條件，而且已經過相當於 <paramref name="timeout" /> 的時間間隔，則為 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-506">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-507">如果`timeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-507">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-508">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-508">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-509"><xref:System.Threading.WaitHandle.WaitAny%2A>方法會擲回<xref:System.Threading.AbandonedMutexException>只等待完成時因為遭到放棄的 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-509">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="0ff5c-510">如果`waitHandles`包含具有較低的索引編號，已放棄的 mutex，比釋放的 mutex<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成，並不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-510">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="0ff5c-511">這個方法傳回時則等候會終止，任何控制代碼會收到信號或逾時發生時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-511">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="0ff5c-512">如果在呼叫期間，多個物件會變成收到訊號，則傳回的值會是物件的已收到訊號具有已收到訊號的所有物件的最小的索引值的陣列索引。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-512">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="0ff5c-513">在某些實作中，如果有多個傳遞 64 的控制代碼，<xref:System.NotSupportedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-513">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="0ff5c-514">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-514">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0ff5c-515">呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-515">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-516"><paramref name="waitHandles" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-516">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-517">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-517">-or-</span></span> 
<span data-ttu-id="0ff5c-518"><paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-518">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-519"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-519">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-520"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-520"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="0ff5c-521">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-521">-or-</span></span> 
 <span data-ttu-id="0ff5c-522"><paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-522"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-523">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-523">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-524">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-524">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ff5c-525"><paramref name="waitHandles" /> 是不含任何項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-525"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-526"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-526">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0ff5c-527"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-527">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0ff5c-528">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-528">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="0ff5c-529"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-529"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0ff5c-530">等候指定陣列中有任何項目收到信號；使用 32 位元帶正負號的整數 (Signed Integer) 來指定時間間隔，並指定是否在等候之前先離開同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-530">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-531">滿足等候條件之物件的陣列索引；如果沒有物件滿足等候條件，而且已經過相當於 <paramref name="millisecondsTimeout" /> 的時間間隔，則為 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-531">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-532">如果`millisecondsTimeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-532">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-533">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-533">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-534"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-534"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0ff5c-535">在舊版中，<xref:System.Threading.WaitHandle.WaitAny%2A>方法會傳回`true`如果等候完成，因為已放棄 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-535">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="0ff5c-536">已放棄的 mutex 通常表示嚴重的程式碼錯誤。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-536">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0ff5c-537">如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-537">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0ff5c-538">例外狀況包含資訊適用於偵錯。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-538">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0ff5c-539"><xref:System.Threading.WaitHandle.WaitAny%2A>方法會擲回<xref:System.Threading.AbandonedMutexException>只等待完成時因為遭到放棄的 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-539">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="0ff5c-540">如果`waitHandles`包含具有較低的索引編號，已放棄的 mutex，比釋放的 mutex<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成，並不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-540">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ff5c-541">在版本早於 2.0 版中，如果執行緒結束或中止而不需要明確地釋放的.NET framework <xref:System.Threading.Mutex>，且`Mutex`位於索引 0 （零），在`WaitAny`陣列在另一個執行緒，所傳回的索引上`WaitAny`是128 而不是 0。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-541">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="0ff5c-542">這個方法傳回時則等候會終止，任何控制代碼會收到信號或發生逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-542">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="0ff5c-543">如果在呼叫期間，多個物件會變成收到訊號，則傳回的值會是物件的已收到訊號具有已收到訊號的所有物件的最小的索引值的陣列索引。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-543">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="0ff5c-544">在某些實作中，如果有多個傳遞 64 的控制代碼，<xref:System.NotSupportedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-544">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0ff5c-545">在結束內容的資訊</span><span class="sxs-lookup"><span data-stu-id="0ff5c-545">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0ff5c-546">`exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitAny%2A>從非預設受管理的內容中呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-546">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0ff5c-547">如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-547">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0ff5c-548">即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-548">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0ff5c-549">時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-549">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="0ff5c-550">執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.WaitAny%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-550">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="0ff5c-551">這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-551">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0ff5c-552">在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-552">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0ff5c-553">如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitAny%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-553">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0ff5c-554">當<xref:System.Threading.WaitHandle.WaitAny%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-554">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-555">下列程式碼範例示範如何使用執行緒集區同時搜尋多個磁碟上的檔案。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-555">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="0ff5c-556">如需空間考量，會搜尋只有每個磁碟的根目錄。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-556">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-557"><paramref name="waitHandles" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-557">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-558">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-558">-or-</span></span> 
<span data-ttu-id="0ff5c-559"><paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-559">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-560"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-560">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="0ff5c-561"><paramref name="waitHandles" /> 是不具有項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-561"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-562"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-562"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-563">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-563">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-564">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-564">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ff5c-565"><paramref name="waitHandles" /> 是不具有元素的陣列，且 .NET Framework 版本為 2.0 (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-565"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-566"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-566">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0ff5c-567"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-567">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="0ff5c-568"><see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-568">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="0ff5c-569"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-569"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0ff5c-570">等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.TimeSpan" /> 來指定時間間隔，並指定是否要先離開同步處理網域，再開始等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-570">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-571">滿足等候條件之物件的陣列索引；如果沒有物件滿足等候條件，而且已經過相當於 <paramref name="timeout" /> 的時間間隔，則為 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-571">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-572">如果`timeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-572">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-573">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-573">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-574"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-574"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0ff5c-575">在舊版中，<xref:System.Threading.WaitHandle.WaitAny%2A>方法會傳回`true`如果等候完成，因為已放棄 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-575">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="0ff5c-576">已放棄的 mutex 通常表示嚴重的程式碼錯誤。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-576">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0ff5c-577">如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-577">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0ff5c-578">例外狀況包含資訊適用於偵錯。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-578">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0ff5c-579"><xref:System.Threading.WaitHandle.WaitAny%2A>方法會擲回<xref:System.Threading.AbandonedMutexException>只等待完成時因為遭到放棄的 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-579">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="0ff5c-580">如果`waitHandles`包含具有較低的索引編號，已放棄的 mutex，比釋放的 mutex<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成，並不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-580">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ff5c-581">在版本早於 2.0 版中，如果執行緒結束或中止而不需要明確地釋放的.NET framework <xref:System.Threading.Mutex>，且`Mutex`位於索引 0 （零），在`WaitAny`陣列在另一個執行緒，所傳回的索引上`WaitAny`是128 而不是 0。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-581">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="0ff5c-582">這個方法傳回時則等候會終止，任何控制代碼會收到信號或逾時發生時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-582">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="0ff5c-583">如果在呼叫期間，多個物件會變成收到訊號，則傳回的值會是物件的已收到訊號具有已收到訊號的所有物件的最小的索引值的陣列索引。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-583">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="0ff5c-584">在某些實作中，如果有多個傳遞 64 的控制代碼，<xref:System.NotSupportedException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-584">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="0ff5c-585">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-585">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0ff5c-586">在結束內容的資訊</span><span class="sxs-lookup"><span data-stu-id="0ff5c-586">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0ff5c-587">`exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitAny%2A>從非預設受管理的內容中呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-587">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0ff5c-588">如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-588">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0ff5c-589">即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-589">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0ff5c-590">時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitAny%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-590">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="0ff5c-591">執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.WaitAny%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-591">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="0ff5c-592">這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-592">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0ff5c-593">在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-593">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0ff5c-594">如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitAny%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-594">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0ff5c-595">當<xref:System.Threading.WaitHandle.WaitAny%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-595">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-596">下列程式碼範例示範如何使用執行緒集區同時搜尋多個磁碟上的檔案。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-596">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="0ff5c-597">如需空間考量，會搜尋只有每個磁碟的根目錄。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-597">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ff5c-598"><paramref name="waitHandles" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-598">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ff5c-599">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-599">-or-</span></span> 
<span data-ttu-id="0ff5c-600"><paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-600">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0ff5c-601"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-601">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="0ff5c-602"><paramref name="waitHandles" /> 是不具有項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-602"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-603"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-603"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="0ff5c-604">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-604">-or-</span></span> 
 <span data-ttu-id="0ff5c-605"><paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-605"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-606">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-606">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-607">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-607">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ff5c-608"><paramref name="waitHandles" /> 是不具有元素的陣列，且 .NET Framework 版本為 2.0 (含) 以後版本。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-608"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-609"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-609">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ff5c-610">封鎖目前的執行緒，直到目前的 <see cref="T:System.Threading.WaitHandle" /> 收到訊號為止。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-610">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ff5c-611">封鎖目前的執行緒，直到目前的 <see cref="T:System.Threading.WaitHandle" /> 收到訊號為止。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-611">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-612">如果目前的執行個體有收到信號，則為 <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-612"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="0ff5c-613">如果目前的執行個體一直沒有收到訊號，<see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> 就一定不會傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-613">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-614"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-614"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0ff5c-615">在舊版中，<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`true`時放棄的 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-615">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0ff5c-616">已放棄的 mutex 通常表示嚴重的程式碼錯誤。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-616">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0ff5c-617">如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-617">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0ff5c-618">例外狀況包含資訊適用於偵錯。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-618">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0ff5c-619">這個方法會封鎖目前的執行個體之前，無限期的呼叫端會收到信號。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-619">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="0ff5c-620">使用這個方法來封鎖直到<xref:System.Threading.WaitHandle>從另一個執行緒收到訊號，例如便會產生非同步作業完成時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-620">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="0ff5c-621">如需詳細資訊，請參閱<xref:System.IAsyncResult>介面。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-621">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="0ff5c-622">呼叫這個方法多載就相當於呼叫<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>方法多載，並指定-1 或是<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>第一個參數和`false`第二個參數。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-622">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="0ff5c-623">覆寫這個方法以自訂在衍生類別的行為。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-623">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-624">下列程式碼範例示範如何使用等候控制代碼，以防止處理程序結束時等候背景執行緒完成執行。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-624">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ff5c-625">目前的執行個體已經過處置。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-625">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-626">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-627">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-628">目前的執行個體是另一個應用程式定義域中 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="0ff5c-629">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-629">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ff5c-630">封鎖目前執行緒，直到目前的 <see cref="T:System.Threading.WaitHandle" /> 收到信號為止，使用 32 位元帶正負號的整數來指定時間間隔 (以毫秒為單位)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-630">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-631">如果目前的執行個體收到信號，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-632">如果`millisecondsTimeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-632">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-633">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-634">這個方法會封鎖，直到目前的執行個體收到信號或逾時的呼叫端就會發生。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="0ff5c-635">使用這個方法來封鎖直到<xref:System.Threading.WaitHandle>從另一個執行緒收到訊號，例如便會產生非同步作業完成時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="0ff5c-636">如需詳細資訊，請參閱<xref:System.IAsyncResult>介面。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="0ff5c-637">覆寫這個方法以自訂在衍生類別的行為。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="0ff5c-638">呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-638">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-639">下列程式碼範例示範如何使用等候控制代碼，以防止處理程序結束時等候背景執行緒完成執行。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-639">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ff5c-640">目前的執行個體已經過處置。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-641"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-641"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-642">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-642">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-643">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-643">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-644">目前的執行個體是另一個應用程式定義域中 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-644">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="0ff5c-645"><see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-645">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ff5c-646">封鎖目前執行緒，直到目前執行個體收到信號為止，使用 <see cref="T:System.TimeSpan" /> 來指定時間間隔。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-646">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-647">如果目前的執行個體收到信號，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-647"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-648">如果`timeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-648">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-649">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-649">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-650">這個方法會封鎖，直到目前的執行個體收到信號或逾時的呼叫端就會發生。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-650">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="0ff5c-651">使用這個方法來封鎖直到<xref:System.Threading.WaitHandle>從另一個執行緒收到訊號，例如便會產生非同步作業完成時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-651">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="0ff5c-652">如需詳細資訊，請參閱<xref:System.IAsyncResult>介面。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-652">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="0ff5c-653">覆寫這個方法以自訂在衍生類別的行為。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-653">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="0ff5c-654">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-654">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0ff5c-655">呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-655">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ff5c-656">目前的執行個體已經過處置。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-656">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-657"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-657"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="0ff5c-658">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-658">-or-</span></span> 
 <span data-ttu-id="0ff5c-659"><paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-659"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-660">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-660">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-661">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-661">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-662">目前的執行個體是另一個應用程式定義域中 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-662">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="0ff5c-663">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-663">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="0ff5c-664"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-664"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0ff5c-665">封鎖目前執行緒，直到目前的 <see cref="T:System.Threading.WaitHandle" /> 收到信號為止，使用 32 位元帶正負號的整數來指定時間間隔，並指定是否要先離開同步處理網域，再開始等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-665">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-666">如果目前的執行個體收到信號，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-666"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-667">如果`millisecondsTimeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-667">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-668">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-668">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-669"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-669"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0ff5c-670">在舊版中，<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`true`時放棄的 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-670">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0ff5c-671">已放棄的 mutex 通常表示嚴重的程式碼錯誤。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-671">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0ff5c-672">如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-672">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0ff5c-673">例外狀況包含資訊適用於偵錯。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-673">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0ff5c-674">這個方法會封鎖，直到目前的執行個體收到信號或逾時的呼叫端就會發生。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-674">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="0ff5c-675">使用這個方法來封鎖直到<xref:System.Threading.WaitHandle>從另一個執行緒收到訊號，例如便會產生非同步作業完成時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-675">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="0ff5c-676">如需詳細資訊，請參閱<xref:System.IAsyncResult>介面。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-676">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="0ff5c-677">覆寫這個方法以自訂在衍生類別的行為。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-677">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0ff5c-678">在結束內容的資訊</span><span class="sxs-lookup"><span data-stu-id="0ff5c-678">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0ff5c-679">`exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitOne%2A>從非預設受管理的內容中呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-679">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0ff5c-680">如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-680">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0ff5c-681">即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-681">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0ff5c-682">時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-682">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="0ff5c-683">執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.WaitOne%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-683">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="0ff5c-684">這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-684">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0ff5c-685">在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-685">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0ff5c-686">如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-686">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0ff5c-687">當<xref:System.Threading.WaitHandle.WaitOne%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-687">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-688">下列範例顯示如何<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>方法多載時就稱為同步處理網域中的行為。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-688">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="0ff5c-689">首先，執行緒會等候與`exitContext`設定為`false`，直到等候的逾時到期。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-689">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="0ff5c-690">第二個執行緒執行之後的第一個執行緒終止，並與等候`exitContext`設定為`true`。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-690">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="0ff5c-691">未封鎖的呼叫，以表示此第二個執行緒的等候控制代碼，並等候逾時之前完成的執行緒。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-691">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ff5c-692">目前的執行個體已經過處置。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-692">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-693"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-693"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-694">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-694">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-695">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-695">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-696">目前的執行個體是另一個應用程式定義域中 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-696">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="0ff5c-697"><see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-697">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="0ff5c-698"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-698"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0ff5c-699">封鎖目前執行緒，直到目前執行個體收到信號為止，使用 <see cref="T:System.TimeSpan" /> 來指定時間間隔，並指定是否要先離開同步處理網域，再開始等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-699">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="0ff5c-700">如果目前的執行個體收到信號，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-700"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-701">如果`timeout`為零，此方法不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-701">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0ff5c-702">它會測試等候控制代碼的狀態，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-702">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="0ff5c-703"><xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-703"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0ff5c-704">在舊版中，<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`true`時放棄的 mutex。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-704">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0ff5c-705">已放棄的 mutex 通常表示嚴重的程式碼錯誤。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-705">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0ff5c-706">如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-706">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0ff5c-707">例外狀況包含資訊適用於偵錯。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-707">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0ff5c-708">這個方法會封鎖，直到目前的執行個體收到信號或逾時的呼叫端就會發生。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-708">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="0ff5c-709">使用這個方法來封鎖直到<xref:System.Threading.WaitHandle>從另一個執行緒收到訊號，例如便會產生非同步作業完成時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-709">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="0ff5c-710">如需詳細資訊，請參閱<xref:System.IAsyncResult>介面。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-710">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="0ff5c-711">覆寫這個方法以自訂在衍生類別的行為。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-711">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="0ff5c-712">最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-712">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0ff5c-713">在結束內容的資訊</span><span class="sxs-lookup"><span data-stu-id="0ff5c-713">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0ff5c-714">`exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitOne%2A>從非預設受管理的內容中呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-714">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0ff5c-715">如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-715">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0ff5c-716">即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-716">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0ff5c-717">時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-717">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="0ff5c-718">執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.WaitOne%2A>方法完成。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-718">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="0ff5c-719">這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-719">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0ff5c-720">在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-720">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0ff5c-721">如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-721">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0ff5c-722">當<xref:System.Threading.WaitHandle.WaitOne%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-722">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-723">下列程式碼範例示範如何使用等候控制代碼，以防止處理程序結束時等候背景執行緒完成執行。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-723">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ff5c-724">目前的執行個體已經過處置。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-724">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ff5c-725"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-725"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="0ff5c-726">-或-</span><span class="sxs-lookup"><span data-stu-id="0ff5c-726">-or-</span></span> 
 <span data-ttu-id="0ff5c-727"><paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-727"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0ff5c-728">由於執行緒結束時未釋放 Mutex，已完成等候。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-728">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0ff5c-729">在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-729">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ff5c-730">目前的執行個體是另一個應用程式定義域中 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-730">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="0ff5c-731">表示 <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 作業在發出任何等候控制代碼信號之前便已逾時。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-731">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="0ff5c-732">這個欄位是常數。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-732">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ff5c-733">此欄位是其中一個可能的傳回值的`WaitAny`。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-733">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ff5c-734">下列程式碼範例示範如何使用執行緒集區同時搜尋多個磁碟上的檔案。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-734">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="0ff5c-735">如需空間考量，會搜尋只有每個磁碟的根目錄。</span><span class="sxs-lookup"><span data-stu-id="0ff5c-735">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>