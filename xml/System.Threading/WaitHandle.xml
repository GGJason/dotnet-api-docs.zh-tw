<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6ebd81e2bf7d5cd0f3352fe967172936ade87ae8" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57934245" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>將等候共用資源獨佔存取權限的特定作業系統物件封裝起來。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle>類別封裝原生作業系統同步處理控制代碼，而且用來代表所有在執行階段允許多個等候作業的同步處理物件。 如需與其他同步處理物件的等候控制代碼的比較，請參閱 <<c0> [ 同步處理原始物件概觀](~/docs/standard/threading/overview-of-synchronization-primitives.md)。  
  
 <xref:System.Threading.WaitHandle>本身的類別是抽象的。 類別衍生自<xref:System.Threading.WaitHandle>定義訊號的機制，以指示耗時或釋放存取共用資源，但是會使用繼承<xref:System.Threading.WaitHandle>方法來封鎖而等待存取共用資源。 類別衍生自<xref:System.Threading.WaitHandle>包括：  
  
-   
  <xref:System.Threading.Mutex> 類別。 請參閱[Mutex](~/docs/standard/threading/mutexes.md)。  
  
-   <xref:System.Threading.EventWaitHandle>類別和其衍生的類別，<xref:System.Threading.AutoResetEvent>和<xref:System.Threading.ManualResetEvent>。  
  
-   
  <xref:System.Threading.Semaphore> 類別。 請參閱[Semaphore 和 SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)。  
  
 個別的等候控制代碼上封鎖執行緒，可以將它所呼叫的執行個體方法<xref:System.Threading.WaitHandle.WaitOne%2A>，其中會由衍生自的類別繼承<xref:System.Threading.WaitHandle>。  
  
 在衍生的類別<xref:System.Threading.WaitHandle>的差異在於其執行緒親和性。 事件等候控制代碼 (<xref:System.Threading.EventWaitHandle>， <xref:System.Threading.AutoResetEvent>，和<xref:System.Threading.ManualResetEvent>)，號誌沒有執行緒相似性; 任何執行緒可以發出信號的事件等候控制代碼或號誌。 Mutex，相反地，沒有執行緒相似性;擁有 mutex 的執行緒必須釋放它，並會擲回例外狀況，如果執行緒呼叫<xref:System.Threading.Mutex.ReleaseMutex%2A>上未擁有 mutex 的方法。  
  
 因為<xref:System.Threading.WaitHandle>類別衍生自<xref:System.MarshalByRefObject>，這些類別可以用來跨應用程式定義域界限同步處理執行緒的活動。  
  
 除了其衍生的類別，<xref:System.Threading.WaitHandle>類別具有一些靜態方法，封鎖執行緒，直到其中一個或多個同步物件收到信號。 它們包括：  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>這可讓發出信號一個等候控制代碼，以及立即等候另一個執行緒。  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>這可讓執行緒等候，直到在陣列中的所有等候控制代碼會都收到信號。  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>這可讓執行緒等候，直到收到訊號的一組指定的等候控制代碼的任何一個。  
  
 這些方法的多載提供放棄等候，並有機會先離開同步處理內容，再進入等候，讓其他執行緒使用的同步處理內容的逾時間隔。  
  
> [!IMPORTANT]
>  此類型會實作<xref:System.IDisposable>介面。 當您完成使用的類型或從中衍生的類型時，您應該處置它直接或間接。 若要直接處置型別，呼叫其<xref:System.Threading.WaitHandle.Close%2A>方法中的`try` / `catch`區塊。 若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
 <xref:System.Threading.WaitHandle> 實作<xref:System.IDisposable.Dispose%2A>模式。 請參閱 [實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。 當您衍生自<xref:System.Threading.WaitHandle>，使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>屬性來儲存您的原生作業系統控制代碼。 您不需要覆寫保護<xref:System.Threading.WaitHandle.Dispose%2A>方法除非您使用其他的 unmanaged 的資源。  
  
   
  
## Examples  
 下列程式碼範例示範如何在兩個執行緒可以執行背景工作，並在主要執行緒等候工作完成使用靜態<xref:System.Threading.WaitHandle.WaitAny%2A>並<xref:System.Threading.WaitHandle.WaitAll%2A>方法<xref:System.Threading.WaitHandle>類別。  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此型別具備執行緒安全。</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">執行緒</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">執行緒物件和功能</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutex</related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle、AutoResetEvent 和 ManualResetEvent</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">號誌</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Threading.WaitHandle" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放目前 <see cref="T:System.Threading.WaitHandle" /> 所持有的全部資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法是公用的實作<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>方法<xref:System.Threading.WaitHandle>類別和其衍生的類別。 它提供標準的實作會呼叫`Dispose(Boolean)`多載`true`引數，然後呼叫<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>方法。 呼叫這個方法來釋放的執行個體所持有的所有資源`WaitHandle`或衍生的類別。  
  
 一旦呼叫這個方法時，目前的執行個體的參考會導致未定義的行為。  
  
> [!NOTE]
>  請務必呼叫<xref:System.Threading.WaitHandle.Close%2A>或是<xref:System.Threading.WaitHandle.Dispose>您釋放最後一個參考之前<xref:System.Threading.WaitHandle>。 否則，將不會釋放它所使用的資源。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>您應該覆寫<see langword="Dispose(Boolean)" />方法來釋放資源配置中衍生的類別。</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">實作 Dispose 方法</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 <see cref="T:System.Threading.WaitHandle" /> 類別的目前執行個體所使用的資源全部釋放</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Threading.WaitHandle" /> 類別目前的執行個體所使用的全部資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法相當於<xref:System.Threading.WaitHandle.Close%2A>方法。  
  
> [!NOTE]
>  請務必呼叫<xref:System.Threading.WaitHandle.Close%2A>或是<xref:System.Threading.WaitHandle.Dispose>您釋放最後一個參考之前<xref:System.Threading.WaitHandle>。 否則，將不會釋放它所使用的資源。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">清除 Unmanaged 資源</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>當在衍生類別中覆寫時，釋放 <see cref="T:System.Threading.WaitHandle" /> 所使用的 Unmanaged 資源，並選擇性釋放 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫<xref:System.Threading.WaitHandle.Close%2A>而<xref:System.Threading.WaitHandle.Dispose>方法`explicitDisposing`參數設定為`true`。  當`explicitDisposing`參數是`true`，這個方法由任何 managed 物件持有的資源全部釋出這個<xref:System.Threading.WaitHandle>物件參考。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>您應該覆寫<see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />方法來釋放資源配置中衍生的類別。  
  
<see cref="M:System.Threading.WaitHandle.Close" />或<see cref="M:System.Threading.WaitHandle.Dispose" />方法可以由其他物件呼叫多次。 當覆寫此方法時，小心不要參考先前處置呼叫中的物件<see langword="Dispose" />或<see langword="Close" />。</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">實作 Dispose 方法</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將目前執行個體所持有的資源釋出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> 這個成員已經移除了.NET Framework 2.0 版與後續版本。 本主題只適用於本主題稍後的 「 版本資訊 」 中所列的版本。


應用程式程式碼不會呼叫這個方法。它會自動叫用記憶體回收期間，除非已停用記憶體回收行程的最終處理。 如需詳細資訊，請參閱 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> 與 <xref:System.Object.Finalize>。 這個方法會覆寫 <xref:System.Object.Finalize>。

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定原生 (Native) 的作業系統控制代碼。</summary>
        <value><see langword="IntPtr" />，代表原生作業系統控制代碼。 預設為 <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> 欄位的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指派新值給<xref:System.Threading.WaitHandle.Handle%2A>屬性不會關閉先前的控制代碼。 這會導致遺漏的控制代碼。  
  
 請勿使用這個屬性在.NET Framework 2.0 版或更新版本;使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>屬性改為。 此屬性設定為有效的控制代碼也設定<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>屬性，但將它設定為<xref:System.Threading.WaitHandle.InvalidHandle>可能會導致遺漏的控制代碼。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者，來設定屬性值。 這個成員無法由部分信任或不透明的程式碼設定。</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">在衍生的型別必須具有<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />來設定屬性值。</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>代表無效的原生作業系統控制代碼。 此欄位為唯讀。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在內部用來初始化<xref:System.Threading.WaitHandle.Handle%2A>屬性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>您可以使用此值來判斷是否<see cref="P:System.Threading.WaitHandle.Handle" />屬性包含有效的原生作業系統控制代碼。</para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定原生 (Native) 的作業系統控制代碼。</summary>
        <value><see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />，代表原生作業系統控制代碼。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您指派新的值，以<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>屬性，先前的控制代碼會在關閉前一個<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>物件回收。 請勿以手動方式關閉此控制代碼，因為這會導致<xref:System.ObjectDisposedException>當<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>嘗試關閉此控制代碼。  
  
 <xref:System.Threading.WaitHandle> 實作<xref:System.IDisposable.Dispose%2A>模式。 請參閱 [實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。 當您衍生自<xref:System.Threading.WaitHandle>，使用<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>屬性來儲存您的原生控制代碼的作業系統控制代碼。 您不需要覆寫保護<xref:System.Threading.WaitHandle.Dispose%2A>方法除非您使用其他的 unmanaged 的資源。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫端。 此成員不能由部分信任或不透明的程式碼。</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">在衍生的型別必須具有<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />呼叫這個成員。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>發出一個 <see cref="T:System.Threading.WaitHandle" /> 信號並等候另一個。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="toSignal">要發出的 <see cref="T:System.Threading.WaitHandle" /> 信號。</param>
        <param name="toWaitOn">要等候的 <see cref="T:System.Threading.WaitHandle" />。</param>
        <summary>發出一個 <see cref="T:System.Threading.WaitHandle" /> 信號並等候另一個。</summary>
        <returns>如果順利完成信號發出和等候，則為 <see langword="true" />；如果未完成等候，則不會傳回這個方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這項作業不保證是不可部分完成。 在目前的執行緒訊號後`toSignal`之前等候`toWaitOn`，另一個處理器執行的執行緒可能會發出信號`toWaitOn`或等候它。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>方法多載來允許主執行緒發出信號已封鎖的執行緒，以及執行緒完成工作，然後等候。  
  
 範例啟動五個執行緒，讓他們封鎖<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>旗標與再發行每一個執行緒時間使用者按下 ENTER 鍵。 此範例會排入佇列的另一個的五個執行緒，並釋放所有使用<xref:System.Threading.EventWaitHandle>以建立<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>旗標。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="toWaitOn" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">在擁有 <see cref="T:System.STAThreadAttribute" /> 的執行緒上呼叫此方法。</exception>
        <exception cref="T:System.PlatformNotSupportedException">在 Windows 98 或 Windows Millennium Edition 上不支援這個方法。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="toSignal" /> 為號誌，且已經有完整計數。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="toSignal">要發出的 <see cref="T:System.Threading.WaitHandle" /> 信號。</param>
        <param name="toWaitOn">要等候的 <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="millisecondsTimeout">整數，表示要等候的間隔。 如果值為 <see cref="F:System.Threading.Timeout.Infinite" /> (亦即 -1)，則會永遠等候。</param>
        <param name="exitContext"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</param>
        <summary>發出一個 <see cref="T:System.Threading.WaitHandle" /> 信號並等候另一個，將逾時間隔指定為 32 位元帶正負號的整數，並指定是否要先離開內容的同步處理網域，再進入等候狀態。</summary>
        <returns>如果順利完成信號發出和等候，則為 <see langword="true" />；如果完成信號發出但等候逾時，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這項作業不保證是不可部分完成。 在目前的執行緒訊號後`toSignal`之前等候`toWaitOn`，另一個處理器執行的執行緒可能會發出信號`toWaitOn`或等候它。  
  
 如果`millisecondsTimeout`為零，此方法不會封鎖。 它會測試的狀態`toWaitOn`並立即傳回。  
  
## <a name="notes-on-exiting-the-context"></a>在結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.SignalAndWait%2A>從非預設受管理的內容中呼叫方法。 如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法。 執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法完成。  
  
 這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。 當<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="toWaitOn" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">在擁有 <see cref="T:System.STAThreadAttribute" /> 的執行緒上呼叫此方法。</exception>
        <exception cref="T:System.PlatformNotSupportedException">在 Windows 98 或 Windows Millennium Edition 上不支援這個方法。</exception>
        <exception cref="T:System.InvalidOperationException">無法對 <see cref="T:System.Threading.WaitHandle" /> 發出信號，因為它可能會超過最大計數。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="toSignal">要發出的 <see cref="T:System.Threading.WaitHandle" /> 信號。</param>
        <param name="toWaitOn">要等候的 <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />，代表要等候的間隔。 如果此值為 -1，則會無限期等候。</param>
        <param name="exitContext"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</param>
        <summary>發出一個 <see cref="T:System.Threading.WaitHandle" /> 信號並等候另一個，將逾時間隔指定為 <see cref="T:System.TimeSpan" />，並指定是否要先離開內容的同步處理網域，再進入等候狀態。</summary>
        <returns>如果順利完成信號發出和等候，則為 <see langword="true" />；如果完成信號發出但等候逾時，則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這項作業不保證是不可部分完成。 在目前的執行緒訊號後`toSignal`之前等候`toWaitOn`，另一個處理器執行的執行緒可能會發出信號`toWaitOn`或等候它。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
 如果`timeout`為零，此方法不會封鎖。 它會測試的狀態`toWaitOn`並立即傳回。  
  
## <a name="notes-on-exiting-the-context"></a>在結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.SignalAndWait%2A>從非預設受管理的內容中呼叫方法。 如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法。 執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法完成。  
  
 這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。 當<xref:System.Threading.WaitHandle.SignalAndWait%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> 為 <see langword="null" />。  
  
-或- 
 <paramref name="toWaitOn" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">在擁有 <see cref="T:System.STAThreadAttribute" /> 的執行緒上呼叫此方法。</exception>
        <exception cref="T:System.PlatformNotSupportedException">在 Windows 98 或 Windows Millennium Edition 上不支援這個方法。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="toSignal" /> 為號誌，且已經有完整計數。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 判定為 -1 以外的負毫秒數目。  
  
-或- 
 <paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>釋放 <see cref="T:System.Threading.WaitHandle" /> 所使用的所有資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
呼叫`Dispose`可讓所使用的資源<xref:System.Threading.WaitHandle>重新配置用於其他用途。 如需詳細資訊`Dispose`，請參閱 <<c2> [ 清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)。

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>等候指定陣列中的所有項目都收到信號。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。 這個陣列不能包含相同物件的多個參考。</param>
        <summary>等候指定陣列中的所有項目都收到信號。</summary>
        <returns>當 <paramref name="waitHandles" /> 中的所有項目都收到信號時，則為 <see langword="true" />；否則絕不會傳回這個方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。 在舊版中，<xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回`true`時放棄的 mutex。 已放棄的 mutex 通常表示嚴重的程式碼錯誤。 如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。 例外狀況包含資訊適用於偵錯。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回所有控制代碼會收到信號。 在某些實作中，若傳遞了 64 個以上的控制代碼，<xref:System.NotSupportedException>就會擲回。 如果陣列包含重複的項目，則呼叫會失敗並<xref:System.DuplicateWaitObjectException>。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>擁有的執行緒上不支援方法<xref:System.STAThreadAttribute>。  
  
 呼叫這個方法多載就相當於呼叫<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>方法多載，並指定-1 (或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) 的`millisecondsTimeout`並`true`如`exitContext`。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用執行緒集區，以非同步方式建立和寫入檔案群組。 完成後，工作項目以及訊號每一個寫入作業已排入佇列。 主執行緒等候發出信號的所有項目，然後結束。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> 參數為 <see langword="null" />。 -或- 
<paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。  
  
-或- 
 <paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 2.0 或更新版本。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況<see cref="T:System.ArgumentException" />。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 陣列包含重複的項目。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。  
  
-或- 
<see cref="T:System.STAThreadAttribute" /> 屬性會套用至目前執行緒的執行緒程序，且 <paramref name="waitHandles" /> 包含多個項目。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已結束等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。 這個陣列無法包含相同物件 (複本) 的多個參考。</param>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.Int32" /> 值來指定時間間隔。</summary>
        <returns>當 <paramref name="waitHandles" /> 中的所有項目都收到信號時，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回在等候終止時，這表示所有控制代碼會收到信號或逾時發生時。 在某些實作中，若傳遞了 64 個以上的控制代碼，<xref:System.NotSupportedException>就會擲回。 如果陣列中有重複的項目，則呼叫會失敗並<xref:System.DuplicateWaitObjectException>。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>擁有的執行緒上不支援方法<xref:System.STAThreadAttribute>。  
  
 呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。  
  
-或- 
 <paramref name="waitHandles" /> 是不含任何項目的陣列。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況<see cref="T:System.ArgumentException" />。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 陣列包含重複的項目。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。  
  
-或- 
<see cref="T:System.STAThreadAttribute" /> 屬性會套用至目前執行緒的執行緒程序，且 <paramref name="waitHandles" /> 包含多個項目。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。 這個陣列不能包含相同物件的多個參考。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />，代表要等候的毫秒數；或是 <see cref="T:System.TimeSpan" />，代表永遠等候的 -1 毫秒。</param>
        <summary>等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.TimeSpan" /> 值來指定時間間隔。</summary>
        <returns>當 <paramref name="waitHandles" /> 中的所有項目都收到信號時，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>方法傳回時則等候會終止，這表示可能是所有控制代碼會收到信號，或發生逾時。 在某些實作中，若傳遞了 64 個以上的控制代碼，<xref:System.NotSupportedException>就會擲回。 如果陣列包含重複的項目，則呼叫會失敗。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>擁有的執行緒上不支援方法<xref:System.STAThreadAttribute>。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
 呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。  
  
-或- 
 <paramref name="waitHandles" /> 是不含任何項目的陣列。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">適用於 Windows 市集應用程式的 .NET</see> 或是<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可攜式類別庫</see>中，改為攔截基底類別例外狀況<see cref="T:System.ArgumentException" />。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 陣列包含重複的項目。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。  
  
-或- 
<see cref="T:System.STAThreadAttribute" /> 屬性會套用至目前執行緒的執行緒程序，且 <paramref name="waitHandles" /> 包含多個項目。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。 
-或- 
 <paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已結束等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。 這個陣列無法包含相同物件 (複本) 的多個參考。</param>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</param>
        <summary>等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.Int32" /> 值來指定時間間隔，並指定是否要先離開同步處理網域，再開始等候。</summary>
        <returns>當 <paramref name="waitHandles" /> 中的所有項目都收到信號時，則為 <see langword="true" />；否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 <xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。 在舊版中，<xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回`true`時放棄的 mutex。 已放棄的 mutex 通常表示嚴重的程式碼錯誤。 如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。 例外狀況包含資訊適用於偵錯。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回在等候終止時，這表示所有控制代碼會收到信號或逾時發生時。 在某些實作中，若傳遞了 64 個以上的控制代碼，<xref:System.NotSupportedException>就會擲回。 如果陣列中有重複的項目，則呼叫會失敗並<xref:System.DuplicateWaitObjectException>。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>擁有的執行緒上不支援方法<xref:System.STAThreadAttribute>。  
  
## <a name="notes-on-exiting-the-context"></a>在結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitAll%2A>從非預設受管理的內容中呼叫方法。 如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitAll%2A>方法。 執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.WaitAll%2A>方法完成。  
  
 這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>屬性。 在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitAll%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。 當<xref:System.Threading.WaitHandle.WaitAll%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用執行緒集區，以非同步方式建立和寫入檔案群組。 完成後，工作項目以及訊號每一個寫入作業已排入佇列。 主執行緒等候發出信號的所有項目，然後結束。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。  
  
-或- 
 <paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 2.0 或更新版本。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><paramref name="waitHandles" /> 陣列包含重複的項目。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。  
  
-或- 
<see cref="T:System.STAThreadAttribute" /> 屬性會套用至目前執行緒的執行緒程序，且 <paramref name="waitHandles" /> 包含多個項目。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。 這個陣列不能包含相同物件的多個參考。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />，代表要等候的毫秒數；或是 <see cref="T:System.TimeSpan" />，代表永遠等候的 -1 毫秒。</param>
        <param name="exitContext"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</param>
        <summary>等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.TimeSpan" /> 值來指定時間間隔，並指定是否要先離開同步處理網域，再開始等候。</summary>
        <returns>當 <paramref name="waitHandles" /> 中的所有元素都收到訊號時，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 <xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。 在舊版中，<xref:System.Threading.WaitHandle.WaitAll%2A>方法會傳回`true`時放棄的 mutex。 已放棄的 mutex 通常表示嚴重的程式碼錯誤。 如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。 例外狀況包含資訊適用於偵錯。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>方法傳回時則等候會終止，這表示可能是所有控制代碼會收到信號，或發生逾時。 在某些實作中，若傳遞了 64 個以上的控制代碼，<xref:System.NotSupportedException>就會擲回。 如果陣列包含重複的項目，則呼叫會失敗。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>擁有的執行緒上不支援方法<xref:System.STAThreadAttribute>。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
## <a name="notes-on-exiting-the-context"></a>在結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitAll%2A>從非預設受管理的內容中呼叫方法。 如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitAll%2A>方法。 它會傳回呼叫之後為原始的非預設內容<xref:System.Threading.WaitHandle.WaitAll%2A>方法完成。  
  
 這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitAll%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。 當<xref:System.Threading.WaitHandle.WaitAll%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用執行緒集區，以非同步方式建立和寫入檔案群組。 完成後，工作項目以及訊號每一個寫入作業已排入佇列。 主執行緒等候發出信號的所有項目，然後結束。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。  
  
-或- 
 <paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 2.0 或更新版本。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><paramref name="waitHandles" /> 陣列包含重複的項目。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。  
  
-或- 
<see cref="T:System.STAThreadAttribute" /> 屬性會套用至目前執行緒的執行緒程序，且 <paramref name="waitHandles" /> 包含多個項目。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> 是沒有任何項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。 
-或- 
 <paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已結束等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>等候指定陣列中有任何項目收到信號。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</param>
        <summary>等候指定陣列中有任何項目收到信號。</summary>
        <returns>滿足等候條件之物件的陣列索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。 在舊版中，<xref:System.Threading.WaitHandle.WaitAny%2A>方法會傳回`true`如果等候完成，因為已放棄 mutex。 已放棄的 mutex 通常表示嚴重的程式碼錯誤。 如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。 例外狀況包含資訊適用於偵錯。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>方法會擲回<xref:System.Threading.AbandonedMutexException>只等待完成時因為遭到放棄的 mutex。 如果`waitHandles`包含具有較低的索引編號，已放棄的 mutex，比釋放的 mutex<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成，並不會擲回例外狀況。  
  
> [!NOTE]
>  在版本早於 2.0 版中，如果執行緒結束或中止而不需要明確地釋放的.NET framework <xref:System.Threading.Mutex>，且`Mutex`位於索引 0 （零），在`WaitAny`陣列在另一個執行緒，所傳回的索引上`WaitAny`是128 而不是 0。  
  
 這個方法會傳回任何控制代碼會收到信號。 如果在呼叫期間，多個物件會變成收到訊號，則傳回的值會是物件的已收到訊號具有已收到訊號的所有物件的最小的索引值的陣列索引。 在某些實作中，如果有多個傳遞 64 的控制代碼，<xref:System.NotSupportedException>就會擲回。  
  
 呼叫這個方法多載就相當於呼叫<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>方法多載，並指定-1 (或<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) 的`millisecondsTimeout`並`true`如`exitContext`。  
  
   
  
## Examples  
 下列程式碼範例示範如何呼叫<xref:System.Threading.WaitHandle.WaitAny%2A>方法。  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> 是不具有項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> 是不具有元素的陣列，且 .NET Framework 版本為 2.0 (含) 以後版本。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</param>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>等候指定之陣列中有任何項目收到信號，使用 32 位元帶正負號的整數以指定時間間隔。</summary>
        <returns>滿足等候條件之物件的陣列索引；如果沒有物件滿足等候條件，而且已經過相當於 <paramref name="millisecondsTimeout" /> 的時間間隔，則為 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>方法會擲回<xref:System.Threading.AbandonedMutexException>只等待完成時因為遭到放棄的 mutex。 如果`waitHandles`包含具有較低的索引編號，已放棄的 mutex，比釋放的 mutex<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成，並不會擲回例外狀況。  
  
 這個方法傳回時則等候會終止，任何控制代碼會收到信號或發生逾時。 如果在呼叫期間，多個物件會變成收到訊號，則傳回的值會是物件的已收到訊號具有已收到訊號的所有物件的最小的索引值的陣列索引。 在某些實作中，如果有多個傳遞 64 的控制代碼，<xref:System.NotSupportedException>就會擲回。  
  
 呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> 是不含任何項目的陣列。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</param>
        <summary>等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.TimeSpan" /> 來指定時間間隔。</summary>
        <returns>滿足等候條件之物件的陣列索引；如果沒有物件滿足等候條件，而且已經過相當於 <paramref name="timeout" /> 的時間間隔，則為 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>方法會擲回<xref:System.Threading.AbandonedMutexException>只等待完成時因為遭到放棄的 mutex。 如果`waitHandles`包含具有較低的索引編號，已放棄的 mutex，比釋放的 mutex<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成，並不會擲回例外狀況。  
  
 這個方法傳回時則等候會終止，任何控制代碼會收到信號或逾時發生時。 如果在呼叫期間，多個物件會變成收到訊號，則傳回的值會是物件的已收到訊號具有已收到訊號的所有物件的最小的索引值的陣列索引。 在某些實作中，如果有多個傳遞 64 的控制代碼，<xref:System.NotSupportedException>就會擲回。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
 呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。 
-或- 
 <paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> 是不含任何項目的陣列。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</param>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</param>
        <summary>等候指定陣列中有任何項目收到信號；使用 32 位元帶正負號的整數 (Signed Integer) 來指定時間間隔，並指定是否在等候之前先離開同步處理領域。</summary>
        <returns>滿足等候條件之物件的陣列索引；如果沒有物件滿足等候條件，而且已經過相當於 <paramref name="millisecondsTimeout" /> 的時間間隔，則為 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 <xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。 在舊版中，<xref:System.Threading.WaitHandle.WaitAny%2A>方法會傳回`true`如果等候完成，因為已放棄 mutex。 已放棄的 mutex 通常表示嚴重的程式碼錯誤。 如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。 例外狀況包含資訊適用於偵錯。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>方法會擲回<xref:System.Threading.AbandonedMutexException>只等待完成時因為遭到放棄的 mutex。 如果`waitHandles`包含具有較低的索引編號，已放棄的 mutex，比釋放的 mutex<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成，並不會擲回例外狀況。  
  
> [!NOTE]
>  在版本早於 2.0 版中，如果執行緒結束或中止而不需要明確地釋放的.NET framework <xref:System.Threading.Mutex>，且`Mutex`位於索引 0 （零），在`WaitAny`陣列在另一個執行緒，所傳回的索引上`WaitAny`是128 而不是 0。  
  
 這個方法傳回時則等候會終止，任何控制代碼會收到信號或發生逾時。 如果在呼叫期間，多個物件會變成收到訊號，則傳回的值會是物件的已收到訊號具有已收到訊號的所有物件的最小的索引值的陣列索引。 在某些實作中，如果有多個傳遞 64 的控制代碼，<xref:System.NotSupportedException>就會擲回。  
  
## <a name="notes-on-exiting-the-context"></a>在結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitAny%2A>從非預設受管理的內容中呼叫方法。 如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitAny%2A>方法。 執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.WaitAny%2A>方法完成。  
  
 這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitAny%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。 當<xref:System.Threading.WaitHandle.WaitAny%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用執行緒集區同時搜尋多個磁碟上的檔案。 如需空間考量，會搜尋只有每個磁碟的根目錄。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> 是不具有項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> 是不具有元素的陣列，且 .NET Framework 版本為 2.0 (含) 以後版本。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><see langword="WaitHandle" /> 陣列，包含目前執行個體將等候的物件。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</param>
        <param name="exitContext"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</param>
        <summary>等候指定陣列中的所有項目都收到信號，使用 <see cref="T:System.TimeSpan" /> 來指定時間間隔，並指定是否要先離開同步處理網域，再開始等候。</summary>
        <returns>滿足等候條件之物件的陣列索引；如果沒有物件滿足等候條件，而且已經過相當於 <paramref name="timeout" /> 的時間間隔，則為 <see cref="F:System.Threading.WaitHandle.WaitTimeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 <xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。 在舊版中，<xref:System.Threading.WaitHandle.WaitAny%2A>方法會傳回`true`如果等候完成，因為已放棄 mutex。 已放棄的 mutex 通常表示嚴重的程式碼錯誤。 如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。 例外狀況包含資訊適用於偵錯。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>方法會擲回<xref:System.Threading.AbandonedMutexException>只等待完成時因為遭到放棄的 mutex。 如果`waitHandles`包含具有較低的索引編號，已放棄的 mutex，比釋放的 mutex<xref:System.Threading.WaitHandle.WaitAny%2A>方法正常完成，並不會擲回例外狀況。  
  
> [!NOTE]
>  在版本早於 2.0 版中，如果執行緒結束或中止而不需要明確地釋放的.NET framework <xref:System.Threading.Mutex>，且`Mutex`位於索引 0 （零），在`WaitAny`陣列在另一個執行緒，所傳回的索引上`WaitAny`是128 而不是 0。  
  
 這個方法傳回時則等候會終止，任何控制代碼會收到信號或逾時發生時。 如果在呼叫期間，多個物件會變成收到訊號，則傳回的值會是物件的已收到訊號具有已收到訊號的所有物件的最小的索引值的陣列索引。 在某些實作中，如果有多個傳遞 64 的控制代碼，<xref:System.NotSupportedException>就會擲回。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
## <a name="notes-on-exiting-the-context"></a>在結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitAny%2A>從非預設受管理的內容中呼叫方法。 如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitAny%2A>方法。 執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.WaitAny%2A>方法完成。  
  
 這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitAny%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。 當<xref:System.Threading.WaitHandle.WaitAny%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用執行緒集區同時搜尋多個磁碟上的檔案。 如需空間考量，會搜尋只有每個磁碟的根目錄。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="waitHandles" /> 陣列中的一或多個物件為 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> 中的物件數目超過系統允許的數目。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> 是不具有項目的陣列，且 .NET Framework 版本為 1.0 或 1.1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。 
-或- 
 <paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> 是不具有元素的陣列，且 .NET Framework 版本為 2.0 (含) 以後版本。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 陣列在另一個應用程式定義域中包含 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>封鎖目前的執行緒，直到目前的 <see cref="T:System.Threading.WaitHandle" /> 收到訊號為止。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>封鎖目前的執行緒，直到目前的 <see cref="T:System.Threading.WaitHandle" /> 收到訊號為止。</summary>
        <returns>如果目前的執行個體有收到信號，則為 <see langword="true" />。 如果目前的執行個體一直沒有收到訊號，<see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> 就一定不會傳回。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。 在舊版中，<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`true`時放棄的 mutex。 已放棄的 mutex 通常表示嚴重的程式碼錯誤。 如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。 例外狀況包含資訊適用於偵錯。  
  
 這個方法會封鎖目前的執行個體之前，無限期的呼叫端會收到信號。 使用這個方法來封鎖直到<xref:System.Threading.WaitHandle>從另一個執行緒收到訊號，例如便會產生非同步作業完成時。 如需詳細資訊，請參閱<xref:System.IAsyncResult>介面。  
  
 呼叫這個方法多載就相當於呼叫<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>方法多載，並指定-1 或是<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>第一個參數和`false`第二個參數。  
  
 覆寫這個方法以自訂在衍生類別的行為。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用等候控制代碼，以防止處理程序結束時等候背景執行緒完成執行。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException">目前的執行個體是另一個應用程式定義域中 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>封鎖目前執行緒，直到目前的 <see cref="T:System.Threading.WaitHandle" /> 收到信號為止，使用 32 位元帶正負號的整數來指定時間間隔 (以毫秒為單位)。</summary>
        <returns>如果目前的執行個體收到信號，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 這個方法會封鎖，直到目前的執行個體收到信號或逾時的呼叫端就會發生。 使用這個方法來封鎖直到<xref:System.Threading.WaitHandle>從另一個執行緒收到訊號，例如便會產生非同步作業完成時。 如需詳細資訊，請參閱<xref:System.IAsyncResult>介面。  
  
 覆寫這個方法以自訂在衍生類別的行為。  
  
 呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用等候控制代碼，以防止處理程序結束時等候背景執行緒完成執行。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException">目前的執行個體是另一個應用程式定義域中 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</param>
        <summary>封鎖目前執行緒，直到目前執行個體收到信號為止，使用 <see cref="T:System.TimeSpan" /> 來指定時間間隔。</summary>
        <returns>如果目前的執行個體收到信號，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 這個方法會封鎖，直到目前的執行個體收到信號或逾時的呼叫端就會發生。 使用這個方法來封鎖直到<xref:System.Threading.WaitHandle>從另一個執行緒收到訊號，例如便會產生非同步作業完成時。 如需詳細資訊，請參閱<xref:System.IAsyncResult>介面。  
  
 覆寫這個方法以自訂在衍生類別的行為。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
 呼叫這個方法多載等同於呼叫<xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29>多載，並指定`false`如`exitContext`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。 
-或- 
 <paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException">目前的執行個體是另一個應用程式定義域中 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</param>
        <summary>封鎖目前執行緒，直到目前的 <see cref="T:System.Threading.WaitHandle" /> 收到信號為止，使用 32 位元帶正負號的整數來指定時間間隔，並指定是否要先離開同步處理網域，再開始等候。</summary>
        <returns>如果目前的執行個體收到信號，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`millisecondsTimeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 <xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。 在舊版中，<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`true`時放棄的 mutex。 已放棄的 mutex 通常表示嚴重的程式碼錯誤。 如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。 例外狀況包含資訊適用於偵錯。  
  
 這個方法會封鎖，直到目前的執行個體收到信號或逾時的呼叫端就會發生。 使用這個方法來封鎖直到<xref:System.Threading.WaitHandle>從另一個執行緒收到訊號，例如便會產生非同步作業完成時。 如需詳細資訊，請參閱<xref:System.IAsyncResult>介面。  
  
 覆寫這個方法以自訂在衍生類別的行為。  
  
## <a name="notes-on-exiting-the-context"></a>在結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitOne%2A>從非預設受管理的內容中呼叫方法。 如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitOne%2A>方法。 執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.WaitOne%2A>方法完成。  
  
 這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。 當<xref:System.Threading.WaitHandle.WaitOne%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。  
  
   
  
## Examples  
 下列範例顯示如何<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>方法多載時就稱為同步處理網域中的行為。 首先，執行緒會等候與`exitContext`設定為`false`，直到等候的逾時到期。 第二個執行緒執行之後的第一個執行緒終止，並與等候`exitContext`設定為`true`。 未封鎖的呼叫，以表示此第二個執行緒的等候控制代碼，並等候逾時之前完成的執行緒。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException">目前的執行個體是另一個應用程式定義域中 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</param>
        <param name="exitContext"><see langword="true" /> 表示在等候 (如果在同步內容中) 前結束內容的同步處理網域，並於之後重新取得，否則為 <see langword="false" />。</param>
        <summary>封鎖目前執行緒，直到目前執行個體收到信號為止，使用 <see cref="T:System.TimeSpan" /> 來指定時間間隔，並指定是否要先離開同步處理網域，再開始等候。</summary>
        <returns>如果目前的執行個體收到信號，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`timeout`為零，此方法不會封鎖。 它會測試等候控制代碼的狀態，並立即傳回。  
  
 <xref:System.Threading.AbandonedMutexException> 是.NET Framework 2.0 版中的新功能。 在舊版中，<xref:System.Threading.WaitHandle.WaitOne%2A>方法會傳回`true`時放棄的 mutex。 已放棄的 mutex 通常表示嚴重的程式碼錯誤。 如果是全系統 mutex，則可能表示，應用程式已意外終止 （例如，透過使用 Windows 工作管理員）。 例外狀況包含資訊適用於偵錯。  
  
 這個方法會封鎖，直到目前的執行個體收到信號或逾時的呼叫端就會發生。 使用這個方法來封鎖直到<xref:System.Threading.WaitHandle>從另一個執行緒收到訊號，例如便會產生非同步作業完成時。 如需詳細資訊，請參閱<xref:System.IAsyncResult>介面。  
  
 覆寫這個方法以自訂在衍生類別的行為。  
  
 最大值`timeout`是<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
## <a name="notes-on-exiting-the-context"></a>在結束內容的資訊  
 `exitContext`參數沒有任何作用，除非<xref:System.Threading.WaitHandle.WaitOne%2A>從非預設受管理的內容中呼叫方法。 如果您的執行緒是衍生自類別的執行個體的呼叫在此情形<xref:System.ContextBoundObject>。 即使您目前正在執行的方法不是衍生自的類別上<xref:System.ContextBoundObject>，例如<xref:System.String>，您可以在非預設內容中如果<xref:System.ContextBoundObject>您目前的應用程式定義域中的堆疊上。  
  
 時的非預設內容中執行您的程式碼，在指定`true`的`exitContext`造成執行緒結束的非預設的 managed 的內容 (也就是轉換成預設內容) 執行之前<xref:System.Threading.WaitHandle.WaitOne%2A>方法。 執行緒在呼叫之後返回原始的非預設內容<xref:System.Threading.WaitHandle.WaitOne%2A>方法完成。  
  
 這有助於進行內容繫結類別具有<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>。 在此情況下，所有呼叫類別的成員會自動同步都處理，並同步處理領域是類別程式碼的整個主體。 如果成員的呼叫堆疊中的程式碼會呼叫<xref:System.Threading.WaitHandle.WaitOne%2A>方法，並指定`true`如`exitContext`，執行緒結束同步處理網域，讓執行緒上呼叫物件的任何成員，以繼續進行封鎖。 當<xref:System.Threading.WaitHandle.WaitOne%2A>方法傳回時，進行呼叫的執行緒必須等待重新輸入一次同步處理領域。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用等候控制代碼，以防止處理程序結束時等候背景執行緒完成執行。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">目前的執行個體已經過處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。 
-或- 
 <paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">由於執行緒結束時未釋放 Mutex，已完成等候。 在 Windows 98 或 Windows Millennium Edition 上不擲回這個例外狀況。</exception>
        <exception cref="T:System.InvalidOperationException">目前的執行個體是另一個應用程式定義域中 <see cref="T:System.Threading.WaitHandle" /> 的 Transparent Proxy。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>表示 <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 作業在發出任何等候控制代碼信號之前便已逾時。 這個欄位是常數。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此欄位是其中一個可能的傳回值的`WaitAny`。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用執行緒集區同時搜尋多個磁碟上的檔案。 如需空間考量，會搜尋只有每個磁碟的根目錄。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>