<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5cecfa2ccfb0c078816afadda63313ffb6ac73cf" />
    <Meta Name="ms.sourcegitcommit" Value="01f28caab7b3f23878dd07b402a8dd48b9478c8c" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/19/2018" />
    <Meta Name="ms.locfileid" Value="39140715" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供平行迴圈和區域的支援。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Parallel>類別提供一般作業，例如迴圈，針對每個迴圈，和一組陳述式執行的程式庫為基礎的資料平行取代。  
  
   
  
## Examples  
 此範例示範數種方法來實作平行迴圈使用多個語言建構。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>所有 public 和 protected 成員<see cref="T:System.Threading.Tasks.Parallel" />是安全執行緒，且可能會從多個執行緒同時使用。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 這會提供兩個引數：  
  
-   <xref:System.Int32>表示反覆項目計數的值。  
  
-   A<xref:System.Threading.Tasks.ParallelLoopState>可用來提早脫離迴圈的執行個體。 <xref:System.Threading.Tasks.ParallelLoopState>編譯器所建立物件; 無法在使用者程式碼中執行個體化。  
  
 呼叫<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法會通知`for`之後目前的反覆項目沒有要執行的作業。 但目前所有的反覆項目將仍然有一個要執行，如果它們還沒有這麼做。  
  
 因此，呼叫<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>類似於使用符號內的作業傳統`for`迴圈的語言如 C# 中，但不是完美的替代： 例如，則之後目前的反覆項目絕對不會不保證執行。  
  
 如果目前不需要之前，請執行所有的反覆項目，使用<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法，而不是使用<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>。 呼叫<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>會通知`for`迴圈，它可能會放棄所有剩餘反覆項目，不論它們位之前或之後的目前反覆項目，因為所有所需的工作將已經完成。 不過，隨著使用<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>，不有哪些其他反覆項目將不會執行任何保證。  
  
 如果迴圈已提前結束，<xref:System.Threading.Tasks.ParallelLoopResult>傳回的結構將會包含迴圈的完成的相關資訊。  
  
 如果`fromInclusive`大於或等於`toExclusive`，方法會立即傳回而不執行任何反覆項目。  
  
   
  
## Examples  
 下列範例會以平行方式執行迴圈的最多 100 個反覆項目。 從 1 到 1000 毫秒之間的隨機間隔就會暫停每個反覆項目。 隨機產生的值會決定迴圈的反覆項目上<xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType>呼叫方法。 如輸出所範例所示，其索引大於任何反覆項目<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType>呼叫後面的屬性值開始<xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 因為迴圈的反覆項目仍可能同時執行的時機<xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType>呼叫方法，每個反覆項目會呼叫<xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType>屬性，以檢查是否已呼叫另一個反覆項目<xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType>方法。 屬性值是否`true`，在反覆項目值檢查<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType>屬性以及其是否大於目前的反覆項目的索引值，會立即傳回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 它隨附的反覆項目計數 (<xref:System.Int32>) 做為參數。  
  
 如果`fromInclusive`大於或等於`toExclusive`，方法會立即傳回而不執行任何反覆項目。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Threading.Tasks.Parallel.For%2A>值 100 的引動過程，會產生隨機位元組之委派的方法，並計算其總和。  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>使用 64 位元索引執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目，還可以監控和操作迴圈的狀態。</summary>
        <returns>
          <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> 結構，包含迴圈已完成部分的相關資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 這提供下列參數： 反覆項目計數 (<xref:System.Int64>)，和<xref:System.Threading.Tasks.ParallelLoopState>可用來提早脫離迴圈的執行個體。  
  
 呼叫<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法會通知`for`之後目前的反覆項目不必執行，但所有的反覆項目之前目前執行的作業。  
  
 因此，呼叫中斷，類似於使用符號內的作業傳統`for`迴圈的語言如 C# 中，但不是完美的替代： 例如，則無法保證該反覆項目之後目前絕對不會執行。  
  
 如果目前不需要之前，請執行所有的反覆項目，使用<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法，而不是使用<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>。 呼叫<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>會通知`for`迴圈，它可能會放棄所有剩餘反覆項目，不論它們位之前或之後的目前反覆項目，因為所有所需的工作將已經完成。 不過，隨著使用<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>，不有哪些其他反覆項目將不會執行任何保證。  
  
 如果迴圈已提前結束，<xref:System.Threading.Tasks.ParallelLoopResult>傳回的結構將會包含迴圈的完成的相關資訊。  
  
 如果`fromInclusive`大於或等於`toExclusive`，則方法會立即傳回而不執行任何反覆項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>使用 64 位元索引執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 它隨附的反覆項目計數 (<xref:System.Int64>) 做為參數。  
  
 如果`fromInclusive`大於或等於`toExclusive`，方法會立即傳回而不執行任何反覆項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 這提供下列參數： 反覆項目計數 (<xref:System.Int32>)，和<xref:System.Threading.Tasks.ParallelLoopState>可用來提早脫離迴圈的執行個體。  
  
 如果`fromInclusive`大於或等於`toExclusive`，方法會立即傳回而不執行任何反覆項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目，還可以設定迴圈選項。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 它隨附的反覆項目計數 (<xref:System.Int32>) 做為參數。  
  
 如果`fromInclusive`大於或等於`toExclusive`，則方法會立即傳回而不執行任何反覆項目。  
  
   
  
## Examples  
 下列範例示範如何取消平行迴圈：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>使用 64 位元索引執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 這提供下列參數： 反覆項目計數 (<xref:System.Int64>)，和<xref:System.Threading.Tasks.ParallelLoopState>可用來提早脫離迴圈的執行個體。  
  
 如果`fromInclusive`大於或等於`toExclusive`，方法會立即傳回而不執行任何反覆項目。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>方法使用<xref:System.Threading.Tasks.ParallelOptions>物件：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>使用 64 位元索引執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目，還可以設定迴圈選項。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 支援 64 位元索引。 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 它隨附的反覆項目計數 (<xref:System.Int64>) 做為參數。  
  
 如果`fromInclusive`大於或等於`toExclusive`，則方法會立即傳回而不執行任何反覆項目。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.Tasks.ParallelOptions>來指定自訂的工作排程器：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="localInit">函式委派，會針對每項工作傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每項工作的本機狀態執行最終動作。</param>
        <summary>使用執行緒區域資料執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 這提供下列參數： 反覆項目計數 (<xref:System.Int32>)、<xref:System.Threading.Tasks.ParallelLoopState>可用來提前結束，脫離迴圈的執行個體，且可能在相同執行緒執行的反覆項目之間共用某些本機狀態。  
  
 `localInit`叫用委派一次參與迴圈的執行，並傳回每個這些工作的初始本機狀態每項工作。 這些初始狀態會傳遞至第一個`body`上每個工作引動過程。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，每個工作上上次的主體引動過程會傳回傳遞至狀態值`localFinally`委派。 `localFinally`叫用委派一次每個工作，每個工作的本機狀態執行最終動作。 這個委派可能會同時叫用多個工作;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
 如果`fromInclusive`大於或等於`toExclusive`，則方法會立即傳回而不執行任何反覆項目。  
  
 如需使用這個方法的範例，請參閱 <<c0> [ 如何： 撰寫含有執行緒區域變數的 Parallel.For 迴圈](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 引數為 <see langword="null" />。  -或-  <paramref name="localFinally" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="localInit">函式委派，會針對每項工作傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每項工作的本機狀態執行最終動作。</param>
        <summary>使用 64 位元索引和執行緒區域資料執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 這提供下列參數： 反覆項目計數 (<xref:System.Int64>)、<xref:System.Threading.Tasks.ParallelLoopState>可用來提前結束，脫離迴圈的執行個體，且可能在相同工作執行的反覆項目之間共用某些本機狀態。  
  
 `localInit`叫用委派一次參與迴圈的執行，並傳回每個這些工作的初始本機狀態每項工作。 這些初始狀態會傳遞至第一個`body`上每個工作引動過程。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，每個工作上上次的主體引動過程會傳回傳遞至狀態值`localFinally`委派。 `localFinally`叫用委派一次每個工作，每個工作的本機狀態執行最終動作。 這個委派可能會同時叫用多個工作;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
 如果`fromInclusive`大於或等於`toExclusive`，則方法會立即傳回而不執行任何反覆項目。  
  
 如需使用這個方法的範例，請參閱 <<c0> [ 如何： 撰寫含有執行緒區域變數的 Parallel.For 迴圈](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 引數為 <see langword="null" />。  -或-  <paramref name="localFinally" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="localInit">函式委派，會針對每項工作傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每項工作的本機狀態執行最終動作。</param>
        <summary>使用執行緒區域資料執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 這提供下列參數： 反覆項目計數 (<xref:System.Int32>)、<xref:System.Threading.Tasks.ParallelLoopState>可用來提前結束，脫離迴圈的執行個體，且可能在相同工作執行的反覆項目之間共用某些本機狀態。  
  
 `localInit`叫用委派一次參與迴圈的執行，並傳回每個這些工作的初始本機狀態每項工作。 這些初始狀態會傳遞至第一個`body`上每個工作引動過程。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，每個工作上上次的主體引動過程會傳回傳遞至狀態值`localFinally`委派。 `localFinally`叫用委派一次每個工作，每個工作的本機狀態執行最終動作。 這個委派可能會同時叫用上多個執行緒;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
 如果`fromInclusive`大於或等於`toExclusive`，則方法會立即傳回而不執行任何反覆項目。  
  
   
  
## Examples  
 下列範例會使用執行緒區域變數，以計算許多長時間作業的結果的總和。 此範例中會限制為 4 的平行處理原則程度。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 引數為 <see langword="null" />。  -或-  <paramref name="localFinally" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="fromInclusive">起始索引 (含)。</param>
        <param name="toExclusive">結束索引 (不含)。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="localInit">函式委派，會針對每個執行緒傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每個執行緒的本機狀態執行最終動作。</param>
        <summary>使用 64 位元索引和執行緒區域資料執行 <see langword="for" /> (在 Visual Basic 中為 <see langword="For" />) 迴圈，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次反覆項目範圍中每個值 (`fromInclusive`， `toExclusive`)。 這提供下列參數： 反覆項目計數 (<xref:System.Int64>)、<xref:System.Threading.Tasks.ParallelLoopState>可用來提前結束，脫離迴圈的執行個體，且可能在相同執行緒執行的反覆項目之間共用某些本機狀態。  
  
 `localInit`叫用委派一次的每個執行緒都參與迴圈的執行，並傳回每個執行緒的初始本機狀態。 這些初始狀態會傳遞至第一個`body`引動過程上每個執行緒。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，在每個執行緒上的最後一個主體引動過程會傳回狀態的值傳遞至`localFinally`委派。 `localFinally`叫用委派一次每個執行緒上每個執行緒的本機狀態執行最終動作。 這個委派可能會同時叫用上多個執行緒;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
 如果`fromInclusive`大於或等於`toExclusive`，則方法會立即傳回而不執行任何反覆項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 引數為 <see langword="null" />。  -或-  <paramref name="localFinally" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each " />) 運算，其中可以平行執行反覆項目。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">中的項目型別<c>來源</c>。</typeparam>
        <param name="source">包含原始資料來源的可排序 Partitioner。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此多載的情況下，您要覆寫預設的資料分割配置。 例如，小型迴圈主體可能受益於資料分割的範圍。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法必須要有支援動態磁碟分割的自訂 partitioner。 如需詳細資訊，請參閱 < [PLINQ 和 TPL 的自訂 Partitioner](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)並[如何： 實作動態磁碟分割](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 可排序 Partitioner 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 屬性會傳回 <see langword="false" />。  -或-  來源可排序 Partitioner 中的 <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> 屬性傳回 <see langword="false" />。  -或-  來源可排序 Partitioner 中的任何方法都傳回 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">中的項目型別<c>來源</c>。</typeparam>
        <param name="source">包含原始資料來源的 Partitioner。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此多載的情況下，您要覆寫預設的資料分割配置。 例如，小型迴圈主體可能受益於資料分割的範圍。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法必須要有支援動態磁碟分割的自訂 partitioner。 如需詳細資訊，請參閱 < [PLINQ 和 TPL 的自訂 Partitioner](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)並[如何： 實作動態磁碟分割](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> Partitioner 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 屬性會傳回 <see langword="false" />。  -或-  <paramref name="source" /> Partitioner 中的方法傳回 <see langword="null" />。  -或-  <paramref name="source" /> Partitioner 中的 <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> 方法未傳回正確的分割數目。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">中的項目型別<c>來源</c>。</typeparam>
        <param name="source">包含原始資料來源的 Partitioner。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此多載的情況下，您要覆寫預設的資料分割配置。 例如，小型迴圈主體可能受益於資料分割的範圍。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法必須要有支援動態磁碟分割的自訂 partitioner。 如需詳細資訊，請參閱 < [PLINQ 和 TPL 的自訂 Partitioner](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)並[如何： 實作動態磁碟分割](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
   
  
## Examples  
 下列範例示範如何實作與搭配使用的範圍 partitioner 來得快<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> Partitioner 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 屬性會傳回 <see langword="false" />。  -或-  <paramref name="source" /> Partitioner 中的任何方法傳回 <see langword="null" /> 時，所擲回的例外狀況。  -或-  <paramref name="source" /> Partitioner 中的 <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> 方法未傳回正確的分割數目。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">來源中的資料類型。</typeparam>
        <param name="source">可列舉的資料來源。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>使用 64 位元索引在 <see cref="T:System.Collections.IEnumerable" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次中每個元素`source`可列舉。 這提供下列參數： 目前的項目，<xref:System.Threading.Tasks.ParallelLoopState>可用來提前結束，脫離迴圈的執行個體與目前項目的索引 (<xref:System.Int64>)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">來源中的資料類型。</typeparam>
        <param name="source">可列舉的資料來源。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>在 <see cref="T:System.Collections.IEnumerable" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次中每個元素`source`可列舉。 這提供下列參數： 目前的項目，和<xref:System.Threading.Tasks.ParallelLoopState>可用來提早脫離迴圈的執行個體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">來源中的資料類型。</typeparam>
        <param name="source">可列舉的資料來源。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>在 <see cref="T:System.Collections.IEnumerable" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次中每個元素`source`可列舉。 這是做為參數提供目前的項目。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29>方法來計算的母音和文字檔案中的非空格字元數。 在此情況下，<xref:System.Threading.Tasks.ParallelLoopResult>方法所傳回的值會被忽略。 請注意，由於作業可以平行執行，您必須確定，遞增的計數器變數是不可部分完成的作業，而且多個執行緒請勿嘗試同時存取計數器變數。 基於此目的，此範例會使用`lock`（在 C# 中) 的陳述式和`SyncLock`（在 Visual Basic) 陳述式。  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">中的項目型別<c>來源</c>。</typeparam>
        <param name="source">包含原始資料來源的可排序 Partitioner。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此多載的情況下，您要覆寫預設的資料分割配置。 例如，小型迴圈主體可能受益於資料分割的範圍。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法必須要有支援動態磁碟分割的自訂 partitioner。 如需詳細資訊，請參閱 < [PLINQ 和 TPL 的自訂 Partitioner](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)並[如何： 實作動態磁碟分割](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> 可排序 Partitioner 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 屬性會傳回 <see langword="false" />。  -或-  <paramref name="source" /> 可排序 Partitioner 中的 <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> 屬性傳回 <see langword="false" />。  -或-  <paramref name="source" /> 可排列 Partitioner 中的任何方法傳回 <see langword="null" /> 時，所擲回的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">中的項目型別<c>來源</c>。</typeparam>
        <param name="source">包含原始資料來源的 Partitioner。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此多載的情況下，您要覆寫預設的資料分割配置。 例如，小型迴圈主體可能受益於資料分割的範圍。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法必須要有支援動態磁碟分割的自訂 partitioner。 如需詳細資訊，請參閱 < [PLINQ 和 TPL 的自訂 Partitioner](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)並[如何： 實作動態磁碟分割](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> Partitioner 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 屬性會傳回 <see langword="false" />。  -或-  <paramref name="source" /> Partitioner 中的任何方法傳回 <see langword="null" /> 時，所擲回的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">中的項目型別<c>來源</c>。</typeparam>
        <param name="source">包含原始資料來源的 Partitioner。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目，還可以設定迴圈選項。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此多載的情況下，您要覆寫預設的資料分割配置。 例如，小型迴圈主體可能受益於資料分割的範圍。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法必須要有支援動態磁碟分割的自訂 partitioner。 如需詳細資訊，請參閱 < [PLINQ 和 TPL 的自訂 Partitioner](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)並[如何： 實作動態磁碟分割](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> Partitioner 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 屬性會傳回 <see langword="false" />。  -或-  <paramref name="source" /> Partitioner 中的任何方法傳回 <see langword="null" /> 時，所擲回的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">來源中的資料類型。</typeparam>
        <param name="source">可列舉的資料來源。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>使用 64 位元索引在 <see cref="T:System.Collections.IEnumerable" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次中每個元素`source`可列舉。 這提供下列參數： 目前的項目，<xref:System.Threading.Tasks.ParallelLoopState>可用來提前結束，脫離迴圈的執行個體與目前項目的索引 (<xref:System.Int64>)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">來源中的資料類型。</typeparam>
        <param name="source">可列舉的資料來源。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>在 <see cref="T:System.Collections.IEnumerable" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次中每個元素`source`可列舉。 這提供下列參數： 目前的項目，和<xref:System.Threading.Tasks.ParallelLoopState>可用來提早脫離迴圈的執行個體。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">來源中的資料類型。</typeparam>
        <param name="source">可列舉的資料來源。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <summary>在 <see cref="T:System.Collections.IEnumerable" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目，還可以設定迴圈選項。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次中每個元素`source`可列舉。 這是做為參數提供目前的項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">中的項目型別<c>來源</c>。</typeparam>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="source">包含原始資料來源的可排序 Partitioner。</param>
        <param name="localInit">函式委派，會針對每項工作傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每項工作的本機狀態執行最終動作。</param>
        <summary>使用執行緒區域資料在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此多載的情況下，您要覆寫預設的資料分割配置。 例如，小型迴圈主體可能受益於資料分割的範圍。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法必須要有支援動態磁碟分割的自訂 partitioner。 如需詳細資訊，請參閱 < [PLINQ 和 TPL 的自訂 Partitioner](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)並[如何： 實作動態磁碟分割](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 `localInit`叫用委派一次參與迴圈的執行，並傳回每個這些工作的初始本機狀態每項工作。 這些初始狀態會傳遞至第一個`body`上每個工作引動過程。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，每個工作上上次的主體引動過程會傳回傳遞至狀態值`localFinally`委派。 `localFinally`叫用委派一次每個工作，每個工作的本機狀態執行最終動作。 這個委派可能會同時叫用多個工作;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 引數為 <see langword="null" />。  -或-  <paramref name="localFinally" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />
          <see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 屬性會傳回 <see langword="false" />，或者 Partitioner 會傳回 <see langword="null" /> 分割。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">中的項目型別<c>來源</c>。</typeparam>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="source">包含原始資料來源的 Partitioner。</param>
        <param name="localInit">函式委派，會針對每項工作傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每項工作的本機狀態執行最終動作。</param>
        <summary>使用執行緒區域資料在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此多載的情況下，您要覆寫預設的資料分割配置。 例如，小型迴圈主體可能受益於資料分割的範圍。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法必須要有支援動態磁碟分割的自訂 partitioner。 如需詳細資訊，請參閱 < [PLINQ 和 TPL 的自訂 Partitioner](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)並[如何： 實作動態磁碟分割](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 `localInit`叫用委派一次的每個執行緒都參與迴圈的執行，並傳回每個這些工作的初始本機狀態。 這些初始狀態會傳遞至第一個`body`上每個工作引動過程。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，每個工作上上次的主體引動過程會傳回傳遞至狀態值`localFinally`委派。 `localFinally`叫用委派一次每個工作，每個工作的本機狀態執行最終動作。 這個委派可能會同時叫用多個工作;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 引數為 <see langword="null" />。  -或-  <paramref name="localFinally" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />
          <see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 屬性會傳回 <see langword="false" />，或者 Partitioner 會傳回 <see langword="null" /> 分割。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">來源中的資料類型。</typeparam>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="source">可列舉的資料來源。</param>
        <param name="localInit">函式委派，會針對每項工作傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每項工作的本機狀態執行最終動作。</param>
        <summary>使用執行緒區域資料在 <see cref="T:System.Collections.IEnumerable" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次中每個元素`source`可列舉。 這提供下列參數： 目前的項目，<xref:System.Threading.Tasks.ParallelLoopState>可用來提早脫離迴圈的執行個體]、 [目前項目的索引 (<xref:System.Int64>)，和一些可能會在執行的反覆項目之間共用的本機狀態在同一執行緒中。  
  
 `localInit`叫用委派一次參與迴圈的執行，並傳回每個這些工作的初始本機狀態每項工作。 這些初始狀態會傳遞至第一個`body`上每個工作引動過程。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，每個工作上上次的主體引動過程會傳回傳遞至狀態值`localFinally`委派。 `localFinally`叫用委派一次每個工作，每個工作的本機狀態執行最終動作。 這個委派可能會同時叫用多個工作;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 引數為 <see langword="null" />。  -或-  <paramref name="localFinally" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">來源中的資料類型。</typeparam>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="source">可列舉的資料來源。</param>
        <param name="localInit">函式委派，會針對每項工作傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每項工作的本機狀態執行最終動作。</param>
        <summary>使用執行緒區域資料在 <see cref="T:System.Collections.IEnumerable" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次中每個元素`source`可列舉。 這提供下列參數： 目前的項目，<xref:System.Threading.Tasks.ParallelLoopState>可用來提前結束，脫離迴圈的執行個體，且可能在相同執行緒執行的反覆項目之間共用某些本機狀態。  
  
 `localInit`叫用委派一次參與迴圈的執行，並傳回每個這些工作的初始本機狀態每項工作。 這些初始狀態會傳遞至第一個`body`上每個工作引動過程。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，每個工作上上次的主體引動過程會傳回傳遞至狀態值`localFinally`委派。 `localFinally`叫用委派一次每個執行緒上每個工作的本機狀態執行最終動作。 這個委派可能會同時叫用多個工作;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.Tasks.Parallel.ForEach%2A>與本機狀態的方法：  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 引數為 <see langword="null" />。  -或-  <paramref name="localFinally" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">中的項目型別<c>來源</c>。</typeparam>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="source">包含原始資料來源的可排序 Partitioner。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="localInit">函式委派，會針對每項工作傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每項工作的本機狀態執行最終動作。</param>
        <summary>使用 64 位元索引和執行緒區域資料在 <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此多載的情況下，您要覆寫預設的資料分割配置。 例如，小型迴圈主體可能受益於資料分割的範圍。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法必須要有支援動態磁碟分割的自訂 partitioner。 如需詳細資訊，請參閱 < [PLINQ 和 TPL 的自訂 Partitioner](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)並[如何： 實作動態磁碟分割](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 `localInit`叫用委派一次參與迴圈的執行，並傳回每個這些工作的初始本機狀態每項工作。 這些初始狀態會傳遞至第一個`body`上每個工作引動過程。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，在每個執行緒上的最後一個主體引動過程會傳回狀態的值傳遞至`localFinally`委派。 `localFinally`叫用委派一次每個工作，每個工作的本機狀態執行最終動作。 這個委派可能會同時叫用多個工作;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 或 <paramref name="localFinally" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />
          <see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 屬性會傳回 <see langword="false" />，或者 Partitioner 會傳回 <see langword="null" /> 分割。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">中的項目型別<c>來源</c>。</typeparam>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="source">包含原始資料來源的 Partitioner。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="localInit">函式委派，會針對每項工作傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每項工作的本機狀態執行最終動作。</param>
        <summary>使用執行緒區域資料在 <see cref="T:System.Collections.Concurrent.Partitioner" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此多載的情況下，您要覆寫預設的資料分割配置。 例如，小型迴圈主體可能受益於資料分割的範圍。 <xref:System.Threading.Tasks.Parallel.ForEach%2A>方法必須要有支援動態磁碟分割的自訂 partitioner。 這個多載可供使用小型迴圈主體可能受益靜態定界分割案例。 Partitioner 必須支援動態分割區。  如需詳細資訊，請參閱 < [PLINQ 和 TPL 的自訂 Partitioner](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)並[如何： 實作動態磁碟分割](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。  
  
 `localInit`叫用委派一次參與迴圈的執行，並傳回每個這些工作的初始本機狀態每項工作。 這些初始狀態會傳遞至第一個`body`上每個工作引動過程。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，每個工作上上次的主體引動過程會傳回傳遞至狀態值`localFinally`委派。 `localFinally`叫用委派一次每個工作，每個工作的本機狀態執行最終動作。 這個委派可能會同時叫用多個工作;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 引數為 <see langword="null" />。  -或-  <paramref name="localFinally" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" />
          <see cref="T:System.Collections.Concurrent.Partitioner" /> 中的 <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> 屬性會傳回 <see langword="false" />，或者 Partitioner 會傳回 <see langword="null" /> 分割。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">來源中的資料類型。</typeparam>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="source">可列舉的資料來源。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="localInit">函式委派，會針對每項工作傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每項工作的本機狀態執行最終動作。</param>
        <summary>使用執行緒區域資料和 64 位元索引在 <see cref="T:System.Collections.IEnumerable" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次中每個元素`source`可列舉。 這提供下列參數： 目前的項目，<xref:System.Threading.Tasks.ParallelLoopState>可用來提早脫離迴圈的執行個體]、 [目前項目的索引 (<xref:System.Int64>)，和一些可能會在執行的反覆項目之間共用的本機狀態在同一執行緒中。  
  
 `localInit`叫用委派一次參與迴圈的執行，並傳回每個這些工作的初始本機狀態每項工作。 這些初始狀態會傳遞至第一個`body`上每個工作引動過程。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，每個工作上上次的主體引動過程會傳回傳遞至狀態值`localFinally`委派。 `localFinally`叫用委派一次每個執行緒上每個工作的本機狀態執行最終動作。 這個委派可能會同時叫用多個工作;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 引數為 <see langword="null" />。  -或-  <paramref name="localFinally" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">來源中的資料類型。</typeparam>
        <typeparam name="TLocal">執行緒區域資料的類型。</typeparam>
        <param name="source">可列舉的資料來源。</param>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="localInit">函式委派，會針對每項工作傳回本機資料的初始狀態。</param>
        <param name="body">每個反覆項目都會叫用一次的委派。</param>
        <param name="localFinally">委派，會針對每項工作的本機狀態執行最終動作。</param>
        <summary>使用執行緒區域資料在 <see cref="T:System.Collections.IEnumerable" /> 上執行 <see langword="foreach" /> (在 Visual Basic 中為 <see langword="For Each" />) 運算，其中可以平行執行反覆項目、可以設定迴圈選項，還可以監控和操作迴圈的狀態。</summary>
        <returns>包含迴圈已完成部分之相關資訊的的結構。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body`叫用委派一次中每個元素`source`可列舉。 這提供下列參數： 目前的項目，<xref:System.Threading.Tasks.ParallelLoopState>可用來提前結束，脫離迴圈的執行個體，且可能在相同執行緒執行的反覆項目之間共用某些本機狀態。  
  
 `localInit`叫用委派一次參與迴圈的執行，並傳回每個這些工作的初始本機狀態每項工作。 這些初始狀態會傳遞至第一個`body`上每個工作引動過程。 然後，每個後續的內文引動過程傳回可能已修改的狀態值傳遞至下一個主體引動過程。 最後，每個工作上上次的主體引動過程會傳回傳遞至狀態值`localFinally`委派。 `localFinally`叫用委派一次每個執行緒上每個工作的本機狀態執行最終動作。 這個委派可能會同時叫用多個工作;因此，您必須同步處理任何共用變數的存取權。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法可能會使用更多的工作，比執行緒存留時間內執行，為現有的工作完成，並由新的工作所取代。 這可讓基礎<xref:System.Threading.Tasks.TaskScheduler>物件有機會新增、 變更或移除服務迴圈的執行緒。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。  -或-  <paramref name="body" /> 引數為 <see langword="null" />。  -或-  <paramref name="localInit" /> 引數為 <see langword="null" />。  -或-  <paramref name="localFinally" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 引數中的 <see cref="T:System.Threading.CancellationToken" /> 已取消。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
        <exception cref="T:System.AggregateException">在所有執行緒擲回包含所有個別例外狀況的例外狀況。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>執行每個提供的動作 (可能會平行執行)。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">要執行的 <see cref="T:System.Action" /> 陣列。</param>
        <summary>執行每個提供的動作 (可能會平行執行)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可用來平行執行一組作業，有可能。  
  
 不保證會執行作業，或它們是否以平行方式執行的順序。 這個方法不會傳回每個提供的作業完成之前，不論是否完成發生一般的或異常終止。  
  
 如需詳細資訊，請參閱[如何：使用 Parallel.Invoke 來執行平行作業](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)。  
  
   
  
## Examples  
 此範例示範如何使用<xref:System.Threading.Tasks.Parallel.Invoke%2A>與其他的方法、 匿名的委派和 lambda 運算式的方法。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="actions" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">當 <paramref name="actions" /> 陣列中的任何動作擲回例外狀況時，所擲回的例外狀況。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="actions" /> 陣列包含 <see langword="null" /> 項目。</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">物件，設定這個作業的行為。</param>
        <param name="actions">要執行的動作陣列。</param>
        <summary>除非使用者取消作業，否則執行每個提供的動作 (可能會平行執行)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法可用來平行執行一組作業，有可能。 取消語彙基元傳遞入<xref:System.Threading.Tasks.ParallelOptions>結構可讓呼叫端若要取消整個作業。 如需詳細資訊，請參閱[受控執行緒中的取消作業](~/docs/standard/threading/cancellation-in-managed-threads.md)。  
  
 不保證會執行作業，或它們是否以平行方式執行的順序。 這個方法不會傳回每個提供的作業完成之前，不論是否完成發生一般的或異常終止。  
  
 如需詳細資訊，請參閱[如何：使用 Parallel.Invoke 來執行平行作業](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationToken" /> 已設定。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="actions" /> 引數為 <see langword="null" />。  -或-  <paramref name="parallelOptions" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">當 <paramref name="actions" /> 陣列中的任何動作擲回例外狀況時，所擲回的例外狀況。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="actions" /> 陣列包含 <see langword="null" /> 項目。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置與 <paramref name="parallelOptions" /> 中的 <see cref="T:System.Threading.CancellationTokenSource" /> 相關聯的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
  </Members>
</Type>