<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ddd94061f594e353cba8674c76ffcb77a643ddb1" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="05771-101">表示物件，這個物件會處理將工作排入至執行緒上的低階工作。</span>
      <span class="sxs-lookup">
        <span data-stu-id="05771-101">Represents an object that handles the low-level work of queuing tasks onto threads.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-102">執行個體<xref:System.Threading.Tasks.TaskScheduler>類別代表工作排程器。</span><span class="sxs-lookup"><span data-stu-id="05771-102">An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler.</span></span> <span data-ttu-id="05771-103">工作排程器可確保最終會執行工作 (Task) 的工作 (Work)。</span><span class="sxs-lookup"><span data-stu-id="05771-103">A task scheduler ensures that the work of a task is eventually executed.</span></span>  
  
 <span data-ttu-id="05771-104">預設工作排程器是以 .NET Framework 4 執行緒集區為基礎，其可提供工作竊取 (以達到平衡負載)、執行緒插入/停用 (以達到最大輸送量)，以及整體良好效能。</span><span class="sxs-lookup"><span data-stu-id="05771-104">The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</span></span> <span data-ttu-id="05771-105">這應該足以應付大多數的情況。</span><span class="sxs-lookup"><span data-stu-id="05771-105">It should be sufficient for most scenarios.</span></span>  
  
 <span data-ttu-id="05771-106"><xref:System.Threading.Tasks.TaskScheduler>類別也可做為所有可自訂的排程邏輯的擴充點。</span><span class="sxs-lookup"><span data-stu-id="05771-106">The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.</span></span>  <span data-ttu-id="05771-107">這包括機制，例如如何排程工作執行，以及如何排程的工作應該會公開給偵錯工具。</span><span class="sxs-lookup"><span data-stu-id="05771-107">This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</span></span> <span data-ttu-id="05771-108">如果您需要特殊功能，您可以建立自訂排程器，並啟用針對特定工作或查詢。</span><span class="sxs-lookup"><span data-stu-id="05771-108">If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</span></span>  
  
 <span data-ttu-id="05771-109">本主題內容：</span><span class="sxs-lookup"><span data-stu-id="05771-109">In this topic:</span></span>  
[<span data-ttu-id="05771-110">預設工作排程器和執行緒集區</span><span class="sxs-lookup"><span data-stu-id="05771-110">The default task scheduler and the thread pool</span></span>](#Default)  
 [<span data-ttu-id="05771-111">全域佇列與本機佇列</span><span class="sxs-lookup"><span data-stu-id="05771-111">The global queue vs. local queues</span></span>](#Queues)  
 [<span data-ttu-id="05771-112">工作竊取</span><span class="sxs-lookup"><span data-stu-id="05771-112">Work stealing</span></span>](#Stealing)  
 [<span data-ttu-id="05771-113">長時間執行的工作</span><span class="sxs-lookup"><span data-stu-id="05771-113">Long-running tasks</span></span>](#LongRunning)  
 [<span data-ttu-id="05771-114">工作內嵌</span><span class="sxs-lookup"><span data-stu-id="05771-114">Task inlining</span></span>](#Inlining)  
[<span data-ttu-id="05771-115">指定同步處理內容</span><span class="sxs-lookup"><span data-stu-id="05771-115">Specifying a synchronization context</span></span>](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a><span data-ttu-id="05771-116">預設工作排程器和執行緒集區</span><span class="sxs-lookup"><span data-stu-id="05771-116">The default task scheduler and the thread pool</span></span>  
 <span data-ttu-id="05771-117">工作平行程式庫和 PLINQ 的預設排程器會使用.NET Framework 執行緒集區，由<xref:System.Threading.ThreadPool>類別，以佇列並執行工作。</span><span class="sxs-lookup"><span data-stu-id="05771-117">The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work.</span></span> <span data-ttu-id="05771-118">執行緒集區會使用所提供的資訊<xref:System.Threading.Tasks.Task>有效率地支援細部平行處理原則 （存留時間短暫的工作單位），平行工作和查詢通常所代表的類型。</span><span class="sxs-lookup"><span data-stu-id="05771-118">The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</span></span>  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a><span data-ttu-id="05771-119">全域佇列與本機佇列</span><span class="sxs-lookup"><span data-stu-id="05771-119">The global queue vs. local queues</span></span>  
 <span data-ttu-id="05771-120">執行緒集區會維護全域 FIFO （先進先出） 工作在每個應用程式定義域中為執行緒的佇列。</span><span class="sxs-lookup"><span data-stu-id="05771-120">The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</span></span> <span data-ttu-id="05771-121">每當程式呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType>(或<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) 方法，這個方法的工作是放入這個共用佇列和最終取消排入佇列到下一個可用的執行緒。</span><span class="sxs-lookup"><span data-stu-id="05771-121">Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</span></span> <span data-ttu-id="05771-122">從.NET Framework 4 開始，此佇列已改良為使用無鎖定演算法類似<xref:System.Collections.Concurrent.ConcurrentQueue%601>類別。</span><span class="sxs-lookup"><span data-stu-id="05771-122">Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class.</span></span> <span data-ttu-id="05771-123">藉由使用這種無鎖定實作，執行緒集區會花較少的時間，當它放入或佇列工作項目。</span><span class="sxs-lookup"><span data-stu-id="05771-123">By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</span></span> <span data-ttu-id="05771-124">這項效能優點可供使用執行緒集區的所有程式。</span><span class="sxs-lookup"><span data-stu-id="05771-124">This performance benefit is available to all programs that use the thread pool.</span></span>  
  
 <span data-ttu-id="05771-125">如同任何其他的工作 (Work) 項目，最上層工作 (Task) (也就是不是在其他工作 (Task) 的內容中建立的工作 (Task)) 會放入全域佇列中。</span><span class="sxs-lookup"><span data-stu-id="05771-125">Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</span></span> <span data-ttu-id="05771-126">不過，巢狀工作或子工作 (也就是在其他工作的內容中建立的工作) 的處理方式則相當不同。</span><span class="sxs-lookup"><span data-stu-id="05771-126">However, nested or child tasks, which are created in the context of another task, are handled quite differently.</span></span> <span data-ttu-id="05771-127">子工作或巢狀工作會放入執行父工作的執行緒專屬的本機佇列中。</span><span class="sxs-lookup"><span data-stu-id="05771-127">A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</span></span> <span data-ttu-id="05771-128">父工作可以是最上層工作，也可以是其他工作的子工作。</span><span class="sxs-lookup"><span data-stu-id="05771-128">The parent task may be a top-level task or it also may be the child of another task.</span></span> <span data-ttu-id="05771-129">這個執行緒在準備好要處理更多工作時，會先查看本機佇列。</span><span class="sxs-lookup"><span data-stu-id="05771-129">When this thread is ready for more work, it first looks in the local queue.</span></span> <span data-ttu-id="05771-130">如果本機佇列中有待處理的工作項目，則可以快速存取這些工作項目。</span><span class="sxs-lookup"><span data-stu-id="05771-130">If work items are waiting there, they can be accessed quickly.</span></span> <span data-ttu-id="05771-131">後進先出順序 (LIFO) 保留快取位置並減少爭用情形會存取本機佇列。</span><span class="sxs-lookup"><span data-stu-id="05771-131">The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</span></span> <span data-ttu-id="05771-132">如需子工作和巢狀的工作的詳細資訊，請參閱[附加與中斷連結子工作](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="05771-132">For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
 <span data-ttu-id="05771-133">使用本機佇列不僅可減少在全域佇列，不足的壓力，也會利用資料位置。</span><span class="sxs-lookup"><span data-stu-id="05771-133">The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</span></span> <span data-ttu-id="05771-134">工作項目，在本機佇列經常參考的實體上彼此靠近會在記憶體中資料結構。</span><span class="sxs-lookup"><span data-stu-id="05771-134">Work items in the local queue frequently reference data structures that are physically near one another in memory.</span></span> <span data-ttu-id="05771-135">在這些情況下，資料便已經快取中之後第一項工作已執行，而可供快速存取。</span><span class="sxs-lookup"><span data-stu-id="05771-135">In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</span></span> <span data-ttu-id="05771-136">同時[平行 LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md)和<xref:System.Threading.Tasks.Parallel>類別，使用巢狀工作和子工作，並且利用本機工作佇列達到處理速度明顯加快。</span><span class="sxs-lookup"><span data-stu-id="05771-136">Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</span></span>  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a><span data-ttu-id="05771-137">工作竊取</span><span class="sxs-lookup"><span data-stu-id="05771-137">Work stealing</span></span>  
 <span data-ttu-id="05771-138">從.NET Framework 4 開始，執行緒集區也提供了工作竊取演算法，協助確保沒有任何執行緒會有某些閒置而其他人仍有工作在佇列。</span><span class="sxs-lookup"><span data-stu-id="05771-138">Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</span></span> <span data-ttu-id="05771-139">執行緒集區的執行緒在準備好要處理更多工作時，會先查看自己本機佇列的開頭，接著查看全域佇列，然後再查看其他執行緒的本機佇列。</span><span class="sxs-lookup"><span data-stu-id="05771-139">When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</span></span> <span data-ttu-id="05771-140">如果在其他執行緒的本機佇列中發現了工作項目，它會先套用啟發學習法，確定可有效率地執行工作。</span><span class="sxs-lookup"><span data-stu-id="05771-140">If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</span></span> <span data-ttu-id="05771-141">如果可以它將佇列佇列工作項目 （以 FIFO 順序） 與 tail。</span><span class="sxs-lookup"><span data-stu-id="05771-141">If it can, it de-queues the work item from the tail (in FIFO order).</span></span> <span data-ttu-id="05771-142">這樣可以減少本機佇列爭用的情形發生，並保留資料位置。</span><span class="sxs-lookup"><span data-stu-id="05771-142">This reduces contention on each local queue and preserves data locality.</span></span> <span data-ttu-id="05771-143">此架構有助於執行緒集區達到負載平衡工作比舊版更有效率。</span><span class="sxs-lookup"><span data-stu-id="05771-143">This architecture helps the  thread pool load-balance work more efficiently than past versions did.</span></span>  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a><span data-ttu-id="05771-144">長時間執行的工作</span><span class="sxs-lookup"><span data-stu-id="05771-144">Long-running tasks</span></span>  
 <span data-ttu-id="05771-145">您可以明確防止將工作放入本機佇列中。</span><span class="sxs-lookup"><span data-stu-id="05771-145">You may want to explicitly prevent a task from being put on a local queue.</span></span> <span data-ttu-id="05771-146">例如，您可能知道某個工作項目會執行相當長的一段時間，而可能阻礙本機佇列上所有其他工作項目的進度。</span><span class="sxs-lookup"><span data-stu-id="05771-146">For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</span></span> <span data-ttu-id="05771-147">在這種情況下，您可以指定 <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> 選項，提示排程器可能需要再加入一個執行緒來執行工作，才不會阻礙本機佇列上其他執行緒或工作項目的進度。</span><span class="sxs-lookup"><span data-stu-id="05771-147">In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</span></span> <span data-ttu-id="05771-148">使用此選項您執行緒集區完全避免，包括全域和本機佇列。</span><span class="sxs-lookup"><span data-stu-id="05771-148">By using this option you avoid the thread pool completely, including the global and local queues.</span></span>  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a><span data-ttu-id="05771-149">工作內嵌</span><span class="sxs-lookup"><span data-stu-id="05771-149">Task inlining</span></span>  
 <span data-ttu-id="05771-150">在某些情況下時<xref:System.Threading.Tasks.Task>等候是 on 時，它可能會執行以同步方式執行等候作業的執行緒上。</span><span class="sxs-lookup"><span data-stu-id="05771-150">In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</span></span> <span data-ttu-id="05771-151">這可以提升效能，這樣就不需要其他的執行緒，並改為使用現有的執行緒，否則會封鎖。</span><span class="sxs-lookup"><span data-stu-id="05771-151">This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</span></span> <span data-ttu-id="05771-152">若要避免回到錯誤，只會執行內嵌工作在相關執行緒的本機佇列中發現等候目標時。</span><span class="sxs-lookup"><span data-stu-id="05771-152">To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</span></span>  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a><span data-ttu-id="05771-153">指定同步處理內容</span><span class="sxs-lookup"><span data-stu-id="05771-153">Specifying a synchronization context</span></span>  
 <span data-ttu-id="05771-154">您可以使用 <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> 方法，指定應該將工作排定在特定執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="05771-154">You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method to specify that a task should be scheduled to run on a particular thread.</span></span> <span data-ttu-id="05771-155">在 Windows Form 和 Windows Presentation Foundation 等架構中，只有在當初建立使用者介面物件的執行緒上執行的程式碼能夠存取該 UI 物件，因此很適合使用這個方法。</span><span class="sxs-lookup"><span data-stu-id="05771-155">This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</span></span>  
  
 <span data-ttu-id="05771-156">下列範例會使用<xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType>來排程工作，以建立使用者介面 (UI) 控制項的相同執行緒上的 Windows Presentation Foundation (WPF) 應用程式中的方法。</span><span class="sxs-lookup"><span data-stu-id="05771-156">The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</span></span>   <span data-ttu-id="05771-157">此範例會建立從指定的目錄中隨機選取的映像的馬賽克。</span><span class="sxs-lookup"><span data-stu-id="05771-157">The example creates a mosaic of images that are randomly selected from a specified directory.</span></span> <span data-ttu-id="05771-158">WPF 物件可用來載入及調整影像的大小。</span><span class="sxs-lookup"><span data-stu-id="05771-158">The WPF objects are used to load and resize the images.</span></span> <span data-ttu-id="05771-159">若要使用的工作接著會傳遞未經處理的像素為單位<xref:System.Threading.Tasks.Parallel.For%2A>在大型的單一位元組陣列中寫入的像素資料的迴圈。</span><span class="sxs-lookup"><span data-stu-id="05771-159">The raw pixels are then passed to a task that uses a <xref:System.Threading.Tasks.Parallel.For%2A> loop to write the pixel data into a large single-byte array.</span></span> <span data-ttu-id="05771-160">因為沒有兩個磚會佔據相同的陣列項目，不就需要任何同步處理。</span><span class="sxs-lookup"><span data-stu-id="05771-160">No synchronization is required because no two tiles occupy the same array elements.</span></span> <span data-ttu-id="05771-161">也可以將圖格寫入任何順序，因為它們的位置計算獨立於任何其他磚。</span><span class="sxs-lookup"><span data-stu-id="05771-161">The tiles can also be written in any order because their position is calculated independently of any other tile.</span></span> <span data-ttu-id="05771-162">大型陣列接著傳遞給像素資料載入影像控制項的位置，在 UI 執行緒執行的工作。</span><span class="sxs-lookup"><span data-stu-id="05771-162">The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</span></span>  
  
 <span data-ttu-id="05771-163">這個範例會將在 UI 執行緒外的資料移動、 加以修改使用平行迴圈和<xref:System.Threading.Tasks.Task>物件，然後再將其傳遞回 UI 執行緒執行的工作。</span><span class="sxs-lookup"><span data-stu-id="05771-163">The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread.</span></span> <span data-ttu-id="05771-164">這種方法時，您必須使用工作平行程式庫來執行作業，不支援的 WPF 應用程式開發介面，或者不夠快。</span><span class="sxs-lookup"><span data-stu-id="05771-164">This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</span></span> <span data-ttu-id="05771-165">若要建立映像馬賽克 WPF 中的另一種方式是使用<xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType>控制，並將影像加入至它。</span><span class="sxs-lookup"><span data-stu-id="05771-165">Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> control and add images to it.</span></span> <span data-ttu-id="05771-166"><xref:System.Windows.Controls.WrapPanel>處理定位圖格的工作。</span><span class="sxs-lookup"><span data-stu-id="05771-166">The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles.</span></span> <span data-ttu-id="05771-167">不過，這項工作只能在 UI 執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="05771-167">However, this work can only be performed on the UI thread.</span></span>  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 <span data-ttu-id="05771-168">若要建立範例，在 Visual Studio 中建立 WPF 應用程式專案，並將它指派您選擇的名稱。</span><span class="sxs-lookup"><span data-stu-id="05771-168">To create the example, create a WPF application project in Visual Studio and assign it a name of your choice.</span></span> <span data-ttu-id="05771-169">然後執行下列作業：</span><span class="sxs-lookup"><span data-stu-id="05771-169">Then do the following:</span></span>  
  
1.  <span data-ttu-id="05771-170">在 [設計] 檢視中，拖曳<xref:System.Windows.Controls.Image>控制項從**工具箱**至設計介面。</span><span class="sxs-lookup"><span data-stu-id="05771-170">In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** to the design surface.</span></span> <span data-ttu-id="05771-171">在 [XAML] 檢視中，指定水平對齊方式，為 「 左 」。</span><span class="sxs-lookup"><span data-stu-id="05771-171">In XAML view, specify the horizontal alignment as "Left."</span></span> <span data-ttu-id="05771-172">因為控制項在執行階段動態調整大小並不重要。</span><span class="sxs-lookup"><span data-stu-id="05771-172">The size does not matter because the control is be dynamically resized at run time.</span></span> <span data-ttu-id="05771-173">接受預設名稱，「 影像 」。</span><span class="sxs-lookup"><span data-stu-id="05771-173">Accept the default name, "image".</span></span>  
  
2.  <span data-ttu-id="05771-174">拖曳<xref:System.Windows.Controls.Button>控制項從**工具箱**到左的應用程式視窗的下方。</span><span class="sxs-lookup"><span data-stu-id="05771-174">Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window.</span></span> <span data-ttu-id="05771-175">按兩下這個按鈕，新增<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="05771-175">Double-click the button to add a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event handler.</span></span> <span data-ttu-id="05771-176">在 [XAML] 檢視中，指定<xref:System.Windows.Controls.ContentControl.Content%2A>按鈕為 「 讓馬賽克 」，並指定其為 「 左 」 的水平對齊方式的屬性。</span><span class="sxs-lookup"><span data-stu-id="05771-176">In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as "Make a Mosaic" and specify its horizontal alignment as "Left".</span></span> <span data-ttu-id="05771-177">接受預設名稱，"button"。</span><span class="sxs-lookup"><span data-stu-id="05771-177">Accept the default name, "button".</span></span>  
  
3.  <span data-ttu-id="05771-178">這個範例中的程式碼取代 MainWindow.xaml.cs 或 MainWindow.xaml.vb 檔案的整個內容。</span><span class="sxs-lookup"><span data-stu-id="05771-178">Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</span></span> <span data-ttu-id="05771-179">請確定工作區的名稱符合專案名稱。</span><span class="sxs-lookup"><span data-stu-id="05771-179">Make sure that the name of the workspace matches the project name.</span></span>  
  
4.  <span data-ttu-id="05771-180">此範例會從名為 C:\Users\Public\Pictures\Sample 圖片的目錄中讀取 JPEG 影像\\。</span><span class="sxs-lookup"><span data-stu-id="05771-180">The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures\\.</span></span> <span data-ttu-id="05771-181">建立目錄和置於一些映像，或變更來參照其他包含映像的目錄路徑。</span><span class="sxs-lookup"><span data-stu-id="05771-181">Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</span></span>  
  
 <span data-ttu-id="05771-182">這個範例有一些限制。</span><span class="sxs-lookup"><span data-stu-id="05771-182">This example has some limitations.</span></span> <span data-ttu-id="05771-183">例如，支援只有 32-位元-每個像素映像。其他格式的映像已損毀的<xref:System.Windows.Media.Imaging.BitmapImage>調整大小作業期間的物件。</span><span class="sxs-lookup"><span data-stu-id="05771-183">For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation.</span></span> <span data-ttu-id="05771-184">此外，來源映像都必須大於並排顯示大小。</span><span class="sxs-lookup"><span data-stu-id="05771-184">Also, the source images must all be larger than the tile size.</span></span> <span data-ttu-id="05771-185">您可以將進一步的練習中，新增功能，以處理多個像素格式和檔案大小。</span><span class="sxs-lookup"><span data-stu-id="05771-185">As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="05771-186">下列範例取自[使用.NET Framework 4 進行平行程式設計的範例](http://go.microsoft.com/fwlink/?LinkID=165717)MSDN Code Gallery 網站上。</span><span class="sxs-lookup"><span data-stu-id="05771-186">The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.</span></span>  <span data-ttu-id="05771-187">它會建立自訂工作排程器，限制應用程式所使用的執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="05771-187">It creates a custom task scheduler that limits the number of threads used by the app.</span></span> <span data-ttu-id="05771-188">然後會啟動兩組工作，並會顯示有關工作和執行工作的執行緒資訊。</span><span class="sxs-lookup"><span data-stu-id="05771-188">It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</span></span>  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 <span data-ttu-id="05771-189">此外，數個範例工作排程器上可用的程式碼庫：[使用.NET Framework 4 進行平行程式設計的範例](http://go.microsoft.com/fwlink/?LinkID=165717)。</span><span class="sxs-lookup"><span data-stu-id="05771-189">In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="05771-190">所有抽象成員<see cref="T:System.Threading.Tasks.TaskScheduler" />型別是安全執行緒，且可能會同時使用從多個執行緒。</span>
      <span class="sxs-lookup">
        <span data-stu-id="05771-190">All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe and may be used from multiple threads concurrently.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="05771-191">初始化 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-191">Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="05771-192">取得與目前執行之工作相關聯的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-192">Gets the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="05771-193">傳回與目前執行之工作相關聯的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-193">Returns the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-194">不會從呼叫內工作，當<xref:System.Threading.Tasks.TaskScheduler.Current%2A>會傳回<xref:System.Threading.Tasks.TaskScheduler.Default%2A>排程器。</span><span class="sxs-lookup"><span data-stu-id="05771-194">When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.</span></span>  
  
 <span data-ttu-id="05771-195">如需詳細資訊，請參閱<xref:System.Threading.Tasks.TaskScheduler>。</span><span class="sxs-lookup"><span data-stu-id="05771-195">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="05771-196">取得 .NET Framework 提供的預設 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-196">Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance that is provided by the .NET Framework.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="05771-197">傳回預設 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-197">Returns the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-198">如需詳細資訊，請參閱[工作排程器](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。</span><span class="sxs-lookup"><span data-stu-id="05771-198">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="05771-199">建立與目前 <see cref="T:System.Threading.SynchronizationContext" />關聯的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-199">Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="05771-200">與目前的 <see cref="T:System.Threading.SynchronizationContext" /> 關聯的 <see cref="T:System.Threading.Tasks.TaskScheduler" />，由 <see cref="P:System.Threading.SynchronizationContext.Current" /> 決定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-200">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />, as determined by <see cref="P:System.Threading.SynchronizationContext.Current" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-201">所有<xref:System.Threading.Tasks.Task>佇列所傳回的執行個體將會執行排程器，透過呼叫<xref:System.Threading.SynchronizationContext.Post%2A>該內容上的方法。</span><span class="sxs-lookup"><span data-stu-id="05771-201">All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.</span></span>  
  
 <span data-ttu-id="05771-202">如需詳細資訊，請參閱[工作排程器](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。</span><span class="sxs-lookup"><span data-stu-id="05771-202">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="05771-203">目前的 SynchronizationContext 不可當做 TaskScheduler 使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-203">The current SynchronizationContext may not be used as a TaskScheduler.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="05771-204">僅限偵錯工具支援，針對目前已排入至排程器中等候執行的 <see cref="T:System.Threading.Tasks.Task" /> 執行個體，產生可列舉項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-204">For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" /> instances currently queued to the scheduler waiting to be executed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="05771-205">可列舉項目，允許偵錯工具在目前已排入至這個排程器中的工作之間周遊。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-205">An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-206">類別衍生自<xref:System.Threading.Tasks.TaskScheduler>會實作這個方法，以支援與偵錯工具整合。</span><span class="sxs-lookup"><span data-stu-id="05771-206">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers.</span></span> <span data-ttu-id="05771-207">這個方法就只會叫用.NET Framework 偵錯工具要求資料的存取權時。</span><span class="sxs-lookup"><span data-stu-id="05771-207">This method will only be invoked by the .NET Framework when the debugger requests access to the data.</span></span> <span data-ttu-id="05771-208">將偵錯公用程式來存取工作可周遊的可列舉傳回目前已排入這個排程器，啟用偵錯工具提供這項資訊的使用者介面中的表示法。</span><span class="sxs-lookup"><span data-stu-id="05771-208">The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</span></span>  
  
 <span data-ttu-id="05771-209">請務必注意，呼叫這個方法時，所有其他的執行緒程序中將會凍結。</span><span class="sxs-lookup"><span data-stu-id="05771-209">It is important to note that, when this method is called, all other threads in the process will be frozen.</span></span> <span data-ttu-id="05771-210">因此，務必避免與其他可能會導致封鎖的執行緒同步處理。</span><span class="sxs-lookup"><span data-stu-id="05771-210">Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</span></span> <span data-ttu-id="05771-211">如果同步處理是必要的而且您無法取得鎖定，此方法中的，然後您應該擲回例外狀況，讓偵錯工具不會不會停止回應。</span><span class="sxs-lookup"><span data-stu-id="05771-211">If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.</span></span> <span data-ttu-id="05771-212">下列範例顯示 C# 中的一個可能的方法：</span><span class="sxs-lookup"><span data-stu-id="05771-212">The following example shows one possible approach in C#:</span></span>  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 <span data-ttu-id="05771-213">此外，這個方法，並傳回列舉必須修改任何全域可見狀態。</span><span class="sxs-lookup"><span data-stu-id="05771-213">Additionally, this method and the enumerable returned must not modify any globally visible state.</span></span>  
  
 <span data-ttu-id="05771-214">傳回可列舉應該永遠不會是 null。</span><span class="sxs-lookup"><span data-stu-id="05771-214">The returned enumerable should never be null.</span></span> <span data-ttu-id="05771-215">如果目前沒有任何佇列的工作，應該改為傳回空列舉。</span><span class="sxs-lookup"><span data-stu-id="05771-215">If there are currently no queued tasks, an empty enumerable should be returned instead.</span></span>  
  
 <span data-ttu-id="05771-216">開發人員實作自訂的偵錯工具不應該直接呼叫這個方法，但是應該使用內部包裝函式方法`GetScheduledTasksForDebugger`改用： `internal Task[] GetScheduledTasksForDebugger()`。</span><span class="sxs-lookup"><span data-stu-id="05771-216">Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`.</span></span> <span data-ttu-id="05771-217">這個包裝函式方法會傳回工作，而不是可列舉的陣列。</span><span class="sxs-lookup"><span data-stu-id="05771-217">This wrapper method returns an array of tasks instead of an enumerable.</span></span> <span data-ttu-id="05771-218">若要擷取作用中排程器的清單，請使用內部的方法`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`。</span><span class="sxs-lookup"><span data-stu-id="05771-218">To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span></span> <span data-ttu-id="05771-219">這個靜態方法會傳回所有作用中的陣列<xref:System.Threading.Tasks.TaskScheduler>執行個體。</span><span class="sxs-lookup"><span data-stu-id="05771-219">This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances.</span></span> <span data-ttu-id="05771-220">然後您可以使用`GetScheduledTasksForDebugger`擷取其排定工作的清單每個排程器執行個體。</span><span class="sxs-lookup"><span data-stu-id="05771-220">You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="05771-221">這個排程器無法在這個階段產生佇列的工作清單。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-221">This scheduler is unable to generate a list of queued tasks at this time.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="05771-222">取得這個 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 的唯一 ID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-222">Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="05771-223">傳回這個 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 的唯一 ID。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-223">Returns the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-224">如需詳細資訊，請參閱[工作排程器](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。</span><span class="sxs-lookup"><span data-stu-id="05771-224">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="05771-225">表示這個 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 可以支援的最大並行層級。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-225">Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="05771-226">傳回整數，表示最大並行層級。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-226">Returns an integer that represents the maximum concurrency level.</span>
          </span>
          <span data-ttu-id="05771-227">預設排程器會傳回 <see cref="F:System.Int32.MaxValue" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-227">The default scheduler returns <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-228">如需詳細資訊，請參閱[工作排程器](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。</span><span class="sxs-lookup"><span data-stu-id="05771-228">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="05771-229">要排入的 <see cref="T:System.Threading.Tasks.Task" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-229">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="05771-230">將 <see cref="T:System.Threading.Tasks.Task" /> 排入至排程器。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-230">Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-231">類別衍生自<xref:System.Threading.Tasks.TaskScheduler>實作這個方法，以接受工作排程器上進行排程。</span><span class="sxs-lookup"><span data-stu-id="05771-231">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.</span></span>  
  
 <span data-ttu-id="05771-232">一般的實作會將工作儲存在內部資料結構中，將會在某段時間在未來執行這些工作的執行緒服務。</span><span class="sxs-lookup"><span data-stu-id="05771-232">A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</span></span>  
  
 <span data-ttu-id="05771-233">這個方法僅用於.NET Framework 所呼叫，並不應該直接由衍生類別呼叫。</span><span class="sxs-lookup"><span data-stu-id="05771-233">This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</span></span> <span data-ttu-id="05771-234">這是所需的維護系統的一致性。</span><span class="sxs-lookup"><span data-stu-id="05771-234">This is necessary for maintaining the consistency of the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="05771-235">
            <paramref name="task" /> 引數為 null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-235">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="05771-236">要清除的 <see cref="T:System.Threading.Tasks.Task" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-236">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="05771-237">嘗試清除之前排入至這個排程器的 <see cref="T:System.Threading.Tasks.Task" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-237">Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="05771-238">布林值，表示是否已經成功清除 <paramref name="task" /> 引數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-238">A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-239">如需詳細資訊，請參閱[工作排程器](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。</span><span class="sxs-lookup"><span data-stu-id="05771-239">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 <span data-ttu-id="05771-240">這個方法可能會執行 finally 區塊。因此它應該傳回盡快讓該任何資源，例如<xref:System.Threading.CancellationTokenRegistration>可以及時的處置物件。</span><span class="sxs-lookup"><span data-stu-id="05771-240">This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="05771-241">
            <paramref name="task" /> 引數為 null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-241">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="05771-242">要執行的 <see cref="T:System.Threading.Tasks.Task" /> 物件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-242">A <see cref="T:System.Threading.Tasks.Task" /> object to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="05771-243">嘗試在這個排程器上執行提供的 <see cref="T:System.Threading.Tasks.Task" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-243">Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task" /> on this scheduler.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="05771-244">布林值，如果已成功執行 <paramref name="task" /> 則為 true，否則為 false。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-244">A Boolean that is true if <paramref name="task" /> was successfully executed, false if it was not.</span>
          </span>
          <span data-ttu-id="05771-245">執行失敗的常見原因是之前已執行過該工作，或另一個執行緒正在執行該工作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-245">A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-246">排程器的實作所提供的<xref:System.Threading.Tasks.Task>執行個體要透過執行<xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>方法或<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="05771-246">Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method.</span></span> <span data-ttu-id="05771-247">當排程器認為適合用來執行所提供的工作，<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A>應該用來執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="05771-247">When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so.</span></span> <span data-ttu-id="05771-248">TryExecuteTask 處理執行的工作，包括動作引動過程、 例外狀況處理、 狀態管理和生命週期控制項的所有層面。</span><span class="sxs-lookup"><span data-stu-id="05771-248">TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</span></span>  
  
 <span data-ttu-id="05771-249"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> 必須僅用於由.NET Framework 基礎結構提供給這個排程器工作。</span><span class="sxs-lookup"><span data-stu-id="05771-249"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</span></span> <span data-ttu-id="05771-250">它不應該用來執行任意的工作，透過自訂機制取得。</span><span class="sxs-lookup"><span data-stu-id="05771-250">It should not be used to execute arbitrary tasks obtained through custom mechanisms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="05771-251">
            <paramref name="task" /> 與此排程器無關。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-251">The <paramref name="task" /> is not associated with this scheduler.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="05771-252">要執行的 <see cref="T:System.Threading.Tasks.Task" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-252">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</span>
          </span>
        </param>
        <param name="taskWasPreviouslyQueued">
          <span data-ttu-id="05771-253">布林值，表示之前是否已排入過工作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-253">A Boolean denoting whether or not task has previously been queued.</span>
          </span>
          <span data-ttu-id="05771-254">如果這個參數為 True，則可能之前已排入 (排定) 過工作，如果為 False，則表示未排入過工作，系統便會隨即執行此呼叫，以內嵌方式執行工作，而不將它排入佇列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-254">If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="05771-255">判斷是否可以在這個呼叫中同步執行所提供的 <see cref="T:System.Threading.Tasks.Task" />，如果可以，即加以執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-255">Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously in this call, and if it can, executes it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="05771-256">布林值，表示工作是否以內嵌方式執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-256">A Boolean value indicating whether the task was executed inline.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-257">類別衍生自<xref:System.Threading.Tasks.TaskScheduler>實作此函式可支援內嵌在工作執行初始化工作物件上的等候的執行緒上。</span><span class="sxs-lookup"><span data-stu-id="05771-257">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</span></span> <span data-ttu-id="05771-258">內嵌執行為選擇性，而且該要求可能會遭到拒絕，透過傳回 false。</span><span class="sxs-lookup"><span data-stu-id="05771-258">Inline execution is optional, and the request may be rejected by returning false.</span></span> <span data-ttu-id="05771-259">不過，更多的工作，可以內嵌，較佳的排程器將會調整。</span><span class="sxs-lookup"><span data-stu-id="05771-259">However, the more tasks that can be inlined, the better the scheduler will scale.</span></span> <span data-ttu-id="05771-260">事實上，排程器的內嵌太少可能容易造成死結。</span><span class="sxs-lookup"><span data-stu-id="05771-260">In fact, a scheduler that inlines too little may be prone to deadlocks.</span></span> <span data-ttu-id="05771-261">正確的實作應該確保，保證排程器原則 下執行的要求可以成功地內嵌。</span><span class="sxs-lookup"><span data-stu-id="05771-261">A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</span></span> <span data-ttu-id="05771-262">例如，如果排程器使用專屬的執行緒執行工作，該執行緒從任何內嵌要求應該會成功。</span><span class="sxs-lookup"><span data-stu-id="05771-262">For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</span></span>  
  
 <span data-ttu-id="05771-263">如果排程器會決定要執行的內嵌執行，它應該這樣藉由呼叫至基底的 TaskScheduler<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A>與提供的工作物件，將傳播的傳回值的方法。</span><span class="sxs-lookup"><span data-stu-id="05771-263">If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value.</span></span> <span data-ttu-id="05771-264">它也可能適用於從其內部資料結構移除內嵌的工作，如果決定要接受內嵌要求排程器。</span><span class="sxs-lookup"><span data-stu-id="05771-264">It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</span></span> <span data-ttu-id="05771-265">請注意，在某些情況下排程器可能會要求您內嵌的工作，先前未提供給它與<xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="05771-265">Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.</span></span>  
  
 <span data-ttu-id="05771-266">在衍生的排程器會負責確保呼叫執行緒適合用來執行它自己的排程就指定的工作，並執行原則而言。</span><span class="sxs-lookup"><span data-stu-id="05771-266">The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</span></span>  
  
 <span data-ttu-id="05771-267">如需詳細資訊，請參閱[工作排程器](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)。</span><span class="sxs-lookup"><span data-stu-id="05771-267">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="05771-268">
            <paramref name="task" /> 引數為 null。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-268">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="05771-269">
            <paramref name="task" /> 已經執行。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-269">The <paramref name="task" /> was already executed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="05771-270">當錯誤工作未觀察到的例外狀況將觸發例外狀況擴大原則時發生，根據預設，這會終止處理程序。</span>
          <span class="sxs-lookup">
            <span data-stu-id="05771-270">Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="05771-271">這個應用程式全網域的事件會提供一個機制，以避免例外狀況擴大原則 （，根據預設，終止處理序），從觸發。</span><span class="sxs-lookup"><span data-stu-id="05771-271">This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</span></span>  
  
 <span data-ttu-id="05771-272">若要簡化開發人員撰寫非同步程式碼，根據工作，[!INCLUDE[net_v45](~/includes/net-v45-md.md)]變成未觀察到的例外狀況的預設例外狀況行為。</span><span class="sxs-lookup"><span data-stu-id="05771-272">To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions.</span></span> <span data-ttu-id="05771-273">雖然仍未觀察到的例外狀況引發<xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException>例外狀況，處理程序不會終止預設。</span><span class="sxs-lookup"><span data-stu-id="05771-273">Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default.</span></span> <span data-ttu-id="05771-274">相反地，例外狀況是由處理執行階段後引發事件時，不論是否事件處理常式會觀察到的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="05771-274">Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</span></span> <span data-ttu-id="05771-275">可以設定此行為。</span><span class="sxs-lookup"><span data-stu-id="05771-275">This behavior can be configured.</span></span> <span data-ttu-id="05771-276">從開始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，您可以使用的組態項目，若要還原的行為[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]和終止處理序：</span><span class="sxs-lookup"><span data-stu-id="05771-276">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the  configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:</span></span>  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>