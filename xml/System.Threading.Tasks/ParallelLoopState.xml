<Type Name="ParallelLoopState" FullName="System.Threading.Tasks.ParallelLoopState">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e4244160069333f5d930b81c7b54173c2ad6d6a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530212" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ParallelLoopState" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ParallelLoopState extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.ParallelLoopState" />
  <TypeSignature Language="VB.NET" Value="Public Class ParallelLoopState" />
  <TypeSignature Language="C++ CLI" Value="public ref class ParallelLoopState" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ShouldExitCurrentIteration = {ShouldExitCurrentIteration}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>讓平行迴圈的反覆項目與其他反覆項目互動。 <see cref="T:System.Threading.Tasks.Parallel" /> 類別會在每個迴圈中提供這個類別的執行個體，您不能在自己的程式碼中建立執行個體。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請注意，您無法具現化這個類別的執行個體。 它自動產生由編譯器所呼叫的引數為<xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>或<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法。 這個範例將提供說明。  
  
 這類建構`for`和`foreach`（C# 中） 和`For`和`For Each`（在 Visual Basic 中) 執行以循序方式從最低到最高的索引，或從集合中的第一個物件的最後一個。 相反地，<xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType>和<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法則否。 因為平行執行迴圈的個別反覆項目，可以開始與結束任何順序。 <xref:System.Threading.Tasks.ParallelLoopState>類別可讓平行迴圈彼此互動的個別反覆項目。 <xref:System.Threading.Tasks.ParallelLoopState>類別可讓您：  
  
-   結束目前的反覆項目，並防止啟動藉由呼叫任何其他反覆項目<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法。 這不會影響已經開始執行的反覆項目。  
  
-   防止索引大於目前的索引與任何反覆項目執行藉由呼叫<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法。 這不會影響已經開始執行的反覆項目。  
  
-   判斷例外狀況是否發生任何迴圈反覆項目中所擷取的值<xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A>屬性。  
  
-   判斷是否已呼叫任何反覆項目迴圈的<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法所擷取的值<xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A>屬性。 您可以使用這個屬性傳回的呼叫之前開始迴圈的反覆項目從<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法，但仍在執行。  
  
-   判斷是否已呼叫任何反覆項目迴圈的<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>或<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法所擷取的值已擲回例外狀況或<xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A>屬性。  
  
-   從執行長時間執行的反覆查看其索引大於反覆項目所擷取的值中斷已呼叫所在的索引結束<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>屬性。  
  
   
  
## Examples  
 下列範例會以平行方式執行迴圈的最多 100 個反覆項目。 從 1 到 1000 毫秒的隨機間隔暫停每個反覆項目。 隨機產生的值會決定迴圈的反覆項目上<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法呼叫。 做為範例所示，其索引大於任何反覆項目從輸出<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>呼叫之後開始屬性值<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 因為迴圈的反覆項目仍可能在執行時<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>呼叫方法時，每個反覆項目呼叫<xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A>屬性來檢查是否已呼叫另一個反覆項目<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法。 如果屬性值為`true`，反覆項目值檢查<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>屬性，如果大於目前的反覆項目的索引值，會立即傳回。  
  
 ]]></format>
    </remarks>
    <threadsafe>A<see cref="T:System.Threading.Tasks.ParallelLoopState" />執行個體是只在迴圈執行個體所提供的主體內使用。  不是安全使用提供<see cref="T:System.Threading.Tasks.ParallelLoopState" />執行個體相關聯的迴圈後結束，也不會明確它遞交給其他的執行緒安全且擁有這些隨時存取它的執行緒。  不同<see cref="T:System.Threading.Tasks.ParallelLoopState" />會提供在迴圈中所涉及的每個執行緒的執行個體。</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public void Break ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Break() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Break" />
      <MemberSignature Language="VB.NET" Value="Public Sub Break ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Break();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳達 <see cref="T:System.Threading.Tasks.Parallel" /> 迴圈應該在過了目前的反覆項目之後，依系統的方便盡早停止執行反覆項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 表示應該執行任何反覆項目在目前的反覆項目。 它會有效地取消迴圈中的任何其他反覆項目。 不過，它不會停止已經開始執行任何反覆項目。 例如，如果<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>平行迴圈，逐一查看從 0 到 1000，所有的反覆項目小於 100 應該仍然會執行，但的反覆項目從透過 101 到 1000，尚未啟動未執行的第 100 反覆項目會從呼叫。  
  
 長時間執行反覆項目可能已經在執行，<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>設定<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>屬性目前反覆項目索引，如果目前的索引是目前的值小於<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>。 若要停止其索引大於競爭執行從最低的中斷反覆項目反覆項目，您應該執行下列作業：  
  
1.  檢查是否<xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A>屬性是`true`。  
  
2.  如果其索引大於結束反覆項目從<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>屬性值。  
  
 這個範例將提供說明。  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> 通常會採用以搜尋為基礎的演算法，是在資料來源中的順序。  
  
   
  
## Examples  
 下列範例會以平行方式執行迴圈的最多 100 個反覆項目。 從 1 到 1000 毫秒的隨機間隔暫停每個反覆項目。 隨機產生的值會決定迴圈的反覆項目上<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法呼叫。 做為範例所示，其索引大於任何反覆項目從輸出<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>呼叫之後開始屬性值<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 因為迴圈的反覆項目仍可能在執行時<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>呼叫方法時，每個反覆項目呼叫<xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A>屬性來檢查是否已呼叫另一個反覆項目<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法。 如果屬性值為`true`，反覆項目值檢查<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>屬性，如果大於目前的反覆項目的索引值，會立即傳回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">先前已呼叫 <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> 方法。 <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> 和 <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> 可能無法由相同迴圈的反覆項目搭配使用。</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      </Docs>
    </Member>
    <Member MemberName="IsExceptional">
      <MemberSignature Language="C#" Value="public bool IsExceptional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExceptional" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsExceptional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExceptional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExceptional { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得迴圈中是否有任何反覆項目已擲回該反覆項目未處理的例外狀況。</summary>
        <value>
          如果擲回未處理的例外狀況，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStopped">
      <MemberSignature Language="C#" Value="public bool IsStopped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStopped" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStopped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStopped { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得迴圈中是否有任何反覆項目已呼叫 <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> 方法。</summary>
        <value>
          如果有任何反覆項目藉由呼叫 <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> 方法而停止迴圈，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 反覆項目長時間執行的迴圈中，您可以擷取的值<xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A>屬性來判斷是否在迴圈的任何反覆項目，開始執行的呼叫之前<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法仍在執行。 然後，您可以使用的值<xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A>屬性來判斷是否應該立即傳回或正常執行。  
  
   
  
## Examples  
 下列範例會以平行方式執行迴圈的最多 10,000 個反覆項目。 從 1 到 1000 毫秒的隨機間隔暫停每個反覆項目。 隨機產生的值會決定迴圈的反覆項目上<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法呼叫。 因為迴圈的反覆項目仍可能在執行時<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>呼叫方法時，lambda 運算式呼叫<xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A>方法來檢查是否已呼叫另一個反覆項目<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法。 如果它傳回`true`，會立即傳回在反覆項目。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LowestBreakIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;long&gt; LowestBreakIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int64&gt; LowestBreakIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LowestBreakIteration As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;long&gt; LowestBreakIteration { Nullable&lt;long&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得迴圈中呼叫 <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> 的最低反覆項目。</summary>
        <value>呼叫 <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> 的最低反覆項目。 在 <see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" /> 迴圈的案例中，值是根據內部產生的索引。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可能的平行迴圈來呼叫多個反覆項目<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法。 如果沒有的話，這個值會是最小的反覆項目呼叫索引<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>。 如果任何反覆項目迴圈的不呼叫<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>，這個屬性會傳回`null`。 請注意，屬性值並不會受到呼叫<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法。  
  
 在呼叫的反覆項目之後的所有反覆項目中的長時間執行反覆項目<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法不需要再執行，<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>屬性用來終止反覆項目，開始執行的呼叫之前<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法。 若要停止其索引大於競爭執行從最低的中斷反覆項目反覆項目，您應該執行下列作業：  
  
1.  檢查是否<xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A>屬性是`true`。  
  
2.  如果其索引大於結束反覆項目從<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>屬性值。  
  
 這個範例將提供說明。  
  
   
  
## Examples  
 下列範例會以平行方式執行迴圈的最多 100 個反覆項目。 從 1 到 1000 毫秒的隨機間隔暫停每個反覆項目。 隨機產生的值會決定迴圈的反覆項目上<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法呼叫。 這可防止反覆項目，其索引大於<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>屬性值從呼叫之後開始<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法，但它不會影響已經開始執行任何反覆項目。 若要避免這些無法完成，每個反覆項目呼叫<xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A>方法來檢查是否已呼叫另一個反覆項目<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法。 因此，在反覆項目會檢查的值如果<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>屬性，如果大於目前的反覆項目的索引值，會立即傳回。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 請注意，因為<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>值超出範圍平行迴圈外，您必須將它指派給此變數會是可見的迴圈外，如果您想要保留其值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
      </Docs>
    </Member>
    <Member MemberName="ShouldExitCurrentIteration">
      <MemberSignature Language="C#" Value="public bool ShouldExitCurrentIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldExitCurrentIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShouldExitCurrentIteration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldExitCurrentIteration { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得是否應該根據迴圈中目前這個或其他反覆項目的要求，來結束目前這個反覆項目。</summary>
        <value>
          如果目前的反覆項目應該結束，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A>屬性設定為`true`任何下列情況：  
  
-   迴圈呼叫的反覆項目<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>或<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>。  
  
-   迴圈的反覆項目會擲回例外狀況。  
  
-   迴圈會取消。  
  
 當這個屬性是`true`、<xref:System.Threading.Tasks.Parallel>類別主動將嘗試開始執行時，禁止其他迴圈反覆項目。 不過，可能無法防止其他反覆項目，使其無法啟動時的情況。  
  
 它也可能是長時間執行的反覆項目已經開始執行的情況。 在這種情況下，反覆項目可能會明確檢查<xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A>如果屬性傳回的屬性和終止執行`true`。  
  
   
  
## Examples  
 下列範例會以平行方式執行迴圈的最多 100 個反覆項目。 從 1 到 1000 毫秒的隨機間隔暫停每個反覆項目。 隨機產生的值會決定迴圈的反覆項目上<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法呼叫。 這可防止反覆項目，其索引大於<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>屬性值從呼叫之後開始<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法，但它不會影響已經開始執行任何反覆項目。 若要避免這些無法完成，每個反覆項目呼叫<xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A>方法來檢查是否已呼叫另一個反覆項目<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>方法。 因此，在反覆項目會檢查的值如果<xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>屬性，如果大於目前的反覆項目的索引值，會立即傳回。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳達 <see cref="T:System.Threading.Tasks.Parallel" /> 迴圈應該依系統的方便盡早停止執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法表示不需要執行迴圈的任何尚未開始的反覆運算。 它會有效地取消迴圈中的任何其他反覆項目。 不過，它不會停止已經開始執行任何反覆項目。  
  
 呼叫<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法會使<xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A>屬性，以傳回`true`仍在執行迴圈的任何反覆項目。 這特別適用於長時間執行反覆項目，可以檢查<xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A>屬性並結束早期如果其值為`true`。  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> 通常會採用以搜尋為基礎的演算法，結果就是一旦找到，其他反覆項目需要執行所在。  
  
   
  
## Examples  
 下列範例會以平行方式執行迴圈的最多 10,000 個反覆項目。 從 1 到 1000 毫秒的隨機間隔暫停每個反覆項目。 隨機產生的值會決定迴圈的反覆項目上<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法呼叫。 範例輸出所示，任何反覆項目執行的呼叫後方<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 因為迴圈的反覆項目仍可能在執行時<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>呼叫方法時，每個反覆項目呼叫<xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A>方法來檢查是否已呼叫另一個反覆項目<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>方法。 如果它傳回`true`，會立即傳回在反覆項目。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">之前呼叫過 <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> 方法。 <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> 和 <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> 可能無法由相同迴圈的反覆項目搭配使用。</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      </Docs>
    </Member>
  </Members>
</Type>