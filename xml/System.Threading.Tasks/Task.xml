<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="13e7e32ba578078cc8de0b455c12600992ffa5ed" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39856462" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示非同步作業。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 <xref:System.Threading.Tasks.Task>類別的代表單一作業不會傳回值，而此通常以非同步方式執行。 <xref:System.Threading.Tasks.Task> 物件是其中一個的中央元件[工作式非同步模式](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)首度引進.NET Framework 4 中。 因為所執行的工作<xref:System.Threading.Tasks.Task>物件通常是以非同步方式執行的執行緒集區執行緒上而不是以同步方式在主應用程式執行緒中，您可以使用<xref:System.Threading.Tasks.Task.Status%2A>屬性，以及<xref:System.Threading.Tasks.Task.IsCanceled%2A>， <xref:System.Threading.Tasks.Task.IsCompleted%2A>，及<xref:System.Threading.Tasks.Task.IsFaulted%2A>屬性，以判斷工作的狀態。 大多數情況下，lambda 運算式用來指定工作可執行的工作。  
  
 對於傳回值的作業，您使用<xref:System.Threading.Tasks.Task%601>類別。  
  
 本節內容：  
  
 [工作具現化範例](#Instant)   
 [建立和執行工作](#Creating)   
 [區隔工作建立和執行](#Separating)   
 [等候完成的一或多個工作](#WaitingForOne)   
 [工作和文化特性](#Culture)   
 [適用於偵錯工具開發人員](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a>工作具現化  
 下列範例會建立，並執行四項工作。 三個工作執行<xref:System.Action%601>名為委派`action`，它可接受類型的引數<xref:System.Object>。 第四個工作執行 lambda 運算式 (<xref:System.Action>委派) 也就是內嵌定義的工作建立方法的呼叫中。 每個工作是具現化，並以不同方式執行：  
  
-   工作`t1`藉由呼叫的工作類別建構函式具現化，但啟動藉由呼叫其<xref:System.Threading.Tasks.Task.Start>方法，只有在工作之後`t2`已啟動。  
  
-   任務`t2`就會具現化，並啟動單一方法呼叫中，藉由呼叫<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType>方法。  
  
-   任務`t3`就會具現化，並啟動單一方法呼叫中，藉由呼叫<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法。  
  
-   任務`t4`藉由呼叫在主執行緒上同步執行<xref:System.Threading.Tasks.Task.RunSynchronously>方法。  
  
 因為工作`t4`執行以同步方式，它會在主應用程式的執行緒上執行。 其餘的工作以非同步方式執行通常在一或多個執行緒集區執行緒上。  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>建立和執行工作  
 <xref:System.Threading.Tasks.Task> 執行個體可能會建立各種不同的方式。 最常見的方法，起[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，方法是呼叫靜態<xref:System.Threading.Tasks.Task.Run%2A>方法。 <xref:System.Threading.Tasks.Task.Run%2A>方法提供簡單的方式來啟動工作，使用預設值且不需要額外的參數。 下列範例會使用<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法來啟動工作並執行迴圈，然後顯示迴圈反覆項目數目：  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 替代方式，以及最常見的方法，來啟動工作以[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，是靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法。 <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType>屬性會傳回<xref:System.Threading.Tasks.TaskFactory>物件。 多載<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法可讓您指定要傳遞至工作建立選項和工作排程器的參數。 下列範例會使用<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>啟動工作的方法。 它相當於前一個範例中的程式碼。  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 如需更完整的範例，請參閱 <<c0> [ 工作式非同步程式設計](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)。  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>區隔工作建立和執行  
 <xref:System.Threading.Tasks.Task>類別也會提供建構函式所初始化的工作，但是，不要排程它執行。 基於效能考量<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>或<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法是慣用的機制，建立和排程計算工作，但其中必須以建立和排程的情況下，您可以使用建構函式，然後呼叫<xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType>方法排定在稍後執行的工作。  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>等候完成的一或多個工作  
 因為工作通常會在執行緒集區執行緒上以非同步方式執行，會建立並啟動工作的執行緒會繼續執行，只要工作具現化。 在某些情況下，當呼叫的執行緒是主應用程式執行緒，應用程式可能會終止任何之前工作實際開始執行。 在其他使用案例，您的應用程式邏輯可能需要當呼叫端執行緒只在一或多個工作完成執行時，才會繼續執行。 您可以同步處理執行呼叫的執行緒和非同步工作就會啟動藉由呼叫`Wait`等候完成的一或多個工作的方法。  
  
 若要等候單一工作完成時，您可以呼叫其<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>方法。 呼叫<xref:System.Threading.Tasks.Task.Wait%2A>方法會封鎖呼叫執行緒，直到執行完成的單一類別執行個體。  
  
 下列範例會呼叫無參數<xref:System.Threading.Tasks.Task.Wait>無條件地等候，直到工作完成的方法。 工作模擬的工作，藉由呼叫<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>兩秒進入睡眠狀態的方法。  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 您可以也有條件地等候工作完成。 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>和<xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>方法會封鎖呼叫執行緒，直到工作完成或經過逾時間隔，視何者先。 因為下列範例會啟動的工作，會進入睡眠狀態兩秒，但定義一秒等候逾時值，則呼叫端執行緒會封鎖直到逾時到期，以及之前工作已完成執行。  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 您也可以藉由呼叫提供的取消語彙基元<xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>和<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>方法。 如果語彙基元<xref:System.Threading.CancellationToken.IsCancellationRequested%2A>屬性是`true`，等候已取消; 如果它成為 true 時<xref:System.Threading.Tasks.Task.Wait%2A>方法會結束。  
  
 在某些情況下，您可能想要等待執行工作的一系列的第一，若要完成，但不是這項工作的照護。  基於此目的，您可以呼叫其中一個多載<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法。  下列範例會建立三項工作，其中每個處於睡眠狀態的間隔來判斷隨機數字產生器。 <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29>方法會等候第一個工作完成。 範例接著會顯示所有三項工作的狀態相關資訊。  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 您也可以等待一系列的工作完成藉由呼叫的所有<xref:System.Threading.Tasks.Task.WaitAll%2A>方法。 下列範例會建立 10 個工作、 等候所有十個完成，然後顯示其狀態。  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 請注意當您等候一或多個工作完成時，在執行中的工作中擲回任何例外狀況會傳播呼叫的執行緒上`Wait`方法，如下列範例所示。 它會啟動 12 的工作，其中三個正常完成和三個例外狀況的擲回。 其餘的六個工作中，三個，並取消之前開始，以及三個同時執行，並取消。 中擲回例外狀況<xref:System.Threading.Tasks.Task.WaitAll%2A>方法呼叫，並會由`try` / `catch`區塊。  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 如需有關以工作為基礎的非同步作業中的例外狀況處理的詳細資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>工作和文化特性  
 從桌面應用程式為目標[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，建立並叫用工作之執行緒的文化特性會變成的執行緒內容的一部分。 也就是工作的目前執行緒文化特性執行該工作，不論目前的文化特性是工作的呼叫執行緒的文化特性。 之前的.NET Framework 版本為目標的應用程式的[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，工作的文化特性是執行該工作之執行緒的文化特性。 如需詳細資訊，請參閱 「 文化特性和以工作為基礎的非同步作業 > 一節中<xref:System.Globalization.CultureInfo>主題。  
  
> [!NOTE]
>  市集應用程式，請遵循 Windows 執行階段設定和取得預設文化特性。  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>適用於偵錯工具開發人員  
 適用於實作自訂的偵錯工具的開發人員，數個內部與私用成員的工作可能很有用 （這些可能會變更版本）。 `m_taskId`欄位做為備份存放區<xref:System.Threading.Tasks.Task.Id%2A>屬性，不過存取這個欄位，直接從偵錯工具可能會比透過屬性的 getter 方法中存取相同的值更有效率 (`s_taskIdCounter`計數器用來擷取工作的下一個可用識別碼。） 同樣地，`m_stateFlags`欄位會儲存目前的生命週期階段相關的工作，也可透過存取資訊的資訊<xref:System.Threading.Tasks.Task.Status%2A>屬性。 `m_action`欄位會儲存工作的委派的參考和`m_stateObject`欄位儲存開發人員所要傳遞給工作的非同步狀態。 最後，針對剖析堆疊框架的偵錯工具`InternalWait`方法做為工作進入等候作業的潛在標記。   
  
 ]]></format>
    </remarks>
    <threadsafe>所有成員<see cref="T:System.Threading.Tasks.Task" />，除了<see cref="M:System.Threading.Tasks.Task.Dispose" />是安全執行緒，可能會從多個執行緒同時使用。</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">委派，表示工作中要執行的程式碼。</param>
        <summary>使用指定的動作，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是呼叫此建構函式，最常見的方式來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType>或<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType>方法。 這個建構函式所提供的唯一優點是它可讓工作引動過程可以區隔的物件具現化。  
  
   
  
## Examples  
 下列範例會使用<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29>建構函式來建立工作，以擷取中的檔名指定的目錄。 所有工作將檔案名稱都寫入單一<xref:System.Collections.Concurrent.ConcurrentBag%601>物件。 此範例接著會呼叫<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>方法，以確保所有工作完成時，，，然後顯示 檔案名稱寫入總數的計數<xref:System.Collections.Concurrent.ConcurrentBag%601>物件。  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 下列範例完全相同，不同之處在於它使用<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法來具現化，並在單一作業中執行的工作。 此方法會傳回<xref:System.Threading.Tasks.Task>代表工作的物件。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引數為 <see langword="null" />。</exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">委派，表示工作中要執行的程式碼。</param>
        <param name="cancellationToken">新工作將會觀察的 <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>使用指定的動作和 <see cref="T:System.Threading.Tasks.Task" />，初始化新的 <see cref="T:System.Threading.CancellationToken" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是呼叫此建構函式，最常見的方式來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>和<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>方法。 這個建構函式所提供的唯一優點是它可讓工作引動過程可以區隔的物件具現化。  
  
 如需詳細資訊，請參閱 <<c0> [ 工作平行處理原則 （工作平行程式庫）](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)並[受控執行緒中的取消](~/docs/standard/threading/cancellation-in-managed-threads.md)。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29>建構函式建立的工作，會逐一查看 C:\Windows\System32 目錄中的檔案。 Lambda 運算式呼叫<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法來新增每個檔案的相關資訊<xref:System.Collections.Generic.List%601>物件。 每個中斷連結的巢狀的工作所叫用<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>迴圈會檢查的取消語彙基元的狀態，以及如果要求取消，則會呼叫<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>方法。 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>方法會擲回<xref:System.OperationCanceledException>會在處理的例外狀況`catch`封鎖呼叫執行緒呼叫時<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>方法。  <xref:System.Threading.Tasks.Task.Start%2A>方法接著會呼叫啟動工作。  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已經處置所提供的 <see cref="T:System.Threading.CancellationToken" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引數為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">委派，表示工作中要執行的程式碼。</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" />，用於自訂工作的行為。</param>
        <summary>使用指定的動作和建立選項，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是呼叫此建構函式，最常見的方式來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType>方法。 這個建構函式所提供的唯一優點是它可讓工作引動過程可以區隔的物件具現化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引數為 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 值不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">委派，表示工作中要執行的程式碼。</param>
        <param name="state">物件，表示動作所需的資料。</param>
        <summary>使用指定的動作和狀態，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是呼叫此建構函式，最常見的方式來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType>方法。 這個建構函式所提供的唯一優點是它可讓工作引動過程可以區隔的物件具現化。  
  
   
  
## Examples  
 下列範例會定義 6 字母字詞的陣列。 每個字接著會傳遞做為引數<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29>建構函式，其<xref:System.Action%601>委派將在 word 中，字元的金鑰加密，則會顯示原始的字組和其變碼的版本。  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引數為 null。</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">委派，表示工作中要執行的程式碼。</param>
        <param name="cancellationToken">新工作將會觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" />，用於自訂工作的行為。</param>
        <summary>使用指定的動作和建立選項，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是呼叫此建構函式，最常見的方式來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType>方法。 這個建構函式所提供的唯一優點是它可讓工作引動過程可以區隔的物件具現化。  
  
 如需詳細資訊，請參閱 <<c0> [ 工作平行處理原則 （工作平行程式庫）](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)並[工作取消](~/docs/standard/parallel-programming/task-cancellation.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引數為 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 值不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">委派，表示工作中要執行的程式碼。</param>
        <param name="state">物件，表示動作所需的資料。</param>
        <param name="cancellationToken">新工作將會觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>使用指定的動作、狀態和選項，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是呼叫此建構函式，最常見的方式來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>方法。 這個建構函式所提供的唯一優點是它可讓工作引動過程可以區隔的物件具現化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引數為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">委派，表示工作中要執行的程式碼。</param>
        <param name="state">物件，表示動作所需的資料。</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" />，用於自訂工作的行為。</param>
        <summary>使用指定的動作、狀態和選項，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是呼叫此建構函式，最常見的方式來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType>方法。 這個建構函式所提供的唯一優點是它可讓工作引動過程可以區隔的物件具現化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引數為 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 值不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">委派，表示工作中要執行的程式碼。</param>
        <param name="state">物件，表示動作所需的資料。</param>
        <param name="cancellationToken">新工作將會觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" />，用於自訂工作的行為。</param>
        <summary>使用指定的動作、狀態和選項，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 而不是呼叫此建構函式，最常見的方式來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType>方法。 這個建構函式所提供的唯一優點是它可讓工作引動過程可以區隔的物件具現化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 引數為 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 值不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得建立 <see cref="T:System.Threading.Tasks.Task" /> 時提供的狀態物件，如果未提供則為 null。</summary>
        <value>
          <see cref="T:System.Object" />，代表工作建立時傳入工作的狀態資料。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 將物件轉換回原始類型，以擷取其資料。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得已成功完成的工作。</summary>
        <value>成功完成的工作。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回工作的<xref:System.Threading.Tasks.Task.Status%2A>屬性設定為<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>。 若要建立傳回值，並執行到完成的工作，請呼叫<xref:System.Threading.Tasks.Task.FromResult%2A>方法。  
  
 擷取這個屬性值的嘗試重複可能不會一律傳回相同的執行個體。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">
          <see langword="true" /> 表示嘗試將接續封送處理回原始擷取的內容，否則為 <see langword="false" />。</param>
        <summary>設定用來等候這個 <see cref="T:System.Threading.Tasks.Task" /> 的 awaiter。</summary>
        <returns>等候這項工作所用的物件。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時非同步執行的接續。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。 執行時，會將已完成的工作當做引數傳遞給委派。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時非同步執行的接續。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task>將不會排定執行目前的工作完成之前，是否因為成功執行到完成、 失敗，因為發生未處理的例外狀況，或提早結束出因取消才完成。  
  
   
  
## Examples  
 下列範例會定義的工作，會填入具有 100 隨機的日期和時間值的陣列。 它會使用<xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29>陣列會完全擴展之後，選取最早和最新的日期值的方法。  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 主控台應用程式可能會終止之前執行的接續工作，因為<xref:System.Threading.Tasks.Task.Wait>方法會呼叫以確保執行範例結束前完成的接續。  
  
 如需其他範例，請參閱 <<c0> [ 使用接續工作鏈結工作](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">當工作完成時要執行的動作。 執行時，會將已完成的工作和呼叫端提供的狀態物件當做引數傳遞給委派。</param>
        <param name="state">物件，表示接續動作所使用的資料。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收呼叫端提供的狀態資訊並執行的接續。</summary>
        <returns>新的接續工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task>將不會排定執行目前的工作完成之前，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或提早結束取消而完成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。 執行時，會將已完成的工作當做引數傳遞給委派。</param>
        <param name="cancellationToken">要指派給新接續工作的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收取消語彙基元並非同步執行的接續。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task>將不會排定執行目前的工作完成之前，是否因為成功執行到完成、 失敗，因為發生未處理的例外狀況，或提早結束出因取消才完成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已處置建立語彙基元的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引數為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">要根據指定的 <c>continuationOptions</c> 執行的動作。 執行時，會將已完成的工作當做引數傳遞給委派。</param>
        <param name="continuationOptions">接續工作的排程時間及其行為方式的適用選項。 這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</param>
        <summary>建立當目標工作完成時，會根據指定之 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 執行的接續。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task>將不會排定執行直到完成目前的工作。 如果接續準則指定透過`continuationOptions`不符合參數，即會取消接續工作而不是排程。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.Threading.Tasks.TaskContinuationOptions>來指定前項工作完成時的接續工作應該會以同步方式執行。 (如果指定的工作已完成的時間<xref:System.Threading.Tasks.Task.ContinueWith%2A>呼叫時，同步執行緒呼叫上執行接續<xref:System.Threading.Tasks.Task.ContinueWith%2A>。)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引數為 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。 執行時，會將已完成的工作當做引數傳遞給委派。</param>
        <param name="scheduler">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時非同步執行的接續。 接續會使用指定的排程器。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task>將不會排定執行目前的工作完成之前，是否因為成功執行到完成、 失敗，因為發生未處理的例外狀況，或提早結束出因取消才完成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引數為 <see langword="null" />。  
  
-或- 
<paramref name="scheduler" /> 引數為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。 當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</param>
        <param name="state">物件，表示接續動作所使用的資料。</param>
        <param name="cancellationToken">要指派給新接續工作的 <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收呼叫端提供的狀態資訊和取消語彙基元，並非同步執行的接續。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task>將不會排定執行目前的工作完成之前，是否因為成功執行到完成、 失敗，因為發生未處理的例外狀況，或提早結束出因取消才完成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">已經處置所提供的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。 當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</param>
        <param name="state">物件，表示接續動作所使用的資料。</param>
        <param name="continuationOptions">接續工作的排程時間及其行為方式的適用選項。 這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收呼叫端提供的狀態資訊並執行的接續。 接續會根據一組指定的條件執行。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task>將不會排定執行直到完成目前的工作。 如果接續準則指定透過`continuationOptions`不符合參數，即會取消接續工作而不是排程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。  當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</param>
        <param name="state">物件，表示接續動作所使用的資料。</param>
        <param name="scheduler">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收呼叫端提供的狀態資訊並非同步執行的接續。 接續會使用指定的排程器。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task>將不會排定執行目前的工作完成之前，是否因為成功執行到完成、 失敗，因為發生未處理的例外狀況，或提早結束出因取消才完成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">要根據指定的 <c>continuationOptions</c> 執行的動作。 執行時，會將已完成的工作當做引數傳遞給委派。</param>
        <param name="cancellationToken">要指派給新接續工作的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="continuationOptions">接續工作的排程時間及其行為方式的適用選項。 這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</param>
        <param name="scheduler">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>建立當目標工作完成時，會根據指定之 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 執行的接續。 接續會接收取消語彙基元，並使用指定的排程器。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task>將不會排定執行直到完成目前的工作。 如果透過指定的準則`continuationOptions`不符合參數，即會取消接續工作而不是排程。  
  
   
  
## Examples  
 以下是範例使用 ContinueWith 執行的工作在背景中與使用者介面執行緒。  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">已處置建立語彙基元的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引數為 null。  
  
-或- 
<paramref name="scheduler" /> 引數為 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。 當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</param>
        <param name="state">物件，表示接續動作所使用的資料。</param>
        <param name="cancellationToken">要指派給新接續工作的 <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">接續工作的排程時間及其行為方式的適用選項。 這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</param>
        <param name="scheduler">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收呼叫端提供的狀態資訊和取消語彙基元，並執行的接續。 接續會根據一組指定的條件執行，並使用指定的排程器。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task>將不會排定執行直到完成目前的工作。 如果透過指定的準則`continuationOptions`不符合參數，即會取消接續工作而不是排程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</exception>
        <exception cref="T:System.ObjectDisposedException">已經處置所提供的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">接續作業所產生的結果類型。</typeparam>
        <param name="continuationFunction">當 <see cref="T:System.Threading.Tasks.Task`1" /> 完成時要執行的函式。 執行時，會將已完成的工作當做引數傳遞給委派。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task`1" /> 完成並傳回值時非同步執行的接續。</summary>
        <returns>新的接續工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task%601>將不會排定執行目前的工作完成之前，是否因為成功執行到完成、 失敗，因為發生未處理的例外狀況，或提早結束出因取消才完成。  
  
   
  
## Examples  
 下列範例示範如何使用 ContinueWith 方法：  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引數為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">接續作業所產生的結果類型。</typeparam>
        <param name="continuationFunction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。 當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</param>
        <param name="state">物件，表示接續函式所使用的資料。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成並傳回值時，會接收呼叫端提供的狀態資訊並非同步執行的接續。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task%601>將不會排定執行目前的工作完成之前，是否因為成功執行到完成、 失敗，因為發生未處理的例外狀況，或提早結束出因取消才完成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">接續作業所產生的結果類型。</typeparam>
        <param name="continuationFunction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。 執行時，會將已完成的工作當做引數傳遞給委派。</param>
        <param name="cancellationToken">要指派給新接續工作的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成並傳回值時非同步執行的接續。 接續會接收取消語彙基元。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task%601>將不會排定執行目前的工作完成之前，是否因為成功執行到完成、 失敗，因為發生未處理的例外狀況，或提早結束出因取消才完成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。  
  
-或- 
已處置建立語彙基元的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引數為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">接續作業所產生的結果類型。</typeparam>
        <param name="continuationFunction">要根據 <c>continuationOptions</c> 中指定之條件執行的函式。 執行時，會將已完成的工作當做引數傳遞給委派。</param>
        <param name="continuationOptions">接續工作的排程時間及其行為方式的適用選項。 這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</param>
        <summary>建立會根據指定之接續選項執行並傳回值的接續。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task%601>將不會排定執行直到完成目前的工作。 如果接續準則指定透過`continuationOptions`不符合參數，即會取消接續工作而不是排程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引數為 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">接續作業所產生的結果類型。</typeparam>
        <param name="continuationFunction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。 執行時，會將已完成的工作當做引數傳遞給委派。</param>
        <param name="scheduler">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成並傳回值時非同步執行的接續。 接續會使用指定的排程器。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task%601>將不會排定執行目前的工作完成之前，是否因為成功執行到完成、 失敗，因為發生未處理的例外狀況，或提早結束出因取消才完成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引數為 null。  
  
-或- 
<paramref name="scheduler" /> 引數為 null。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">接續作業所產生的結果類型。</typeparam>
        <param name="continuationFunction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。 當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</param>
        <param name="state">物件，表示接續函式所使用的資料。</param>
        <param name="cancellationToken">要指派給新接續工作的 <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成並傳回值時非同步執行的接續。 接續會接收呼叫端提供的狀態資訊和取消語彙基元。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task%601>將不會排定執行目前的工作完成之前，是否因為成功執行到完成、 失敗，因為發生未處理的例外狀況，或提早結束出因取消才完成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ObjectDisposedException">已經處置所提供的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">接續作業所產生的結果類型。</typeparam>
        <param name="continuationFunction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。 當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</param>
        <param name="state">物件，表示接續函式所使用的資料。</param>
        <param name="continuationOptions">接續工作的排程時間及其行為方式的適用選項。 這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會根據指定的工作接續選項來執行的接續。 接續會接收呼叫端提供的狀態資訊。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task%601>將不會排定執行直到完成目前的工作。 如果接續準則指定透過`continuationOptions`不符合參數，即會取消接續工作而不是排程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">接續作業所產生的結果類型。</typeparam>
        <param name="continuationFunction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。  當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</param>
        <param name="state">物件，表示接續函式所使用的資料。</param>
        <param name="scheduler">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時非同步執行的接續。 接續會接收呼叫端提供的狀態資訊，並使用指定的排程器。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task%601>將不會排定執行目前的工作完成之前，是否因為成功執行到完成、 失敗，因為發生未處理的例外狀況，或提早結束出因取消才完成。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">接續作業所產生的結果類型。</typeparam>
        <param name="continuationFunction">要根據指定的 <c>continuationOptions</c> 執行的函式。 執行時，會將已完成的工作當做引數傳遞給委派。</param>
        <param name="cancellationToken">要指派給新接續工作的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <param name="continuationOptions">接續工作的排程時間及其行為方式的適用選項。 這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</param>
        <param name="scheduler">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>建立會根據指定之接續選項執行並傳回值的接續。 接續會接收取消語彙基元，並使用指定的排程器。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task%601>將不會排定執行直到完成目前的工作。 如果透過指定的準則`continuationOptions`不符合參數，即會取消接續工作而不是排程。  
  
   
  
## Examples  
 下列範例示範如何使用 ContinueWith 方法並接續選項：  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。  
  
-或- 
已處置建立語彙基元的 <see cref="T:System.Threading.CancellationTokenSource" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引數為 null。  
  
-或- 
<paramref name="scheduler" /> 引數為 null。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">接續作業所產生的結果類型。</typeparam>
        <param name="continuationFunction">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。 當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</param>
        <param name="state">物件，表示接續函式所使用的資料。</param>
        <param name="cancellationToken">要指派給新接續工作的 <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">接續工作的排程時間及其行為方式的適用選項。 這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</param>
        <param name="scheduler">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成並傳回值時，會根據指定的工作接續選項來執行的接續。 接續會接收呼叫端提供的狀態資訊和取消語彙基元，並使用指定的排程器。</summary>
        <returns>新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回<xref:System.Threading.Tasks.Task%601>將不會排定執行直到完成目前的工作。 如果透過指定的準則`continuationOptions`不符合參數，即會取消接續工作而不是排程。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</exception>
        <exception cref="T:System.ObjectDisposedException">已經處置所提供的 <see cref="T:System.Threading.CancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得用來建立這個工作的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</summary>
        <value>用來建立這個工作的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>傳回目前執行之 <see cref="T:System.Threading.Tasks.Task" /> 的唯一 ID。</summary>
        <value>系統指派給目前執行中工作的整數。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A> 已`static`(`Shared` Visual Basic 中) 用來取得目前執行之工作的識別碼與工作正在執行的程式碼的屬性。 不同於<xref:System.Threading.Tasks.Task.Id%2A>屬性，會傳回特定的識別項<xref:System.Threading.Tasks.Task>執行個體。 如果您嘗試擷取<xref:System.Threading.Tasks.Task.CurrentId%2A>從外部工作正在執行的程式碼的值，這個屬性會傳回`null`。  
  
 請注意，雖然衝突情況非常罕見，工作識別碼不保證是唯一的。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立在時間延遲之後才會完成的工作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">完成所傳回工作之前等待的毫秒數；-1 為無限期地等待。</param>
        <summary>建立在時間延遲之後才會完成的工作。</summary>
        <returns>代表時間延遲的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Delay%2A>方法通常用來在指定的時間間隔內延遲的所有作業或工作的一部分。 大多數情況下，已導入的時間延遲：  
  
-   在開頭的工作，如下列範例顯示。  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   有時在工作時正在執行。 在此情況下，呼叫<xref:System.Threading.Tasks.Task.Delay%2A>方法會執行子工作中一項工作，如下列範例所示。 請注意，此工作之後，呼叫<xref:System.Threading.Tasks.Task.Delay%2A>方法以非同步方式執行時，父工作必須等候它完成使用`await`關鍵字。  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 指定的時間延遲之後，在完成工作<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。  
  
 這個方法會取決於系統時鐘。 這表示時間延遲會大約等於系統時鐘的解析度如果`millisecondsDelay`引數小於系統時鐘，也就是在 Windows 系統上的大約 15 毫秒的解析度。  
  
   
  
## Examples  
 下列範例示範的簡易使用<xref:System.Threading.Tasks.Task.Delay%2A>方法。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsDelay" /> 引數小於 -1。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">完成所傳回工作之前要等待的時間範圍；<see langword="TimeSpan.FromMilliseconds(-1)" /> 表示無限期地等待。</param>
        <summary>建立在指定時間間隔之後完成的工作。</summary>
        <returns>代表時間延遲的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的時間延遲之後，在完成工作<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。  
  
 使用案例和其他範例，請參閱文件<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>多載。  
  
 這個方法會取決於系統時鐘。 這表示時間延遲會大約等於系統時鐘的解析度如果`delay`引數小於系統時鐘，也就是在 Windows 系統上的大約 15 毫秒的解析度。  
  
   
  
## Examples  
 下列範例示範的簡易使用<xref:System.Threading.Tasks.Task.Delay%2A>方法。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> 表示 <see langword="TimeSpan.FromMillseconds(-1)" /> 以外的負數時間間隔。  
  
-或- 
<paramref name="delay" /> 引數的 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 屬性大於 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">完成所傳回工作之前等待的毫秒數；-1 為無限期地等待。</param>
        <param name="cancellationToken">將在完成傳回的工作之前檢查的取消語彙基元。</param>
        <summary>建立在時間延遲之後才會完成的可取消工作。</summary>
        <returns>代表時間延遲的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在指定的時間延遲之前，收到信號的取消語彙基元<xref:System.Threading.Tasks.TaskCanceledException>例外狀況的結果，以及工作完成的<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。  否則，會在完成工作中<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態後經過指定的時間延遲。  
  
 使用案例和其他範例，請參閱文件<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>多載。  
  
 這個方法會取決於系統時鐘。 這表示時間延遲會大約等於系統時鐘的解析度如果`millisecondsDelay`引數小於系統時鐘，也就是在 Windows 系統上的大約 15 毫秒的解析度。  
  
   
  
## Examples  
 下列範例會啟動的工作，包括呼叫<xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29>方法一秒的延遲。 延遲間隔結束之前，已取消的語彙基元。 範例輸出顯示，如此一來，則<xref:System.Threading.Tasks.TaskCanceledException>擲回，和工作的<xref:System.Threading.Tasks.Task.Status%2A>屬性設定為<xref:System.Threading.Tasks.TaskStatus.Canceled>。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsDelay" /> 引數小於 -1。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">已取消這項工作。</exception>
        <exception cref="T:System.ObjectDisposedException">已經處置所提供的 <paramref name="cancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">完成所傳回工作之前要等待的時間範圍；<see langword="TimeSpan.FromMilliseconds(-1)" /> 表示無限期地等待。</param>
        <param name="cancellationToken">將在完成傳回的工作之前檢查的取消語彙基元。</param>
        <summary>建立在指定時間間隔之後完成的可取消工作。</summary>
        <returns>代表時間延遲的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在指定的時間延遲之前，收到信號的取消語彙基元<xref:System.Threading.Tasks.TaskCanceledException>例外狀況的結果，以及工作完成的<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。  否則，會在完成工作中<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態後經過指定的時間延遲。  
  
 使用案例和其他範例，請參閱文件<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>多載。  
  
 這個方法會取決於系統時鐘。 這表示時間延遲會大約等於系統時鐘的解析度如果`delay`引數小於系統時鐘，也就是在 Windows 系統上的大約 15 毫秒的解析度。  
  
   
  
## Examples  
 下列範例會啟動的工作，包括呼叫<xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>方法具有與-a-1.5 秒的延遲。 延遲間隔結束之前，已取消的語彙基元。 範例輸出顯示，如此一來，則<xref:System.Threading.Tasks.TaskCanceledException>擲回，和工作的<xref:System.Threading.Tasks.Task.Status%2A>屬性設定為<xref:System.Threading.Tasks.TaskStatus.Canceled>。  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 請注意，此範例中包含潛在的競爭情形： 它取決於工作的取消語彙基元時，以非同步方式執行延遲。 雖然 1.5 秒延遲，呼叫<xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>方法會使這個假設可能，還是有可能，呼叫<xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>方法可能會在取消語彙基元之前傳回。 在此情況下，此範例會產生下列輸出：  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> 表示 <see langword="TimeSpan.FromMillseconds(-1)" /> 以外的負數時間間隔。  
  
-或- 
<paramref name="delay" /> 引數的 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 屬性大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">已取消這項工作。</exception>
        <exception cref="T:System.ObjectDisposedException">已經處置所提供的 <paramref name="cancellationToken" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將 <see cref="T:System.Threading.Tasks.Task" /> 類別目前的執行個體所使用的資源全部釋出。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>將 <see cref="T:System.Threading.Tasks.Task" /> 類別目前的執行個體所使用的資源全部釋出。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task>類別會實作<xref:System.IDisposable>介面，因為它會在內部使用，也會實作資源<xref:System.IDisposable>。 不過，特別是當應用程式目標[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或更新版本中，則不需要呼叫<xref:System.Threading.Tasks.Task.Dispose%2A>除非效能或延展性測試指出，根據您的使用量模式，您的應用程式會改善效能的處置工作。 如需詳細資訊，請參閱 <<c0> [ 我要處置的工作嗎？](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)中平行程式設計與.NET 部落格。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作不是下列其中一個最終狀態：<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />、<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> 或 <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">布林值，表示是否會因為呼叫 <see cref="M:System.Threading.Tasks.Task.Dispose" /> 而呼叫這個方法。</param>
        <summary>處置 <see cref="T:System.Threading.Tasks.Task" />，並釋放它的所有 Unmanaged 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task>類別會實作<xref:System.IDisposable>介面，因為它會在內部使用，也會實作資源<xref:System.IDisposable>。 不過，特別是當應用程式目標[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或更新版本中，則不需要呼叫<xref:System.Threading.Tasks.Task.Dispose%2A>除非效能或延展性測試指出，根據您的使用量模式，您的應用程式會改善效能的處置工作。 如需詳細資訊，請參閱 <<c0> [ 我要處置的工作嗎？](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)中平行程式設計與.NET 部落格。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">工作不是下列其中一個最終狀態：<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />、<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> 或 <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />。</exception>
        <threadsafe>不同於大部分的成員清單<see cref="T:System.Threading.Tasks.Task" />類別，這個方法不是安全執行緒。</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得導致 <see cref="T:System.AggregateException" /> 不當結束的 <see cref="T:System.Threading.Tasks.Task" />。 如果 <see cref="T:System.Threading.Tasks.Task" /> 順利完成，或未擲回任何例外狀況，則這會傳回 <see langword="null" />。</summary>
        <value>導致 <see cref="T:System.AggregateException" /> 不當結束的 <see cref="T:System.Threading.Tasks.Task" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 擲回未處理的例外狀況的工作儲存產生的例外狀況，並將它包裝在散佈<xref:System.AggregateException>呼叫中<xref:System.Threading.Tasks.Task.Wait%2A>或存取<xref:System.Threading.Tasks.Task.Exception%2A>屬性。 工作執行個體是記憶體回收的時間未觀察到的任何例外狀況會在完成項執行緒上傳播。 如需詳細資訊和範例，請參閱 <<c0> [ 例外狀況處理 （工作平行程式庫）](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供 Factory 方法的存取，這些 Factory 方法用於建立及設定 <see cref="T:System.Threading.Tasks.Task" /> 和 <see cref="T:System.Threading.Tasks.Task`1" /> 執行個體。</summary>
        <value>Factory 物件，可以建立各種不同的 <see cref="T:System.Threading.Tasks.Task" /> 和 <see cref="T:System.Threading.Tasks.Task`1" /> 物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性會傳回預設執行個體<xref:System.Threading.Tasks.TaskFactory>等同於呼叫無參數所建立的類別<xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType>建構函式。 它有下列屬性值：  
  
|屬性|值|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`或 <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 這個屬性的最常見的使用，就是建立並啟動新工作的單一呼叫中<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法。  
  
> [!NOTE]
>  開頭[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，則<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>方法會提供最簡單的方式建立<xref:System.Threading.Tasks.Task>物件使用預設組態值。  
  
 下列範例會使用靜態<xref:System.Threading.Tasks.Task.Factory%2A>屬性，以便在兩個呼叫<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法。 第一個會填入使用者的 MyDocuments 目錄中的檔案名稱陣列，而第二個會填入使用者的 MyDocuments 目錄之子目錄的名稱陣列。 然後它會呼叫<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType>方法，以顯示兩個陣列中的檔案和目錄的數目相關資訊之後的前兩個工作已完成執行。  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">可用來完成工作的取消語彙基元。</param>
        <summary>建立以指定的取消語彙基元取消而完成的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
        <returns>取消的工作。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">並未針對 <paramref name="cancellationToken" /> 要求取消；其 <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> 屬性為 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">工作傳回的結果的類型。</typeparam>
        <param name="cancellationToken">可用來完成工作的取消語彙基元。</param>
        <summary>建立以指定的取消語彙基元取消而完成的 <see cref="T:System.Threading.Tasks.Task`1" />。</summary>
        <returns>取消的工作。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">並未針對 <paramref name="cancellationToken" /> 要求取消；其 <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> 屬性為 <see langword="false" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">可用來完成工作的例外狀況。</param>
        <summary>建立以指定例外狀況完成的 <see cref="T:System.Threading.Tasks.Task" />。</summary>
        <returns>發生錯誤的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立<xref:System.Threading.Tasks.Task>物件，其<xref:System.Threading.Tasks.Task.Status%2A>屬性是<xref:System.Threading.Tasks.TaskStatus.Faulted>，且<xref:System.Threading.Tasks.Task.Exception%2A>屬性包含`exception`。 當您立即知道工作執行的工作將會擲回例外狀況，再執行較長的程式碼路徑時，通常使用的方法。 如需範例，請參閱<xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29>多載。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">工作傳回的結果的類型。</typeparam>
        <param name="exception">可用來完成工作的例外狀況。</param>
        <summary>建立以指定例外狀況完成的 <see cref="T:System.Threading.Tasks.Task`1" />。</summary>
        <returns>發生錯誤的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立<xref:System.Threading.Tasks.Task%601>物件，其<xref:System.Threading.Tasks.Task.Status%2A>屬性是<xref:System.Threading.Tasks.TaskStatus.Faulted>，且<xref:System.Threading.Tasks.Task.Exception%2A>屬性包含`exception`。 當您立即知道工作執行的工作將會擲回例外狀況，再執行較長的程式碼路徑時，通常使用的方法。 這個範例將提供說明。  
  
   
  
## Examples  
 下列範例會計算其名稱做為命令列引數傳遞每個目錄中的檔案中的位元組數的命令列公用程式。 而不是執行較長的程式碼路徑，具現化<xref:System.IO.FileInfo>物件，並擷取值，其<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>目錄中的每個檔案的屬性，此範例只會呼叫<xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29>方法來建立錯誤的工作，如果特定子目錄不存在。  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">工作傳回的結果的類型。</typeparam>
        <param name="result">要儲存到完成的工作的結果。</param>
        <summary>建立已成功完成且具有指定之結果的 <see cref="T:System.Threading.Tasks.Task`1" />。</summary>
        <returns>成功完成的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會建立<xref:System.Threading.Tasks.Task%601>物件，其<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>屬性是`result`，且<xref:System.Threading.Tasks.Task.Status%2A>屬性是<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>。 但不會執行較長的程式碼路徑立即知道工作的傳回值時，通常使用的方法。 這個範例將提供說明。  
  
 若要建立不會傳回值的物件，擷取工作物件，從<xref:System.Threading.Tasks.Task.CompletedTask%2A>屬性。  
  
   
  
## Examples  
 下列範例會計算其名稱做為命令列引數傳遞每個目錄中的檔案中的位元組數的命令列公用程式。 而不是執行較長的程式碼路徑，具現化<xref:System.IO.FileStream>物件，並擷取值，其<xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType>目錄中的每個檔案的屬性，此範例只會呼叫<xref:System.Threading.Tasks.Task.FromResult%2A>方法來建立工作的<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>如果目錄不有任何檔案，則屬性會為零 (0)。  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得用來等候這個 <see cref="T:System.Threading.Tasks.Task" /> 的 awaiter。</summary>
        <returns>awaiter 執行個體。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法僅供編譯器使用，而不是應用程式程式碼中使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的 ID。</summary>
        <value>系統指派給這個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的識別項。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作識別碼皆依需求，並不一定代表哪一項工作中建立執行個體的順序。 請注意，雖然衝突情況非常罕見，工作識別碼不保證是唯一的。  
  
 若要取得這項工作正在執行的程式碼中，將從目前執行之工作的工作識別碼，請使用<xref:System.Threading.Tasks.Task.CurrentId%2A>屬性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體是否因取消才完成執行。</summary>
        <value>如果工作是由於取消而完成則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Threading.Tasks.Task>將在完成<xref:System.Threading.Tasks.TaskStatus.Canceled>任何下列的情況下的狀態：  
  
-   其<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A>已標示為取消之前在工作開始執行，  
  
-   工作確認取消要求，在其已收到信號<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A>藉由擲回<xref:System.OperationCanceledException>，與相同<xref:System.Threading.CancellationToken>。  
  
-   工作確認取消要求，在其已收到信號<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A>藉由呼叫<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>方法<xref:System.Threading.CancellationToken>。  
  
> [!IMPORTANT]
>  擷取的值<xref:System.Threading.Tasks.Task.IsCanceled%2A>屬性不會封鎖呼叫執行緒，直到工作完成為止。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個 <see cref="T:System.Threading.Tasks.Task" /> 是否已完成。</summary>
        <value>如果工作已完成則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.IsCompleted%2A> 會傳回`true`當工作處於其中三種最終狀態： <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>， <xref:System.Threading.Tasks.TaskStatus.Faulted>，或<xref:System.Threading.Tasks.TaskStatus.Canceled>。  
  
> [!IMPORTANT]
>  擷取的值<xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType>屬性不會封鎖呼叫執行緒，直到工作完成為止。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Threading.Tasks.Task" /> 是否因未處理的例外狀況才完成。</summary>
        <value>如果工作擲回未處理的例外狀況則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Threading.Tasks.Task.IsFaulted%2A>已`true`，工作<xref:System.Threading.Tasks.Task.Status%2A>等於<xref:System.Threading.Tasks.TaskStatus.Faulted>，並將其<xref:System.Threading.Tasks.Task.Exception%2A>屬性為非 null。  
  
> [!IMPORTANT]
>  擷取的值<xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType>屬性不會封鎖呼叫執行緒，直到工作完成為止。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將指定在 ThreadPool 執行工作排入佇列，並傳回該工作的工作或 <see cref="T:System.Threading.Tasks.Task`1" /> 控制代碼。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A>方法提供一組容易使用的預設值啟動工作的多載。 它是輕量級替代方案<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>多載。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">要以非同步方式執行的工作</param>
        <summary>將指定在執行緒集區執行工作排入佇列，並傳回代表該工作的 <see cref="T:System.Threading.Tasks.Task" /> 物件。</summary>
        <returns>表示已進入佇列要在 ThreadPool 中執行之工作 (work) 的工作 (task)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A>方法可讓您建立和執行單一方法呼叫中的工作，而且是簡單的替代方案<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>方法。 它會使用下列預設值建立一項工作：  
  
-   其取消語彙基元是<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>。  
  
-   其<xref:System.Threading.Tasks.Task.CreationOptions%2A>屬性值是<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。  
  
-   它會使用預設工作排程器。  
  
 如需處理工作作業所擲回的例外狀況資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
   
  
## Examples  
 下列範例會定義`ShowThreadInfo`方法，以顯示<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>目前執行緒。 它會直接從應用程式執行緒呼叫，並從呼叫<xref:System.Action>委派傳遞至<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 下列範例是類似於上一個，不同之處在於它使用 lambda 運算式來定義工作可執行的程式碼。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 範例將示範非同步工作是在不同於主應用程式執行緒的執行緒上執行。  
  
 若要呼叫<xref:System.Threading.Tasks.Task.Wait%2A>方法可確保工作完成，並顯示其應用程式結束前的輸出。 否則，它有可能，`Main`方法將會在工作完成之前完成。  
  
 下列範例說明<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法。 它會定義目錄名稱的陣列，並啟動個別的工作，來擷取每個目錄中的檔案名稱。 所有工作將檔案名稱都寫入單一<xref:System.Collections.Concurrent.ConcurrentBag%601>物件。 此範例接著會呼叫<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>方法，以確保所有工作完成時，，，然後顯示 檔案名稱寫入總數的計數<xref:System.Collections.Concurrent.ConcurrentBag%601>物件。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">要以非同步方式執行的工作</param>
        <summary>將指定在執行緒集區執行的工作排入佇列，並傳回 <paramref name="function" /> 所傳回之工作的 Proxy。</summary>
        <returns>表示 <paramref name="function" /> 所傳回工作之 Proxy 的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理工作作業所擲回的例外狀況資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">要以非同步方式執行的工作</param>
        <param name="cancellationToken">可以用來取消工作的取消語彙基元</param>
        <summary>將指定在執行緒集區執行工作排入佇列，並傳回代表該工作的 <see cref="T:System.Threading.Tasks.Task" /> 物件。 取消語彙基元允許取消工作。</summary>
        <returns>表示已進入佇列，並要在執行緒集區中執行之工作 (work) 的工作 (task)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果工作開始執行之前，已要求取消，則不會執行工作。 改為設定為<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態，並擲回<xref:System.Threading.Tasks.TaskCanceledException>例外狀況。  
  
 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29>方法是簡單的替代方案<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>方法。 它會使用下列預設值建立一項工作：  
  
-   其<xref:System.Threading.Tasks.Task.CreationOptions%2A>屬性值是<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。  
  
-   它會使用預設工作排程器。  
  
 如需處理工作作業所擲回的例外狀況資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29>方法用來建立的工作，會逐一查看 C:\Windows\System32 目錄中的檔案。 Lambda 運算式呼叫<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法來新增每個檔案的相關資訊<xref:System.Collections.Generic.List%601>物件。 每個中斷連結的巢狀的工作所叫用<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>迴圈會檢查的取消語彙基元的狀態，以及如果要求取消，則會呼叫<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>方法。 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>方法會擲回<xref:System.OperationCanceledException>會在處理的例外狀況`catch`封鎖呼叫執行緒呼叫時<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">已取消這項工作。</exception>
        <exception cref="T:System.ObjectDisposedException">與 <paramref name="cancellationToken" /> 相關聯的 <see cref="T:System.Threading.CancellationTokenSource" /> 已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">要以非同步方式執行的工作。</param>
        <param name="cancellationToken">應該用來取消工作的取消語彙基元。</param>
        <summary>將指定在執行緒集區執行的工作排入佇列，並傳回 <paramref name="function" /> 所傳回之工作的 Proxy。</summary>
        <returns>表示 <paramref name="function" /> 所傳回工作之 Proxy 的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理工作作業所擲回的例外狀況資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">已取消這項工作。</exception>
        <exception cref="T:System.ObjectDisposedException">與 <paramref name="cancellationToken" /> 相關聯的 <see cref="T:System.Threading.CancellationTokenSource" /> 已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Proxy 工作傳回的結果類型。</typeparam>
        <param name="function">要以非同步方式執行的工作</param>
        <summary>將指定在執行緒集區執行的工作排入佇列，並傳回 <paramref name="function" /> 所傳回之 <see langword="Task(TResult)" /> 的 Proxy。</summary>
        <returns>
          <see langword="Task(TResult)" />，代表 <see langword="Task(TResult)" /> 所傳回之 <paramref name="function" /> 的 Proxy。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理工作作業所擲回的例外狀況資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">工作的傳回型別。</typeparam>
        <param name="function">要以非同步方式執行的工作。</param>
        <summary>將指定在執行緒集區執行工作排入佇列，並傳回代表該工作的 <see cref="T:System.Threading.Tasks.Task`1" /> 物件。</summary>
        <returns>代表已排入佇列要在執行緒集區中執行之工作 (work) 的工作 (task) 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A>方法是簡單的替代方案<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType>方法。 它會使用下列預設值建立一項工作：  
  
-   其取消語彙基元是<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>。  
  
-   其<xref:System.Threading.Tasks.Task.CreationOptions%2A>屬性值是<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。  
  
-   它會使用預設工作排程器。  
  
 如需處理工作作業所擲回的例外狀況資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
   
  
## Examples  
 下列範例會計算文字在代表已發行活頁簿的文字檔案中的近似數目。 每個工作負責開啟檔案，以非同步的方式，讀取其完整內容，而且使用規則運算式來計算字數統計。 <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>會呼叫方法，以確保所有工作已都完成之前向主控台顯示每本書的字數。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 規則運算式`\p{P}*\s+`比對零個、 一個或多個標點符號字元，後面接著一或多個空格字元。 它會假設的相符項目總數等於大約字數。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 參數為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Proxy 工作傳回的結果類型。</typeparam>
        <param name="function">要以非同步方式執行的工作</param>
        <param name="cancellationToken">應該用來取消工作的取消語彙基元</param>
        <summary>將指定在執行緒集區執行的工作排入佇列，並傳回 <paramref name="function" /> 所傳回之 <see langword="Task(TResult)" /> 的 Proxy。</summary>
        <returns>
          <see langword="Task(TResult)" />，代表 <see langword="Task(TResult)" /> 所傳回之 <paramref name="function" /> 的 Proxy。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需處理工作作業所擲回的例外狀況資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">已取消這項工作。</exception>
        <exception cref="T:System.ObjectDisposedException">與 <paramref name="cancellationToken" /> 相關聯的 <see cref="T:System.Threading.CancellationTokenSource" /> 已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">工作的結果類型。</typeparam>
        <param name="function">要以非同步方式執行的工作</param>
        <param name="cancellationToken">應該用來取消工作的取消語彙基元</param>
        <summary>將指定在執行緒集區執行工作排入佇列，並傳回代表該工作的 <see langword="Task(TResult)" /> 物件。 取消語彙基元允許取消工作。</summary>
        <returns>
          <see langword="Task(TResult)" />，代表已排入佇列要在執行緒集區中執行的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果工作開始執行之前，已要求取消，則不會執行工作。 改為設定為<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態，並擲回<xref:System.Threading.Tasks.TaskCanceledException>例外狀況。  
  
 <xref:System.Threading.Tasks.Task.Run%2A>方法是簡單的替代方案<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>方法。 它會使用下列預設值建立一項工作：  
  
-   其<xref:System.Threading.Tasks.Task.CreationOptions%2A>屬性值是<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。  
  
-   它會使用預設工作排程器。  
  
 如需處理工作作業所擲回的例外狀況資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
   
  
## Examples  
 下列範例會建立 20 會執行迴圈，直到計數器會遞增為 2 百萬個值的工作。 當的前 10 個工作達到 2 百萬個，已取消的取消語彙基元，並取消其計數器尚未到達 2 百萬個的任何工作。 此範例示範可能的輸出。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 而不是使用<xref:System.AggregateException.InnerExceptions%2A>屬性可檢查例外狀況，此範例會逐一查看所有的工作，以決定它已順利完成和它已取消。 對於已完成，它會顯示工作所傳回的值。  
  
 取消是合作式的因為每個工作可以決定如何回應取消。 下列範例是第一個，類似，只不過當取消語彙基元，則工作會傳回它們已經完成而不是擲回例外狀況的次數。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 此範例仍然必須處理<xref:System.AggregateException>例外狀況，因為任何尚未開始時已要求取消的工作仍會擲回的例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">已取消這項工作。</exception>
        <exception cref="T:System.ObjectDisposedException">與 <paramref name="cancellationToken" /> 相關聯的 <see cref="T:System.Threading.CancellationTokenSource" /> 已經處置。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在目前的 <see cref="T:System.Threading.Tasks.Task" /> 上同步執行 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在目前的 <see cref="T:System.Threading.Tasks.Task" /> 上同步執行 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般情況下，工作會在執行緒集區執行緒上以非同步方式執行，並不會封鎖呼叫執行緒。 藉由呼叫執行的工作<xref:System.Threading.Tasks.Task.RunSynchronously>方法會關聯到目前<xref:System.Threading.Tasks.TaskScheduler>並且會在呼叫執行緒上執行。 如果目標排程器不支援呼叫的執行緒上執行這項工作中，將排程工作，以便在排程器上執行，並呼叫的執行緒會封鎖，直到工作已完成執行為止。 即使工作是以同步方式執行，仍應該呼叫呼叫的執行緒<xref:System.Threading.Tasks.Task.Wait%2A>處理工作可能會擲回任何例外狀況。  如需有關例外狀況處理的詳細資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
 藉由呼叫執行的工作<xref:System.Threading.Tasks.Task.RunSynchronously%2A>方法會藉由呼叫具現化<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>類別建構函式。 以同步方式執行工作必須在<xref:System.Threading.Tasks.TaskStatus.Created>狀態。 工作可能會啟動，並只執行一次。 若要排程的工作例外狀況的第二個階段結果的任何嘗試。  
  
   
  
## Examples  
 下列範例會比較工作，藉由呼叫執行<xref:System.Threading.Tasks.Task.RunSynchronously%2A>與其中一個以非同步方式執行的方法。 在這兩種情況下，工作會執行相同的 lambda 運算式，顯示工作識別碼和執行緒的 ID 上執行工作。 工作計算介於 1 到 1000000 之間的整數的總和。 如範例輸出所示，工作會執行呼叫<xref:System.Threading.Tasks.Task.RunSynchronously%2A>上應用程式執行緒，而非同步工作並不會執行的方法。  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 執行個體已經過處置。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> 不是處於有效的啟動狀態。 它可能已經啟動、執行或取消，也可能已透過不支援直接排程的方式建立。</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">排程器，要嘗試在其上以內嵌方式執行這個工作。</param>
        <summary>在提供的 <see cref="T:System.Threading.Tasks.Task" /> 上同步執行 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 藉由呼叫執行的工作<xref:System.Threading.Tasks.Task.RunSynchronously%2A>方法會藉由呼叫具現化<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>類別建構函式。 以同步方式執行工作必須在<xref:System.Threading.Tasks.TaskStatus.Created>狀態。 工作可能會啟動，並只執行一次。 若要排程的工作例外狀況的第二個階段結果的任何嘗試。  
  
 如果目標排程器不支援目前的執行緒上執行這項工作中，將排程工作，以便在排程器上執行，並會封鎖目前的執行緒，直到工作已完成執行。 因為這個緣故，呼叫的執行緒不會不需要呼叫方法，例如<xref:System.Threading.Tasks.Task.Wait%2A>以確保工作已完成執行。 如需有關工作作業的例外狀況處理的詳細資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 執行個體已經過處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> 不是處於有效的啟動狀態。 它可能已經啟動、執行或取消，也可能已透過不支援直接排程的方式建立。</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>啟動 <see cref="T:System.Threading.Tasks.Task" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>啟動 <see cref="T:System.Threading.Tasks.Task" />，並排定它在目前的 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作可能會啟動，並只執行一次。 第二次排程工作的任何嘗試都會導致例外狀況。  
  
 <xref:System.Threading.Tasks.Task.Start%2A>用來執行的工作，藉由呼叫其中一個已建立<xref:System.Threading.Tasks.Task>建構函式。 一般而言，您執行這項操作時，您需要將工作的建立，其執行，例如當您有條件地執行您已建立的工作。 對於較常見的案例，您不需要個別執行的工作具現化，我們建議您呼叫的多載<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>或<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法。  
  
 如需處理工作作業所擲回的例外狀況資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29>建構函式來具現化新<xref:System.Threading.Tasks.Task>物件，會顯示其工作識別碼和 managed 的執行緒識別碼，並接著就執行迴圈。 然後它會呼叫<xref:System.Threading.Tasks.Task.Start%2A>方法來執行工作。  由於這是主控台應用程式，以呼叫<xref:System.Threading.Tasks.Task.Wait%2A>方法是為了防止應用程式終止之前執行的工作完成。  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 執行個體已經過處置。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> 不是處於有效的啟動狀態。 它可能已經啟動、執行或取消，也可能已透過不支援直接排程的方式建立。</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">要與這個工作產生關聯，並用於執行這個工作的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>啟動 <see cref="T:System.Threading.Tasks.Task" />，並排定它在指定的 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 工作可能只會啟動，只執行一次。 第二次排程工作的任何嘗試都會導致例外狀況。  
  
 如需處理工作作業所擲回的例外狀況資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> 不是處於有效的啟動狀態。 它可能已經啟動、執行或取消，也可能已透過不支援直接排程的方式建立。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 執行個體已經過處置。</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">排程器無法將這項工作排入佇列。</exception>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個工作的 <see cref="T:System.Threading.Tasks.TaskStatus" />。</summary>
        <value>這個工作執行個體目前的 <see cref="T:System.Threading.Tasks.TaskStatus" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 擷取的值<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>屬性不會封鎖呼叫執行緒，直到工作完成為止。  
  
 如需詳細資訊和範例，請參閱 <<c0> [ 使用接續工作鏈結工作](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)並[如何： 取消工作及其子系](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)。  
  
   
  
## Examples  
 下列範例會建立 20 會執行迴圈，直到計數器會遞增為 2 百萬個值的工作。 當的前 10 個工作達到 2 百萬個，已取消的取消語彙基元，並取消其計數器尚未到達 2 百萬個的任何工作。 此範例接著會檢查<xref:System.Threading.Tasks.Task.Status%2A>屬性指出是否已順利完成，或已取消每項工作。 對於已完成，它會顯示工作所傳回的值。  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Threading.WaitHandle" />，這個項目可用來等候工作完成。</summary>
        <value>
          <see cref="T:System.Threading.WaitHandle" />，可用來等候工作完成。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用所提供的等候功能<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>最好使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>來執行類似功能。 如需詳細資訊，請參閱中的 「 工作正在等候 」 一節[工作式非同步程式設計](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)並[使用具有其他非同步模式的 TPL](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得作業是否已同步完成的指示。</summary>
        <value>如果作業同步完成，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>等候 <see cref="T:System.Threading.Tasks.Task" /> 完成執行。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>等候 <see cref="T:System.Threading.Tasks.Task" /> 完成執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A> 會造成呼叫執行緒等候，直到目前的工作已完成同步處理方法。 如果目前的工作尚未啟動執行，等候方法會嘗試從排程器中移除此工作，並執行它內嵌在目前的執行緒上。 如果無法這麼做，或目前的工作已經開始執行，它會封鎖呼叫執行緒直到工作完成。 如需詳細資訊，請參閱 < [Task.Wait 和 「 內嵌 」](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx)中平行程式設計與.NET 部落格。  
  
 如需詳細資訊和範例，請參閱 <<c0> [ 如何： 等候一個或多個工作完成](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374)。  
  
   
  
## Examples  
 下列範例會啟動的工作，會產生介於 0 到 100 之間的 1 百萬個亂數，並計算其平均值。 此範例會使用<xref:System.Threading.Tasks.Task.Wait%2A>方法，以確保應用程式終止之前，工作會完成。 否則因為這是一個主控台應用程式時，範例會終止之前的工作可以計算並顯示平均值。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.AggregateException">工作已取消。 <see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 物件。  
  
-或- 
在工作執行期間擲回例外狀況。 <see cref="P:System.AggregateException.InnerExceptions" /> 集合包含例外狀況的相關資訊。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>等待 <see cref="T:System.Threading.Tasks.Task" /> 在指定的毫秒數內完成執行。</summary>
        <returns>如果 <see langword="true" /> 在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> 是一種同步處理方法造成呼叫執行緒等待目前的工作執行個體完成，直到發生下列其中一項：  
  
-   在工作順利完成。  
  
-   工作本身已取消或擲回例外狀況。 在此情況下，您處理<xref:System.AggregateException>例外狀況。 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>屬性包含有關例外狀況或例外狀況詳細資料。  
  
-   所定義的間隔`millisecondsTimeout`耗盡。 在此情況下，目前的執行緒會繼續執行，而且此方法會傳回`false`。  
  
   
  
## Examples  
 下列範例會啟動的工作，會產生 5 百萬個隨機整數，介於 0 到 100 之間，並計算其平均值。 此範例會使用<xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>方法等候 150 毫秒內完成應用程式。 如果應用程式正常完成，工作會顯示 sum 和它產生隨機數字的平均值。 如果經過逾時間隔，這個範例會顯示一則訊息，它終止之前。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.AggregateException">工作已取消。 <see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 物件。  
  
-或- 
在工作執行期間擲回例外狀況。 <see cref="P:System.AggregateException.InnerExceptions" /> 集合包含例外狀況的相關資訊。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">等候工作完成時要觀察的取消語彙基元。</param>
        <summary>等候 <see cref="T:System.Threading.Tasks.Task" /> 完成執行。 如果在工作完成之前取消語彙基元已取消，則等候會終止。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>方法會建立可取消等待，也就是它會導致目前的執行緒等候，直到發生下列其中一項：  
  
-   在工作完成。  
  
-   已取消的取消語彙基元。 在此情況下，呼叫<xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>方法會擲回<xref:System.OperationCanceledException>。  
  
> [!NOTE]
>  正在取消`cancellationToken`取消語彙基元已不會影響執行中的工作，除非它也被傳遞取消語彙基元，而且已準備好處理取消作業。 傳遞`cancellationToken`物件給此方法只可取消等待。  
  
   
  
## Examples  
 下列範例說明簡單的使用取消語彙基元取消等待工作完成。 工作啟動時，會呼叫<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>方法來取消任何語彙基元來源取消語彙基元，然後延遲五秒。 請注意，工作本身不被傳遞取消語彙基元，便無法取消。 應用程式執行緒呼叫的工作<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>方法等候工作完成，但是等候已取消後已取消的取消語彙基元和<xref:System.OperationCanceledException>就會擲回。 例外狀況處理常式回報例外狀況，並接著會進入睡眠狀態六秒。 如範例輸出所示，這種延遲可讓工作在完成<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">已取消 <paramref name="cancellationToken" />。</exception>
        <exception cref="T:System.ObjectDisposedException">此工作已經處置。</exception>
        <exception cref="T:System.AggregateException">工作已取消。 <see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 物件。  
  
-或- 
在工作執行期間擲回例外狀況。 <see cref="P:System.AggregateException.InnerExceptions" /> 集合包含例外狀況的相關資訊。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</param>
        <summary>等待 <see cref="T:System.Threading.Tasks.Task" /> 在指定的時間間隔內完成執行。</summary>
        <returns>如果 <see langword="true" /> 在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> 是一種同步處理方法造成呼叫執行緒等待目前的工作執行個體完成，直到發生下列其中一項：  
  
-   在工作順利完成。  
  
-   工作本身已取消或擲回例外狀況。 在此情況下，您處理<xref:System.AggregateException>例外狀況。 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>屬性包含有關例外狀況或例外狀況詳細資料。  
  
-   所定義的間隔`timeout`耗盡。 在此情況下，目前的執行緒會繼續執行，而且此方法會傳回`false`。  
  
   
  
## Examples  
 下列範例會啟動的工作，會產生 5 百萬個隨機整數，介於 0 到 100 之間，並計算其平均值。 此範例會使用<xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>方法等候 150 毫秒內完成應用程式。 如果應用程式正常完成，工作會顯示 sum 和它產生隨機數字的平均值。 如果經過逾時間隔，這個範例會顯示一則訊息，它終止之前。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。 
-或- 
 <paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.AggregateException">工作已取消。 <see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 物件。  
  
-或- 
在工作執行期間擲回例外狀況。 <see cref="P:System.AggregateException.InnerExceptions" /> 集合包含例外狀況的相關資訊。</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="cancellationToken">等候工作完成時要觀察的取消語彙基元。</param>
        <summary>等候 <see cref="T:System.Threading.Tasks.Task" /> 完成執行。 如果在工作完成之前經過逾時間隔或取消語彙基元已取消，則等候會終止。</summary>
        <returns>如果 <see langword="true" /> 在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> 是一種同步處理方法造成呼叫執行緒等待目前的工作執行個體完成，直到發生下列其中一項：  
  
-   在工作順利完成。  
  
-   工作本身已取消或擲回例外狀況。 在此情況下，您處理<xref:System.AggregateException>例外狀況。 <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>屬性包含有關例外狀況或例外狀況詳細資料。  
  
-   `cancellationToken`取消語彙基元已取消。 在此情況下，呼叫<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>方法會擲回<xref:System.OperationCanceledException>。  
  
-   所定義的間隔`millisecondsTimeout`耗盡。 在此情況下，目前的執行緒會繼續執行，而且此方法會傳回`false`。  
  
> [!NOTE]
>  正在取消`cancellationToken`取消語彙基元已不會影響執行中的工作，除非它也被傳遞取消語彙基元，而且已準備好處理取消作業。 傳遞`cancellationToken`物件給此方法只允許取消等待基礎上的某些條件。  
  
   
  
## Examples  
 下列範例會呼叫<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>方法，以提供的逾時值和取消語彙基元可以結束等候工作完成。 新的執行緒已啟動並執行`CancelToken`方法，其中會暫停，然後呼叫<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>方法來取消取消語彙基元。 工作是然後啟動，就會延遲 5 秒鐘。 <xref:System.Threading.Tasks.Task.Wait%2A>方法接著會呼叫等待工作完成，並提供簡短的逾時值和取消語彙基元。  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 請注意，範例的精確輸出取決於是否在等候已取消的取消語彙基元因為或經過逾時間隔。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">已取消 <paramref name="cancellationToken" />。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.AggregateException">工作已取消。 <see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 物件。  
  
-或- 
在工作執行期間擲回例外狀況。 <see cref="P:System.AggregateException.InnerExceptions" /> 集合包含例外狀況的相關資訊。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>等候所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</param>
        <summary>等候所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會啟動 10 個工作，其中每個被當做狀態物件中的索引。 使用索引的兩到五個工作擲回例外狀況。 若要在呼叫<xref:System.Threading.Tasks.Task.WaitAll%2A>方法會包裝中的所有例外狀況<xref:System.AggregateException>物件，並將它傳播到呼叫的執行緒。  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="tasks" /> 中的一個或多個 <see cref="T:System.Threading.Tasks.Task" /> 物件已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引數包含 null 項目。  
  
-或- 
<paramref name="tasks" /> 引數是空的陣列。</exception>
        <exception cref="T:System.AggregateException">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體已取消。 如果工作已取消，<see cref="T:System.AggregateException" /> 例外狀況會在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" /> 例外狀況。  
  
-或- 
至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體在執行期間擲回例外狀況。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</param>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>等待所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的毫秒數內完成執行。</summary>
        <returns>如果所有 <see langword="true" /> 執行個體在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="tasks" /> 中的一個或多個 <see cref="T:System.Threading.Tasks.Task" /> 物件已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體已取消。 如果工作已取消，<see cref="T:System.AggregateException" /> 會在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。  
  
-或- 
至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體在執行期間擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引數包含 null 項目。  
  
-或- 
<paramref name="tasks" /> 引數是空的陣列。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</param>
        <param name="cancellationToken">等候工作完成時要觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>等候所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken`引數用來取消之等候作業。 取消的工作是相異的作業，並收到<xref:System.AggregateException>如先前所述。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">已取消 <paramref name="cancellationToken" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體已取消。 如果工作已取消，<see cref="T:System.AggregateException" /> 會在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。  
  
-或- 
至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體在執行期間擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引數包含 null 項目。  
  
-或- 
<paramref name="tasks" /> 引數是空的陣列。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="tasks" /> 中的一個或多個 <see cref="T:System.Threading.Tasks.Task" /> 物件已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</param>
        <summary>等候所有提供的可取消 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的時間間隔內完成執行。</summary>
        <returns>如果所有 <see langword="true" /> 執行個體在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="tasks" /> 中的一個或多個 <see cref="T:System.Threading.Tasks.Task" /> 物件已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體已取消。 如果工作已取消，<see cref="T:System.AggregateException" /> 會在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。  
  
-或- 
至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體在執行期間擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。 
-或- 
 <paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引數包含 null 項目。  
  
-或- 
<paramref name="tasks" /> 引數是空的陣列。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</param>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="cancellationToken">等候工作完成時要觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>等待所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的毫秒數內完成執行。</summary>
        <returns>如果所有 <see langword="true" /> 執行個體在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken`引數用來取消之等候作業。 取消的工作是相異的作業，並收到<xref:System.AggregateException>先前所述。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="tasks" /> 中的一個或多個 <see cref="T:System.Threading.Tasks.Task" /> 物件已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.AggregateException">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體已取消。 如果工作已取消，<see cref="T:System.AggregateException" /> 會在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。  
  
-或- 
至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體在執行期間擲回例外狀況。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引數包含 null 項目。  
  
-或- 
<paramref name="tasks" /> 引數是空的陣列。</exception>
        <exception cref="T:System.OperationCanceledException">已取消 <paramref name="cancellationToken" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>等候任一提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</param>
        <summary>等候任一提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</summary>
        <returns>
          <paramref name="tasks" /> 陣列中已完成之 <see cref="T:System.Threading.Tasks.Task" /> 的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會啟動五個工作，其中每個會睡 50 毫秒的最小值或最大為 1050 （毫秒）。 <xref:System.Threading.Tasks.Task.WaitAny%2A>方法接著等候所有工作完成。 此範例會顯示已結束等候工作的工作識別碼，以及所有工作的目前狀態。  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引數包含 null 項目。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</param>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>等候所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的毫秒數內完成執行。</summary>
        <returns>
          <paramref name="tasks" /> 陣列引數中已完成工作的索引；如果發生逾時，則為 -1。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引數包含 null 項目。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</param>
        <param name="cancellationToken">等候工作完成時要觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>等候所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</summary>
        <returns>
          <paramref name="tasks" /> 陣列引數中已完成工作的索引。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引數包含 null 項目。</exception>
        <exception cref="T:System.OperationCanceledException">已取消 <paramref name="cancellationToken" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</param>
        <summary>等候其中任何一個提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的時間間隔內完成執行。</summary>
        <returns>
          <paramref name="tasks" /> 陣列引數中已完成工作的索引；如果發生逾時，則為 -1。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。 
-或- 
 <paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引數包含 null 項目。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</param>
        <param name="millisecondsTimeout">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="cancellationToken">等候工作完成時要觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</param>
        <summary>等待所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的毫秒數內完成執行。</summary>
        <returns>
          <paramref name="tasks" /> 陣列引數中已完成工作的索引；如果發生逾時，則為 -1。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> 已經處置。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> 引數包含 null 項目。</exception>
        <exception cref="T:System.OperationCanceledException">已取消 <paramref name="cancellationToken" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立當所有提供的工作完成時才會完成的工作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">要等待完成的工作。</param>
        <summary>建立一個工作，當可列舉集合中的所有 <see cref="T:System.Threading.Tasks.Task" /> 物件完成時，會完成此工作。</summary>
        <returns>工作，代表所有提供的工作已完成。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Threading.Tasks.Task.WhenAll%2A>方法會傳回<xref:System.Threading.Tasks.Task>您感興趣的一組工作的狀態或一組工作所擲回的例外狀況時，通常會呼叫物件。  
  
> [!NOTE]
>  若要呼叫<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>方法不會封鎖呼叫執行緒。  
  
 如果任何提供的工作完成處於錯誤狀態時，傳回的工作也會完成在<xref:System.Threading.Tasks.TaskStatus.Faulted>其例外狀況會在其中包含未包裝的例外狀況，從每個提供的工作集的彙總的狀態。  
  
 如果沒有提供的工作發生錯誤，但至少其中一個已取消，則傳回的工作便會在結束<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。  
  
 如果沒有任何工作發生錯誤，則工作已取消，產生的工作便會在結束<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。  
  
 如果提供陣列/可列舉不包含任何工作，傳回的工作就會立即轉換成<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態，再將它傳回給呼叫端。  
  
   
  
## Examples  
 下列範例會建立一組的陣列中的 Url 執行 ping 命令的工作。 這些工作會儲存在`List<Task>`集合傳遞給<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>方法。 若要在呼叫之後<xref:System.Threading.Tasks.Task.Wait%2A>方法可確保所有的執行緒已完成，此範例會檢查<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>屬性來判斷是否有錯誤的任何工作。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" />集合包含 <see langword="null" /> 工作。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">要等待完成的工作。</param>
        <summary>建立一個工作，當陣列中的所有 <see cref="T:System.Threading.Tasks.Task" /> 物件完成時，會完成此工作。</summary>
        <returns>工作，代表所有提供的工作已完成。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 多載<xref:System.Threading.Tasks.Task.WhenAll%2A>方法會傳回<xref:System.Threading.Tasks.Task>您感興趣的一組工作的狀態或一組工作所擲回的例外狀況時，通常會呼叫物件。  
  
> [!NOTE]
>  若要呼叫<xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29>方法不會封鎖呼叫執行緒。  
  
 如果任何提供的工作完成處於錯誤狀態時，傳回的工作也會完成在<xref:System.Threading.Tasks.TaskStatus.Faulted>其例外狀況會在其中包含未包裝的例外狀況，從每個提供的工作集的彙總的狀態。  
  
 如果沒有提供的工作發生錯誤，但至少其中一個已取消，則傳回的工作便會在結束<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。  
  
 如果沒有任何工作發生錯誤，則工作已取消，產生的工作便會在結束<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。  
  
 如果提供陣列/可列舉不包含任何工作，傳回的工作就會立即轉換成<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態，再將它傳回給呼叫端。  
  
   
  
## Examples  
 下列範例會建立一組的陣列中的 Url 執行 ping 命令的工作。 這些工作會儲存在`List<Task>`集合轉換成陣列，並傳遞至<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>方法。 若要在呼叫之後<xref:System.Threading.Tasks.Task.Wait%2A>方法可確保所有的執行緒已完成，此範例會檢查<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>屬性來判斷是否有錯誤的任何工作。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" />陣列包含 <see langword="null" /> 工作。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">完成的工作類型。</typeparam>
        <param name="tasks">要等待完成的工作。</param>
        <summary>建立一個工作，當可列舉集合中的所有 <see cref="T:System.Threading.Tasks.Task`1" /> 物件完成時，會完成此工作。</summary>
        <returns>工作，代表所有提供的工作已完成。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要呼叫<xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29>方法不會封鎖呼叫執行緒。 不過，所傳回的呼叫<xref:System.Threading.Tasks.Task%601.Result%2A>屬性會封鎖呼叫執行緒。  
  
 如果任何提供的工作完成處於錯誤狀態時，傳回的工作也會完成在<xref:System.Threading.Tasks.TaskStatus.Faulted>其例外狀況會在其中包含未包裝的例外狀況，從每個提供的工作集的彙總的狀態。  
  
 如果沒有提供的工作發生錯誤，但至少其中一個已取消，則傳回的工作便會在結束<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。  
  
 如果沒有任何工作發生錯誤，則工作已取消，產生的工作便會在結束<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。  <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>屬性傳回的工作將會設定為陣列，包含所有以相同順序提供的工作結果，它們所提供 (例如如果輸入工作包含陣列 t1，t2，t3，輸出工作的<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>屬性會傳回`TResult[]`其中`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`。  
  
 如果`tasks`引數包含任何工作，傳回的工作就會立即轉換成<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態，再將它傳回給呼叫端。 傳回`TResult[]`就會是陣列的項目 0。  
  
   
  
## Examples  
 下列範例會建立 10 個工作，其中每個具現化的隨機數字產生器建立 1,000 個介於 1 到 1000 之間的亂數，並計算其平均值。 <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>方法用來延遲具現化的亂數產生器，使它們不會建立具有相同的種子值。 若要在呼叫<xref:System.Threading.Tasks.Task.WhenAll%2A>方法接著會傳回<xref:System.Int64>陣列，其中包含平均值計算每一項工作。 這些會接著用來計算整體的平均數。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 在此情況下，將 10 個個別的工作儲存在<xref:System.Collections.Generic.List%601>物件。 <xref:System.Collections.Generic.List%601> 會實作 <xref:System.Collections.Generic.IEnumerable%601> 介面。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" />集合包含 <see langword="null" /> 工作。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">完成的工作類型。</typeparam>
        <param name="tasks">要等待完成的工作。</param>
        <summary>建立一個工作，當陣列中的所有 <see cref="T:System.Threading.Tasks.Task`1" /> 物件完成時，會完成此工作。</summary>
        <returns>工作，代表所有提供的工作已完成。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要呼叫<xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29>方法不會封鎖呼叫執行緒。 不過，所傳回的呼叫<xref:System.Threading.Tasks.Task%601.Result%2A>屬性會封鎖呼叫執行緒。  
  
 如果任何提供的工作完成處於錯誤狀態時，傳回的工作也會完成在<xref:System.Threading.Tasks.TaskStatus.Faulted>其例外狀況會在其中包含未包裝的例外狀況，從每個提供的工作集的彙總的狀態。  
  
 如果沒有提供的工作發生錯誤，但至少其中一個已取消，則傳回的工作便會在結束<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。  
  
 如果沒有任何工作發生錯誤，則工作已取消，產生的工作便會在結束<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。  <xref:System.Threading.Tasks.Task%601.Result%2A>傳回的工作將會設定為陣列，包含所有以相同順序提供的工作結果，它們所提供 (例如如果輸入工作包含陣列 t1，t2，t3，輸出工作<xref:System.Threading.Tasks.Task%601.Result%2A>會傳回`TResult[]`其中`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`。  
  
 如果提供陣列/可列舉不包含任何工作，傳回的工作就會立即轉換成<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態，再將它傳回給呼叫端。  傳回`TResult[]`就會是陣列的項目 0。  
  
   
  
## Examples  
 下列範例會建立 10 個工作，其中每個具現化的隨機數字產生器建立 1,000 個介於 1 到 1000 之間的亂數，並計算其平均值。 在此情況下，將 10 個個別的工作儲存在`Task<Int64>`陣列。  <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>方法用來延遲具現化的亂數產生器，使它們不會建立具有相同的種子值。 若要在呼叫<xref:System.Threading.Tasks.Task.WhenAll%2A>方法接著會傳回<xref:System.Int64>陣列，其中包含平均值計算每一項工作。 這些會接著用來計算整體的平均數。  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" />陣列包含 <see langword="null" /> 工作。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立當任何一個提供的工作完成時才會完成的工作。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">要等待完成的工作。</param>
        <summary>建立當任何一個提供的工作完成時才會完成的工作。</summary>
        <returns>工作，代表其中一個提供的工作已完成。  傳回的工作結果為已完成的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回的工作會完成時提供的任何的工作已完成。  傳回的工作將一律會在結束`RanToCompletion`狀態設定為第一項工作，以完成其結果。  這是，則為 true，即使在第一個工作完成結束`Canceled`或`Faulted`狀態。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" />陣列包含 null 工作或是空的。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">要等待完成的工作。</param>
        <summary>建立當任何一個提供的工作完成時才會完成的工作。</summary>
        <returns>工作，代表其中一個提供的工作已完成。  傳回的工作結果為已完成的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回的工作會完成時提供的任何的工作已完成。  傳回的工作將一律會在結束`RanToCompletion`狀態及其`Result`設為第一項工作以完成。  這是，則為 true，即使在第一個工作完成結束`Canceled`或`Faulted`狀態。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" />陣列包含 null 工作或是空的。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">完成的工作類型。</typeparam>
        <param name="tasks">要等待完成的工作。</param>
        <summary>建立當任何一個提供的工作完成時才會完成的工作。</summary>
        <returns>工作，代表其中一個提供的工作已完成。  傳回的工作結果為已完成的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回的工作會完成時提供的任何的工作已完成。  一律設為第一項工作以完成其結果與 RanToCompletion 狀態最後傳回的工作。 即使在 「 Canceled 」 或 「 Faulted 狀態中結束的第一個工作完成時，這是 true。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" />陣列包含 null 工作或是空的。</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">完成的工作類型。</typeparam>
        <param name="tasks">要等待完成的工作。</param>
        <summary>建立當任何一個提供的工作完成時才會完成的工作。</summary>
        <returns>工作，代表其中一個提供的工作已完成。  傳回的工作結果為已完成的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回的工作會完成時提供的任何的工作已完成。  一律設為第一項工作以完成其結果與 RanToCompletion 狀態最後傳回的工作。 即使在 「 Canceled 」 或 「 Faulted 狀態中結束的第一個工作完成時，這是 true。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> 引數為 null。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" />陣列包含 null 工作或是空的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立會在等候時以非同步方式遞交 (Yield) 給目前內容的 awaitable 工具。</summary>
        <returns>內容，這個內容會在受到等候時非同步轉換回等候當時的最新內容。 如果目前的 <see cref="T:System.Threading.SynchronizationContext" /> 非 null，即視為目前的內容。 否則，將與目前執行之工作相關聯的工作排程器視為目前的內容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用`await Task.Yield();`中非同步的方法，以強制以非同步方式完成的方法。 如果沒有目前的同步處理內容 (<xref:System.Threading.SynchronizationContext>物件)，這將會公佈回該內容的方法執行的其餘部分。 不過，內容會決定如何設定此工作相對於其他可能在擱置中的工作優先權。 存在於 UI 執行緒大部分的 UI 環境中的同步處理內容通常會排定優先順序高於輸入和轉譯工作的內容發佈的工作。 基於這個理由，請勿依賴`await Task.Yield();`以保留 UI 回應性。  如需詳細資訊，請參閱文章[有用的抽象概念啟用 ContinueWith](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx)中平行程式設計與.NET 部落格。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>