<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="cccf2-101">表示非同步作業。</span><span class="sxs-lookup"><span data-stu-id="cccf2-101">Represents an asynchronous operation.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 <span data-ttu-id="cccf2-102"><xref:System.Threading.Tasks.Task>類別的代表單一作業不會傳回值，而此通常是以非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-102">The <xref:System.Threading.Tasks.Task> class represents a single operation that does not return a value and that usually executes asynchronously.</span></span> <span data-ttu-id="cccf2-103"><xref:System.Threading.Tasks.Task> 物件是其中一個的中央元件[工作架構非同步模式](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)首度引進.NET Framework 4 中。</span><span class="sxs-lookup"><span data-stu-id="cccf2-103"><xref:System.Threading.Tasks.Task> objects are one of the central components of the  [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) first introduced in the .NET Framework 4.</span></span> <span data-ttu-id="cccf2-104">因為工作所執行<xref:System.Threading.Tasks.Task>物件通常是以非同步方式執行的執行緒集區執行緒上而不是以同步方式主應用程式執行緒，您可以使用<xref:System.Threading.Tasks.Task.Status%2A>屬性，並將<xref:System.Threading.Tasks.Task.IsCanceled%2A>， <xref:System.Threading.Tasks.Task.IsCompleted%2A>，和<xref:System.Threading.Tasks.Task.IsFaulted%2A>屬性，以判斷工作的狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-104">Because the work performed by a <xref:System.Threading.Tasks.Task> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <xref:System.Threading.Tasks.Task.Status%2A> property, as well as the <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, and <xref:System.Threading.Tasks.Task.IsFaulted%2A> properties, to determine the   state of a task.</span></span> <span data-ttu-id="cccf2-105">大多數情況下，lambda 運算式用來指定的工作是將執行的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-105">Most commonly, a lambda expression is used to specify the work that the task is to perform.</span></span>  
  
 <span data-ttu-id="cccf2-106">傳回值的作業，您使用<xref:System.Threading.Tasks.Task%601>類別。</span><span class="sxs-lookup"><span data-stu-id="cccf2-106">For operations that return values, you use the <xref:System.Threading.Tasks.Task%601> class.</span></span>  
  
 <span data-ttu-id="cccf2-107">本節內容：</span><span class="sxs-lookup"><span data-stu-id="cccf2-107">In this section:</span></span>  
  
 <span data-ttu-id="cccf2-108">[工作具現化範例](#Instant) </span><span class="sxs-lookup"><span data-stu-id="cccf2-108">[Task instantiation examples](#Instant) </span></span>  
 <span data-ttu-id="cccf2-109">[建立和執行工作](#Creating) </span><span class="sxs-lookup"><span data-stu-id="cccf2-109">[Creating and executing a task](#Creating) </span></span>  
 <span data-ttu-id="cccf2-110">[將工作建立及執行](#Separating) </span><span class="sxs-lookup"><span data-stu-id="cccf2-110">[Separating task creation and execution](#Separating) </span></span>  
 <span data-ttu-id="cccf2-111">[等候一或多個工作完成](#WaitingForOne) </span><span class="sxs-lookup"><span data-stu-id="cccf2-111">[Waiting for one or more tasks to complete](#WaitingForOne) </span></span>  
 <span data-ttu-id="cccf2-112">[工作和文化特性](#Culture) </span><span class="sxs-lookup"><span data-stu-id="cccf2-112">[Tasks and culture](#Culture) </span></span>  
 [<span data-ttu-id="cccf2-113">適用於偵錯工具開發人員</span><span class="sxs-lookup"><span data-stu-id="cccf2-113">For debugger developers</span></span>](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a><span data-ttu-id="cccf2-114">工作具現化</span><span class="sxs-lookup"><span data-stu-id="cccf2-114">Task instantiation</span></span>  
 <span data-ttu-id="cccf2-115">下列範例會建立並執行四項工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-115">The following example creates and executes four tasks.</span></span> <span data-ttu-id="cccf2-116">三個工作執行<xref:System.Action%601>委派名為`action`，它會接受類型的引數<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-116">Three tasks execute an <xref:System.Action%601> delegate named `action`, which accepts an argument of type <xref:System.Object>.</span></span> <span data-ttu-id="cccf2-117">第四個工作執行的 lambda 運算式 (<xref:System.Action>委派) 也就是內嵌定義的工作建立方法的呼叫中。</span><span class="sxs-lookup"><span data-stu-id="cccf2-117">A fourth task executes a lambda expression (an <xref:System.Action> delegate) that is defined inline in the call to the task creation method.</span></span> <span data-ttu-id="cccf2-118">每項工作是具現化，並以不同方式執行：</span><span class="sxs-lookup"><span data-stu-id="cccf2-118">Each task is instantiated and run in a different way:</span></span>  
  
-   <span data-ttu-id="cccf2-119">工作`t1`會藉由呼叫的工作類別建構函式的具現化，但藉由呼叫並啟動其<xref:System.Threading.Tasks.Task.Start>方法只有在工作之後`t2`已啟動。</span><span class="sxs-lookup"><span data-stu-id="cccf2-119">Task `t1` is instantiated by calling a Task class constructor, but is started by calling its <xref:System.Threading.Tasks.Task.Start> method only after task `t2` has started.</span></span>  
  
-   <span data-ttu-id="cccf2-120">工作`t2`會具現化並啟動單一方法呼叫中，藉由呼叫<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-120">Task `t2` is instantiated and started in a single method call by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="cccf2-121">工作`t3`會具現化並啟動單一方法呼叫中，藉由呼叫<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-121">Task `t3` is instantiated and started in a single method call by calling the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span>  
  
-   <span data-ttu-id="cccf2-122">工作`t4`藉由呼叫主執行緒上同步執行<xref:System.Threading.Tasks.Task.RunSynchronously>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-122">Task `t4` is executed synchronously on the main thread by calling the <xref:System.Threading.Tasks.Task.RunSynchronously> method.</span></span>  
  
 <span data-ttu-id="cccf2-123">因為工作`t4`執行以同步方式，它會在主應用程式的執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-123">Because task `t4` executes synchronously, it executes on the main application thread.</span></span> <span data-ttu-id="cccf2-124">其餘的工作以非同步方式執行通常在一或多個執行緒集區執行緒上。</span><span class="sxs-lookup"><span data-stu-id="cccf2-124">The remaining tasks execute asynchronously typically on one or more thread pool threads.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a><span data-ttu-id="cccf2-125">建立和執行工作</span><span class="sxs-lookup"><span data-stu-id="cccf2-125">Creating and executing a task</span></span>  
 <span data-ttu-id="cccf2-126"><xref:System.Threading.Tasks.Task> 可能在各種不同的方式建立執行個體。</span><span class="sxs-lookup"><span data-stu-id="cccf2-126"><xref:System.Threading.Tasks.Task> instances may be created in a variety of ways.</span></span> <span data-ttu-id="cccf2-127">最常見的方法，從開始提供[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，是呼叫靜態<xref:System.Threading.Tasks.Task.Run%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-127">The most common approach, which is available starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], is to call the static <xref:System.Threading.Tasks.Task.Run%2A> method.</span></span> <span data-ttu-id="cccf2-128"><xref:System.Threading.Tasks.Task.Run%2A>方法提供簡單的方式來啟動工作，使用預設值且不需要額外的參數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-128">The <xref:System.Threading.Tasks.Task.Run%2A> method provides a simple way to start a task using default values and without requiring additional parameters.</span></span> <span data-ttu-id="cccf2-129">下列範例會使用<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法啟動的工作，執行迴圈，並接著會顯示迴圈反覆項目數目：</span><span class="sxs-lookup"><span data-stu-id="cccf2-129">The following example uses the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method to start a task that loops and then displays the number of loop iterations:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 <span data-ttu-id="cccf2-130">或者和最常用的方法來啟動工作以[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]，是靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-130">An alternative, and the most common method to start a task in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], is the static <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-131"><xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType>屬性會傳回<xref:System.Threading.Tasks.TaskFactory>物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-131">The <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> property returns a <xref:System.Threading.Tasks.TaskFactory> object.</span></span> <span data-ttu-id="cccf2-132">多載<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法可讓您指定要傳遞給工作建立選項和工作排程器參數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-132">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method let you specify parameters to pass to the task creation options and a task scheduler.</span></span> <span data-ttu-id="cccf2-133">下列範例會使用<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法啟動工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-133">The following example uses the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to start a task.</span></span> <span data-ttu-id="cccf2-134">它在功能上相當於前一個範例中的程式碼。</span><span class="sxs-lookup"><span data-stu-id="cccf2-134">It is functionally equivalent to the code in the previous example.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 <span data-ttu-id="cccf2-135">如需更完整的範例，請參閱[以工作為基礎的非同步程式設計](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-135">For more complete examples, see [Task-based Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).</span></span>  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a><span data-ttu-id="cccf2-136">將工作建立及執行</span><span class="sxs-lookup"><span data-stu-id="cccf2-136">Separating task creation and execution</span></span>  
 <span data-ttu-id="cccf2-137"><xref:System.Threading.Tasks.Task>類別也會提供建構函式所初始化的工作，但的未排程它執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-137">The <xref:System.Threading.Tasks.Task> class also provides constructors that initialize the task but that do not schedule it for execution.</span></span> <span data-ttu-id="cccf2-138">基於效能考量，<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>或<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法為建立和排定計算的工作的慣用的機制，但是其中必須以建立和排程的情況下，您可以使用建構函式，然後呼叫<xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType>方法來排定在稍後執行的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-138">For performance reasons, the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method is the preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation and scheduling must be separated, you can use the constructors and then call the <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> method to schedule the task for execution at a later time.</span></span>  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a><span data-ttu-id="cccf2-139">等候一或多個工作完成</span><span class="sxs-lookup"><span data-stu-id="cccf2-139">Waiting for one or more tasks to complete</span></span>  
 <span data-ttu-id="cccf2-140">工作通常會在執行緒集區執行緒上以非同步方式執行，因為工作具現化時，立即建立並啟動工作的執行緒會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-140">Because tasks typically run asynchronously on a thread pool thread, the thread that creates and starts the task continues execution as soon as the task has been instantiated.</span></span> <span data-ttu-id="cccf2-141">在某些情況下，呼叫的執行緒時，在主應用程式執行緒應用程式可能會在結束任何之前，先工作實際上就會開始執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-141">In some cases, when the calling thread is the main application thread, the app may terminate before any the task actually begins execution.</span></span> <span data-ttu-id="cccf2-142">在其他應用程式的邏輯可能需要呼叫執行緒繼續執行，只有當一或多個工作已完成執行時。</span><span class="sxs-lookup"><span data-stu-id="cccf2-142">In others,   your application's logic may require that the calling thread continue execution only when one or more tasks has completed execution.</span></span> <span data-ttu-id="cccf2-143">您可以在呼叫執行緒執行同步和非同步工作它會啟動藉由呼叫`Wait`方法等候一個或多個工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-143">You can synchronize the execution of the calling thread and the asynchronous tasks it launches by calling a `Wait` method to wait for one or more tasks to complete.</span></span>  
  
 <span data-ttu-id="cccf2-144">若要等候完成單一工作，您可以呼叫其<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-144">To wait for a single task to complete, you can call its <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-145">呼叫<xref:System.Threading.Tasks.Task.Wait%2A>方法會封鎖呼叫執行緒，直到單一類別執行個體已完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-145">A call to the  <xref:System.Threading.Tasks.Task.Wait%2A> method blocks the calling thread until the single class instance has completed execution.</span></span>  
  
 <span data-ttu-id="cccf2-146">下列範例會呼叫無參數<xref:System.Threading.Tasks.Task.Wait>無條件地等候，直到工作完成的方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-146">The following example calls the parameterless <xref:System.Threading.Tasks.Task.Wait> method to wait unconditionally until a task completes.</span></span> <span data-ttu-id="cccf2-147">工作模擬的工作，藉由呼叫<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>兩秒睡眠狀態的方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-147">The task simulates work by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to sleep for two seconds.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 <span data-ttu-id="cccf2-148">您可以也有條件地等待工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-148">You can also conditionally wait for a task to complete.</span></span> <span data-ttu-id="cccf2-149"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>和<xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>方法會封鎖呼叫執行緒，直到工作完成或經過逾時間隔、 何者較早。</span><span class="sxs-lookup"><span data-stu-id="cccf2-149">The  <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> and <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> methods block the calling thread until the task finishes or a timeout interval elapses, whichever comes first.</span></span> <span data-ttu-id="cccf2-150">因為下列範例會啟動兩秒會進入睡眠狀態，但定義了一秒的逾時值，則呼叫執行緒會封鎖直到逾時過期的工作，以及之前工作已完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-150">Since the following example launches a task that sleeps for two seconds but defines a one-second timeout value, the calling thread blocks until the timeout expires and before the task has completed execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 <span data-ttu-id="cccf2-151">您也可以藉由呼叫提供的取消語彙基元<xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>和<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-151">You can also supply a cancellation token by calling the <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> and  <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> methods.</span></span> <span data-ttu-id="cccf2-152">如果此語彙基元的<xref:System.Threading.CancellationToken.IsCancellationRequested%2A>屬性是`true`，等候已取消; 如果它成為 true 時<xref:System.Threading.Tasks.Task.Wait%2A>方法會結束。</span><span class="sxs-lookup"><span data-stu-id="cccf2-152">If the  token's <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true`, the wait is cancelled; if it becomes true while the <xref:System.Threading.Tasks.Task.Wait%2A> method terminates.</span></span>  
  
 <span data-ttu-id="cccf2-153">在某些情況下，您可能想要等待完成，但不執行工作的一系列的第一個是注意這項工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-153">In some cases, you may want to wait for the first of a series of executing tasks to complete, but don't care which task it is.</span></span>  <span data-ttu-id="cccf2-154">基於此目的，您可以呼叫其中一個多載的<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-154">For this purpose, you can call one of the overloads of the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="cccf2-155">下列範例會建立三項工作，其中每個進入睡眠狀態的間隔來判斷隨機號碼產生器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-155">The following example creates three tasks, each of which sleeps for an interval determine by a random number generator.</span></span> <span data-ttu-id="cccf2-156"><xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29>方法會等候第一個工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-156">The <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> method waits for the first task to complete.</span></span> <span data-ttu-id="cccf2-157">然後這個範例會顯示所有三項工作的狀態相關資訊。</span><span class="sxs-lookup"><span data-stu-id="cccf2-157">The example then displays information about the status of all three tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 <span data-ttu-id="cccf2-158">您也可以等待所有的一系列的工作完成藉由呼叫<xref:System.Threading.Tasks.Task.WaitAll%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-158">You can also wait for all of a series of tasks to complete by calling the <xref:System.Threading.Tasks.Task.WaitAll%2A> method.</span></span> <span data-ttu-id="cccf2-159">下列範例會建立十個工作、 等候所有的十個完成，然後顯示其狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-159">The following example creates ten tasks, waits for all ten to complete, and then displays their status.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 <span data-ttu-id="cccf2-160">請注意當您在等候一個或多個工作完成，正在執行的工作中擲回任何例外狀況會傳播呼叫的執行緒上`Wait`方法，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="cccf2-160">Note that when you wait for one or more tasks to complete, any exceptions thrown in the running tasks are propagated on the thread that calls the `Wait` method, as the following example shows.</span></span> <span data-ttu-id="cccf2-161">它會啟動 12 的工作，其中三種正常完成和三個例外狀況的擲回。</span><span class="sxs-lookup"><span data-stu-id="cccf2-161">It launches 12 tasks, three of which complete normally and three of which throw an exception.</span></span> <span data-ttu-id="cccf2-162">其餘的六個工作中，三個會取消開始之前，請而且三個被取消時執行它們。</span><span class="sxs-lookup"><span data-stu-id="cccf2-162">Of the remaining six tasks, three are cancelled before the start, and three are cancelled while they executing.</span></span> <span data-ttu-id="cccf2-163">中擲回例外狀況<xref:System.Threading.Tasks.Task.WaitAll%2A>方法呼叫和都是由處理`try` / `catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="cccf2-163">Exceptions are thrown in the <xref:System.Threading.Tasks.Task.WaitAll%2A> method call and are handled by a `try`/`catch` block.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 <span data-ttu-id="cccf2-164">如需有關在以工作為基礎的非同步作業的例外狀況處理的詳細資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-164">For more information on exception handling in task-based asynchronous operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a><span data-ttu-id="cccf2-165">工作和文化特性</span><span class="sxs-lookup"><span data-stu-id="cccf2-165">Tasks and culture</span></span>  
 <span data-ttu-id="cccf2-166">從桌面應用程式開始目標[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，建立與叫用工作之執行緒的文化特性會成為在執行緒內容的一部分。</span><span class="sxs-lookup"><span data-stu-id="cccf2-166">Starting with desktop apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the thread that creates and invokes a task becomes part of the thread's context.</span></span> <span data-ttu-id="cccf2-167">也就是工作的工作所執行之執行緒的目前文化特性，不論目前的文化特性是工作的呼叫執行緒的文化特性。</span><span class="sxs-lookup"><span data-stu-id="cccf2-167">That is, regardless of the current culture of the thread on which the task executes, the current culture of the task is the culture of the calling thread.</span></span> <span data-ttu-id="cccf2-168">之前的.NET Framework 版本為目標的應用程式[!INCLUDE[net_v46](~/includes/net-v46-md.md)]，工作的文化特性為工作所執行之執行緒的文化特性。</span><span class="sxs-lookup"><span data-stu-id="cccf2-168">For apps that target versions of the .NET Framework prior to the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the task is the culture of the thread on which the task executes.</span></span> <span data-ttu-id="cccf2-169">如需詳細資訊，請參閱中的 < 文化特性和以工作為基礎的非同步作業 」 一節<xref:System.Globalization.CultureInfo>主題。</span><span class="sxs-lookup"><span data-stu-id="cccf2-169">For more information, see the "Culture and task-based asynchronous operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cccf2-170">市集應用程式遵循 Windows 執行階段中設定和取得的預設文化特性。</span><span class="sxs-lookup"><span data-stu-id="cccf2-170">Store apps follow the Windows Runtime in setting and getting the default culture.</span></span>  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a><span data-ttu-id="cccf2-171">適用於偵錯工具開發人員</span><span class="sxs-lookup"><span data-stu-id="cccf2-171">For debugger developers</span></span>  
 <span data-ttu-id="cccf2-172">實作自訂的偵錯工具開發人員的工作數個內部及私人成員可能很有用 （這些可能會變更版本）。</span><span class="sxs-lookup"><span data-stu-id="cccf2-172">For developers implementing custom debuggers, several internal and private members of task may be useful (these may change from release to release).</span></span> <span data-ttu-id="cccf2-173">`m_taskId`欄位做為備份存放區<xref:System.Threading.Tasks.Task.Id%2A>屬性，但是存取此欄位直接從偵錯工具可能會比透過屬性的 getter 方法存取相同的值更有效率 (`s_taskIdCounter`計數器用來擷取工作的下一個可用識別碼。）</span><span class="sxs-lookup"><span data-stu-id="cccf2-173">The `m_taskId` field serves as the backing store for the <xref:System.Threading.Tasks.Task.Id%2A> property, however accessing this field directly from a debugger may be more efficient than accessing the same value through the property's getter method (the `s_taskIdCounter` counter is used to retrieve the next available ID for a task).</span></span> <span data-ttu-id="cccf2-174">同樣地，`m_stateFlags`欄位會儲存目前的生命週期階段資訊的工作，也可以透過存取資訊<xref:System.Threading.Tasks.Task.Status%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="cccf2-174">Similarly, the `m_stateFlags` field stores information about the current lifecycle stage of the task, information also accessible through the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="cccf2-175">`m_action`欄位儲存工作的委派的參考和`m_stateObject`欄位儲存由開發人員要傳遞給工作的非同步狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-175">The `m_action` field stores a reference to the task's delegate, and the `m_stateObject` field stores the async state passed to the task by the developer.</span></span> <span data-ttu-id="cccf2-176">最後，針對剖析堆疊框架的偵錯工具`InternalWait`方法適用於當工作正在進入等候作業的潛在標記。</span><span class="sxs-lookup"><span data-stu-id="cccf2-176">Finally, for debuggers that parse stack frames, the `InternalWait` method serves a potential marker for when a task is entering a wait operation.</span></span>   
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="cccf2-177">所有成員<see cref="T:System.Threading.Tasks.Task" />，除了<see cref="M:System.Threading.Tasks.Task.Dispose" />、 是安全執行緒，且可能會同時使用從多個執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-177">All members of <see cref="T:System.Threading.Tasks.Task" />, except for <see cref="M:System.Threading.Tasks.Task.Dispose" />, are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-178">初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-178">Initializes a new <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="cccf2-179">委派，表示工作中要執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="cccf2-179">The delegate that represents the code to execute in the task.</span></span></param>
        <summary><span data-ttu-id="cccf2-180">使用指定的動作，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-180">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-181">而不是呼叫這個建構函式，最常見的方式，來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType>或<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-181">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-182">這個建構函式所提供的唯一優點是它可讓物件具現化，分隔從工作引動過程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-182">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-183">下列範例會使用<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29>建構函式來建立工作，以擷取的檔名在指定的目錄。</span><span class="sxs-lookup"><span data-stu-id="cccf2-183">The following example uses the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor to create tasks that retrieve the filenames in specified directories.</span></span> <span data-ttu-id="cccf2-184">所有工作的檔案名稱都寫入單一<xref:System.Collections.Concurrent.ConcurrentBag%601>物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-184">All tasks write the file names to a single <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span> <span data-ttu-id="cccf2-185">此範例會接著呼叫<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>方法，以確保所有工作完成，並接著會顯示檔案名稱寫入總數的計數<xref:System.Collections.Concurrent.ConcurrentBag%601>物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-185">The example then calls the <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 <span data-ttu-id="cccf2-186">下列範例是完全相同，不同之處在於它使用<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法具現化，並在單一作業中執行的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-186">The following example is identical, except that it used the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method to instantiate and run the task in a single operation.</span></span> <span data-ttu-id="cccf2-187">方法會傳回<xref:System.Threading.Tasks.Task>代表工作的物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-187">The method returns the <xref:System.Threading.Tasks.Task> object that represents the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-188"><paramref name="action" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-188">The <paramref name="action" /> argument is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="cccf2-189">委派，表示工作中要執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="cccf2-189">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-190">新工作將會觀察的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-190">The <see cref="T:System.Threading.CancellationToken" /> that the new  task will observe.</span></span></param>
        <summary><span data-ttu-id="cccf2-191">使用指定的動作和 <see cref="T:System.Threading.Tasks.Task" />，初始化新的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-191">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and <see cref="T:System.Threading.CancellationToken" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-192">而不是呼叫這個建構函式，最常見的方式，來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>和<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-192">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="cccf2-193">這個建構函式所提供的唯一優點是它可讓物件具現化，分隔從工作引動過程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-193">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 <span data-ttu-id="cccf2-194">如需詳細資訊，請參閱[工作平行處理原則 （工作平行程式庫）](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)和[Managed 執行緒中的取消](~/docs/standard/threading/cancellation-in-managed-threads.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-194">For more information, see [Task Parallelism (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Cancellation in Managed Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-195">下列範例會呼叫<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29>建構函式建立的工作，會逐一查看 C:\Windows\System32 目錄中的檔案。</span><span class="sxs-lookup"><span data-stu-id="cccf2-195">The following example calls the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> constructor to create a task that iterates the files in the C:\Windows\System32 directory.</span></span> <span data-ttu-id="cccf2-196">Lambda 運算式呼叫<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法，將每個檔案的相關資訊<xref:System.Collections.Generic.List%601>物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-196">The lambda expression calls the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to add information about each  file to a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="cccf2-197">每個中斷連結的巢狀的工作所叫用<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>迴圈會檢查的取消語彙基元的狀態，並在要求取消，如果呼叫<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-197">Each detached nested task invoked by the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop checks the state of the cancellation token and, if cancellation is requested, calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-198"><xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>方法會擲回<xref:System.OperationCanceledException>進行處理的例外狀況`catch`封鎖呼叫執行緒呼叫時<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-198">The <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method throws an <xref:System.OperationCanceledException> exception that is handled in a `catch` block when the calling thread calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="cccf2-199"><xref:System.Threading.Tasks.Task.Start%2A>方法接著會呼叫啟動工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-199">The <xref:System.Threading.Tasks.Task.Start%2A> method is then called to start the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-200">已經處置所提供的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-200">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-201"><paramref name="action" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-201">The <paramref name="action" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="cccf2-202">委派，表示工作中要執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="cccf2-202">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="cccf2-203"><see cref="T:System.Threading.Tasks.TaskCreationOptions" />，用於自訂工作的行為。</span><span class="sxs-lookup"><span data-stu-id="cccf2-203">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="cccf2-204">使用指定的動作和建立選項，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-204">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-205">而不是呼叫這個建構函式，最常見的方式，來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-205">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-206">這個建構函式所提供的唯一優點是它可讓物件具現化，分隔從工作引動過程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-206">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-207"><paramref name="action" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-207">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-208"><paramref name="creationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-208">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="cccf2-209">委派，表示工作中要執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="cccf2-209">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-210">物件，表示動作所需的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-210">An object representing data to be used by the action.</span></span></param>
        <summary><span data-ttu-id="cccf2-211">使用指定的動作和狀態，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-211">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-212">而不是呼叫這個建構函式，最常見的方式，來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-212">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-213">這個建構函式所提供的唯一優點是它可讓物件具現化，分隔從工作引動過程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-213">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-214">下列範例會定義陣列 6 字母的文字。</span><span class="sxs-lookup"><span data-stu-id="cccf2-214">The following example defines an array of 6-letter words.</span></span> <span data-ttu-id="cccf2-215">每個字再傳遞做為引數<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29>建構函式，其<xref:System.Action%601>委派的字元，在 word 中，將金鑰加密，則會顯示原始的單字和其變碼的版本。</span><span class="sxs-lookup"><span data-stu-id="cccf2-215">Each word is then passed as an argument to the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> constructor, whose <xref:System.Action%601> delegate scrambles the characters in the word, then displays the original word and its scrambled version.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-216"><paramref name="action" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-216">The <paramref name="action" /> argument is null.</span></span></exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="cccf2-217">委派，表示工作中要執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="cccf2-217">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-218">新工作將會觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-218">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="cccf2-219"><see cref="T:System.Threading.Tasks.TaskCreationOptions" />，用於自訂工作的行為。</span><span class="sxs-lookup"><span data-stu-id="cccf2-219">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="cccf2-220">使用指定的動作和建立選項，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-220">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-221">而不是呼叫這個建構函式，最常見的方式，來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-221">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-222">這個建構函式所提供的唯一優點是它可讓物件具現化，分隔從工作引動過程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-222">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 <span data-ttu-id="cccf2-223">如需詳細資訊，請參閱[工作平行處理原則 （工作平行程式庫）](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)和[工作取消](~/docs/standard/parallel-programming/task-cancellation.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-223">For more information, see [Task Parallelism (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Task Cancellation](~/docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-224">已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-224">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-225"><paramref name="action" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-225">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-226"><paramref name="creationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-226">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="cccf2-227">委派，表示工作中要執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="cccf2-227">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-228">物件，表示動作所需的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-228">An object representing data to be used by the action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-229">新工作將會觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-229">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that that the new task will observe.</span></span></param>
        <summary><span data-ttu-id="cccf2-230">使用指定的動作、狀態和選項，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-230">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-231">而不是呼叫這個建構函式，最常見的方式，來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-231">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-232">這個建構函式所提供的唯一優點是它可讓物件具現化，分隔從工作引動過程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-232">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-233">已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-233">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-234"><paramref name="action" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-234">The <paramref name="action" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="cccf2-235">委派，表示工作中要執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="cccf2-235">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-236">物件，表示動作所需的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-236">An object representing data to be used by the action.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="cccf2-237"><see cref="T:System.Threading.Tasks.TaskCreationOptions" />，用於自訂工作的行為。</span><span class="sxs-lookup"><span data-stu-id="cccf2-237">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="cccf2-238">使用指定的動作、狀態和選項，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-238">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-239">而不是呼叫這個建構函式，最常見的方式，來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-239">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-240">這個建構函式所提供的唯一優點是它可讓物件具現化，分隔從工作引動過程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-240">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-241"><paramref name="action" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-241">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-242"><paramref name="creationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-242">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="cccf2-243">委派，表示工作中要執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="cccf2-243">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-244">物件，表示動作所需的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-244">An object representing data to be used by the action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-245">新工作將會觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-245">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that that the new task will observe..</span></span></param>
        <param name="creationOptions"><span data-ttu-id="cccf2-246"><see cref="T:System.Threading.Tasks.TaskCreationOptions" />，用於自訂工作的行為。</span><span class="sxs-lookup"><span data-stu-id="cccf2-246">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="cccf2-247">使用指定的動作、狀態和選項，初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-247">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-248">而不是呼叫這個建構函式，最常見的方式，來具現化<xref:System.Threading.Tasks.Task>物件和啟動工作是藉由呼叫靜態<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-248">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-249">這個建構函式所提供的唯一優點是它可讓物件具現化，分隔從工作引動過程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-249">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-250">已處置建立 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-250">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-251"><paramref name="action" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-251">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-252"><paramref name="creationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-252">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-253">取得建立 <see cref="T:System.Threading.Tasks.Task" /> 時提供的狀態物件，如果未提供則為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-253">Gets the state object supplied when the <see cref="T:System.Threading.Tasks.Task" /> was created, or null if none was supplied.</span></span></summary>
        <value><span data-ttu-id="cccf2-254"><see cref="T:System.Object" />，代表工作建立時傳入工作的狀態資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-254">An <see cref="T:System.Object" /> that represents the state data that was passed in to the task when it was created.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-255">將物件轉換回原始擷取其資料型別。</span><span class="sxs-lookup"><span data-stu-id="cccf2-255">Cast the object back to the original type to retrieve its data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-256">取得已成功完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-256">Gets a task that has already completed successfully.</span></span></summary>
        <value><span data-ttu-id="cccf2-257">成功完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-257">The successfully completed task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-258">這個屬性會傳回工作的<xref:System.Threading.Tasks.Task.Status%2A>屬性設定為<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-258">This property returns a task whose <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span></span> <span data-ttu-id="cccf2-259">若要建立工作並傳回值，則執行到完成，請呼叫<xref:System.Threading.Tasks.Task.FromResult%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-259">To create task that returns a value and runs to completion, call the <xref:System.Threading.Tasks.Task.FromResult%2A> method.</span></span>  
  
 <span data-ttu-id="cccf2-260">擷取這個屬性值的重複的嘗試可能不會一律傳回相同的執行個體。</span><span class="sxs-lookup"><span data-stu-id="cccf2-260">Repeated attempts to retrieve this property value may not always return the same instance.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">
          <span data-ttu-id="cccf2-261"><see langword="true" /> 表示嘗試將接續封送處理回原始擷取的內容，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-261"><see langword="true" /> to attempt to marshal the continuation back to the original context captured; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="cccf2-262">設定用來等候這個 <see cref="T:System.Threading.Tasks.Task" /> 的 awaiter。</span><span class="sxs-lookup"><span data-stu-id="cccf2-262">Configures an awaiter used to await this <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <returns><span data-ttu-id="cccf2-263">等候這項工作所用的物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-263">An object used to await this task.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-264">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-264">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="cccf2-265">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-265">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-266">執行時，會將已完成的工作當做引數傳遞給委派。</span><span class="sxs-lookup"><span data-stu-id="cccf2-266">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="cccf2-267">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-267">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="cccf2-268">新的接續 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-268">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-269">傳回<xref:System.Threading.Tasks.Task>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或因取消提早結束時完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-269">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-270">下列範例定義的工作，填入具有 100 隨機的日期和時間值的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-270">The following example defines a task that populates an array with 100 random date and time values.</span></span> <span data-ttu-id="cccf2-271">它會使用<xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29>方法來選取最早和最新的日期值，一旦陣列會完全擴展。</span><span class="sxs-lookup"><span data-stu-id="cccf2-271">It uses the <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> method to select the earliest and the latest date values once the array is fully populated.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 <span data-ttu-id="cccf2-272">主控台應用程式可能會終止之前執行的接續工作，因為<xref:System.Threading.Tasks.Task.Wait>呼叫方法，請執行範例結束前完成的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-272">Because a console application may terminate before the continuation task executes, the <xref:System.Threading.Tasks.Task.Wait> method is called to ensure that the continuation finishes executing before the example ends.</span></span>  
  
 <span data-ttu-id="cccf2-273">如需其他範例，請參閱[使用接續工作鏈結工作](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-273">For an additional example, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-274"><paramref name="continuationAction" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-274">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="cccf2-275">當工作完成時要執行的動作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-275">An action to run when the task completes.</span></span> <span data-ttu-id="cccf2-276">執行時，會將已完成的工作和呼叫端提供的狀態物件當做引數傳遞給委派。</span><span class="sxs-lookup"><span data-stu-id="cccf2-276">When run, the delegate is passed the completed task and a caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-277">物件，表示接續動作所使用的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-277">An object representing data to be used by the continuation action.</span></span></param>
        <summary><span data-ttu-id="cccf2-278">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收呼叫端提供的狀態資訊並執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-278">Creates a continuation that receives caller-supplied state information and executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="cccf2-279">新的接續工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-279">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-280">傳回<xref:System.Threading.Tasks.Task>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成、 判定為失敗，因為發生未處理的例外狀況，或提早結束取消而完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-280">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to cancellation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-281"><paramref name="continuationAction" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-281">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="cccf2-282">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-282">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-283">執行時，會將已完成的工作當做引數傳遞給委派。</span><span class="sxs-lookup"><span data-stu-id="cccf2-283">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-284">要指派給新接續工作的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-284">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="cccf2-285">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收取消語彙基元並非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-285">Creates a continuation that receives a cancellation token and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="cccf2-286">新的接續 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-286">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-287">傳回<xref:System.Threading.Tasks.Task>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或因取消提早結束時完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-287">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-288">已處置建立語彙基元的 <see cref="T:System.Threading.CancellationTokenSource" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-288">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-289"><paramref name="continuationAction" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-289">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="cccf2-290">要根據指定的 <c>continuationOptions</c> 執行的動作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-290">An action to run according to the specified <c>continuationOptions</c>.</span></span> <span data-ttu-id="cccf2-291">執行時，會將已完成的工作當做引數傳遞給委派。</span><span class="sxs-lookup"><span data-stu-id="cccf2-291">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="cccf2-292">接續工作的排程時間及其行為方式的適用選項。</span><span class="sxs-lookup"><span data-stu-id="cccf2-292">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="cccf2-293">這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-293">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="cccf2-294">建立當目標工作完成時，會根據指定之 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-294">Creates a continuation that executes when the target task completes according to the specified <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="cccf2-295">新的接續 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-295">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-296">傳回<xref:System.Threading.Tasks.Task>將不會執行直到目前的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-296">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="cccf2-297">如果透過指定接續準則`continuationOptions`參數不符合，接續工作將會取消而不是排程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-297">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-298">下列範例示範如何使用<xref:System.Threading.Tasks.TaskContinuationOptions>指定當前項工作完成時的接續工作應該會以同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-298">The following example demonstrates using <xref:System.Threading.Tasks.TaskContinuationOptions> to specify that a continuation task should run synchronously when the antecedent task completes.</span></span> <span data-ttu-id="cccf2-299">(如果指定的工作已完成的時間<xref:System.Threading.Tasks.Task.ContinueWith%2A>呼叫時，同步接續會在呼叫執行緒上執行<xref:System.Threading.Tasks.Task.ContinueWith%2A>。)</span><span class="sxs-lookup"><span data-stu-id="cccf2-299">(If the specified task has already completed by the time <xref:System.Threading.Tasks.Task.ContinueWith%2A> is called, the synchronous continuation will run on the thread calling <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)</span></span>  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-300"><paramref name="continuationAction" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-300">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-301"><paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-301">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="cccf2-302">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-302">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-303">執行時，會將已完成的工作當做引數傳遞給委派。</span><span class="sxs-lookup"><span data-stu-id="cccf2-303">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="cccf2-304">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-304">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="cccf2-305">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-305">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-306">接續會使用指定的排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-306">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="cccf2-307">新的接續 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-307">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-308">傳回<xref:System.Threading.Tasks.Task>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或因取消提早結束時完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-308">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-309"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-309">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-310"><paramref name="continuationAction" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-310">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="cccf2-311">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-311">-or-</span></span>  
  
 <span data-ttu-id="cccf2-312"><paramref name="scheduler" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-312">The <paramref name="scheduler" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="cccf2-313">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-313">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-314">當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-314">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-315">物件，表示接續動作所使用的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-315">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-316">要指派給新接續工作的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-316">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="cccf2-317">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收呼叫端提供的狀態資訊和取消語彙基元，並非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-317">Creates a continuation that receives caller-supplied state information and a cancellation token and that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="cccf2-318">新的接續 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-318">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-319">傳回<xref:System.Threading.Tasks.Task>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或因取消提早結束時完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-319">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-320"><paramref name="continuationAction" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-320">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-321">已經處置所提供的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-321">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="cccf2-322">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-322">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-323">當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-323">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-324">物件，表示接續動作所使用的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-324">An object representing data to be used by the continuation action.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="cccf2-325">接續工作的排程時間及其行為方式的適用選項。</span><span class="sxs-lookup"><span data-stu-id="cccf2-325">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="cccf2-326">這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-326">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="cccf2-327">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收呼叫端提供的狀態資訊並執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-327">Creates a continuation that receives caller-supplied state information and executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-328">接續會根據一組指定的條件執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-328">The continuation executes based on a set of specified conditions.</span></span></summary>
        <returns><span data-ttu-id="cccf2-329">新的接續 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-329">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-330">傳回<xref:System.Threading.Tasks.Task>將不會執行直到目前的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-330">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="cccf2-331">如果透過指定接續準則`continuationOptions`參數不符合，接續工作將會取消而不是排程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-331">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-332"><paramref name="continuationAction" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-332">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-333"><paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-333">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="cccf2-334">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-334">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span>  <span data-ttu-id="cccf2-335">當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-335">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-336">物件，表示接續動作所使用的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-336">An object representing data to be used by the continuation action.</span></span></param>
        <param name="scheduler"><span data-ttu-id="cccf2-337">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-337">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="cccf2-338">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收呼叫端提供的狀態資訊並非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-338">Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-339">接續會使用指定的排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-339">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="cccf2-340">新的接續 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-340">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-341">傳回<xref:System.Threading.Tasks.Task>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或因取消提早結束時完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-341">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-342"><paramref name="scheduler" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-342">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="cccf2-343">要根據指定的 <c>continuationOptions</c> 執行的動作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-343">An action to run according to the specified <c>continuationOptions</c>.</span></span> <span data-ttu-id="cccf2-344">執行時，會將已完成的工作當做引數傳遞給委派。</span><span class="sxs-lookup"><span data-stu-id="cccf2-344">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-345">要指派給新接續工作的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-345">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="cccf2-346">接續工作的排程時間及其行為方式的適用選項。</span><span class="sxs-lookup"><span data-stu-id="cccf2-346">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="cccf2-347">這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-347">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="cccf2-348">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-348">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="cccf2-349">建立當目標工作完成時，會根據指定之 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-349">Creates a continuation that executes when the target task competes according to the specified <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span> <span data-ttu-id="cccf2-350">接續會接收取消語彙基元，並使用指定的排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-350">The continuation receives a cancellation token and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="cccf2-351">新的接續 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-351">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-352">傳回<xref:System.Threading.Tasks.Task>將不會執行直到目前的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-352">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="cccf2-353">如果透過指定的準則`continuationOptions`參數不符合，接續工作將會取消而不是排程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-353">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-354">以下是範例使用 ContinueWith 來執行的工作在背景中，在使用者介面執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-354">The following is an example of using ContinueWith to run work both in the background and on the user interface threads.</span></span>  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-355">已處置建立語彙基元的 <see cref="T:System.Threading.CancellationTokenSource" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-355">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-356"><paramref name="continuationAction" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-356">The <paramref name="continuationAction" /> argument is null.</span></span>  
  
 <span data-ttu-id="cccf2-357">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-357">-or-</span></span>  
  
 <span data-ttu-id="cccf2-358"><paramref name="scheduler" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-358">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-359"><paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-359">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="cccf2-360">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的動作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-360">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-361">當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-361">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-362">物件，表示接續動作所使用的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-362">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-363">要指派給新接續工作的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-363">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="cccf2-364">接續工作的排程時間及其行為方式的適用選項。</span><span class="sxs-lookup"><span data-stu-id="cccf2-364">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="cccf2-365">這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-365">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="cccf2-366">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-366">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="cccf2-367">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會接收呼叫端提供的狀態資訊和取消語彙基元，並執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-367">Creates a continuation that receives caller-supplied state information and a cancellation token and that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-368">接續會根據一組指定的條件執行，並使用指定的排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-368">The continuation executes based on a set of specified conditions and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="cccf2-369">新的接續 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-369">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-370">傳回<xref:System.Threading.Tasks.Task>將不會執行直到目前的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-370">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="cccf2-371">如果透過指定的準則`continuationOptions`參數不符合，接續工作將會取消而不是排程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-371">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-372"><paramref name="scheduler" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-372">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-373"><paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-373">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-374">已經處置所提供的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-374">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-375">接續作業所產生的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-375">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="cccf2-376">當 <see cref="T:System.Threading.Tasks.Task`1" /> 完成時要執行的函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-376">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="cccf2-377">執行時，會將已完成的工作當做引數傳遞給委派。</span><span class="sxs-lookup"><span data-stu-id="cccf2-377">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="cccf2-378">建立當目標 <see cref="T:System.Threading.Tasks.Task`1" /> 完成並傳回值時非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-378">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes and returns a value.</span></span></summary>
        <returns><span data-ttu-id="cccf2-379">新的接續工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-379">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-380">傳回<xref:System.Threading.Tasks.Task%601>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或因取消提早結束時完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-380">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-381">下列範例會示範如何使用 ContinueWith 方法：</span><span class="sxs-lookup"><span data-stu-id="cccf2-381">The following example shows how to use the ContinueWith method:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-382"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-382">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-383"><paramref name="continuationFunction" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-383">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-384">接續作業所產生的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-384">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="cccf2-385">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-385">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-386">當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-386">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-387">物件，表示接續函式所使用的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-387">An object representing data to be used by the continuation function.</span></span></param>
        <summary><span data-ttu-id="cccf2-388">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成並傳回值時，會接收呼叫端提供的狀態資訊並非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-388">Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span></summary>
        <returns><span data-ttu-id="cccf2-389">新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-389">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-390">傳回<xref:System.Threading.Tasks.Task%601>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或因取消提早結束時完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-390">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-391"><paramref name="continuationFunction" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-391">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-392">接續作業所產生的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-392">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="cccf2-393">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-393">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-394">執行時，會將已完成的工作當做引數傳遞給委派。</span><span class="sxs-lookup"><span data-stu-id="cccf2-394">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-395">要指派給新接續工作的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-395">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="cccf2-396">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成並傳回值時非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-396">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="cccf2-397">接續會接收取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-397">The continuation receives a cancellation token.</span></span></summary>
        <returns><span data-ttu-id="cccf2-398">新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-398">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-399">傳回<xref:System.Threading.Tasks.Task%601>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或因取消提早結束時完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-399">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-400"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-400">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span>  
  
 <span data-ttu-id="cccf2-401">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-401">-or-</span></span>  
  
 <span data-ttu-id="cccf2-402">已處置建立語彙基元的 <see cref="T:System.Threading.CancellationTokenSource" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-402">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-403"><paramref name="continuationFunction" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-403">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-404">接續作業所產生的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-404">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="cccf2-405">要根據 <c>continuationOptions</c> 中指定之條件執行的函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-405">A function to run according to the condition specified in <c>continuationOptions</c>.</span></span> <span data-ttu-id="cccf2-406">執行時，會將已完成的工作當做引數傳遞給委派。</span><span class="sxs-lookup"><span data-stu-id="cccf2-406">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="cccf2-407">接續工作的排程時間及其行為方式的適用選項。</span><span class="sxs-lookup"><span data-stu-id="cccf2-407">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="cccf2-408">這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-408">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="cccf2-409">建立會根據指定之接續選項執行並傳回值的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-409">Creates a continuation that executes according to the specified continuation options and returns a value.</span></span></summary>
        <returns><span data-ttu-id="cccf2-410">新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-410">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-411">傳回<xref:System.Threading.Tasks.Task%601>將不會執行直到目前的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-411">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="cccf2-412">如果透過指定接續準則`continuationOptions`參數不符合，接續工作將會取消而不是排程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-412">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-413"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-413">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-414"><paramref name="continuationFunction" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-414">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-415"><paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-415">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-416">接續作業所產生的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-416">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="cccf2-417">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-417">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-418">執行時，會將已完成的工作當做引數傳遞給委派。</span><span class="sxs-lookup"><span data-stu-id="cccf2-418">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="cccf2-419">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-419">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="cccf2-420">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成並傳回值時非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-420">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="cccf2-421">接續會使用指定的排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-421">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="cccf2-422">新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-422">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-423">傳回<xref:System.Threading.Tasks.Task%601>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或因取消提早結束時完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-423">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-424"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-424">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-425"><paramref name="continuationFunction" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-425">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
 <span data-ttu-id="cccf2-426">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-426">-or-</span></span>  
  
 <span data-ttu-id="cccf2-427"><paramref name="scheduler" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-427">The <paramref name="scheduler" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-428">接續作業所產生的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-428">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="cccf2-429">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-429">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-430">當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-430">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-431">物件，表示接續函式所使用的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-431">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-432">要指派給新接續工作的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-432">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="cccf2-433">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成並傳回值時非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-433">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="cccf2-434">接續會接收呼叫端提供的狀態資訊和取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-434">The continuation receives caller-supplied state information and a cancellation token.</span></span></summary>
        <returns><span data-ttu-id="cccf2-435">新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-435">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-436">傳回<xref:System.Threading.Tasks.Task%601>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或因取消提早結束時完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-436">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-437"><paramref name="continuationFunction" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-437">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-438">已經處置所提供的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-438">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-439">接續作業所產生的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-439">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="cccf2-440">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-440">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-441">當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-441">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-442">物件，表示接續函式所使用的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-442">An object representing data to be used by the continuation function.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="cccf2-443">接續工作的排程時間及其行為方式的適用選項。</span><span class="sxs-lookup"><span data-stu-id="cccf2-443">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="cccf2-444">這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-444">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="cccf2-445">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時，會根據指定的工作接續選項來執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-445">Creates a continuation that executes based on the specified task continuation options when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-446">接續會接收呼叫端提供的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="cccf2-446">The continuation receives caller-supplied state information.</span></span></summary>
        <returns><span data-ttu-id="cccf2-447">新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-447">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-448">傳回<xref:System.Threading.Tasks.Task%601>將不會執行直到目前的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-448">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="cccf2-449">如果透過指定接續準則`continuationOptions`參數不符合，接續工作將會取消而不是排程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-449">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-450"><paramref name="continuationFunction" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-450">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-451"><paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-451">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-452">接續作業所產生的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-452">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="cccf2-453">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-453">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span>  <span data-ttu-id="cccf2-454">當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-454">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-455">物件，表示接續函式所使用的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-455">An object representing data to be used by the continuation function.</span></span></param>
        <param name="scheduler"><span data-ttu-id="cccf2-456">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-456">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="cccf2-457">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成時非同步執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-457">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-458">接續會接收呼叫端提供的狀態資訊，並使用指定的排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-458">The continuation receives caller-supplied state information and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="cccf2-459">新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-459">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-460">傳回<xref:System.Threading.Tasks.Task%601>將不進行執行排程目前的工作完成為止，是否因為成功執行到完成為止，判定為失敗，因為發生未處理的例外狀況，或因取消提早結束時完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-460">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-461"><paramref name="scheduler" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-461">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-462">接續作業所產生的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-462">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="cccf2-463">要根據指定的 <c>continuationOptions</c> 執行的函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-463">A function to run according to the specified <c>continuationOptions.</c></span></span> <span data-ttu-id="cccf2-464">執行時，會將已完成的工作當做引數傳遞給委派。</span><span class="sxs-lookup"><span data-stu-id="cccf2-464">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-465">要指派給新接續工作的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-465">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="cccf2-466">接續工作的排程時間及其行為方式的適用選項。</span><span class="sxs-lookup"><span data-stu-id="cccf2-466">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="cccf2-467">這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-467">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="cccf2-468">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-468">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="cccf2-469">建立會根據指定之接續選項執行並傳回值的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-469">Creates a continuation that executes according to the specified continuation options and returns a value.</span></span> <span data-ttu-id="cccf2-470">接續會接收取消語彙基元，並使用指定的排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-470">The continuation is passed a cancellation token and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="cccf2-471">新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-471">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-472">傳回<xref:System.Threading.Tasks.Task%601>將不會執行直到目前的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-472">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="cccf2-473">如果透過指定的準則`continuationOptions`參數不符合，接續工作將會取消而不是排程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-473">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-474">下列範例會示範如何搭配接續選項來使用 ContinueWith 方法：</span><span class="sxs-lookup"><span data-stu-id="cccf2-474">The following example shows how to use the ContinueWith method with continuation options:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-475"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-475">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span>  
  
 <span data-ttu-id="cccf2-476">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-476">-or-</span></span>  
  
 <span data-ttu-id="cccf2-477">已處置建立語彙基元的 <see cref="T:System.Threading.CancellationTokenSource" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-477">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-478"><paramref name="continuationFunction" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-478">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
 <span data-ttu-id="cccf2-479">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-479">-or-</span></span>  
  
 <span data-ttu-id="cccf2-480"><paramref name="scheduler" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-480">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-481"><paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-481">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-482">接續作業所產生的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-482">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="cccf2-483">當 <see cref="T:System.Threading.Tasks.Task" /> 完成時要執行的函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-483">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="cccf2-484">當執行時，完成的工作會傳遞至委派，並以呼叫端提供狀態的物件做為引數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-484">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="cccf2-485">物件，表示接續函式所使用的資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-485">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-486">要指派給新接續工作的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-486">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="cccf2-487">接續工作的排程時間及其行為方式的適用選項。</span><span class="sxs-lookup"><span data-stu-id="cccf2-487">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="cccf2-488">這包含準則 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />) 和執行選項 (如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-488">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="cccf2-489">要與接續工作產生關聯且於執行時使用的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-489">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="cccf2-490">建立當目標 <see cref="T:System.Threading.Tasks.Task" /> 完成並傳回值時，會根據指定的工作接續選項來執行的接續。</span><span class="sxs-lookup"><span data-stu-id="cccf2-490">Creates a continuation that executes based on the specified task continuation options when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="cccf2-491">接續會接收呼叫端提供的狀態資訊和取消語彙基元，並使用指定的排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-491">The continuation receives caller-supplied state information and a cancellation token and uses the specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="cccf2-492">新的接續 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-492">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-493">傳回<xref:System.Threading.Tasks.Task%601>將不會執行直到目前的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-493">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="cccf2-494">如果透過指定的準則`continuationOptions`參數不符合，接續工作將會取消而不是排程。</span><span class="sxs-lookup"><span data-stu-id="cccf2-494">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-495"><paramref name="scheduler" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-495">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-496"><paramref name="continuationOptions" /> 引數指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 值不正確。</span><span class="sxs-lookup"><span data-stu-id="cccf2-496">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-497">已經處置所提供的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-497">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-498">取得用來建立這個工作的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-498">Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to create this task.</span></span></summary>
        <value><span data-ttu-id="cccf2-499">用來建立這個工作的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-499">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to create this task.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-500">傳回目前執行之 <see cref="T:System.Threading.Tasks.Task" /> 的唯一 ID。</span><span class="sxs-lookup"><span data-stu-id="cccf2-500">Returns the ID of the currently executing <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <value><span data-ttu-id="cccf2-501">系統指派給目前執行中工作的整數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-501">An integer that was assigned by the system to the currently-executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-502"><xref:System.Threading.Tasks.Task.CurrentId%2A> 是`static`(`Shared`在 Visual Basic 中) 用來取得目前執行之工作的識別碼執行工作的程式碼的屬性。</span><span class="sxs-lookup"><span data-stu-id="cccf2-502"><xref:System.Threading.Tasks.Task.CurrentId%2A> is a `static` (`Shared` in Visual Basic) property that is used to get the identifier of the currently executing task from the code that the task is executing.</span></span> <span data-ttu-id="cccf2-503">不同於<xref:System.Threading.Tasks.Task.Id%2A>屬性，傳回特定的識別項<xref:System.Threading.Tasks.Task>執行個體。</span><span class="sxs-lookup"><span data-stu-id="cccf2-503">It differs from the <xref:System.Threading.Tasks.Task.Id%2A> property, which returns the identifier of a particular <xref:System.Threading.Tasks.Task> instance.</span></span> <span data-ttu-id="cccf2-504">如果您嘗試擷取<xref:System.Threading.Tasks.Task.CurrentId%2A>從工作正在執行的程式碼之外的值，則屬性會傳回`null`。</span><span class="sxs-lookup"><span data-stu-id="cccf2-504">If you attempt to retrieve the <xref:System.Threading.Tasks.Task.CurrentId%2A> value from outside the code that a task is executing, the property returns `null`.</span></span>  
  
 <span data-ttu-id="cccf2-505">請注意，雖然發生衝突情況非常罕見，工作識別碼不保證是唯一的。</span><span class="sxs-lookup"><span data-stu-id="cccf2-505">Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-506">建立在時間延遲之後才會完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-506">Creates a task that will complete after a time delay.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay"><span data-ttu-id="cccf2-507">完成所傳回工作之前等待的毫秒數；-1 為無限期地等待。</span><span class="sxs-lookup"><span data-stu-id="cccf2-507">The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cccf2-508">建立在時間延遲之後才會完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-508">Creates a task that completes after a time delay.</span></span></summary>
        <returns><span data-ttu-id="cccf2-509">代表時間延遲的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-509">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-510"><xref:System.Threading.Tasks.Task.Delay%2A>方法通常用來指定的時間間隔的延遲時間的所有作業或工作的一部分。</span><span class="sxs-lookup"><span data-stu-id="cccf2-510">The <xref:System.Threading.Tasks.Task.Delay%2A> method is typically used to delay the operation of all or part of a task for a specified time interval.</span></span> <span data-ttu-id="cccf2-511">大多數情況下，會導入的時間延遲：</span><span class="sxs-lookup"><span data-stu-id="cccf2-511">Most commonly, the time delay is introduced:</span></span>  
  
-   <span data-ttu-id="cccf2-512">在開始工作，如下列範例顯示。</span><span class="sxs-lookup"><span data-stu-id="cccf2-512">At the beginning of the task, as the following example shows.</span></span>  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   <span data-ttu-id="cccf2-513">一段時間時執行工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-513">Sometime while the task is executing.</span></span> <span data-ttu-id="cccf2-514">在此情況下，呼叫<xref:System.Threading.Tasks.Task.Delay%2A>方法執行為工作中, 的子工作，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="cccf2-514">In this case, the call to the <xref:System.Threading.Tasks.Task.Delay%2A> method executes as a child task within a task, as the following example shows.</span></span> <span data-ttu-id="cccf2-515">請注意，因為工作呼叫<xref:System.Threading.Tasks.Task.Delay%2A>方法以非同步方式執行，父工作必須等候它完成使用`await`關鍵字。</span><span class="sxs-lookup"><span data-stu-id="cccf2-515">Note that since the task that calls the <xref:System.Threading.Tasks.Task.Delay%2A> method executes asynchronously, the parent task must wait for it to complete by using the `await` keyword.</span></span>  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 <span data-ttu-id="cccf2-516">指定的時間延遲之後，在完成工作<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-516">After the specified time delay, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="cccf2-517">這個方法會取決於系統時鐘。</span><span class="sxs-lookup"><span data-stu-id="cccf2-517">This method depends on the system clock.</span></span> <span data-ttu-id="cccf2-518">這表示的時間延遲將大約等於系統時鐘的解析度如果`millisecondsDelay`引數小於大約 15 毫秒在 Windows 系統系統時鐘的解析度。</span><span class="sxs-lookup"><span data-stu-id="cccf2-518">This means that the time delay will approximately equal the resolution of the system clock if the `millisecondsDelay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-519">下列範例會示範簡單搭配<xref:System.Threading.Tasks.Task.Delay%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-519">The following example shows a simple use of the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-520"><paramref name="millisecondsDelay" /> 引數小於 -1。</span><span class="sxs-lookup"><span data-stu-id="cccf2-520">The <paramref name="millisecondsDelay" /> argument is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay"><span data-ttu-id="cccf2-521">完成所傳回工作之前要等待的時間範圍；<see langword="TimeSpan.FromMilliseconds(-1)" /> 表示無限期地等待。</span><span class="sxs-lookup"><span data-stu-id="cccf2-521">The time span to wait before completing the returned task, or <see langword="TimeSpan.FromMilliseconds(-1)" /> to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cccf2-522">建立在指定時間間隔之後完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-522">Creates a task that completes after a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="cccf2-523">代表時間延遲的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-523">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-524">指定的時間延遲之後，在完成工作<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-524">After the specified time delay, the task is completed in <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="cccf2-525">使用方式案例和其他範例，請參閱文件<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>多載。</span><span class="sxs-lookup"><span data-stu-id="cccf2-525">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="cccf2-526">這個方法會取決於系統時鐘。</span><span class="sxs-lookup"><span data-stu-id="cccf2-526">This method depends on the system clock.</span></span> <span data-ttu-id="cccf2-527">這表示的時間延遲將大約等於系統時鐘的解析度如果`delay`引數小於大約 15 毫秒在 Windows 系統系統時鐘的解析度。</span><span class="sxs-lookup"><span data-stu-id="cccf2-527">This means that the time delay will approximately equal the resolution of the system clock if the `delay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-528">下列範例會示範簡單搭配<xref:System.Threading.Tasks.Task.Delay%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-528">The following example shows a simple use of the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cccf2-529"><paramref name="delay" /> 表示 <see langword="TimeSpan.FromMillseconds(-1)" /> 以外的負數時間間隔。</span><span class="sxs-lookup"><span data-stu-id="cccf2-529"><paramref name="delay" /> represents a negative time interval other than <see langword="TimeSpan.FromMillseconds(-1)" />.</span></span>  
  
 <span data-ttu-id="cccf2-530">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-530">-or-</span></span>  
  
 <span data-ttu-id="cccf2-531"><paramref name="delay" /> 引數的 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 屬性大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-531">The <paramref name="delay" /> argument's <see cref="P:System.TimeSpan.TotalMilliseconds" /> property is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay"><span data-ttu-id="cccf2-532">完成所傳回工作之前等待的毫秒數；-1 為無限期地等待。</span><span class="sxs-lookup"><span data-stu-id="cccf2-532">The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-533">將在完成傳回的工作之前檢查的取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-533">The cancellation token that will be checked prior to completing the returned task.</span></span></param>
        <summary><span data-ttu-id="cccf2-534">建立在時間延遲之後才會完成的可取消工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-534">Creates a cancellable task that completes after a time delay.</span></span></summary>
        <returns><span data-ttu-id="cccf2-535">代表時間延遲的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-535">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-536">如果在指定的時間延遲之前, 收到信號的取消語彙基元<xref:System.Threading.Tasks.TaskCanceledException>例外狀況的結果，且工作會在完成<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-536">If the cancellation token is signaled before the specified time delay, a <xref:System.Threading.Tasks.TaskCanceledException> exception results, and the task is completed in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  <span data-ttu-id="cccf2-537">否則，在工作完成中<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態後經過指定的時間延遲。</span><span class="sxs-lookup"><span data-stu-id="cccf2-537">Otherwise, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state once the specified time delay has elapsed.</span></span>  
  
 <span data-ttu-id="cccf2-538">使用方式案例和其他範例，請參閱文件<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>多載。</span><span class="sxs-lookup"><span data-stu-id="cccf2-538">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="cccf2-539">這個方法會取決於系統時鐘。</span><span class="sxs-lookup"><span data-stu-id="cccf2-539">This method depends on the system clock.</span></span> <span data-ttu-id="cccf2-540">這表示的時間延遲將大約等於系統時鐘的解析度如果`millisecondsDelay`引數小於大約 15 毫秒在 Windows 系統系統時鐘的解析度。</span><span class="sxs-lookup"><span data-stu-id="cccf2-540">This means that the time delay will approximately equal the resolution of the system clock if the `millisecondsDelay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-541">下列範例會啟動的工作，包括呼叫<xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29>第二個會有一個延遲方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-541">The following example launches a task that includes a call to the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> method with a one second delay.</span></span> <span data-ttu-id="cccf2-542">延遲間隔耗盡之前，語彙基元被取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-542">Before the delay interval elapses, the token is cancelled.</span></span> <span data-ttu-id="cccf2-543">範例輸出顯示，如此一來，<xref:System.Threading.Tasks.TaskCanceledException>擲回，和工作的<xref:System.Threading.Tasks.Task.Status%2A>屬性設定為<xref:System.Threading.Tasks.TaskStatus.Canceled>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-543">The output from the example shows that, as a result, a <xref:System.Threading.Tasks.TaskCanceledException> is thrown, and the tasks' <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-544"><paramref name="millisecondsDelay" /> 引數小於 -1。</span><span class="sxs-lookup"><span data-stu-id="cccf2-544">The <paramref name="millisecondsDelay" /> argument is less than -1.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="cccf2-545">已取消這項工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-545">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-546">已經處置所提供的 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-546">The provided <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay"><span data-ttu-id="cccf2-547">完成所傳回工作之前要等待的時間範圍；<see langword="TimeSpan.FromMilliseconds(-1)" /> 表示無限期地等待。</span><span class="sxs-lookup"><span data-stu-id="cccf2-547">The time span to wait before completing the returned task, or <see langword="TimeSpan.FromMilliseconds(-1)" /> to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-548">將在完成傳回的工作之前檢查的取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-548">The cancellation token that will be checked prior to completing the returned task.</span></span></param>
        <summary><span data-ttu-id="cccf2-549">建立在指定時間間隔之後完成的可取消工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-549">Creates a cancellable task that completes after a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="cccf2-550">代表時間延遲的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-550">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-551">如果在指定的時間延遲之前, 收到信號的取消語彙基元<xref:System.Threading.Tasks.TaskCanceledException>例外狀況的結果，且工作會在完成<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-551">If the cancellation token is signaled before the specified time delay, a <xref:System.Threading.Tasks.TaskCanceledException> exception results, and the task is completed in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  <span data-ttu-id="cccf2-552">否則，在工作完成中<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態後經過指定的時間延遲。</span><span class="sxs-lookup"><span data-stu-id="cccf2-552">Otherwise, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state once the specified time delay has elapsed.</span></span>  
  
 <span data-ttu-id="cccf2-553">使用方式案例和其他範例，請參閱文件<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>多載。</span><span class="sxs-lookup"><span data-stu-id="cccf2-553">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="cccf2-554">這個方法會取決於系統時鐘。</span><span class="sxs-lookup"><span data-stu-id="cccf2-554">This method depends on the system clock.</span></span> <span data-ttu-id="cccf2-555">這表示的時間延遲將大約等於系統時鐘的解析度如果`delay`引數小於大約 15 毫秒在 Windows 系統系統時鐘的解析度。</span><span class="sxs-lookup"><span data-stu-id="cccf2-555">This means that the time delay will approximately equal the resolution of the system clock if the `delay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-556">下列範例會啟動的工作，包括呼叫<xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>方法和-a-1.5 秒的延遲。</span><span class="sxs-lookup"><span data-stu-id="cccf2-556">The following example launches a task that includes a call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method with a one-and-a-half second delay.</span></span> <span data-ttu-id="cccf2-557">延遲間隔耗盡之前，語彙基元被取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-557">Before the delay interval elapses, the token is cancelled.</span></span> <span data-ttu-id="cccf2-558">範例輸出顯示，如此一來，<xref:System.Threading.Tasks.TaskCanceledException>擲回，和工作的<xref:System.Threading.Tasks.Task.Status%2A>屬性設定為<xref:System.Threading.Tasks.TaskStatus.Canceled>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-558">The output from the example shows that, as a result, a <xref:System.Threading.Tasks.TaskCanceledException> is thrown, and the tasks' <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 <span data-ttu-id="cccf2-559">請注意此範例包含可能的競爭情形： 它相依於當語彙基元被取消時，以非同步方式執行延遲的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-559">Note that this example includes a potential race condition: it depends on the task asynchronously executing the delay when the token is cancelled.</span></span> <span data-ttu-id="cccf2-560">雖然 1.5 秒延遲，呼叫<xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>方法讓可能假設，不過可能是，呼叫<xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>方法無法傳回之前語彙基元被取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-560">Although the 1.5 second delay from the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method makes that assumption likely, it is nevertheless possible that the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method could return before the token is cancelled.</span></span> <span data-ttu-id="cccf2-561">在此情況下，這個範例會產生下列輸出：</span><span class="sxs-lookup"><span data-stu-id="cccf2-561">In that case, the example produces the following output:</span></span>  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cccf2-562"><paramref name="delay" /> 表示 <see langword="TimeSpan.FromMillseconds(-1)" /> 以外的負數時間間隔。</span><span class="sxs-lookup"><span data-stu-id="cccf2-562"><paramref name="delay" /> represents a negative time interval other than <see langword="TimeSpan.FromMillseconds(-1)" />.</span></span>  
  
 <span data-ttu-id="cccf2-563">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-563">-or-</span></span>  
  
 <span data-ttu-id="cccf2-564"><paramref name="delay" /> 引數的 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 屬性大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-564">The <paramref name="delay" /> argument's <see cref="P:System.TimeSpan.TotalMilliseconds" /> property is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="cccf2-565">已取消這項工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-565">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-566">已經處置所提供的 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-566">The provided <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-567">將 <see cref="T:System.Threading.Tasks.Task" /> 類別目前的執行個體所使用的資源全部釋出。</span><span class="sxs-lookup"><span data-stu-id="cccf2-567">Releases all resources used by the current instance of the <see cref="T:System.Threading.Tasks.Task" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cccf2-568">將 <see cref="T:System.Threading.Tasks.Task" /> 類別目前的執行個體所使用的資源全部釋出。</span><span class="sxs-lookup"><span data-stu-id="cccf2-568">Releases all resources used by the current instance of the <see cref="T:System.Threading.Tasks.Task" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-569"><xref:System.Threading.Tasks.Task>類別會實作<xref:System.IDisposable>介面，因為它會在內部使用，也會實作資源<xref:System.IDisposable>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-569">The <xref:System.Threading.Tasks.Task> class implements the <xref:System.IDisposable> interface because internally it uses resources that also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="cccf2-570">不過，特別是當您的應用程式的目標[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或更新版本中，您就不必呼叫<xref:System.Threading.Tasks.Task.Dispose%2A>除非效能或延展性測試指出，根據您使用模式，您的應用程式提升的效能會透過處置的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-570">However, particularly if your app targets the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or later, there is no need to call <xref:System.Threading.Tasks.Task.Dispose%2A> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</span></span> <span data-ttu-id="cccf2-571">如需詳細資訊，請參閱[我需要處置的工作？](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)中平行程式設計.NET 部落格。</span><span class="sxs-lookup"><span data-stu-id="cccf2-571">For more information, see [Do I need to dispose of Tasks?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cccf2-572">工作不是下列其中一個最終狀態：<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />、<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> 或 <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-572">The task is not in one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="cccf2-573">布林值，表示是否會因為呼叫 <see cref="M:System.Threading.Tasks.Task.Dispose" /> 而呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-573">A Boolean value that indicates whether this method is being called due to a call to <see cref="M:System.Threading.Tasks.Task.Dispose" />.</span></span></param>
        <summary><span data-ttu-id="cccf2-574">處置 <see cref="T:System.Threading.Tasks.Task" />，並釋放它的所有 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="cccf2-574">Disposes the <see cref="T:System.Threading.Tasks.Task" />, releasing all of its unmanaged resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-575"><xref:System.Threading.Tasks.Task>類別會實作<xref:System.IDisposable>介面，因為它會在內部使用，也會實作資源<xref:System.IDisposable>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-575">The <xref:System.Threading.Tasks.Task> class implements the <xref:System.IDisposable> interface because internally it uses resources that also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="cccf2-576">不過，特別是當您的應用程式的目標[!INCLUDE[net_v45](~/includes/net-v45-md.md)]或更新版本中，您就不必呼叫<xref:System.Threading.Tasks.Task.Dispose%2A>除非效能或延展性測試指出，根據您使用模式，您的應用程式提升的效能會透過處置的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-576">However, particularly if your app targets the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or later, there is no need to call <xref:System.Threading.Tasks.Task.Dispose%2A> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</span></span> <span data-ttu-id="cccf2-577">如需詳細資訊，請參閱[我需要處置的工作？](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)中平行程式設計.NET 部落格。</span><span class="sxs-lookup"><span data-stu-id="cccf2-577">For more information, see [Do I need to dispose of Tasks?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cccf2-578">工作不是下列其中一個最終狀態：<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />、<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> 或 <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-578">The task is not in one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span></span></exception>
        <threadsafe><span data-ttu-id="cccf2-579">不同於大部分的成員<see cref="T:System.Threading.Tasks.Task" />類別，這個方法不是安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-579">Unlike most of the members of the <see cref="T:System.Threading.Tasks.Task" /> class, this method is not thread-safe.</span></span></threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-580">取得導致 <see cref="T:System.AggregateException" /> 不當結束的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-580">Gets the <see cref="T:System.AggregateException" /> that caused the <see cref="T:System.Threading.Tasks.Task" /> to end prematurely.</span></span> <span data-ttu-id="cccf2-581">如果 <see cref="T:System.Threading.Tasks.Task" /> 順利完成，或未擲回任何例外狀況，則這會傳回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-581">If the <see cref="T:System.Threading.Tasks.Task" /> completed successfully or has not yet thrown any exceptions, this will return <see langword="null" />.</span></span></summary>
        <value><span data-ttu-id="cccf2-582">導致 <see cref="T:System.AggregateException" /> 不當結束的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-582">The <see cref="T:System.AggregateException" /> that caused the <see cref="T:System.Threading.Tasks.Task" /> to end prematurely.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-583">儲存產生的例外狀況擲回未處理的例外狀況的工作，以及傳播包裝在<xref:System.AggregateException>中呼叫<xref:System.Threading.Tasks.Task.Wait%2A>或存取<xref:System.Threading.Tasks.Task.Exception%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="cccf2-583">Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a <xref:System.AggregateException> in calls to <xref:System.Threading.Tasks.Task.Wait%2A> or in accesses to the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span> <span data-ttu-id="cccf2-584">工作執行個體是記憶體回收的時間未觀察到任何例外狀況會在完成項執行緒上傳播。</span><span class="sxs-lookup"><span data-stu-id="cccf2-584">Any exceptions not observed by the time the task instance is garbage collected will be propagated on the finalizer thread.</span></span> <span data-ttu-id="cccf2-585">如需詳細資訊和範例，請參閱[例外狀況處理 （工作平行程式庫）](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-585">For more information and an example, see [Exception Handling (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-586">提供 Factory 方法的存取，這些 Factory 方法用於建立及設定 <see cref="T:System.Threading.Tasks.Task" /> 和 <see cref="T:System.Threading.Tasks.Task`1" /> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="cccf2-586">Provides access to factory methods for creating and configuring <see cref="T:System.Threading.Tasks.Task" /> and <see cref="T:System.Threading.Tasks.Task`1" /> instances.</span></span></summary>
        <value><span data-ttu-id="cccf2-587">Factory 物件，可以建立各種不同的 <see cref="T:System.Threading.Tasks.Task" /> 和 <see cref="T:System.Threading.Tasks.Task`1" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-587">A factory object that can create a variety of <see cref="T:System.Threading.Tasks.Task" /> and <see cref="T:System.Threading.Tasks.Task`1" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-588">這個屬性會傳回預設執行個體<xref:System.Threading.Tasks.TaskFactory>等同於呼叫的無參數所建立的類別<xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType>建構函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-588">This property returns a default instance of the <xref:System.Threading.Tasks.TaskFactory> class that is identical to the one created by calling the parameterless <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="cccf2-589">它有下列屬性值：</span><span class="sxs-lookup"><span data-stu-id="cccf2-589">It has the following property values:</span></span>  
  
|<span data-ttu-id="cccf2-590">屬性</span><span class="sxs-lookup"><span data-stu-id="cccf2-590">Property</span></span>|<span data-ttu-id="cccf2-591">值</span><span class="sxs-lookup"><span data-stu-id="cccf2-591">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|<span data-ttu-id="cccf2-592">`null`或 <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="cccf2-592">`null`, or <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span></span>|  
  
 <span data-ttu-id="cccf2-593">這個屬性的最常見用法是以建立並啟動新工作的單一呼叫中<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-593">The most common use of this property is to create and start a new task in a single call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cccf2-594">從開始[!INCLUDE[net_v45](~/includes/net-v45-md.md)]、<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>方法提供最簡單的方式建立<xref:System.Threading.Tasks.Task>使用預設組態值的物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-594">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method provides the easiest way to create a <xref:System.Threading.Tasks.Task> object with default configuration values.</span></span>  
  
 <span data-ttu-id="cccf2-595">下列範例會使用靜態<xref:System.Threading.Tasks.Task.Factory%2A>屬性使兩個呼叫<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-595">The following example uses the static <xref:System.Threading.Tasks.Task.Factory%2A> property to make two calls to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-596">第一個填入使用者的 MyDocuments 目錄中的檔案名稱陣列，而第二個擴展使用者 MyDocuments 目錄的子目錄名稱陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-596">The first populates an array with the names of files in the user's MyDocuments directory, while the second populates an array with the names of subdirectories of the user's MyDocuments directory.</span></span> <span data-ttu-id="cccf2-597">然後它會呼叫<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType>方法，這個方法會顯示兩個陣列中的檔案和目錄的數目的相關資訊前, 兩個工作完成執行之後。</span><span class="sxs-lookup"><span data-stu-id="cccf2-597">It then calls the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> method, which displays information about the number of files and directories in the two arrays after the first two tasks have completed execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="cccf2-598">可用來完成工作的取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-598">The cancellation token with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="cccf2-599">建立以指定的取消語彙基元取消而完成的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-599">Creates a <see cref="T:System.Threading.Tasks.Task" /> that's completed due to cancellation with a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="cccf2-600">取消的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-600">The canceled task.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-601">並未針對 <paramref name="cancellationToken" /> 要求取消；其 <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> 屬性為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-601">Cancellation has not been requested for <paramref name="cancellationToken" />; its <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-602">工作傳回的結果的類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-602">The type of the result returned by the task.</span></span></typeparam>
        <param name="cancellationToken"><span data-ttu-id="cccf2-603">可用來完成工作的取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-603">The cancellation token with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="cccf2-604">建立以指定的取消語彙基元取消而完成的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-604">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed due to cancellation with a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="cccf2-605">取消的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-605">The canceled task.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cccf2-606">並未針對 <paramref name="cancellationToken" /> 要求取消；其 <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> 屬性為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-606">Cancellation has not been requested for <paramref name="cancellationToken" />; its <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception"><span data-ttu-id="cccf2-607">可用來完成工作的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-607">The exception with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="cccf2-608">建立以指定例外狀況完成的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-608">Creates a <see cref="T:System.Threading.Tasks.Task" /> that has completed with a specified exception.</span></span></summary>
        <returns><span data-ttu-id="cccf2-609">發生錯誤的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-609">The faulted task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-610">這個方法會建立<xref:System.Threading.Tasks.Task>物件，其<xref:System.Threading.Tasks.Task.Status%2A>屬性是<xref:System.Threading.Tasks.TaskStatus.Faulted>，且<xref:System.Threading.Tasks.Task.Exception%2A>屬性包含`exception`。</span><span class="sxs-lookup"><span data-stu-id="cccf2-610">This method creates a <xref:System.Threading.Tasks.Task> object whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.Faulted> and whose <xref:System.Threading.Tasks.Task.Exception%2A> property contains `exception`.</span></span> <span data-ttu-id="cccf2-611">當您立即知道工作執行的工作將會擲回的例外狀況，再執行較長的程式碼路徑時，通常會使用此方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-611">The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</span></span> <span data-ttu-id="cccf2-612">如需範例，請參閱<xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29>多載。</span><span class="sxs-lookup"><span data-stu-id="cccf2-612">For an example, see the <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-613">工作傳回的結果的類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-613">The type of the result returned by the task.</span></span></typeparam>
        <param name="exception"><span data-ttu-id="cccf2-614">可用來完成工作的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-614">The exception with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="cccf2-615">建立以指定例外狀況完成的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-615">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed with a specified exception.</span></span></summary>
        <returns><span data-ttu-id="cccf2-616">發生錯誤的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-616">The faulted task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-617">這個方法會建立<xref:System.Threading.Tasks.Task%601>物件，其<xref:System.Threading.Tasks.Task.Status%2A>屬性是<xref:System.Threading.Tasks.TaskStatus.Faulted>，且<xref:System.Threading.Tasks.Task.Exception%2A>屬性包含`exception`。</span><span class="sxs-lookup"><span data-stu-id="cccf2-617">This method creates a <xref:System.Threading.Tasks.Task%601> object whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.Faulted> and whose <xref:System.Threading.Tasks.Task.Exception%2A> property contains `exception`.</span></span> <span data-ttu-id="cccf2-618">當您立即知道工作執行的工作將會擲回的例外狀況，再執行較長的程式碼路徑時，通常會使用此方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-618">The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</span></span> <span data-ttu-id="cccf2-619">這個範例將提供說明。</span><span class="sxs-lookup"><span data-stu-id="cccf2-619">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-620">下列範例會計算每個名稱會當做命令列引數傳遞的目錄中的檔案中的位元組數的命令列公用程式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-620">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="cccf2-621">而不是執行較長的程式碼路徑可具現化<xref:System.IO.FileInfo>物件，並擷取的值及其<xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType>目錄中的每個檔案的屬性，此範例只會呼叫<xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29>建立發生錯誤的工作，如果特定的方法子目錄不存在。</span><span class="sxs-lookup"><span data-stu-id="cccf2-621">Rather than executing a longer code path that instantiates a <xref:System.IO.FileInfo> object and retrieves the value of its <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> property for each file in the directory, the example simply calls the <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> method to create a faulted task if a particular subdirectory does not exist.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-622">工作傳回的結果的類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-622">The type of the result returned by the task.</span></span></typeparam>
        <param name="result"><span data-ttu-id="cccf2-623">要儲存到完成的工作的結果。</span><span class="sxs-lookup"><span data-stu-id="cccf2-623">The result to store into the completed task.</span></span></param>
        <summary><span data-ttu-id="cccf2-624">建立已成功完成且具有指定之結果的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-624">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed successfully with the specified result.</span></span></summary>
        <returns><span data-ttu-id="cccf2-625">成功完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-625">The successfully completed task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-626">這個方法會建立<xref:System.Threading.Tasks.Task%601>物件，其<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>屬性是`result`，且<xref:System.Threading.Tasks.Task.Status%2A>屬性是<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-626">This method creates a <xref:System.Threading.Tasks.Task%601> object whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is `result` and whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span></span> <span data-ttu-id="cccf2-627">不會執行較長的程式碼路徑立即知道工作的傳回值時，通常使用的方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-627">The method is commonly used when the return value of a task is immediately known without executing a longer code path.</span></span> <span data-ttu-id="cccf2-628">這個範例將提供說明。</span><span class="sxs-lookup"><span data-stu-id="cccf2-628">The example provides an illustration.</span></span>  
  
 <span data-ttu-id="cccf2-629">若要建立沒有傳回值的工作物件，擷取工作物件，從<xref:System.Threading.Tasks.Task.CompletedTask%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="cccf2-629">To create a Task object that does not return a value, retrieve the Task object from the <xref:System.Threading.Tasks.Task.CompletedTask%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-630">下列範例會計算每個名稱會當做命令列引數傳遞的目錄中的檔案中的位元組數的命令列公用程式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-630">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="cccf2-631">而不是執行較長的程式碼路徑可具現化<xref:System.IO.FileStream>物件，並擷取的值及其<xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType>目錄中的每個檔案的屬性，此範例只會呼叫<xref:System.Threading.Tasks.Task.FromResult%2A>方法來建立工作的<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>屬性為零 (0)，如果沒有檔案的目錄。</span><span class="sxs-lookup"><span data-stu-id="cccf2-631">Rather than executing a longer code path that instantiates a <xref:System.IO.FileStream> object and retrieves the value of its <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> property for each file in the directory, the example simply calls the <xref:System.Threading.Tasks.Task.FromResult%2A> method to create a task whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is zero (0) if a directory has no files.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cccf2-632">取得用來等候這個 <see cref="T:System.Threading.Tasks.Task" /> 的 awaiter。</span><span class="sxs-lookup"><span data-stu-id="cccf2-632">Gets an awaiter used to await this <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <returns><span data-ttu-id="cccf2-633">awaiter 執行個體。</span><span class="sxs-lookup"><span data-stu-id="cccf2-633">An awaiter instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-634">這個方法僅供編譯器使用，而不是應用程式程式碼中使用。</span><span class="sxs-lookup"><span data-stu-id="cccf2-634">This method is intended for compiler use rather than for use in application code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-635">取得這個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的 ID。</span><span class="sxs-lookup"><span data-stu-id="cccf2-635">Gets an ID for this <see cref="T:System.Threading.Tasks.Task" /> instance.</span></span></summary>
        <value><span data-ttu-id="cccf2-636">系統指派給這個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的識別項。</span><span class="sxs-lookup"><span data-stu-id="cccf2-636">The identifier that is assigned by the system to this <see cref="T:System.Threading.Tasks.Task" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-637">工作 Id 指派隨並不一定代表哪一項工作中建立執行個體的順序。</span><span class="sxs-lookup"><span data-stu-id="cccf2-637">Task IDs are assigned on-demand and do not necessarily represent the order in which task instances are created.</span></span> <span data-ttu-id="cccf2-638">請注意，雖然發生衝突情況非常罕見，工作識別碼不保證是唯一的。</span><span class="sxs-lookup"><span data-stu-id="cccf2-638">Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</span></span>  
  
 <span data-ttu-id="cccf2-639">若要取得該工作正在執行的程式碼中，將從目前執行之工作的工作識別碼，請使用<xref:System.Threading.Tasks.Task.CurrentId%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="cccf2-639">To get the task ID of the currently executing task from within code that that task is executing, use the <xref:System.Threading.Tasks.Task.CurrentId%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-640">取得這個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體是否因取消才完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-640">Gets whether this <see cref="T:System.Threading.Tasks.Task" /> instance has completed execution due to being canceled.</span></span></summary>
        <value>
          <span data-ttu-id="cccf2-641">如果工作是由於取消而完成則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-641"><see langword="true" /> if the task has completed due to being canceled; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-642">A<xref:System.Threading.Tasks.Task>會完成<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態任何下列情況：</span><span class="sxs-lookup"><span data-stu-id="cccf2-642">A <xref:System.Threading.Tasks.Task> will complete in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="cccf2-643">其<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A>在工作開始執行時之前, 已標示為取消</span><span class="sxs-lookup"><span data-stu-id="cccf2-643">Its <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> was marked for cancellation before the task started executing,</span></span>  
  
-   <span data-ttu-id="cccf2-644">工作確認取消要求，在其已收到信號<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A>藉由擲回<xref:System.OperationCanceledException>，具有相同<xref:System.Threading.CancellationToken>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-644">The task acknowledged the cancellation request on its already signaled <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> by throwing an <xref:System.OperationCanceledException> that bears the same <xref:System.Threading.CancellationToken>.</span></span>  
  
-   <span data-ttu-id="cccf2-645">工作確認取消要求，在其已收到信號<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A>藉由呼叫<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>方法<xref:System.Threading.CancellationToken>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-645">The task acknowledged the cancellation request on its already signaled <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> by calling the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> method on the <xref:System.Threading.CancellationToken>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="cccf2-646">擷取的值<xref:System.Threading.Tasks.Task.IsCanceled%2A>屬性不會封鎖呼叫執行緒，直到工作完成為止。</span><span class="sxs-lookup"><span data-stu-id="cccf2-646">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsCanceled%2A> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-647">取得這個 <see cref="T:System.Threading.Tasks.Task" /> 是否已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-647">Gets whether this <see cref="T:System.Threading.Tasks.Task" /> has completed.</span></span></summary>
        <value>
          <span data-ttu-id="cccf2-648">如果工作已完成則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-648"><see langword="true" /> if the task has completed; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-649"><xref:System.Threading.Tasks.Task.IsCompleted%2A> 會傳回`true`當工作處於三種最終狀態的其中一個： <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>， <xref:System.Threading.Tasks.TaskStatus.Faulted>，或<xref:System.Threading.Tasks.TaskStatus.Canceled>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-649"><xref:System.Threading.Tasks.Task.IsCompleted%2A> will return `true` when the task is in one of the three final states: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, or <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="cccf2-650">擷取的值<xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType>屬性不會封鎖呼叫執行緒，直到工作完成為止。</span><span class="sxs-lookup"><span data-stu-id="cccf2-650">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-651">取得 <see cref="T:System.Threading.Tasks.Task" /> 是否因未處理的例外狀況才完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-651">Gets whether the <see cref="T:System.Threading.Tasks.Task" /> completed due to an unhandled exception.</span></span></summary>
        <value>
          <span data-ttu-id="cccf2-652">如果工作擲回未處理的例外狀況則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-652"><see langword="true" /> if the task has thrown an unhandled exception; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-653">如果<xref:System.Threading.Tasks.Task.IsFaulted%2A>是`true`，工作的<xref:System.Threading.Tasks.Task.Status%2A>等於<xref:System.Threading.Tasks.TaskStatus.Faulted>，且其<xref:System.Threading.Tasks.Task.Exception%2A>屬性為非 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-653">If <xref:System.Threading.Tasks.Task.IsFaulted%2A> is `true`, the task's <xref:System.Threading.Tasks.Task.Status%2A> is equal to <xref:System.Threading.Tasks.TaskStatus.Faulted>, and its <xref:System.Threading.Tasks.Task.Exception%2A> property will be non-null.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="cccf2-654">擷取的值<xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType>屬性不會封鎖呼叫執行緒，直到工作完成為止。</span><span class="sxs-lookup"><span data-stu-id="cccf2-654">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-655">將指定在 ThreadPool 執行工作排入佇列，並傳回該工作的工作或 <see cref="T:System.Threading.Tasks.Task`1" /> 控制代碼。</span><span class="sxs-lookup"><span data-stu-id="cccf2-655">Queues the specified work to run on the ThreadPool and returns a task or <see cref="T:System.Threading.Tasks.Task`1" /> handle for that work.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-656"><xref:System.Threading.Tasks.Task.Run%2A>方法提供一組多載可讓您輕鬆地使用預設值啟動工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-656">The <xref:System.Threading.Tasks.Task.Run%2A> method provides a set of overloads that make it easy to start a task by using default values.</span></span> <span data-ttu-id="cccf2-657">它是輕量級替代方案<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>多載。</span><span class="sxs-lookup"><span data-stu-id="cccf2-657">It is a lightweight alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> overloads.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="cccf2-658">要以非同步方式執行的工作</span><span class="sxs-lookup"><span data-stu-id="cccf2-658">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="cccf2-659">將指定在執行緒集區執行工作排入佇列，並傳回代表該工作的 <see cref="T:System.Threading.Tasks.Task" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-659">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task" /> object that represents that work.</span></span></summary>
        <returns><span data-ttu-id="cccf2-660">表示已進入佇列要在 ThreadPool 中執行之工作 (work) 的工作 (task)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-660">A task that represents the work queued to execute in the ThreadPool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-661"><xref:System.Threading.Tasks.Task.Run%2A>方法可讓您建立和執行單一方法呼叫中的工作，簡單的替代方案<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-661">The <xref:System.Threading.Tasks.Task.Run%2A> method allows you to create and execute a task in a single method call and is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method.</span></span> <span data-ttu-id="cccf2-662">它會建立工作以下列的預設值：</span><span class="sxs-lookup"><span data-stu-id="cccf2-662">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="cccf2-663">它的取消語彙基元是<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-663">Its cancellation token is <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="cccf2-664">其<xref:System.Threading.Tasks.Task.CreationOptions%2A>屬性值是<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-664">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="cccf2-665">它會使用預設工作排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-665">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="cccf2-666">處理工作的作業所擲回的例外狀況的資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-666">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-667">下列範例會定義`ShowThreadInfo`顯示方法<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>目前執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-667">The following example defines a `ShowThreadInfo` method  that displays the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> of the current thread.</span></span> <span data-ttu-id="cccf2-668">它會直接從執行緒中呼叫應用程式，並從呼叫<xref:System.Action>傳遞至委派<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-668">It is called directly from the application thread, and is called from the <xref:System.Action> delegate passed to the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 <span data-ttu-id="cccf2-669">下列範例是類似於上一個，，不同之處在於它使用 lambda 運算式來定義的工作是將執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="cccf2-669">The following example is similar to the previous one, except that it uses a lambda expression to define the code that the task is to execute.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 <span data-ttu-id="cccf2-670">範例將示範非同步工作是在主應用程式執行緒以外的不同執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-670">The examples show that the asynchronous task executes on a different thread than the main application thread.</span></span>  
  
 <span data-ttu-id="cccf2-671">若要呼叫<xref:System.Threading.Tasks.Task.Wait%2A>方法可確保在工作完成，也會顯示應用程式結束前的其輸出。</span><span class="sxs-lookup"><span data-stu-id="cccf2-671">The call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that the task completes and displays its output before the application ends.</span></span> <span data-ttu-id="cccf2-672">否則，它有可能，`Main`方法將在工作完成之前完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-672">Otherwise, it is possible that the `Main` method will complete before the task finishes.</span></span>  
  
 <span data-ttu-id="cccf2-673">下列範例說明<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-673">The following example illustrates the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span> <span data-ttu-id="cccf2-674">它定義的目錄名稱陣列，並啟動個別的工作，以擷取每個目錄中的檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="cccf2-674">It defines an array of directory names and starts a separate task to retrieve the file names in each directory.</span></span> <span data-ttu-id="cccf2-675">所有工作的檔案名稱都寫入單一<xref:System.Collections.Concurrent.ConcurrentBag%601>物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-675">All tasks write the file names to a single <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span> <span data-ttu-id="cccf2-676">此範例會接著呼叫<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>方法，以確保所有工作完成，並接著會顯示檔案名稱寫入總數的計數<xref:System.Collections.Concurrent.ConcurrentBag%601>物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-676">The example then calls the <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-677"><paramref name="action" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-677">The <paramref name="action" /> parameter was <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="cccf2-678">要以非同步方式執行的工作</span><span class="sxs-lookup"><span data-stu-id="cccf2-678">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="cccf2-679">將指定在執行緒集區執行的工作排入佇列，並傳回 <paramref name="function" /> 所傳回之工作的 Proxy。</span><span class="sxs-lookup"><span data-stu-id="cccf2-679">Queues the specified work to run on the thread pool and returns a proxy for the  task returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="cccf2-680">表示 <paramref name="function" /> 所傳回工作之 Proxy 的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-680">A task that represents a proxy for the task returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-681">處理工作的作業所擲回的例外狀況的資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-681">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-682"><paramref name="function" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-682">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="cccf2-683">要以非同步方式執行的工作</span><span class="sxs-lookup"><span data-stu-id="cccf2-683">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-684">可以用來取消工作的取消語彙基元</span><span class="sxs-lookup"><span data-stu-id="cccf2-684">A cancellation token that can be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="cccf2-685">將指定在執行緒集區執行工作排入佇列，並傳回代表該工作的 <see cref="T:System.Threading.Tasks.Task" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-685">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task" /> object that represents that work.</span></span> <span data-ttu-id="cccf2-686">取消語彙基元允許取消工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-686">A cancellation token allows the work to be cancelled.</span></span></summary>
        <returns><span data-ttu-id="cccf2-687">表示已進入佇列，並要在執行緒集區中執行之工作 (work) 的工作 (task)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-687">A task that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-688">如果工作開始執行之前，已要求取消，則不會執行工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-688">If cancellation is requested before the task begins execution, the task does not execute.</span></span> <span data-ttu-id="cccf2-689">而是設定為<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態，則擲回<xref:System.Threading.Tasks.TaskCanceledException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-689">Instead it is set to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state and throws a <xref:System.Threading.Tasks.TaskCanceledException> exception.</span></span>  
  
 <span data-ttu-id="cccf2-690"><xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29>方法是簡單的替代方案<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-690">The <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-691">它會建立工作以下列的預設值：</span><span class="sxs-lookup"><span data-stu-id="cccf2-691">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="cccf2-692">其<xref:System.Threading.Tasks.Task.CreationOptions%2A>屬性值是<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-692">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="cccf2-693">它會使用預設工作排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-693">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="cccf2-694">處理工作的作業所擲回的例外狀況的資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-694">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-695">下列範例會呼叫<xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29>方法建立逐一查看 C:\Windows\System32 目錄中的檔案的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-695">The following example calls the <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> method to create a task that iterates the files in the C:\Windows\System32 directory.</span></span> <span data-ttu-id="cccf2-696">Lambda 運算式呼叫<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法，將每個檔案的相關資訊<xref:System.Collections.Generic.List%601>物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-696">The lambda expression calls the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to add information about each  file to a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="cccf2-697">每個中斷連結的巢狀的工作所叫用<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>迴圈會檢查的取消語彙基元的狀態，並在要求取消，如果呼叫<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-697">Each detached nested task invoked by the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop checks the state of the cancellation token and, if cancellation is requested, calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-698"><xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>方法會擲回<xref:System.OperationCanceledException>進行處理的例外狀況`catch`封鎖呼叫執行緒呼叫時<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-698">The <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method throws an <xref:System.OperationCanceledException> exception that is handled in a `catch` block when the calling thread calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-699"><paramref name="action" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-699">The <paramref name="action" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="cccf2-700">已取消這項工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-700">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-701">與 <paramref name="cancellationToken" /> 相關聯的 <see cref="T:System.Threading.CancellationTokenSource" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-701">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="cccf2-702">要以非同步方式執行的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-702">The work to execute asynchronously.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-703">應該用來取消工作的取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-703">A cancellation token that should be used to cancel the work.</span></span></param>
        <summary><span data-ttu-id="cccf2-704">將指定在執行緒集區執行的工作排入佇列，並傳回 <paramref name="function" /> 所傳回之工作的 Proxy。</span><span class="sxs-lookup"><span data-stu-id="cccf2-704">Queues the specified work to run on the thread pool and returns a proxy for the task returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="cccf2-705">表示 <paramref name="function" /> 所傳回工作之 Proxy 的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-705">A task that represents a proxy for the task returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-706">處理工作的作業所擲回的例外狀況的資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-706">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-707"><paramref name="function" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-707">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="cccf2-708">已取消這項工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-708">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-709">與 <paramref name="cancellationToken" /> 相關聯的 <see cref="T:System.Threading.CancellationTokenSource" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-709">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-710">Proxy 工作傳回的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-710">The type of the result returned by the proxy task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="cccf2-711">要以非同步方式執行的工作</span><span class="sxs-lookup"><span data-stu-id="cccf2-711">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="cccf2-712">將指定在執行緒集區執行的工作排入佇列，並傳回 <paramref name="function" /> 所傳回之 <see langword="Task(TResult)" /> 的 Proxy。</span><span class="sxs-lookup"><span data-stu-id="cccf2-712">Queues the specified work to run on the thread pool and returns a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="cccf2-713"><see langword="Task(TResult)" />，代表 <see langword="Task(TResult)" /> 所傳回之 <paramref name="function" /> 的 Proxy。</span><span class="sxs-lookup"><span data-stu-id="cccf2-713">A <see langword="Task(TResult)" /> that represents a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-714">處理工作的作業所擲回的例外狀況的資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-714">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-715"><paramref name="function" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-715">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-716">工作的傳回型別。</span><span class="sxs-lookup"><span data-stu-id="cccf2-716">The return type of the task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="cccf2-717">要以非同步方式執行的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-717">The work to execute asynchronously.</span></span></param>
        <summary><span data-ttu-id="cccf2-718">將指定在執行緒集區執行工作排入佇列，並傳回代表該工作的 <see cref="T:System.Threading.Tasks.Task`1" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-718">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task`1" /> object that represents that work.</span></span></summary>
        <returns><span data-ttu-id="cccf2-719">代表已排入佇列要在執行緒集區中執行之工作 (work) 的工作 (task) 物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-719">A task object that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-720"><xref:System.Threading.Tasks.Task.Run%2A>方法是簡單的替代方案<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-720">The <xref:System.Threading.Tasks.Task.Run%2A> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="cccf2-721">它會建立工作以下列的預設值：</span><span class="sxs-lookup"><span data-stu-id="cccf2-721">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="cccf2-722">它的取消語彙基元是<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-722">Its cancellation token is <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="cccf2-723">其<xref:System.Threading.Tasks.Task.CreationOptions%2A>屬性值是<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-723">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="cccf2-724">它會使用預設工作排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-724">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="cccf2-725">處理工作的作業所擲回的例外狀況的資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-725">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-726">下列範例會計算文字在文字檔案，代表已發行活頁簿中的近似數目。</span><span class="sxs-lookup"><span data-stu-id="cccf2-726">The following example counts the approximate number of words in text files that represent published books.</span></span> <span data-ttu-id="cccf2-727">每項工作負責開啟檔案，以非同步的方式，讀取其完整內容，而且使用規則運算式的計算字數統計。</span><span class="sxs-lookup"><span data-stu-id="cccf2-727">Each task is responsible for opening a file, reading its entire contents asynchronously, and calculating the word count by using a regular expression.</span></span> <span data-ttu-id="cccf2-728"><xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>呼叫方法，請確定所有工作已都完成之後，主控台中顯示每本書的字數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-728">The <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method is called to ensure that all tasks have completed before  displaying the word count of each book to the console.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 <span data-ttu-id="cccf2-729">規則運算式`\p{P}*\s+`比對零個、 一個或多個標點符號字元後面接著一個或多個空格字元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-729">The regular expression `\p{P}*\s+` matches zero, one, or more punctuation characters followed by one or more whitespace characters.</span></span> <span data-ttu-id="cccf2-730">它會假設的相符項目總數等於大約字數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-730">It assumes that the total number of matches equals the approximate word count.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-731"><paramref name="function" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-731">The <paramref name="function" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-732">Proxy 工作傳回的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-732">The type of the result returned by the proxy task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="cccf2-733">要以非同步方式執行的工作</span><span class="sxs-lookup"><span data-stu-id="cccf2-733">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-734">應該用來取消工作的取消語彙基元</span><span class="sxs-lookup"><span data-stu-id="cccf2-734">A cancellation token that should be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="cccf2-735">將指定在執行緒集區執行的工作排入佇列，並傳回 <paramref name="function" /> 所傳回之 <see langword="Task(TResult)" /> 的 Proxy。</span><span class="sxs-lookup"><span data-stu-id="cccf2-735">Queues the specified work to run on the thread pool and returns a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="cccf2-736"><see langword="Task(TResult)" />，代表 <see langword="Task(TResult)" /> 所傳回之 <paramref name="function" /> 的 Proxy。</span><span class="sxs-lookup"><span data-stu-id="cccf2-736">A <see langword="Task(TResult)" /> that represents a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-737">處理工作的作業所擲回的例外狀況的資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-737">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-738"><paramref name="function" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-738">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="cccf2-739">已取消這項工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-739">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-740">與 <paramref name="cancellationToken" /> 相關聯的 <see cref="T:System.Threading.CancellationTokenSource" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-740">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-741">工作的結果類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-741">The result type of the task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="cccf2-742">要以非同步方式執行的工作</span><span class="sxs-lookup"><span data-stu-id="cccf2-742">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-743">應該用來取消工作的取消語彙基元</span><span class="sxs-lookup"><span data-stu-id="cccf2-743">A cancellation token that should be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="cccf2-744">將指定在執行緒集區執行工作排入佇列，並傳回代表該工作的 <see langword="Task(TResult)" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-744">Queues the specified work to run on the thread pool and returns a <see langword="Task(TResult)" /> object that represents that work.</span></span> <span data-ttu-id="cccf2-745">取消語彙基元允許取消工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-745">A cancellation token allows the work to be cancelled.</span></span></summary>
        <returns><span data-ttu-id="cccf2-746"><see langword="Task(TResult)" />，代表已排入佇列要在執行緒集區中執行的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-746">A <see langword="Task(TResult)" /> that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-747">如果工作開始執行之前，已要求取消，則不會執行工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-747">If cancellation is requested before the task begins execution, the task does not execute.</span></span> <span data-ttu-id="cccf2-748">而是設定為<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態，則擲回<xref:System.Threading.Tasks.TaskCanceledException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-748">Instead it is set to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state and throws a <xref:System.Threading.Tasks.TaskCanceledException> exception.</span></span>  
  
 <span data-ttu-id="cccf2-749"><xref:System.Threading.Tasks.Task.Run%2A>方法是簡單的替代方案<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-749">The <xref:System.Threading.Tasks.Task.Run%2A> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method.</span></span> <span data-ttu-id="cccf2-750">它會建立工作以下列的預設值：</span><span class="sxs-lookup"><span data-stu-id="cccf2-750">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="cccf2-751">其<xref:System.Threading.Tasks.Task.CreationOptions%2A>屬性值是<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-751">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="cccf2-752">它會使用預設工作排程器。</span><span class="sxs-lookup"><span data-stu-id="cccf2-752">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="cccf2-753">處理工作的作業所擲回的例外狀況的資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-753">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-754">下列範例會建立將迴圈，直到計數器就會遞增為 2 百萬個值的 20 任務。</span><span class="sxs-lookup"><span data-stu-id="cccf2-754">The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</span></span> <span data-ttu-id="cccf2-755">當前 10 個工作都達到 2 百萬個時，取消語彙基元被取消，並會取消其計數器未達到 2 百萬個的任何工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-755">When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</span></span> <span data-ttu-id="cccf2-756">此範例示範可能的輸出。</span><span class="sxs-lookup"><span data-stu-id="cccf2-756">The example shows possible output.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 <span data-ttu-id="cccf2-757">而不是使用<xref:System.AggregateException.InnerExceptions%2A>屬性可檢查例外狀況，此範例會逐一查看所有工作，以決定其已成功完成，這都已取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-757">Instead of using the <xref:System.AggregateException.InnerExceptions%2A> property to   examine exceptions, the example iterates all tasks to determine which have completed successfully and which have been cancelled.</span></span> <span data-ttu-id="cccf2-758">對於已完成，它會顯示工作所傳回的值。</span><span class="sxs-lookup"><span data-stu-id="cccf2-758">For those that have completed, it displays the value returned by the task.</span></span>  
  
 <span data-ttu-id="cccf2-759">取消是合作式的因為每個工作可以決定如何回應取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-759">Because cancellation is cooperative, each task can decide how to respond to cancellation.</span></span> <span data-ttu-id="cccf2-760">下列範例是類似第一，只不過在語彙基元被取消，工作會恢復它們已經完成而不是擲回例外狀況的反覆項目數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-760">The following example is like the first, except that, once the token is cancelled, tasks return the number of iterations they've completed rather than throw an exception.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 <span data-ttu-id="cccf2-761">此範例仍然必須處理<xref:System.AggregateException>例外狀況，因為尚未啟動時，在要求取消的任何工作仍會擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-761">The example still must handle the <xref:System.AggregateException> exception,   since any tasks that have not started when cancellation is requested still throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-762"><paramref name="function" /> 參數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-762">The <paramref name="function" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="cccf2-763">已取消這項工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-763">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-764">與 <paramref name="cancellationToken" /> 相關聯的 <see cref="T:System.Threading.CancellationTokenSource" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-764">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-765">在目前的 <see cref="T:System.Threading.Tasks.Task" /> 上同步執行 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-765">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cccf2-766">在目前的 <see cref="T:System.Threading.Tasks.Task" /> 上同步執行 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-766">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-767">一般情況下，工作會在執行緒集區執行緒上非同步執行，而不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-767">Ordinarily, tasks are executed asynchronously on a thread pool thread and do not block the calling thread.</span></span> <span data-ttu-id="cccf2-768">藉由呼叫執行的工作<xref:System.Threading.Tasks.Task.RunSynchronously>方法會關聯到目前<xref:System.Threading.Tasks.TaskScheduler>且在呼叫執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-768">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously> method are associated with the current <xref:System.Threading.Tasks.TaskScheduler> and are run on the calling thread.</span></span> <span data-ttu-id="cccf2-769">如果目標排程器不支援呼叫的執行緒上執行這項工作，以便在排程器上執行排定工作時，會和呼叫的執行緒會封鎖直到工作完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-769">If the target scheduler does not support running this task on the calling thread, the task will be scheduled for execution on the scheduler, and the calling thread will block until the task has completed execution.</span></span> <span data-ttu-id="cccf2-770">即使工作是以同步方式執行，仍應該呼叫呼叫執行緒<xref:System.Threading.Tasks.Task.Wait%2A>處理工作可能會擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-770">Even though the task runs synchronously, the calling thread should still call <xref:System.Threading.Tasks.Task.Wait%2A> to handle any exceptions that the task might throw.</span></span>  <span data-ttu-id="cccf2-771">如需例外狀況處理的詳細資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-771">For more information on exception handling, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 <span data-ttu-id="cccf2-772">藉由呼叫執行的工作<xref:System.Threading.Tasks.Task.RunSynchronously%2A>藉由呼叫的方法會具現化<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-772">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method are instantiated by calling a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> class constructor.</span></span> <span data-ttu-id="cccf2-773">若要以同步方式執行工作必須在<xref:System.Threading.Tasks.TaskStatus.Created>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-773">The task to be run synchronously must be in the <xref:System.Threading.Tasks.TaskStatus.Created> state.</span></span> <span data-ttu-id="cccf2-774">工作可能會啟動，以及僅執行一次。</span><span class="sxs-lookup"><span data-stu-id="cccf2-774">A task may be started and run only once.</span></span> <span data-ttu-id="cccf2-775">排程工作中例外狀況的第二個階段結果的任何嘗試。</span><span class="sxs-lookup"><span data-stu-id="cccf2-775">Any attempts to schedule a task a second time results in an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-776">下列範例會比較工作，藉由呼叫執行<xref:System.Threading.Tasks.Task.RunSynchronously%2A>具有一個以非同步方式執行方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-776">The following example compares a task executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method with one executed asynchronously.</span></span> <span data-ttu-id="cccf2-777">在這兩種情況下，工作執行的顯示工作識別碼和執行緒的識別碼相同的 lambda 運算式上執行工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-777">In both cases, the tasks execute identical lambda expressions that display the task ID and the ID of the thread on which the task is running.</span></span> <span data-ttu-id="cccf2-778">工作計算介於 1 到 1000000 之間的整數的總和。</span><span class="sxs-lookup"><span data-stu-id="cccf2-778">The task calculates the sum of the integers between 1 and 1,000,000.</span></span> <span data-ttu-id="cccf2-779">範例輸出所示，執行此工作，藉由呼叫<xref:System.Threading.Tasks.Task.RunSynchronously%2A>應用程式執行緒，而非同步工作沒有執行的方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-779">As the output from the example shows, the task executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method runs on the application thread, while the asynchronous task does not.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-780"><see cref="T:System.Threading.Tasks.Task" /> 執行個體已經過處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-780">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cccf2-781"><see cref="T:System.Threading.Tasks.Task" /> 不是處於有效的啟動狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-781">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="cccf2-782">它可能已經啟動、執行或取消，也可能已透過不支援直接排程的方式建立。</span><span class="sxs-lookup"><span data-stu-id="cccf2-782">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><span data-ttu-id="cccf2-783">排程器，要嘗試在其上以內嵌方式執行這個工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-783">The scheduler on which to attempt to run this task inline.</span></span></param>
        <summary><span data-ttu-id="cccf2-784">在提供的 <see cref="T:System.Threading.Tasks.Task" /> 上同步執行 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-784">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the <see cref="T:System.Threading.Tasks.TaskScheduler" /> provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-785">藉由呼叫執行的工作<xref:System.Threading.Tasks.Task.RunSynchronously%2A>藉由呼叫的方法會具現化<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-785">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method are instantiated by calling a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> class constructor.</span></span> <span data-ttu-id="cccf2-786">若要以同步方式執行工作必須在<xref:System.Threading.Tasks.TaskStatus.Created>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-786">The task to be run synchronously must be in the <xref:System.Threading.Tasks.TaskStatus.Created> state.</span></span> <span data-ttu-id="cccf2-787">工作可能會啟動，以及僅執行一次。</span><span class="sxs-lookup"><span data-stu-id="cccf2-787">A task may be started and run only once.</span></span> <span data-ttu-id="cccf2-788">排程工作中例外狀況的第二個階段結果的任何嘗試。</span><span class="sxs-lookup"><span data-stu-id="cccf2-788">Any attempts to schedule a task a second time results in an exception.</span></span>  
  
 <span data-ttu-id="cccf2-789">如果目標排程器不支援目前的執行緒上執行這項工作，以便在排程器上執行排定工作時，會和目前的執行緒會封鎖直到工作完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-789">If the target scheduler does not support running this task on the current thread, the task will be scheduled for execution on the scheduler, and the current thread will block until the task has completed execution.</span></span> <span data-ttu-id="cccf2-790">因為這個緣故，呼叫的執行緒不會不需要呼叫方法，例如<xref:System.Threading.Tasks.Task.Wait%2A>以確保工作已完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-790">Because of this, the calling thread does not need to call a method such as <xref:System.Threading.Tasks.Task.Wait%2A> to ensure that the task has completed execution.</span></span> <span data-ttu-id="cccf2-791">如需有關工作作業的例外狀況處理的詳細資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-791">For more information on exception handling for task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-792"><see cref="T:System.Threading.Tasks.Task" /> 執行個體已經過處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-792">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-793"><paramref name="scheduler" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-793">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cccf2-794"><see cref="T:System.Threading.Tasks.Task" /> 不是處於有效的啟動狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-794">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="cccf2-795">它可能已經啟動、執行或取消，也可能已透過不支援直接排程的方式建立。</span><span class="sxs-lookup"><span data-stu-id="cccf2-795">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-796">啟動 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-796">Starts the <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cccf2-797">啟動 <see cref="T:System.Threading.Tasks.Task" />，並排定它在目前的 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-797">Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-798">工作可能會啟動，以及僅執行一次。</span><span class="sxs-lookup"><span data-stu-id="cccf2-798">A task may be started and run only once.</span></span> <span data-ttu-id="cccf2-799">第二次排定工作的任何嘗試會導致例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-799">Any attempts to schedule a task a second time will result in an exception.</span></span>  
  
 <span data-ttu-id="cccf2-800"><xref:System.Threading.Tasks.Task.Start%2A>用來執行的工作，透過呼叫其中一個已建立<xref:System.Threading.Tasks.Task>建構函式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-800">The <xref:System.Threading.Tasks.Task.Start%2A> is used to execute a task that has been created by calling one of the <xref:System.Threading.Tasks.Task> constructors.</span></span> <span data-ttu-id="cccf2-801">一般而言，您這樣做時，您需要將從其執行，例如當您有條件地執行工作所建立的工作的建立。</span><span class="sxs-lookup"><span data-stu-id="cccf2-801">Typically, you do this when you need to separate the task's creation from its execution, such as when you conditionally execute tasks that you've created.</span></span> <span data-ttu-id="cccf2-802">較常見的情況，您不需要個別執行的工作具現化，我們建議您呼叫的多載<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>或<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-802">For the more common case in which you don't need to separate  task instantiation from execution, we recommend that you call an overload of the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="cccf2-803">處理工作的作業所擲回的例外狀況的資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-803">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-804">下列範例會呼叫<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29>建構函式來具現化新<xref:System.Threading.Tasks.Task>物件，以顯示其識別碼與 managed 的執行緒識別碼的工作，並接著會執行迴圈。</span><span class="sxs-lookup"><span data-stu-id="cccf2-804">The following example calls the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor to instantiate a new <xref:System.Threading.Tasks.Task> object that displays its task ID and managed thread ID and then executes a loop.</span></span> <span data-ttu-id="cccf2-805">然後它會呼叫<xref:System.Threading.Tasks.Task.Start%2A>方法才能執行工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-805">It then calls the <xref:System.Threading.Tasks.Task.Start%2A> method to execute the task.</span></span>  <span data-ttu-id="cccf2-806">由於這是主控台應用程式呼叫<xref:System.Threading.Tasks.Task.Wait%2A>方法是為了防止應用程式終止之前執行的工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-806">Since this is a console app, the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method is necessary to prevent the app from terminating before the task finishes execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-807"><see cref="T:System.Threading.Tasks.Task" /> 執行個體已經過處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-807">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cccf2-808"><see cref="T:System.Threading.Tasks.Task" /> 不是處於有效的啟動狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-808">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="cccf2-809">它可能已經啟動、執行或取消，也可能已透過不支援直接排程的方式建立。</span><span class="sxs-lookup"><span data-stu-id="cccf2-809">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><span data-ttu-id="cccf2-810">要與這個工作產生關聯，並用於執行這個工作的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-810">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> with which to associate and execute this task.</span></span></param>
        <summary><span data-ttu-id="cccf2-811">啟動 <see cref="T:System.Threading.Tasks.Task" />，並排定它在指定的 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-811">Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the specified <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-812">工作可能僅啟動和僅執行一次。</span><span class="sxs-lookup"><span data-stu-id="cccf2-812">A task may only be started and run only once.</span></span> <span data-ttu-id="cccf2-813">第二次排定工作的任何嘗試會導致例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-813">Any attempts to schedule a task a second time will result in an exception.</span></span>  
  
 <span data-ttu-id="cccf2-814">處理工作的作業所擲回的例外狀況的資訊，請參閱[例外狀況處理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-814">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-815"><paramref name="scheduler" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-815">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="cccf2-816"><see cref="T:System.Threading.Tasks.Task" /> 不是處於有效的啟動狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-816">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="cccf2-817">它可能已經啟動、執行或取消，也可能已透過不支援直接排程的方式建立。</span><span class="sxs-lookup"><span data-stu-id="cccf2-817">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-818"><see cref="T:System.Threading.Tasks.Task" /> 執行個體已經過處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-818">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException"><span data-ttu-id="cccf2-819">排程器無法將這項工作排入佇列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-819">The scheduler was unable to queue this task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-820">取得這個工作的 <see cref="T:System.Threading.Tasks.TaskStatus" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-820">Gets the <see cref="T:System.Threading.Tasks.TaskStatus" /> of this task.</span></span></summary>
        <value><span data-ttu-id="cccf2-821">這個工作執行個體目前的 <see cref="T:System.Threading.Tasks.TaskStatus" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-821">The current <see cref="T:System.Threading.Tasks.TaskStatus" /> of this task instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-822">擷取的值<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>屬性不會封鎖呼叫執行緒，直到工作完成為止。</span><span class="sxs-lookup"><span data-stu-id="cccf2-822">Retrieving the value of the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 <span data-ttu-id="cccf2-823">如需詳細資訊和範例，請參閱[使用接續工作鏈結工作](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)和[如何： 取消工作及其子系](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-823">For more information and an example, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) and [How to: Cancel a Task and Its Children](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-824">下列範例會建立將迴圈，直到計數器就會遞增為 2 百萬個值的 20 任務。</span><span class="sxs-lookup"><span data-stu-id="cccf2-824">The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</span></span> <span data-ttu-id="cccf2-825">當前 10 個工作都達到 2 百萬個時，取消語彙基元被取消，並會取消其計數器未達到 2 百萬個的任何工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-825">When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</span></span> <span data-ttu-id="cccf2-826">此範例接著會檢查<xref:System.Threading.Tasks.Task.Status%2A>屬性指出是否已順利完成，或已取消每項工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-826">The example then examines the <xref:System.Threading.Tasks.Task.Status%2A> property of each task to indicate whether it completed successfully or was cancelled.</span></span> <span data-ttu-id="cccf2-827">對於已完成，它會顯示工作所傳回的值。</span><span class="sxs-lookup"><span data-stu-id="cccf2-827">For those that completed, it displays the value returned by the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System.IAsyncResult.AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-828">取得 <see cref="T:System.Threading.WaitHandle" />，這個項目可用來等候工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-828">Gets a <see cref="T:System.Threading.WaitHandle" /> that can be used to wait for the task to complete.</span></span></summary>
        <value><span data-ttu-id="cccf2-829"><see cref="T:System.Threading.WaitHandle" />，可用來等候工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-829">A <see cref="T:System.Threading.WaitHandle" /> that can be used to wait for the task to complete.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-830">使用所提供的等候功能<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>最好使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>類似的功能。</span><span class="sxs-lookup"><span data-stu-id="cccf2-830">Using the wait functionality provided by <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> is preferable to using <xref:System.IAsyncResult.AsyncWaitHandle%2A> for similar functionality.</span></span> <span data-ttu-id="cccf2-831">如需詳細資訊，請參閱中的 「 工作正在等候 」 一節[以工作為基礎的非同步程式設計](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)和[使用具有其他非同步模式的 TPL](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-831">For more information, see the "Waiting on Tasks" section in [Task-based Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Using TPL with Other Asynchronous Patterns](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-832"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-832">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System.IAsyncResult.CompletedSynchronously { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="cccf2-833">取得作業是否已同步完成的指示。</span><span class="sxs-lookup"><span data-stu-id="cccf2-833">Gets an indication of whether the operation completed synchronously.</span></span></summary>
        <value>
          <span data-ttu-id="cccf2-834">如果作業同步完成，則為 <see langword="true" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-834"><see langword="true" /> if the operation completed synchronously; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-835">等候 <see cref="T:System.Threading.Tasks.Task" /> 完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-835">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cccf2-836">等候 <see cref="T:System.Threading.Tasks.Task" /> 完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-836">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-837"><xref:System.Threading.Tasks.Task.Wait%2A> 會造成呼叫執行緒等候，直到目前的工作已完成同步處理方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-837"><xref:System.Threading.Tasks.Task.Wait%2A> is a synchronization method that causes the calling thread to wait until the current task has completed.</span></span> <span data-ttu-id="cccf2-838">如果目前的工作開始執行，等候方法嘗試移除從排程器工作並執行它內嵌在目前的執行緒上。</span><span class="sxs-lookup"><span data-stu-id="cccf2-838">If the current task has not started execution, the Wait method attempts to remove the task from the scheduler and execute it inline on the current thread.</span></span> <span data-ttu-id="cccf2-839">如果無法這麼做，或目前的工作已經開始執行，它會封鎖呼叫執行緒直到工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-839">If it is unable to do that, or if the current task has already started execution, it blocks the calling thread until the task completes.</span></span> <span data-ttu-id="cccf2-840">如需詳細資訊，請參閱[Task.Wait 和 「 內嵌 」](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx)中平行程式設計.NET 部落格。</span><span class="sxs-lookup"><span data-stu-id="cccf2-840">For more information, see [Task.Wait and "Inlining"](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) in the Parallel Programming with .NET blog.</span></span>  
  
 <span data-ttu-id="cccf2-841">如需詳細資訊和範例，請參閱[如何： 等候一個或多個工作完成](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-841">For more information and an example, see [How to: Wait on One or More Tasks to Complete](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-842">下列範例會啟動的工作，會產生介於 0 到 100 之間的 1 百萬個亂數，並會計算其平均值。</span><span class="sxs-lookup"><span data-stu-id="cccf2-842">The following example starts a task that generates one million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="cccf2-843">此範例會使用<xref:System.Threading.Tasks.Task.Wait%2A>方法，以確保應用程式終止前，工作會完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-843">The example uses the <xref:System.Threading.Tasks.Task.Wait%2A> method to ensure that the task completes before the application terminates.</span></span> <span data-ttu-id="cccf2-844">否則，因為這是主控台應用程式時，此範例會之前就終止工作可以計算並顯示平均值。</span><span class="sxs-lookup"><span data-stu-id="cccf2-844">Otherwise, because this is a console application, the example would terminate before the task can compute and display the mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-845"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-845">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="cccf2-846">工作已取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-846">The task was canceled.</span></span> <span data-ttu-id="cccf2-847"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-847">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
 <span data-ttu-id="cccf2-848">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-848">-or-</span></span>  
  
 <span data-ttu-id="cccf2-849">在工作執行期間擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-849">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="cccf2-850"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含例外狀況的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="cccf2-850">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="cccf2-851">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-851">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cccf2-852">等待 <see cref="T:System.Threading.Tasks.Task" /> 在指定的毫秒數內完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-852">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns>
          <span data-ttu-id="cccf2-853">如果 <see langword="true" /> 在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-853"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-854"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> 是同步處理方法會造成呼叫執行緒等待目前的工作執行個體，以完成之前發生下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="cccf2-854"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="cccf2-855">工作順利完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-855">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="cccf2-856">工作本身卻遭取消或擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-856">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="cccf2-857">在此情況下，您處理<xref:System.AggregateException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-857">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="cccf2-858"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>屬性包含有關例外狀況或例外狀況詳細資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-858">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="cccf2-859">所定義的間隔`millisecondsTimeout`捨棄。</span><span class="sxs-lookup"><span data-stu-id="cccf2-859">The interval defined by `millisecondsTimeout` elapses.</span></span> <span data-ttu-id="cccf2-860">在此情況下，目前的執行緒會繼續執行，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="cccf2-860">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-861">下列範例會啟動的工作，會產生介於 0 到 100 之間的 5 百萬個亂數，並會計算其平均值。</span><span class="sxs-lookup"><span data-stu-id="cccf2-861">The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="cccf2-862">此範例會使用<xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>方法等候 150 毫秒內完成的應用程式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-862">The example uses the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> method to wait for the application to complete within 150 milliseconds.</span></span> <span data-ttu-id="cccf2-863">如果應用程式正常完成，工作將會顯示總和與平均值它已產生隨機數字。</span><span class="sxs-lookup"><span data-stu-id="cccf2-863">If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</span></span> <span data-ttu-id="cccf2-864">如果經過逾時間隔，這個範例會顯示一則訊息之前它所終止。</span><span class="sxs-lookup"><span data-stu-id="cccf2-864">If the timeout interval has elapsed, the example displays a message before it terminates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-865"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-865">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cccf2-866"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="cccf2-866"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="cccf2-867">工作已取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-867">The task was canceled.</span></span> <span data-ttu-id="cccf2-868"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-868">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
 <span data-ttu-id="cccf2-869">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-869">-or-</span></span>  
  
 <span data-ttu-id="cccf2-870">在工作執行期間擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-870">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="cccf2-871"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含例外狀況的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="cccf2-871">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="cccf2-872">等候工作完成時要觀察的取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-872">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="cccf2-873">等候 <see cref="T:System.Threading.Tasks.Task" /> 完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-873">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span> <span data-ttu-id="cccf2-874">如果在工作完成之前取消語彙基元已取消，則等候會終止。</span><span class="sxs-lookup"><span data-stu-id="cccf2-874">The wait terminates if a cancellation token is canceled before the task completes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-875"><xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>方法會建立可取消等待; 也就是說，它會導致目前的執行緒等候，直到發生下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="cccf2-875">The <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> method creates a cancelable wait; that is, it causes the current thread to wait until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="cccf2-876">在工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-876">The task completes.</span></span>  
  
-   <span data-ttu-id="cccf2-877">已取消的取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-877">The cancellation token is canceled.</span></span> <span data-ttu-id="cccf2-878">在此情況下，呼叫<xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>方法會擲回<xref:System.OperationCanceledException>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-878">In this case, the call to the <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> method throws an <xref:System.OperationCanceledException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cccf2-879">取消`cancellationToken`取消語彙基元已不會影響執行中工作，除非它也已傳遞的取消語彙基元，並準備好處理取消作業。</span><span class="sxs-lookup"><span data-stu-id="cccf2-879">Canceling the `cancellationToken` cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</span></span> <span data-ttu-id="cccf2-880">傳遞`cancellationToken`物件給這個方法只會允許要取消等待。</span><span class="sxs-lookup"><span data-stu-id="cccf2-880">Passing the `cancellationToken` object to this method simply allows the wait to be canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-881">下列範例說明將簡單的取消語彙基元來取消等待工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-881">The following example illustrates the simple use of a cancellation token to cancel waiting for a task's completion.</span></span> <span data-ttu-id="cccf2-882">工作啟動時，會呼叫<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>方法來取消的語彙基元來源取消語彙基元，然後再延遲任何五秒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-882">A task is launched, calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to cancel any of the token source's cancellation tokens, and then delays for five seconds.</span></span> <span data-ttu-id="cccf2-883">請注意工作本身尚未被傳送的取消語彙基元，而且不是可取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-883">Note that the task itself has not been passed the cancellation token and is not cancelable.</span></span> <span data-ttu-id="cccf2-884">應用程式執行緒會呼叫工作<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>方法等候工作完成，但等候已取消一旦取消語彙基元取消而<xref:System.OperationCanceledException>就會擲回。</span><span class="sxs-lookup"><span data-stu-id="cccf2-884">The application thread calls the task's <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the task to complete, but the wait is canceled once the cancellation token is cancelled and an <xref:System.OperationCanceledException> is thrown.</span></span> <span data-ttu-id="cccf2-885">例外狀況處理常式報告的例外狀況，然後進入睡眠狀態六秒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-885">The exception handler reports the exception and then sleeps for six seconds.</span></span> <span data-ttu-id="cccf2-886">範例輸出所示，這種延遲可讓工作在完成<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-886">As the output from the example shows, that delay allows the task to complete in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="cccf2-887">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-887">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-888">此工作已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-888">The task has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="cccf2-889">工作已取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-889">The task was canceled.</span></span> <span data-ttu-id="cccf2-890"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-890">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
 <span data-ttu-id="cccf2-891">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-891">-or-</span></span>  
  
 <span data-ttu-id="cccf2-892">在工作執行期間擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-892">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="cccf2-893"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含例外狀況的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="cccf2-893">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="cccf2-894">
          <see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-894">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cccf2-895">等待 <see cref="T:System.Threading.Tasks.Task" /> 在指定的時間間隔內完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-895">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution within a specified time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="cccf2-896">如果 <see langword="true" /> 在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-896"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-897"><xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> 是同步處理方法會造成呼叫執行緒等待目前的工作執行個體，以完成之前發生下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="cccf2-897"><xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="cccf2-898">工作順利完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-898">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="cccf2-899">工作本身卻遭取消或擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-899">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="cccf2-900">在此情況下，您處理<xref:System.AggregateException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-900">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="cccf2-901"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>屬性包含有關例外狀況或例外狀況詳細資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-901">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="cccf2-902">所定義的間隔`timeout`捨棄。</span><span class="sxs-lookup"><span data-stu-id="cccf2-902">The interval defined by `timeout` elapses.</span></span> <span data-ttu-id="cccf2-903">在此情況下，目前的執行緒會繼續執行，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="cccf2-903">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-904">下列範例會啟動的工作，會產生介於 0 到 100 之間的 5 百萬個亂數，並會計算其平均值。</span><span class="sxs-lookup"><span data-stu-id="cccf2-904">The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="cccf2-905">此範例會使用<xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>方法等候 150 毫秒內完成的應用程式。</span><span class="sxs-lookup"><span data-stu-id="cccf2-905">The example uses the <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> method to wait for the application to complete within 150 milliseconds.</span></span> <span data-ttu-id="cccf2-906">如果應用程式正常完成，工作將會顯示總和與平均值它已產生隨機數字。</span><span class="sxs-lookup"><span data-stu-id="cccf2-906">If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</span></span> <span data-ttu-id="cccf2-907">如果經過逾時間隔，這個範例會顯示一則訊息之前它所終止。</span><span class="sxs-lookup"><span data-stu-id="cccf2-907">If the timeout interval has elapsed, the example displays a message before it terminates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-908"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-908">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cccf2-909"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="cccf2-909"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="cccf2-910">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-910">-or-</span></span>  
  
 <span data-ttu-id="cccf2-911"><paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-911"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="cccf2-912">工作已取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-912">The task was canceled.</span></span> <span data-ttu-id="cccf2-913"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-913">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
 <span data-ttu-id="cccf2-914">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-914">-or-</span></span>  
  
 <span data-ttu-id="cccf2-915">在工作執行期間擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-915">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="cccf2-916"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含例外狀況的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="cccf2-916">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="cccf2-917">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-917">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-918">等候工作完成時要觀察的取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-918">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="cccf2-919">等候 <see cref="T:System.Threading.Tasks.Task" /> 完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-919">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span> <span data-ttu-id="cccf2-920">如果在工作完成之前經過逾時間隔或取消語彙基元已取消，則等候會終止。</span><span class="sxs-lookup"><span data-stu-id="cccf2-920">The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes.</span></span></summary>
        <returns>
          <span data-ttu-id="cccf2-921">如果 <see langword="true" /> 在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-921"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-922"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> 是同步處理方法會造成呼叫執行緒等待目前的工作執行個體，以完成之前發生下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="cccf2-922"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="cccf2-923">工作順利完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-923">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="cccf2-924">工作本身卻遭取消或擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-924">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="cccf2-925">在此情況下，您處理<xref:System.AggregateException>例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-925">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="cccf2-926"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>屬性包含有關例外狀況或例外狀況詳細資料。</span><span class="sxs-lookup"><span data-stu-id="cccf2-926">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="cccf2-927">`cancellationToken`取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-927">The `cancellationToken` cancellation token is canceled.</span></span> <span data-ttu-id="cccf2-928">在此情況下，呼叫<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>方法會擲回<xref:System.OperationCanceledException>。</span><span class="sxs-lookup"><span data-stu-id="cccf2-928">In this case, the call to the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> method throws an <xref:System.OperationCanceledException>.</span></span>  
  
-   <span data-ttu-id="cccf2-929">所定義的間隔`millisecondsTimeout`捨棄。</span><span class="sxs-lookup"><span data-stu-id="cccf2-929">The interval defined by `millisecondsTimeout` elapses.</span></span> <span data-ttu-id="cccf2-930">在此情況下，目前的執行緒會繼續執行，而且方法會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="cccf2-930">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cccf2-931">取消`cancellationToken`取消語彙基元已不會影響執行中工作，除非它也已傳遞的取消語彙基元，並準備好處理取消作業。</span><span class="sxs-lookup"><span data-stu-id="cccf2-931">Canceling the `cancellationToken` cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</span></span> <span data-ttu-id="cccf2-932">傳遞`cancellationToken`物件給這個方法只會允許要取消等待根據在某些狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-932">Passing the `cancellationToken` object to this method simply allows the wait to be canceled based on some condition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-933">下列範例會呼叫<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>方法以提供的逾時值和取消語彙基元可以結束等候工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-933">The following example calls the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> method to provide both a timeout value and a cancellation token that can end the wait for a task's completion.</span></span> <span data-ttu-id="cccf2-934">新的執行緒已啟動並執行`CancelToken`方法，這個方法會暫停，然後呼叫<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>方法來取消取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-934">A new thread is started and executes the `CancelToken` method, which pauses and then calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to cancel the cancellation tokens.</span></span> <span data-ttu-id="cccf2-935">工作，然後啟動，以及 5 秒鐘的延遲。</span><span class="sxs-lookup"><span data-stu-id="cccf2-935">A task is then launched and delays for 5 seconds.</span></span> <span data-ttu-id="cccf2-936"><xref:System.Threading.Tasks.Task.Wait%2A>方法以等候工作完成再呼叫，並提供簡短的逾時值和取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="cccf2-936">The <xref:System.Threading.Tasks.Task.Wait%2A> method is then called to wait for the task's completion and is provided both a brief timeout value and a cancellation token.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 <span data-ttu-id="cccf2-937">請注意此範例的精確輸出取決於是否在等候已取消的取消語彙基元因為或因為逾時間隔經過。</span><span class="sxs-lookup"><span data-stu-id="cccf2-937">Note that the precise output from the example depends on whether the wait was canceled because of the cancellation token or because the timeout interval elapsed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="cccf2-938">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-938">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-939"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-939">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cccf2-940"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="cccf2-940"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="cccf2-941">工作已取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-941">The task was canceled.</span></span> <span data-ttu-id="cccf2-942"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-942">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
 <span data-ttu-id="cccf2-943">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-943">-or-</span></span>  
  
 <span data-ttu-id="cccf2-944">在工作執行期間擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-944">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="cccf2-945"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含例外狀況的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="cccf2-945">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-946">等候所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-946">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-947">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-947">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <summary><span data-ttu-id="cccf2-948">等候所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-948">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="cccf2-949">下列範例會啟動 10 個工作，其中每個被當做狀態物件中的索引。</span><span class="sxs-lookup"><span data-stu-id="cccf2-949">The following example starts 10 tasks, each of which is passed an index as a state object.</span></span> <span data-ttu-id="cccf2-950">使用索引從兩個五個工作擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-950">Tasks with an index from two to five throw exceptions.</span></span> <span data-ttu-id="cccf2-951">若要呼叫<xref:System.Threading.Tasks.Task.WaitAll%2A>方法會包裝中的所有例外狀況<xref:System.AggregateException>物件，並將其傳播到呼叫的執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-951">The call to the <xref:System.Threading.Tasks.Task.WaitAll%2A> method wraps all exceptions in an <xref:System.AggregateException> object and propagates it to the calling thread.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-952"><paramref name="tasks" /> 中的一個或多個 <see cref="T:System.Threading.Tasks.Task" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-952">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-953"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-953">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-954"><paramref name="tasks" /> 引數包含 null 項目。</span><span class="sxs-lookup"><span data-stu-id="cccf2-954">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
 <span data-ttu-id="cccf2-955">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-955">-or-</span></span>  
  
 <span data-ttu-id="cccf2-956"><paramref name="tasks" /> 引數是空的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-956">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="cccf2-957">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體已取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-957">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="cccf2-958">如果工作已取消，<see cref="T:System.AggregateException" /> 例外狀況會在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" /> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-958">If a task was canceled, the <see cref="T:System.AggregateException" /> exception contains an <see cref="T:System.OperationCanceledException" /> exception in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
 <span data-ttu-id="cccf2-959">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-959">-or-</span></span>  
  
 <span data-ttu-id="cccf2-960">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體在執行期間擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-960">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-961">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-961">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="cccf2-962">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-962">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cccf2-963">等待所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的毫秒數內完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-963">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns>
          <span data-ttu-id="cccf2-964">如果所有 <see langword="true" /> 執行個體在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-964"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-965"><paramref name="tasks" /> 中的一個或多個 <see cref="T:System.Threading.Tasks.Task" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-965">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-966"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-966">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="cccf2-967">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體已取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-967">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="cccf2-968">如果工作已取消，<see cref="T:System.AggregateException" /> 會在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-968">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
 <span data-ttu-id="cccf2-969">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-969">-or-</span></span>  
  
 <span data-ttu-id="cccf2-970">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體在執行期間擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-970">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cccf2-971"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="cccf2-971"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-972"><paramref name="tasks" /> 引數包含 null 項目。</span><span class="sxs-lookup"><span data-stu-id="cccf2-972">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
 <span data-ttu-id="cccf2-973">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-973">-or-</span></span>  
  
 <span data-ttu-id="cccf2-974"><paramref name="tasks" /> 引數是空的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-974">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-975">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-975">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-976">等候工作完成時要觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-976">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for the tasks to complete.</span></span></param>
        <summary><span data-ttu-id="cccf2-977">等候所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-977">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution unless the wait is cancelled.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-978">`cancellationToken`引數用來取消等候作業。</span><span class="sxs-lookup"><span data-stu-id="cccf2-978">The `cancellationToken` argument is used to cancel the wait operation.</span></span> <span data-ttu-id="cccf2-979">取消的工作是相異的作業，並收到訊號的<xref:System.AggregateException>如先前所述。</span><span class="sxs-lookup"><span data-stu-id="cccf2-979">Cancellation of the tasks is a distinct operation, and is signaled by the <xref:System.AggregateException> as noted above.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="cccf2-980">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-980">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-981"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-981">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="cccf2-982">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體已取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-982">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="cccf2-983">如果工作已取消，<see cref="T:System.AggregateException" /> 會在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-983">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
 <span data-ttu-id="cccf2-984">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-984">-or-</span></span>  
  
 <span data-ttu-id="cccf2-985">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體在執行期間擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-985">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-986"><paramref name="tasks" /> 引數包含 null 項目。</span><span class="sxs-lookup"><span data-stu-id="cccf2-986">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
 <span data-ttu-id="cccf2-987">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-987">-or-</span></span>  
  
 <span data-ttu-id="cccf2-988"><paramref name="tasks" /> 引數是空的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-988">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-989"><paramref name="tasks" /> 中的一個或多個 <see cref="T:System.Threading.Tasks.Task" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-989">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-990">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-990">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="cccf2-991">
          <see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-991">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cccf2-992">等候所有提供的可取消 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的時間間隔內完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-992">Waits for all of the provided cancellable <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="cccf2-993">如果所有 <see langword="true" /> 執行個體在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-993"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-994"><paramref name="tasks" /> 中的一個或多個 <see cref="T:System.Threading.Tasks.Task" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-994">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-995"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-995">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="cccf2-996">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體已取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-996">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="cccf2-997">如果工作已取消，<see cref="T:System.AggregateException" /> 會在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-997">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
 <span data-ttu-id="cccf2-998">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-998">-or-</span></span>  
  
 <span data-ttu-id="cccf2-999">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體在執行期間擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-999">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cccf2-1000"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1000"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="cccf2-1001">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-1001">-or-</span></span>  
  
 <span data-ttu-id="cccf2-1002"><paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1002"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1003"><paramref name="tasks" /> 引數包含 null 項目。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1003">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
 <span data-ttu-id="cccf2-1004">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-1004">-or-</span></span>  
  
 <span data-ttu-id="cccf2-1005"><paramref name="tasks" /> 引數是空的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1005">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-1006">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1006">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="cccf2-1007">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1007">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-1008">等候工作完成時要觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1008">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for the tasks to complete.</span></span></param>
        <summary><span data-ttu-id="cccf2-1009">等待所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的毫秒數內完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1009">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds or until the wait is cancelled.</span></span></summary>
        <returns>
          <span data-ttu-id="cccf2-1010">如果所有 <see langword="true" /> 執行個體在指定的時間內執行完成，則為 <see cref="T:System.Threading.Tasks.Task" />，否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1010"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-1011">`cancellationToken`引數用來取消等候作業。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1011">The `cancellationToken` argument is used to cancel the wait operation.</span></span> <span data-ttu-id="cccf2-1012">取消的工作是相異的作業，並收到訊號的<xref:System.AggregateException>先前所述。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1012">Cancellation of the tasks is a distinct operation, and is signaled by the <xref:System.AggregateException> noted above.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-1013"><paramref name="tasks" /> 中的一個或多個 <see cref="T:System.Threading.Tasks.Task" /> 物件已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1013">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1014"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1014">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="cccf2-1015">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體已取消。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1015">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="cccf2-1016">如果工作已取消，<see cref="T:System.AggregateException" /> 會在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1016">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
 <span data-ttu-id="cccf2-1017">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-1017">-or-</span></span>  
  
 <span data-ttu-id="cccf2-1018">至少其中一個 <see cref="T:System.Threading.Tasks.Task" /> 執行個體在執行期間擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1018">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cccf2-1019"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1019"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1020"><paramref name="tasks" /> 引數包含 null 項目。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1020">The <paramref name="tasks" /> argument contains a null element.</span></span>  
  
 <span data-ttu-id="cccf2-1021">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-1021">-or-</span></span>  
  
 <span data-ttu-id="cccf2-1022"><paramref name="tasks" /> 引數是空的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1022">The <paramref name="tasks" /> argument is an empty array.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="cccf2-1023">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1023">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-1024">等候任一提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1024">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-1025">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1025">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <summary><span data-ttu-id="cccf2-1026">等候任一提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1026">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1027"><paramref name="tasks" /> 陣列中已完成之 <see cref="T:System.Threading.Tasks.Task" /> 的索引。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1027">The index of the completed <see cref="T:System.Threading.Tasks.Task" /> object in the <paramref name="tasks" /> array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="cccf2-1028">下列範例會啟動五個工作，其中每個已進入睡眠狀態 50 毫秒為單位的最小值或最大值為 1050 （毫秒）。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1028">The following example launches five tasks, each of which sleeps for a minimum of 50 milliseconds or a maximum of 1,050 milliseconds.</span></span> <span data-ttu-id="cccf2-1029"><xref:System.Threading.Tasks.Task.WaitAny%2A>方法然後等候所有完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1029">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method then waits for any of the tasks to complete.</span></span> <span data-ttu-id="cccf2-1030">這個範例會顯示結束等候工作的工作識別碼，以及所有工作的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1030">The example displays the task ID of the task that ended the wait, as well as the current status of all the tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-1031"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1031">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1032"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1032">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1033"><paramref name="tasks" /> 引數包含 null 項目。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1033">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-1034">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1034">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="cccf2-1035">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1035">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cccf2-1036">等候所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的毫秒數內完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1036">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1037"><paramref name="tasks" /> 陣列引數中已完成工作的索引；如果發生逾時，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1037">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-1038"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1038">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1039"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1039">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cccf2-1040"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1040"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1041"><paramref name="tasks" /> 引數包含 null 項目。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1041">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-1042">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1042">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-1043">等候工作完成時要觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1043">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for a task to complete.</span></span></param>
        <summary><span data-ttu-id="cccf2-1044">等候所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1044">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution unless the wait is cancelled.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1045"><paramref name="tasks" /> 陣列引數中已完成工作的索引。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1045">The index of the completed task in the <paramref name="tasks" /> array argument.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-1046"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1046">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1047"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1047">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1048"><paramref name="tasks" /> 引數包含 null 項目。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1048">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="cccf2-1049">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1049">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-1050">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1050">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="cccf2-1051">
          <see cref="T:System.TimeSpan" />，代表等候毫秒數；或是 <see cref="T:System.TimeSpan" />，代表無限期等候的 -1 毫秒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1051">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="cccf2-1052">等候其中任何一個提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的時間間隔內完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1052">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1053"><paramref name="tasks" /> 陣列引數中已完成工作的索引；如果發生逾時，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1053">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-1054"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1054">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1055"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1055">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cccf2-1056"><paramref name="timeout" /> 為 -1 毫秒以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1056"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="cccf2-1057">-或-</span><span class="sxs-lookup"><span data-stu-id="cccf2-1057">-or-</span></span>  
  
 <span data-ttu-id="cccf2-1058"><paramref name="timeout" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1058"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1059"><paramref name="tasks" /> 引數包含 null 項目。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1059">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-1060">要等待之 <see cref="T:System.Threading.Tasks.Task" /> 執行個體的陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1060">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="cccf2-1061">要等候的毫秒數，如果要無限期等候，則為 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1061">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="cccf2-1062">等候工作完成時要觀察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1062">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for a task to complete.</span></span></param>
        <summary><span data-ttu-id="cccf2-1063">等待所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 物件在指定的毫秒數內完成執行。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1063">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1064"><paramref name="tasks" /> 陣列引數中已完成工作的索引；如果發生逾時，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1064">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="cccf2-1065"><see cref="T:System.Threading.Tasks.Task" /> 已經處置。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1065">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1066"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1066">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="cccf2-1067"><paramref name="millisecondsTimeout" /> 為 -1 以外的負數，表示無限逾時。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1067"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1068"><paramref name="tasks" /> 引數包含 null 項目。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1068">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="cccf2-1069">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1069">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-1070">建立當所有提供的工作完成時才會完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1070">Creates a task that will complete when all of the supplied tasks have completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-1071">要等待完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1071">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="cccf2-1072">建立一個工作，當可列舉集合中的所有 <see cref="T:System.Threading.Tasks.Task" /> 物件完成時，會完成此工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1072">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task" /> objects in an enumerable collection have completed.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1073">工作，代表所有提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1073">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-1074">多載<xref:System.Threading.Tasks.Task.WhenAll%2A>這個方法傳回<xref:System.Threading.Tasks.Task>您感興趣的一組工作的狀態或一組工作所擲回的例外狀況時，通常會呼叫物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1074">The overloads of the <xref:System.Threading.Tasks.Task.WhenAll%2A> method that return a <xref:System.Threading.Tasks.Task> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cccf2-1075">若要呼叫<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>方法不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1075">The call to <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method does not block the calling thread.</span></span>  
  
 <span data-ttu-id="cccf2-1076">如果任何一個提供的工作完成處於錯誤狀態時，傳回的工作也會完成中<xref:System.Threading.Tasks.TaskStatus.Faulted>其中其例外狀況將會包含未包裝的例外狀況，從每個提供的工作集的彙總的狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1076">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state,  where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="cccf2-1077">如果沒有提供的工作發生錯誤，但至少一個已取消，則傳回的工作將在結束<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1077">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="cccf2-1078">如果工作都未發生錯誤的工作已取消，則產生的工作將在結束<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1078">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="cccf2-1079">如果提供陣列/可列舉不包含任何工作，則傳回的工作就會立即轉換成<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態，才能傳回給呼叫者。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1079">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-1080">下列範例會建立一組 ping 陣列中的 Url 的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1080">The following example creates a set of tasks that ping the URLs in an array.</span></span> <span data-ttu-id="cccf2-1081">工作會儲存在`List<Task>`集合傳遞至<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1081">The tasks are stored in a `List<Task>` collection that is passed to the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method.</span></span> <span data-ttu-id="cccf2-1082">若要在呼叫之後<xref:System.Threading.Tasks.Task.Wait%2A>方法可確保所有執行緒都完成，此範例會檢查<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>屬性來判斷是否有錯誤的任何工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1082">After the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that all threads have completed, the example examines the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property to determine whether any tasks have faulted.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1083"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1083">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1084"><paramref name="tasks" />集合包含 <see langword="null" /> 工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1084">The <paramref name="tasks" /> collection contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-1085">要等待完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1085">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="cccf2-1086">建立一個工作，當陣列中的所有 <see cref="T:System.Threading.Tasks.Task" /> 物件完成時，會完成此工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1086">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task" /> objects in an array have completed.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1087">工作，代表所有提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1087">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-1088">多載<xref:System.Threading.Tasks.Task.WhenAll%2A>這個方法傳回<xref:System.Threading.Tasks.Task>您感興趣的一組工作的狀態或一組工作所擲回的例外狀況時，通常會呼叫物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1088">The overloads of the <xref:System.Threading.Tasks.Task.WhenAll%2A> method that return a <xref:System.Threading.Tasks.Task> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cccf2-1089">若要呼叫<xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29>方法不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1089">The call to <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> method does not block the calling thread.</span></span>  
  
 <span data-ttu-id="cccf2-1090">如果任何一個提供的工作完成處於錯誤狀態時，傳回的工作也會完成中<xref:System.Threading.Tasks.TaskStatus.Faulted>其中其例外狀況將會包含未包裝的例外狀況，從每個提供的工作集的彙總的狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1090">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="cccf2-1091">如果沒有提供的工作發生錯誤，但至少一個已取消，則傳回的工作將在結束<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1091">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="cccf2-1092">如果工作都未發生錯誤的工作已取消，則產生的工作將在結束<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1092">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="cccf2-1093">如果提供陣列/可列舉不包含任何工作，則傳回的工作就會立即轉換成<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態，才能傳回給呼叫者。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1093">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-1094">下列範例會建立一組 ping 陣列中的 Url 的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1094">The following example creates a set of tasks that ping the URLs in an array.</span></span> <span data-ttu-id="cccf2-1095">工作會儲存在`List<Task>`集合轉換成陣列，並傳遞至<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>方法。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1095">The tasks are stored in a `List<Task>` collection that is converted to an array and passed to the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method.</span></span> <span data-ttu-id="cccf2-1096">若要在呼叫之後<xref:System.Threading.Tasks.Task.Wait%2A>方法可確保所有執行緒都完成，此範例會檢查<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>屬性來判斷是否有錯誤的任何工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1096">After the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that all threads have completed, the example examines the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property to determine whether any tasks have faulted.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1097"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1097">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1098"><paramref name="tasks" />陣列包含 <see langword="null" /> 工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1098">The <paramref name="tasks" /> array contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-1099">完成的工作類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1099">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="cccf2-1100">要等待完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1100">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="cccf2-1101">建立一個工作，當可列舉集合中的所有 <see cref="T:System.Threading.Tasks.Task`1" /> 物件完成時，會完成此工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1101">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task`1" /> objects in an enumerable collection have completed.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1102">工作，代表所有提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1102">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-1103">若要呼叫<xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29>方法不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1103">The call to <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> method does not block the calling thread.</span></span> <span data-ttu-id="cccf2-1104">不過，所傳回的呼叫<xref:System.Threading.Tasks.Task%601.Result%2A>屬性未封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1104">However, a call to the returned <xref:System.Threading.Tasks.Task%601.Result%2A> property does block the calling thread.</span></span>  
  
 <span data-ttu-id="cccf2-1105">如果任何一個提供的工作完成處於錯誤狀態時，傳回的工作也會完成中<xref:System.Threading.Tasks.TaskStatus.Faulted>其中其例外狀況將會包含未包裝的例外狀況，從每個提供的工作集的彙總的狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1105">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="cccf2-1106">如果沒有提供的工作發生錯誤，但至少一個已取消，則傳回的工作將在結束<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1106">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="cccf2-1107">如果工作都未發生錯誤的工作已取消，則產生的工作將在結束<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1107">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  <span data-ttu-id="cccf2-1108"><xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>傳回工作的屬性會設定為按照提供包含所有的相同順序提供的工作結果的陣列 (例如如果輸入工作所包含的陣列 t1、 t2、 t3、 輸出工作<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>屬性會傳回`TResult[]`其中`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1108">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property will return an `TResult[]` where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span></span>  
  
 <span data-ttu-id="cccf2-1109">如果`tasks`引數包含任何工作，則傳回的工作就會立即轉換成<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態，才能傳回給呼叫者。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1109">If the `tasks` argument contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span> <span data-ttu-id="cccf2-1110">傳回`TResult[]`就會是陣列的項目為 0。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1110">The returned `TResult[]` will be an array of 0 elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-1111">下列範例會建立十個工作，其中每個具現化隨機號碼產生器建立 1000 介於 1 到 1000 之間的隨機數字，並會計算其平均值。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1111">The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</span></span> <span data-ttu-id="cccf2-1112"><xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>方法用來延遲亂數產生器的具現化，使它們不會建立具有相同的種子值。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1112">The <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</span></span> <span data-ttu-id="cccf2-1113">若要呼叫<xref:System.Threading.Tasks.Task.WhenAll%2A>方法接著會傳回<xref:System.Int64>陣列，其中包含平均值計算出每項工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1113">The call to the <xref:System.Threading.Tasks.Task.WhenAll%2A> method then returns an <xref:System.Int64> array that contains the mean computed by each task.</span></span> <span data-ttu-id="cccf2-1114">然後使用這些計算整體的平均數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1114">These are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 <span data-ttu-id="cccf2-1115">在此情況下，將 10 個個別的工作儲存在<xref:System.Collections.Generic.List%601>物件。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1115">In this case, the ten individual tasks are stored in a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="cccf2-1116"><xref:System.Collections.Generic.List%601> 會實作 <xref:System.Collections.Generic.IEnumerable%601> 介面。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1116"><xref:System.Collections.Generic.List%601> implements the <xref:System.Collections.Generic.IEnumerable%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1117"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1117">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1118"><paramref name="tasks" />集合包含 <see langword="null" /> 工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1118">The <paramref name="tasks" /> collection contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-1119">完成的工作類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1119">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="cccf2-1120">要等待完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1120">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="cccf2-1121">建立一個工作，當陣列中的所有 <see cref="T:System.Threading.Tasks.Task`1" /> 物件完成時，會完成此工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1121">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task`1" /> objects in an array have completed.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1122">工作，代表所有提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1122">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-1123">若要呼叫<xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29>方法不會封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1123">The call to <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> method does not block the calling thread.</span></span> <span data-ttu-id="cccf2-1124">不過，所傳回的呼叫<xref:System.Threading.Tasks.Task%601.Result%2A>屬性未封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1124">However, a call to the returned <xref:System.Threading.Tasks.Task%601.Result%2A> property does block the calling thread.</span></span>  
  
 <span data-ttu-id="cccf2-1125">如果任何一個提供的工作完成處於錯誤狀態時，傳回的工作也會完成中<xref:System.Threading.Tasks.TaskStatus.Faulted>其中其例外狀況將會包含未包裝的例外狀況，從每個提供的工作集的彙總的狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1125">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="cccf2-1126">如果沒有提供的工作發生錯誤，但至少一個已取消，則傳回的工作將在結束<xref:System.Threading.Tasks.TaskStatus.Canceled>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1126">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="cccf2-1127">如果工作都未發生錯誤的工作已取消，則產生的工作將在結束<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1127">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  <span data-ttu-id="cccf2-1128"><xref:System.Threading.Tasks.Task%601.Result%2A>傳回的工作將會設定為按照提供包含所有的相同順序提供的工作結果的陣列 (例如如果輸入工作所包含的陣列 t1、 t2、 t3、 輸出工作<xref:System.Threading.Tasks.Task%601.Result%2A>會傳回`TResult[]`其中`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1128">The <xref:System.Threading.Tasks.Task%601.Result%2A> of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output   task's <xref:System.Threading.Tasks.Task%601.Result%2A> will return an `TResult[]` where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span></span>  
  
 <span data-ttu-id="cccf2-1129">如果提供陣列/可列舉不包含任何工作，則傳回的工作就會立即轉換成<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>狀態，才能傳回給呼叫者。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1129">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  <span data-ttu-id="cccf2-1130">傳回`TResult[]`就會是陣列的項目為 0。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1130">The returned `TResult[]` will be an array of 0 elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cccf2-1131">下列範例會建立十個工作，其中每個具現化隨機號碼產生器建立 1000 介於 1 到 1000 之間的隨機數字，並會計算其平均值。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1131">The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</span></span> <span data-ttu-id="cccf2-1132">在此情況下，將 10 個個別的工作儲存在`Task<Int64>`陣列。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1132">In this case, the ten individual tasks are stored in a `Task<Int64>` array.</span></span>  <span data-ttu-id="cccf2-1133"><xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>方法用來延遲亂數產生器的具現化，使它們不會建立具有相同的種子值。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1133">The <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</span></span> <span data-ttu-id="cccf2-1134">若要呼叫<xref:System.Threading.Tasks.Task.WhenAll%2A>方法接著會傳回<xref:System.Int64>陣列，其中包含平均值計算出每項工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1134">The call to the <xref:System.Threading.Tasks.Task.WhenAll%2A> method then returns an <xref:System.Int64> array that contains the mean computed by each task.</span></span> <span data-ttu-id="cccf2-1135">然後使用這些計算整體的平均數。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1135">These are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1136"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1136">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1137"><paramref name="tasks" />陣列包含 <see langword="null" /> 工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1137">The <paramref name="tasks" /> array contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cccf2-1138">建立當任何一個提供的工作完成時才會完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1138">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-1139">要等待完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1139">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="cccf2-1140">建立當任何一個提供的工作完成時才會完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1140">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1141">工作，代表其中一個提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1141">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="cccf2-1142">傳回的工作結果為已完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1142">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-1143">傳回的工作會完成當任何一個提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1143">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="cccf2-1144">傳回的工作將一律會在結束`RanToCompletion`它的結果集的第一個工作完成狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1144">The returned task will always end in the `RanToCompletion` state  with its Result set to the first task to complete.</span></span>  <span data-ttu-id="cccf2-1145">這是 true，即使在第一個工作完成結束`Canceled`或`Faulted`狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1145">This is true even if the first task to complete ended in the `Canceled` or `Faulted` state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1146"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1146">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1147"><paramref name="tasks" />陣列包含 null 工作或是空的。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1147">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="cccf2-1148">要等待完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1148">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="cccf2-1149">建立當任何一個提供的工作完成時才會完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1149">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1150">工作，代表其中一個提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1150">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="cccf2-1151">傳回的工作結果為已完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1151">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-1152">傳回的工作會完成當任何一個提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1152">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="cccf2-1153">傳回的工作將一律會在結束`RanToCompletion`狀態其`Result`設第一個工作，才能完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1153">The returned task will always end in the `RanToCompletion` state   with its `Result` set to the first task to complete.</span></span>  <span data-ttu-id="cccf2-1154">這是 true，即使在第一個工作完成結束`Canceled`或`Faulted`狀態。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1154">This is true even if the first task to complete ended in the `Canceled` or `Faulted` state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1155"><paramref name="tasks" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1155">The <paramref name="tasks" /> argument was null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1156"><paramref name="tasks" />陣列包含 null 工作或是空的。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1156">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-1157">完成的工作類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1157">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="cccf2-1158">要等待完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1158">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="cccf2-1159">建立當任何一個提供的工作完成時才會完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1159">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1160">工作，代表其中一個提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1160">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="cccf2-1161">傳回的工作結果為已完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1161">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-1162">傳回的工作會完成當任何一個提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1162">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="cccf2-1163">傳回的工作最後一定會處於 RanToCompletion 狀態與它的結果集的第一個工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1163">The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</span></span> <span data-ttu-id="cccf2-1164">即使處於已取消或 Faulted 狀態結束的第一個工作完成，也是如此。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1164">This is true even if the first task to complete ended in the Canceled or Faulted state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1165"><paramref name="tasks" /> 引數為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1165">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1166"><paramref name="tasks" />陣列包含 null 工作或是空的。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1166">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="cccf2-1167">完成的工作類型。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1167">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="cccf2-1168">要等待完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1168">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="cccf2-1169">建立當任何一個提供的工作完成時才會完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1169">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1170">工作，代表其中一個提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1170">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="cccf2-1171">傳回的工作結果為已完成的工作。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1171">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-1172">傳回的工作會完成當任何一個提供的工作已完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1172">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="cccf2-1173">傳回的工作最後一定會處於 RanToCompletion 狀態與它的結果集的第一個工作完成。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1173">The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</span></span> <span data-ttu-id="cccf2-1174">即使處於已取消或 Faulted 狀態結束的第一個工作完成，也是如此。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1174">This is true even if the first task to complete ended in the Canceled or Faulted state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cccf2-1175"><paramref name="tasks" /> 引數為 null。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1175">The <paramref name="tasks" /> argument was null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="cccf2-1176"><paramref name="tasks" />陣列包含 null 工作或是空的。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1176">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="cccf2-1177">建立會在等候時以非同步方式遞交 (Yield) 給目前內容的 awaitable 工具。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1177">Creates an awaitable task that asynchronously yields back to the current context when awaited.</span></span></summary>
        <returns><span data-ttu-id="cccf2-1178">內容，這個內容會在受到等候時非同步轉換回等候當時的最新內容。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1178">A context that, when awaited, will asynchronously transition back into the current context at the time of the await.</span></span> <span data-ttu-id="cccf2-1179">如果目前的 <see cref="T:System.Threading.SynchronizationContext" /> 非 null，即視為目前的內容。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1179">If the current <see cref="T:System.Threading.SynchronizationContext" /> is non-null, it is treated as the current context.</span></span> <span data-ttu-id="cccf2-1180">否則，將與目前執行之工作相關聯的工作排程器視為目前的內容。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1180">Otherwise, the task scheduler that is associated with the currently executing task is treated as the current context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cccf2-1181">您可以使用`await Task.Yield();`強制以非同步方式完成方法的非同步方法中。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1181">You can use `await Task.Yield();` in an asynchronous method to force the method to complete asynchronously.</span></span> <span data-ttu-id="cccf2-1182">如果沒有目前的同步處理內容 (<xref:System.Threading.SynchronizationContext>物件)，這將會公佈回該內容的方法執行的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1182">If there is a current synchronization context (<xref:System.Threading.SynchronizationContext> object), this will post the remainder of the method’s execution back to that context.</span></span> <span data-ttu-id="cccf2-1183">不過，內容會決定如何設定這個工作，相對於其他可能是暫止的工作優先權。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1183">However, the context will decide how to prioritize this work relative to other work that may be pending.</span></span> <span data-ttu-id="cccf2-1184">存在於 UI 執行緒在大多數的 UI 環境中的同步處理內容通常會設定優先順序工作公佈到高於輸入和轉譯工作內容。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1184">The synchronization context that is present on a UI thread in most UI environments will often prioritize work posted to the context higher than input and rendering work.</span></span> <span data-ttu-id="cccf2-1185">基於這個理由，請勿依賴`await Task.Yield();`以保留 UI 回應性。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1185">For this reason, do not rely on `await Task.Yield();` to keep a UI responsive.</span></span>  <span data-ttu-id="cccf2-1186">如需詳細資訊，請參閱文章[有用的抽象概念啟用 ContinueWith](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx)中平行程式設計.NET 部落格。</span><span class="sxs-lookup"><span data-stu-id="cccf2-1186">For more information, see the entry [Useful Abstractions Enabled with ContinueWith](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>