<Type Name="IComSoapPublisher" FullName="System.EnterpriseServices.Internal.IComSoapPublisher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2f4ed5c55f002e0539bfb490ba5f807d67d234fa" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30410082" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="VB.NET" Value="Public Interface IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public interface class IComSoapPublisher" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eee-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>發行啟用 SOAP 之 COM+ 應用程式的 COM 介面。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作<xref:System.EnterpriseServices.Internal.IComSoapPublisher>是<xref:System.EnterpriseServices.Internal.Publish>; 請參閱該主題取得詳細資訊。  
  
 <xref:System.EnterpriseServices.Internal.IComSoapPublisher> 為.NET framework 內部使用。 您不需要在您的程式碼中直接使用它。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(6)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Domain" Type="System.String&amp;" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">根郵件伺服器的 URL。</param>
        <param name="MailBox">要建立的信箱。</param>
        <param name="SmtpName">當這個方法傳回時，這個參數會包含內含信箱的 Simple Mail Transfer Protocol (SMTP) 伺服器名稱。</param>
        <param name="Domain">當這個方法傳回時，這個參數會包含 SMTP 伺服器的網域。</param>
        <param name="PhysicalPath">當這個方法傳回時，這個參數會包含信箱的檔案系統路徑。</param>
        <param name="Error">如果遇到問題，則這個方法傳回時，這個參數會包含錯誤訊息。</param>
        <summary>在指定的 URL 建立啟用 SOAP 的 COM+ 應用程式信箱。 未完整實作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未完整實作。目前，不會建立信箱。 傳回的錯誤訊息 「 COM + SOAP 服務不支援 SMTP 發行集 」。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫鏈結中的呼叫端沒有存取 Unmanaged 程式碼的使用權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(4)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String&amp;" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String&amp;" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">要執行的作業。</param>
        <param name="FullUrl">虛擬根目錄 (Virtual Root) 的完整 URL 位址。</param>
        <param name="BaseUrl">當這個方法傳回時，這個參數會包含基礎 URL 位址。</param>
        <param name="VirtualRoot">當這個方法傳回時，這個參數會包含虛擬根目錄的名稱。</param>
        <param name="PhysicalPath">當這個方法傳回時，這個參數會包含虛擬根目錄的檔案路徑。</param>
        <param name="Error">如果遇到問題，則這個方法傳回時，這個參數會包含錯誤訊息。</param>
        <summary>建立啟用 SOAP 的 COM+ 應用程式的虛擬根目錄 (Virtual Root)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建議<xref:System.EnterpriseServices.Internal.ISoapServerVRoot.CreateVirtualRootEx%2A>來取代<xref:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫鏈結中的呼叫端沒有存取 Unmanaged 程式碼的使用權限。  
  
 -或-  
  
 呼叫端並沒有可以存取網域名稱系統 (DNS) 資訊的使用權限。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="FullUrl" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">當解析本機主機名稱時，發生錯誤。</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="FullUrl" /> 是空的。  
  
 -或-  
  
 <paramref name="FullUrl" /> 中指定的配置無效。  
  
 -或-  
  
 <paramref name="FullUrl" /> 包含兩個以上連續的斜線。  
  
 -或-  
  
 <paramref name="FullUrl" /> 中指定的密碼無效。  
  
 -或-  
  
 <paramref name="FullUrl" /> 中指定的主機名稱無效。  
  
 -或-  
  
 <paramref name="FullUrl" /> 中指定的檔案名稱無效。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(7)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">根郵件伺服器的 URL。</param>
        <param name="MailBox">要刪除的信箱。</param>
        <param name="Error">如果遇到問題，則這個方法傳回時，這個參數會包含錯誤訊息。</param>
        <summary>在指定的 URL 刪除啟用 SOAP 的 COM+ 應用程式信箱。 未完整實作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 未完整實作。不會刪除信箱。 傳回的錯誤訊息 「 COM + SOAP 服務不支援 SMTP 發行集 」。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫鏈結中的呼叫端沒有存取 Unmanaged 程式碼的使用權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">根 Web 伺服器。</param>
        <param name="FullUrl">虛擬根目錄 (Virtual Root) 的完整 URL 位址。</param>
        <param name="Error">如果遇到問題，則這個方法傳回時，這個參數會包含錯誤訊息。</param>
        <summary>刪除啟用 SOAP 的 COM+ 應用程式的虛擬根目錄。 未完整實作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 功能<xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A>尚無法使用。  
  
> [!CAUTION]
>  目前，此方法會傳回不會產生錯誤，但不是會刪除虛擬根目錄。  
  
 當功能就會變成可用時，建議使用這個方法會<xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫鏈結中的呼叫端沒有存取 Unmanaged 程式碼的使用權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacInstall(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(13)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">組件的檔案系統路徑。</param>
        <summary>將組件 (Assembly) 安裝到全域組件快取中。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼叫鏈結中的呼叫端沒有存取 Unmanaged 程式碼的使用權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacRemove(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(14)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">組件的檔案系統路徑。</param>
        <summary>將組件從全域組件快取中移除。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="AssemblyPath" /> 是空的。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="AssemblyPath" />。</exception>
        <exception cref="T:System.IO.FileLoadException">使用兩個不同的辨識項載入組件或模組兩次。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> 不是有效的組件。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(15)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">含有 typelib 之檔案的路徑。</param>
        <param name="CachePath">當這個方法傳回時，這個參數會包含 SoapCache 目錄中 Proxy 組件的完整路徑。</param>
        <summary>傳回 SoapCache 目錄中以強式名稱簽名所產生組件的完整路徑。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unmanaged COM + 元件已發佈，透過 SOAP 端點的.NET 遠端處理，必須可讓.NET Framework 中使用的 unmanaged 的元件會產生 proxy。 這樣做，以程式設計方式執行相同的步驟，做為類型程式庫匯入工具 (Tlbimp.exe)，[!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]工具，用於 proxy 的中繼資料組件轉換成 unmanaged 的 COM + 型別程式庫。 不過，對於透過成功的 SOAP 用戶端啟用，用戶端和伺服器電腦必須共用相同的強式名稱簽章的中繼資料 proxy。 基於這個理由，受管理的 proxy 組件時產生的 unmanaged COM + 元件，強式名稱金鑰也產生並用於登入 proxy 的組件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="TypeLibPath" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">此檔案名稱是空的，只包含空格或包含無效字元。</exception>
        <exception cref="T:System.UnauthorizedAccessException">存取 <paramref name="TypeLibPath" /> 遭拒。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在以 Windows 為基礎的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="TypeLibPath" /> 在字串的中間包含一個冒號 (:)。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(10)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">組件的檔案系統路徑。</param>
        <param name="ProgId">類別的程式設計識別項。</param>
        <summary>反映在組件上，並傳回符合 ProgID 的型別名稱。</summary>
        <returns>符合 ProgID 的型別名稱。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼叫鏈結中的呼叫端沒有存取 Unmanaged 程式碼的使用權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(9)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="TypeName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">類別的程式設計識別項。</param>
        <param name="SrcTlbPath">含有 typelib 之檔案的路徑。</param>
        <param name="PhysicalPath">Web 應用程式目錄。</param>
        <param name="VRoot">虛擬根目錄的名稱。</param>
        <param name="BaseUrl">含有虛擬根目錄的基礎 URL。</param>
        <param name="Mode">啟動模式。</param>
        <param name="Transport">未使用。 為此參數指定 <see langword="null" />。</param>
        <param name="AssemblyName">當這個方法傳回時，這個參數會包含組件的顯示名稱。</param>
        <param name="TypeName">當這個方法傳回時，這個參數會包含組件的完整型別名稱。</param>
        <param name="Error">如果遇到問題，則這個方法傳回時，這個參數會包含錯誤訊息。</param>
        <summary>處理用戶端型別程式庫，並在用戶端建立組態檔。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法在用戶端 proxy 匯入用於產生遠端組態檔。  
  
 在實作中，如果`Mode`參數為"wellknownobject"或空字串 ("")，會假設已知的物件。否則，會假設用戶端啟用。  
  
 建議<xref:System.EnterpriseServices.Internal.ISoapClientImport.ProcessClientTlbEx%2A>來取代<xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫鏈結中的呼叫端沒有存取 Unmanaged 程式碼的使用權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(8)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="TypeName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">類別的程式設計識別項。</param>
        <param name="SrcTlbPath">含有型別程式庫之檔案的路徑。</param>
        <param name="PhysicalPath">Web 應用程式目錄。</param>
        <param name="Operation">要執行的作業。</param>
        <param name="AssemblyName">當這個方法傳回時，這個參數會包含組件的顯示名稱。</param>
        <param name="TypeName">當這個方法傳回時，這個參數會包含組件的完整型別名稱。</param>
        <param name="Error">如果遇到問題，則這個方法傳回時，這個參數會包含錯誤訊息。</param>
        <summary>處理伺服器型別程式庫，不是將元件項目加入 Web.config 和 Default.disco 檔案中，就是將之刪除。 若有必要則產生 Proxy。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 會產生 COM + 元件的 Web.config 和 Default.disco 檔案項目。 若有必要則產生 Proxy。  
  
 建議<xref:System.EnterpriseServices.Internal.ISoapServerTlb.AddServerTlb%2A>和<xref:System.EnterpriseServices.Internal.ISoapServerTlb.DeleteServerTlb%2A>來取代<xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫鏈結中的呼叫端沒有存取 Unmanaged 程式碼的使用權限。</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException">
          <paramref name="SrcTlbPath" /> 參數參考到 scrobj.dll，因此不支援指令碼元件的 SOAP 發行作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(11)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">組件的檔案系統路徑。</param>
        <summary>註冊 COM Interop 的組件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作<xref:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly%2A>使用組件註冊工具 (Regasm.exe) 來註冊組件中可建立的類別。 如需詳細資訊，請參閱[Regasm.exe （組件登錄工具）](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">輸入組件沒有強式名稱。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫鏈結中的呼叫端沒有存取 Unmanaged 程式碼的使用權限。  
  
 -或-  
  
 指定了不是以 "file://" 開頭的基礎碼，而且沒有必要的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="AssemblyPath" />，或未指定副檔名。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> 不是有效的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">以兩個不同辨識項載入兩次組件或模組，或是組件名稱長度超過 MAX_PATH 字元數。</exception>
        <exception cref="T:System.InvalidOperationException">以 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 標記的方法不是 <see langword="static" />。  
  
 -或-  
  
 在階層架構的指定層級中，有一個以上的方法是以 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 標記。  
  
 -或-  
  
 以 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 標記之方法的簽章無效。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(12)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">組件的檔案系統路徑。</param>
        <summary>移除 COM Interop 組件的註冊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 實作<xref:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly%2A>使用 Regasm.exe 取消登錄組件中可建立的類別。 如需詳細資訊，請參閱[Regasm.exe （組件登錄工具）](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫鏈結中的呼叫端沒有存取 Unmanaged 程式碼的使用權限。  
  
 -或-  
  
 指定了不是以 "file://" 開頭的基礎碼，而且沒有必要的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          找不到 <paramref name="AssemblyPath" />，或未指定副檔名。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> 不是有效的組件。</exception>
        <exception cref="T:System.IO.FileLoadException">以兩個不同辨識項載入兩次組件或模組，或是組件名稱長度超過 MAX_PATH 字元數。</exception>
        <exception cref="T:System.InvalidOperationException">以 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 標記的方法不是 <see langword="static" />。  
  
 -或-  
  
 在階層架構的指定層級中，有一個以上的方法是以 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 標記。  
  
 -或-  
  
 以 <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> 標記之方法的簽章無效。</exception>
      </Docs>
    </Member>
  </Members>
</Type>