<Type Name="CustomReflectionContext" FullName="System.Reflection.Context.CustomReflectionContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2cb0994464985332742e76a283814be590106a9b" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30470022" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CustomReflectionContext : System.Reflection.ReflectionContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CustomReflectionContext extends System.Reflection.ReflectionContext" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Context.CustomReflectionContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CustomReflectionContext&#xA;Inherits ReflectionContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class CustomReflectionContext abstract : System::Reflection::ReflectionContext" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Context</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.ReflectionContext</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>表示可自訂的反射內容。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Context.CustomReflectionContext> 可讓您新增或移除反映物件中的自訂屬性或新增虛設屬性給那些物件，而不必重新實作完整反映模型。 預設值<xref:System.Reflection.Context.CustomReflectionContext>只包裝反映物件而不進行任何變更，但子類別化並覆寫相關的方法，您可以新增、 移除或變更屬性套用至任何反映的參數或成員，或加入新的屬性以反映型別。  
  
 例如，假設您的程式碼會遵循的慣例套用特定的屬性，這些 factory 方法，但現在您必須使用缺少屬性的協力廠商程式碼。 您可以使用<xref:System.Reflection.Context.CustomReflectionContext>指定識別的物件具有屬性的規則，並提供具有這些屬性的物件，來檢視您的程式碼。  
  
 若要使用<xref:System.Reflection.Context.CustomReflectionContext>有效地使用反映的物件的程式碼必須支援的反映內容，而不是假設所有反映物件與相關聯的執行階段反映內容所指定之概念。 .NET Framework 中的許多反映方法提供<xref:System.Reflection.ReflectionContext>針對此用途的參數。  
  
 若要修改套用至反映的參數或成員的屬性，覆寫<xref:System.Reflection.Context.CustomReflectionContext.GetCustomAttributes%28System.Reflection.ParameterInfo%2CSystem.Collections.Generic.IEnumerable%7BSystem.Object%7D%29>或<xref:System.Reflection.Context.CustomReflectionContext.GetCustomAttributes%28System.Reflection.MemberInfo%2CSystem.Collections.Generic.IEnumerable%7BSystem.Object%7D%29>方法。 這些方法會採用反映的物件和其目前的反映內容，在屬性清單，並傳回的屬性則不能有自訂的反映內容下的清單。  
  
> [!WARNING]
>  <xref:System.Reflection.Context.CustomReflectionContext> 方法不應該呼叫來直接存取的反映的物件或方法的屬性清單<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>至所提供的方法<xref:System.Reflection.MemberInfo>或<xref:System.Reflection.ParameterInfo>執行個體，但是應該改用`declaredAttributes`清單，做為參數傳遞若要<xref:System.Reflection.Context.CustomReflectionContext.GetCustomAttributes%2A>方法多載。  
  
 若要將屬性加入至反映型別，覆寫<xref:System.Reflection.Context.CustomReflectionContext.AddProperties%2A>方法。 方法會接受參數，以指定反映型別，並傳回清單的其他屬性。 您應該使用<xref:System.Reflection.Context.CustomReflectionContext.CreateProperty%2A>方法來建立要傳回的屬性物件。 當建立屬性做為屬性存取子，而且您可以省略其中一個來建立唯讀或唯寫屬性存取子時，您可以指定委派。 請注意，這類虛設屬性沒有中繼資料或通用中繼語言 (CIL) 支援。  
  
> [!WARNING]
>  小心反映物件之間的等號比較當您使用反映的內容，因為物件可能代表相同的反映的物件中多個內容。 您可以使用<xref:System.Reflection.Context.CustomReflectionContext.MapType%2A>方法，以取得特定的反映內容之版本的反映物件。  
  
> [!WARNING]
>  A<xref:System.Reflection.Context.CustomReflectionContext>物件更改屬性反映特定物件，例如所得到的傳回<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法。 它並不會改變所傳回的自訂屬性資料<xref:System.Reflection.MemberInfo.GetCustomAttributesData%2A>方法，而且這兩個清單不會符合您使用自訂的反映內容時。  
  
   
  
## Examples  
 下列範例會示範如何以子類別<xref:System.Reflection.Context.CustomReflectionContext>將自訂屬性新增至指定的型別名稱開頭為"To"的所有成員。 若要執行此程式碼，將它貼到空白主控台中的專案，並確定包含 System.Reflection.Context.dll 的參考。  
  
 [!code-csharp[System.Reflection.Context.CustomReflectionContext#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.context.customreflectioncontext/cs/program.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Reflection.Context.CustomReflectionContext" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CustomReflectionContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CustomReflectionContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Reflection.Context.CustomReflectionContext" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CustomReflectionContext (System.Reflection.ReflectionContext source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Reflection.ReflectionContext source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.#ctor(System.Reflection.ReflectionContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (source As ReflectionContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CustomReflectionContext(System::Reflection::ReflectionContext ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="source" Type="System.Reflection.ReflectionContext" />
      </Parameters>
      <Docs>
        <param name="source">要作為基礎的反射內容。</param>
        <summary>使用指定的反映內容為基底，初始化 <see cref="T:System.Reflection.Context.CustomReflectionContext" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddProperties">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.PropertyInfo&gt; AddProperties (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.PropertyInfo&gt; AddProperties(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.AddProperties(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Reflection::PropertyInfo ^&gt; ^ AddProperties(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.PropertyInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要在其中加入屬性的類型。</param>
        <summary>在衍生類別中覆寫時，為指定的類型提供額外屬性集合，如這個反射內容所表示。</summary>
        <returns>所指定類型的其他屬性集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 覆寫這個方法，以指定哪些屬性應加入至指定的型別。 若要建立屬性，請使用<xref:System.Reflection.Context.CustomReflectionContext.CreateProperty%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立表示要加入至 <see cref="M:System.Reflection.Context.CustomReflectionContext.AddProperties(System.Type)" /> 方法所指定型別之屬性的物件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="protected System.Reflection.PropertyInfo CreateProperty (Type propertyType, string name, Func&lt;object,object&gt; getter, Action&lt;object,object&gt; setter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Reflection.PropertyInfo CreateProperty(class System.Type propertyType, string name, class System.Func`2&lt;object, object&gt; getter, class System.Action`2&lt;object, object&gt; setter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.CreateProperty(System.Type,System.String,System.Func{System.Object,System.Object},System.Action{System.Object,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateProperty (propertyType As Type, name As String, getter As Func(Of Object, Object), setter As Action(Of Object, Object)) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Reflection::PropertyInfo ^ CreateProperty(Type ^ propertyType, System::String ^ name, Func&lt;System::Object ^, System::Object ^&gt; ^ getter, Action&lt;System::Object ^, System::Object ^&gt; ^ setter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="getter" Type="System.Func&lt;System.Object,System.Object&gt;" />
        <Parameter Name="setter" Type="System.Action&lt;System.Object,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyType">要建立的屬性類型。</param>
        <param name="name">要建立的屬性名稱。</param>
        <param name="getter">物件，表示屬性的 <see langword="get" /> 存取子。</param>
        <param name="setter">物件，表示屬性的 <see langword="set" /> 存取子。</param>
        <summary>建立表示要加入至型別之屬性的物件，該型別會搭配 <see cref="M:System.Reflection.Context.CustomReflectionContext.AddProperties(System.Type)" /> 方法使用。</summary>
        <returns>表示屬性的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法所傳回的物件不是完整<xref:System.Reflection.PropertyInfo>物件，並應該只在內容中使用<xref:System.Reflection.Context.CustomReflectionContext.AddProperties%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateProperty">
      <MemberSignature Language="C#" Value="protected System.Reflection.PropertyInfo CreateProperty (Type propertyType, string name, Func&lt;object,object&gt; getter, Action&lt;object,object&gt; setter, System.Collections.Generic.IEnumerable&lt;Attribute&gt; propertyCustomAttributes, System.Collections.Generic.IEnumerable&lt;Attribute&gt; getterCustomAttributes, System.Collections.Generic.IEnumerable&lt;Attribute&gt; setterCustomAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Reflection.PropertyInfo CreateProperty(class System.Type propertyType, string name, class System.Func`2&lt;object, object&gt; getter, class System.Action`2&lt;object, object&gt; setter, class System.Collections.Generic.IEnumerable`1&lt;class System.Attribute&gt; propertyCustomAttributes, class System.Collections.Generic.IEnumerable`1&lt;class System.Attribute&gt; getterCustomAttributes, class System.Collections.Generic.IEnumerable`1&lt;class System.Attribute&gt; setterCustomAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.CreateProperty(System.Type,System.String,System.Func{System.Object,System.Object},System.Action{System.Object,System.Object},System.Collections.Generic.IEnumerable{System.Attribute},System.Collections.Generic.IEnumerable{System.Attribute},System.Collections.Generic.IEnumerable{System.Attribute})" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateProperty (propertyType As Type, name As String, getter As Func(Of Object, Object), setter As Action(Of Object, Object), propertyCustomAttributes As IEnumerable(Of Attribute), getterCustomAttributes As IEnumerable(Of Attribute), setterCustomAttributes As IEnumerable(Of Attribute)) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Reflection::PropertyInfo ^ CreateProperty(Type ^ propertyType, System::String ^ name, Func&lt;System::Object ^, System::Object ^&gt; ^ getter, Action&lt;System::Object ^, System::Object ^&gt; ^ setter, System::Collections::Generic::IEnumerable&lt;Attribute ^&gt; ^ propertyCustomAttributes, System::Collections::Generic::IEnumerable&lt;Attribute ^&gt; ^ getterCustomAttributes, System::Collections::Generic::IEnumerable&lt;Attribute ^&gt; ^ setterCustomAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="getter" Type="System.Func&lt;System.Object,System.Object&gt;" />
        <Parameter Name="setter" Type="System.Action&lt;System.Object,System.Object&gt;" />
        <Parameter Name="propertyCustomAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Attribute&gt;" />
        <Parameter Name="getterCustomAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Attribute&gt;" />
        <Parameter Name="setterCustomAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Attribute&gt;" />
      </Parameters>
      <Docs>
        <param name="propertyType">要建立的屬性類型。</param>
        <param name="name">要建立的屬性名稱。</param>
        <param name="getter">物件，表示屬性的 <see langword="get" /> 存取子。</param>
        <param name="setter">物件，表示屬性的 <see langword="set" /> 存取子。</param>
        <param name="propertyCustomAttributes">要套用至屬性 (Property) 之自訂屬性 (Attribute) 的集合。</param>
        <param name="getterCustomAttributes">要套用至屬性 (Property) 的 <see langword="get" /> 存取子之自訂屬性 (Attribute) 的集合。</param>
        <param name="setterCustomAttributes">要套用至屬性 (Property) 的 <see langword="set" /> 存取子之自訂屬性 (Attribute) 的集合。</param>
        <summary>建立表示要加入至型別之屬性 (Property) 的物件，該型別會搭配 <see cref="M:System.Reflection.Context.CustomReflectionContext.AddProperties(System.Type)" /> 方法使用且使用指定的自訂屬性 (Attribute)。</summary>
        <returns>表示屬性的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法所傳回的物件不是完整<xref:System.Reflection.PropertyInfo>物件，並應該只在內容中使用<xref:System.Reflection.Context.CustomReflectionContext.AddProperties%2A>方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在衍生類別中覆寫時，為指定的物件提供修改過的自訂屬性集合，如這個反射內容所表示。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;object&gt; GetCustomAttributes (System.Reflection.MemberInfo member, System.Collections.Generic.IEnumerable&lt;object&gt; declaredAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;object&gt; GetCustomAttributes(class System.Reflection.MemberInfo member, class System.Collections.Generic.IEnumerable`1&lt;object&gt; declaredAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.GetCustomAttributes(System.Reflection.MemberInfo,System.Collections.Generic.IEnumerable{System.Object})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetCustomAttributes (member As MemberInfo, declaredAttributes As IEnumerable(Of Object)) As IEnumerable(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Object ^&gt; ^ GetCustomAttributes(System::Reflection::MemberInfo ^ member, System::Collections::Generic::IEnumerable&lt;System::Object ^&gt; ^ declaredAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.Reflection.MemberInfo" />
        <Parameter Name="declaredAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="member">會傳回其自訂屬性的成員。</param>
        <param name="declaredAttributes">成員在其目前內容中的屬性集合。</param>
        <summary>在衍生類別中覆寫時，為指定的成員提供自訂屬性清單，如這個反射內容所表示。</summary>
        <returns>表示此反射內容中指定成員之自訂屬性的集合。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;object&gt; GetCustomAttributes (System.Reflection.ParameterInfo parameter, System.Collections.Generic.IEnumerable&lt;object&gt; declaredAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;object&gt; GetCustomAttributes(class System.Reflection.ParameterInfo parameter, class System.Collections.Generic.IEnumerable`1&lt;object&gt; declaredAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.GetCustomAttributes(System.Reflection.ParameterInfo,System.Collections.Generic.IEnumerable{System.Object})" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetCustomAttributes (parameter As ParameterInfo, declaredAttributes As IEnumerable(Of Object)) As IEnumerable(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Object ^&gt; ^ GetCustomAttributes(System::Reflection::ParameterInfo ^ parameter, System::Collections::Generic::IEnumerable&lt;System::Object ^&gt; ^ declaredAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Reflection.ParameterInfo" />
        <Parameter Name="declaredAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="parameter">會傳回其自訂屬性的參數。</param>
        <param name="declaredAttributes">參數在其目前內容中的屬性集合。</param>
        <summary>在衍生類別中覆寫時，為指定的參數提供自訂屬性的清單，如這個反射內容所表示。</summary>
        <returns>表示此反射內容中指定參數之自訂屬性的集合。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapAssembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly MapAssembly (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Assembly MapAssembly(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.MapAssembly(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::Assembly ^ MapAssembly(System::Reflection::Assembly ^ assembly);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly">要在此內容中表示之組件的外部表示。</param>
        <summary>取得此反射內容中由來自另一個反射內容的物件所代表的表示。</summary>
        <returns>此反射內容中的組件表示。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapType">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeInfo MapType (System.Reflection.TypeInfo type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.TypeInfo MapType(class System.Reflection.TypeInfo type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Context.CustomReflectionContext.MapType(System.Reflection.TypeInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MapType (type As TypeInfo) As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::TypeInfo ^ MapType(System::Reflection::TypeInfo ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Context</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="type">要在此內容中表示之型別的外部表示。</param>
        <summary>取得此反射內容中由來自另一個反射內容的物件所代表的型別表示。</summary>
        <returns>此反射內容中的型別表示。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>