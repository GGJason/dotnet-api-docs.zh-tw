<Type Name="DirectoryInfo" FullName="System.IO.DirectoryInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="04e7aec2fa1472f2f76065ad1b2a9c4d599a224c" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37652839" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DirectoryInfo : System.IO.FileSystemInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit DirectoryInfo extends System.IO.FileSystemInfo" />
  <TypeSignature Language="DocId" Value="T:System.IO.DirectoryInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DirectoryInfo&#xA;Inherits FileSystemInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DirectoryInfo sealed : System::IO::FileSystemInfo" />
  <TypeSignature Language="F#" Value="type DirectoryInfo = class&#xA;    inherit FileSystemInfo" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileSystemInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>公開建立、移動和全面列舉目錄和子目錄的執行個體 (Instance) 方法。 這個類別無法被繼承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.DirectoryInfo>類別，例如複製、 移動、 重新命名、 建立和刪除目錄的一般作業。  
  
 如果您要重複使用的物件數次，請考慮使用的執行個體方法<xref:System.IO.DirectoryInfo>而非對應的靜態方法的<xref:System.IO.Directory>類別，因為安全性檢查不一定是必要的。  
  
> [!NOTE]
>  接受的路徑做為輸入字串的成員，該路徑必須是語式正確，或引發例外狀況。 比方說，如果路徑是完整名稱，但以空格開頭，路徑不被修剪中類別的方法。 因此，路徑的格式不正確，而且會引發例外狀況。 同樣地，路徑的組合無法完整限定兩次。 例如，"c:\temp c:\windows，"也會引發例外狀況在大部分情況下。 請確定您的路徑是語式正確的當您使用接受路徑字串的方法。  
  
 在接受路徑的成員，路徑可以參考到檔案或只是一個目錄。 指定的路徑也可以參考相對路徑或通用命名慣例 (UNC) 路徑的伺服器和共用的名稱。 例如，如果以下所有狀況可接受的路徑：  
  
-   "c:\\\MyDir\\\MyFile.txt 」 以 C# 或 Visual Basic 中的 「 c:\MyDir\MyFile.txt"。  
  
-   "c:\\\MyDir 」 以 C# 或 Visual Basic 中的 「 c:\mydir\"。  
  
-   "MyDir\\\MySubdir 」 以 C# 或 Visual Basic 中的 「 MyDir\MySubDir"。  
  
-   「\\\\\\\MyServer\\\MyShare 」 在 C# 中，或 「\\\MyServer\MyShare"在 Visual Basic 中。  
  
 根據預設，新的目錄完整讀取/寫入存取會授與所有使用者。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範一些主要成員的`DirectoryInfo`類別。  
  
 [!code-cpp[DirInfo Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Class Example/CPP/dirinfo class example.cpp#1)]
 [!code-csharp[DirInfo Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Class Example/CS/dirinfo class example.cs#1)]
 [!code-vb[DirInfo Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Class Example/VB/dirinfo class example.vb#1)]  
  
 下列範例示範如何複製目錄及其內容。  
  
 [!code-csharp[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/cs/copydir.cs#1)]
 [!code-vb[IO.DirectoryInfo-CopyDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DirectoryInfo-CopyDir/vb/CopyDir.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="P:System.IO.FileSystemInfo.Attributes" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
    <altmember cref="T:System.IO.Directory" />
    <altmember cref="T:System.IO.Path" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DirectoryInfo (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DirectoryInfo(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.DirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="new System.IO.DirectoryInfo path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">字串，指定用來建立 <see langword="DirectoryInfo" /> 的路徑。</param>
        <summary>在指定的路徑上，初始化 <see cref="T:System.IO.DirectoryInfo" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個建構函式不會檢查目錄是否存在。 這個建構函式是字串，用來存取後續作業中的磁碟的預留位置。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
> [!CAUTION]
>  當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會建立指定的目錄和子目錄中，會使用這個建構函式，並示範，無法刪除此目錄包含子目錄。  
  
 [!code-cpp[DirInfo Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Ctor/CPP/dirinfo ctor.cpp#1)]
 [!code-csharp[DirInfo Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Ctor/CS/dirinfo ctor.cs#1)]
 [!code-vb[DirInfo Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Ctor/VB/dirinfo ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 包含無效的字元，例如 "、&lt;、&gt; 或 |。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取檔案和目錄。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.DriveInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立目錄。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create" />
      <MemberSignature Language="VB.NET" Value="Public Sub Create ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create();" />
      <MemberSignature Language="F#" Value="member this.Create : unit -&gt; unit" Usage="directoryInfo.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>建立目錄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目錄已經存在，這個方法沒有任何作用。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會檢查指定的目錄是否存在，請在如果它不存在，並刪除該目錄建立目錄。  
  
 [!code-cpp[DirInfo Create#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Create/CPP/dirinfo create.cpp#1)]
 [!code-csharp[DirInfo Create#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Create/CS/dirinfo create.cs#1)]
 [!code-vb[DirInfo Create#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Create/VB/dirinfo create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">無法建立目錄。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public void Create (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Create(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Create(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Create(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.Create : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.Create directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">要套用至目錄的存取控制。</param>
        <summary>使用 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 物件建立目錄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法多載來建立目錄透過存取控制，因此不會有的機會可以存取的目錄，才能套用安全性。  
  
 如果目錄已經存在，這個方法沒有任何作用。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">由 <paramref name="path" /> 指定的目錄是唯讀或不是空的。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.NotSupportedException">嘗試只用冒號字元 (:) 建立目錄。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">若要建立目錄的權限。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateSubdirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定路徑上建立子目錄。 指定的路徑可以相對於 <see cref="T:System.IO.DirectoryInfo" /> 類別的這個執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSubdirectory (path As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">指定的路徑。 不能是不同的磁碟區或通用命名慣例 (UNC) 名稱。</param>
        <summary>在指定路徑上建立子目錄。 指定的路徑可以相對於 <see cref="T:System.IO.DirectoryInfo" /> 類別的這個執行個體。</summary>
        <returns>
          <paramref name="path" /> 中指定的最後一個目錄。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中指定的所有目錄`path`會建立，除非有部分的`path`無效。 `path`參數指定的目錄路徑，不是檔案路徑。 如果子目錄已存在，這個方法沒有任何作用。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範如何建立一個子目錄。 在此範例中，建立的目錄建立後移除。 因此，若要測試此範例中，標記為註解刪除的那一行程式碼中。  
  
 [!code-cpp[directoryinfocreatesub#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfocreatesub/CPP/directoryinfocreatesub.cpp#1)]
 [!code-csharp[directoryinfocreatesub#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfocreatesub/CS/directoryinfocreatesub.cs#1)]
 [!code-vb[directoryinfocreatesub#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfocreatesub/VB/directoryinfocreatesub.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 未指定有效的檔案路徑或包含無效的 <see langword="DirectoryInfo" /> 字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.IO.IOException">無法建立子目錄。  或檔案或目錄已有 <paramref name="path" /> 指定的名稱。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有程式碼存取權限，不能建立目錄。  或呼叫端沒有程式碼存取權限，無法讀取傳回的 <see cref="T:System.IO.DirectoryInfo" /> 物件所描述的目錄。  當 <paramref name="path" /> 參數描述現有的目錄時就會發生這種情況。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 包含不是磁碟機標籤 ("C:\\") 一部分的冒號字元 (:)。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateSubdirectory">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo CreateSubdirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo CreateSubdirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.CreateSubdirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ CreateSubdirectory(System::String ^ path, System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.CreateSubdirectory : string * System.Security.AccessControl.DirectorySecurity -&gt; System.IO.DirectoryInfo" Usage="directoryInfo.CreateSubdirectory (path, directorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">指定的路徑。 不能是不同的磁碟區或通用命名慣例 (UNC) 名稱。</param>
        <param name="directorySecurity">要套用的安全性。</param>
        <summary>使用指定的安全性在指定路徑上建立子目錄。 指定的路徑可以相對於 <see cref="T:System.IO.DirectoryInfo" /> 類別的這個執行個體。</summary>
        <returns>
          <paramref name="path" /> 中指定的最後一個目錄。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中指定的所有目錄`path`會建立，除非有部分的`path`無效。 `path`參數指定的目錄路徑，不是檔案路徑。 如果子目錄已存在，這個方法沒有任何作用。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 未指定有效的檔案路徑或包含無效的 <see langword="DirectoryInfo" /> 字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.IO.IOException">無法建立子目錄。  或檔案或目錄已有 <paramref name="path" /> 指定的名稱。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有程式碼存取權限，不能建立目錄。  或呼叫端沒有程式碼存取權限，無法讀取傳回的 <see cref="T:System.IO.DirectoryInfo" /> 物件所描述的目錄。  當 <paramref name="path" /> 參數描述現有的目錄時就會發生這種情況。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 包含不是磁碟機標籤 ("C:\\") 一部分的冒號字元 (:)。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從路徑刪除 <see cref="T:System.IO.DirectoryInfo" /> 和其內容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public override void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Delete();" />
      <MemberSignature Language="F#" Value="override this.Delete : unit -&gt; unit" Usage="directoryInfo.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如果這個 <see cref="T:System.IO.DirectoryInfo" /> 是空的，則將它刪除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 如果您嘗試刪除不是空的目錄，則下列範例會擲回例外狀況。  
  
 [!code-cpp[DirInfo Delete1#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo Delete1/CPP/dirinfo delete1.cpp#1)]
 [!code-csharp[DirInfo Delete1#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo Delete1/CS/dirinfo delete1.cs#1)]
 [!code-vb[DirInfo Delete1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo Delete1/VB/dirinfo delete1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">這個目錄包含唯讀檔案。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">這個 <see cref="T:System.IO.DirectoryInfo" /> 物件描述的目錄不存在，或找不到該目錄。</exception>
        <exception cref="T:System.IO.IOException">目錄不是空的。  或目錄是應用程式目前的工作目錄。  目錄上有開啟的控制代碼，而且作業系統是 Windows XP 或更早的版本。 這個開啟控制代碼可能是列舉目錄所產生的結果。 如需詳細資訊，請參閱 [如何：列舉目錄和檔案] (~/docs/standard/io/how-to-enumerate-directories-and-files.md)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入目錄。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.Delete(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (recursive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(bool recursive);" />
      <MemberSignature Language="F#" Value="override this.Delete : bool -&gt; unit" Usage="directoryInfo.Delete recursive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="recursive">若要刪除這個目錄、其子目錄和所有檔案，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>刪除 <see cref="T:System.IO.DirectoryInfo" /> 的這個執行個體，並指定是否刪除子目錄和檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`DirectoryInfo`沒有檔案或子目錄，此方法會刪除`DirectoryInfo`即使`recursive`是`false`。 嘗試刪除`DirectoryInfo`不是空的時機`recursive`是`false`就會擲回<xref:System.IO.IOException>。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範刪除目錄。 因為目錄已移除，第一次標記為註解`Delete`一行來測試該目錄存在。 然後取消註解程式碼來測試已成功移除目錄的相同一行。  
  
 [!code-cpp[directoryinfodelete#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfodelete/CPP/directoryinfodelete.cpp#1)]
 [!code-csharp[directoryinfodelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfodelete/CS/directoryinfodelete.cs#1)]
 [!code-vb[directoryinfodelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfodelete/VB/directoryinfodelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">這個目錄包含唯讀檔案。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">這個 <see cref="T:System.IO.DirectoryInfo" /> 物件描述的目錄不存在，或找不到該目錄。</exception>
        <exception cref="T:System.IO.IOException">目錄是唯讀的。  或目錄包含一或多個檔案或子目錄，且 <paramref name="recursive" /> 是 <see langword="false" />。  或目錄是應用程式目前的工作目錄。  目錄上或目錄的其中一個檔案上有開啟的控制代碼，而且作業系統是 Windows XP 或之前的版本。 這個開啟的控制代碼可能是列舉目錄和檔案所產生的結果。 如需詳細資訊，請參閱 [如何：列舉目錄和檔案] (~/docs/standard/io/how-to-enumerate-directories-and-files.md)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">撰寫所需的寫入權限的旗標<see langword="DirectoryInfo" />和要刪除的子目錄。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回目前目錄中目錄資訊的可列舉集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories () As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories();" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : unit -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前目錄中目錄資訊的可列舉集合。</summary>
        <returns>目前目錄中目錄的可列舉集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>和<xref:System.IO.DirectoryInfo.GetDirectories%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>，您可以開始列舉的集合<xref:System.IO.DirectoryInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetDirectories%2A>，您必須等到整個陣列<xref:System.IO.DirectoryInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>可能會更有效率。  
  
 這個方法會預先填入下列值<xref:System.IO.DirectoryInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 不會快取傳回的集合;每次呼叫<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>集合上的方法將會啟動新的列舉型別。  
  
   
  
## Examples  
 下列範例會列舉在 C:\Program Files 目錄下的子目錄，並使用 LINQ 查詢來傳回藉由檢查值 2009年之前所建立的所有目錄的名稱<xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>屬性。  
  
 如果您只需要子目錄的名稱，使用靜態<xref:System.IO.Directory>類別，以提升效能。 如需範例，請參閱<xref:System.IO.Directory.EnumerateDirectories%28System.String%29>方法。  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumDirs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumdirs/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <see cref="T:System.IO.DirectoryInfo" /> 物件中封裝的路徑無效 (例如它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateDirectories (searchPattern As String) As IEnumerable(Of DirectoryInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對目錄名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <summary>傳回符合指定之搜尋模式的目錄資訊的可列舉集合。</summary>
        <returns>傳回符合 <paramref name="searchPattern" /> 的目錄的可列舉集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 可以是常值與萬用字元字元的組合，但它不支援規則運算式。 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元規範|符合|  
|------------------------|-------------|  
|* (星號)|在該位置的零或多個字元。|  
|? （問號）|該位置中的零個或一個字元。|  
  
 非萬用字元的字元是常值字元。 例如，字串"* t 」 中以字母"t"結尾的所有名稱的搜尋。 ". `searchPattern`字串"s\*」 中的所有名稱搜尋`path`開頭為字母"s"。  
  
 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>和<xref:System.IO.DirectoryInfo.GetDirectories%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>，您可以開始列舉的集合<xref:System.IO.DirectoryInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetDirectories%2A>，您必須等到整個陣列<xref:System.IO.DirectoryInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>可能會更有效率。  
  
 這個方法會預先填入下列值<xref:System.IO.DirectoryInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 不會快取傳回的集合;每次呼叫<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>集合上的方法將會啟動新的列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <see cref="T:System.IO.DirectoryInfo" /> 物件中封裝的路徑無效 (例如它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt; EnumerateDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.DirectoryInfo&gt; EnumerateDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::DirectoryInfo ^&gt; ^ EnumerateDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateDirectories : string * System.IO.SearchOption -&gt; seq&lt;System.IO.DirectoryInfo&gt;" Usage="directoryInfo.EnumerateDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.DirectoryInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對目錄名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <param name="searchOption">其中一個列舉值，指定搜尋作業應該只包含目前目錄還是包含所有子目錄。 預設值是 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />。</param>
        <summary>傳回符合指定之搜尋模式和搜尋子目錄選項的目錄資訊的可列舉集合。</summary>
        <returns>傳回符合 <paramref name="searchPattern" /> 和 <paramref name="searchOption" /> 的目錄的可列舉集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 可以是常值與萬用字元字元的組合，但它不支援規則運算式。 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元規範|符合|  
|------------------------|-------------|  
|* (星號)|在該位置的零或多個字元。|  
|? （問號）|該位置中的零個或一個字元。|  
  
 非萬用字元的字元是常值字元。 例如，字串"* t 」 中以字母"t"結尾的所有名稱的搜尋。 ". `searchPattern`字串"s\*」 中的所有名稱搜尋`path`開頭為字母"s"。  
  
 <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>和<xref:System.IO.DirectoryInfo.GetDirectories%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>，您可以開始列舉的集合<xref:System.IO.DirectoryInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetDirectories%2A>，您必須等到整個陣列<xref:System.IO.DirectoryInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>可能會更有效率。  
  
 這個方法會預先填入下列值<xref:System.IO.DirectoryInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 不會快取傳回的集合;每次呼叫<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>集合上的方法將會啟動新的列舉型別。  
  
   
  
## Examples  
 下列範例中，從指定的目錄中，會使用這個方法和<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>方法來列舉的檔案和目錄內的開始目錄，並顯示任何詳細資料檔案超過 10 MB 的大小。  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumerateDirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumeratedirectories/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> 不是有效的 <see cref="T:System.IO.SearchOption" /> 值。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <see cref="T:System.IO.DirectoryInfo" /> 物件中封裝的路徑無效 (例如它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回目前目錄中檔案資訊的可列舉集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles () As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : unit -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前目錄中檔案資訊的可列舉集合。</summary>
        <returns>目前目錄中檔案的可列舉集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>和<xref:System.IO.DirectoryInfo.GetFiles%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>，您可以開始列舉的集合<xref:System.IO.FileInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetFiles%2A>，您必須等到整個陣列<xref:System.IO.FileInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>可能會更有效率。  
  
 這個方法會預先填入下列值<xref:System.IO.FileInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 不會快取傳回的集合;每次呼叫<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>集合上的方法將會啟動新的列舉型別。  
  
   
  
## Examples  
 下列範例會列舉指定的目錄下的檔案，並使用 LINQ 查詢來傳回藉由檢查值 2009年之前所建立的所有檔案的名稱<xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>屬性。  
  
 如果您只需要的檔案名稱，使用靜態<xref:System.IO.Directory>類別，以提升效能。 如需範例，請參閱<xref:System.IO.Directory.EnumerateFiles%28System.String%29?displayProperty=nameWithType>方法。  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module1.vb#1)]  
  
 下列範例會示範如何使用不同的搜尋選項列舉目錄中的檔案。 此範例假設目錄名為具有名為 log1.txt、 log2.txt、 test1.txt、 test2.txt、 test3.txt 和名為 SubFile.txt 檔案的子目錄的檔案。  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <see cref="T:System.IO.DirectoryInfo" /> 物件中封裝的路徑無效 (例如它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFiles (searchPattern As String) As IEnumerable(Of FileInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對檔案名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <summary>傳回符合指定之搜尋模式的檔案資訊的可列舉集合。</summary>
        <returns>傳回符合 <paramref name="searchPattern" /> 的檔案的可列舉集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 可以是常值與萬用字元字元的組合，但它不支援規則運算式。 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元規範|符合|  
|------------------------|-------------|  
|* (星號)|在該位置的零或多個字元。|  
|? （問號）|該位置中的零個或一個字元。|  
  
 非萬用字元的字元是常值字元。 例如，字串"* t 」 中以字母"t"結尾的所有名稱的搜尋。 ". `searchPattern`字串"s\*」 中的所有名稱搜尋`path`開頭為字母"s"。  
  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>和<xref:System.IO.DirectoryInfo.GetFiles%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>，您可以開始列舉的集合<xref:System.IO.FileInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetFiles%2A>，您必須等到整個陣列<xref:System.IO.FileInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>可能會更有效率。  
  
 這個方法會預先填入下列值<xref:System.IO.FileInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 不會快取傳回的集合;每次呼叫<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>集合上的方法將會啟動新的列舉型別。  
  
   
  
## Examples  
 下列範例會示範如何使用不同的搜尋選項列舉目錄中的檔案。 此範例假設目錄名為具有名為 log1.txt、 log2.txt、 test1.txt、 test2.txt、 test3.txt 和名為 SubFile.txt 檔案的子目錄的檔案。  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <see cref="T:System.IO.DirectoryInfo" /> 物件中封裝的路徑無效 (例如它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt; EnumerateFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileInfo&gt; EnumerateFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileInfo ^&gt; ^ EnumerateFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFiles : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileInfo&gt;" Usage="directoryInfo.EnumerateFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對檔案名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <param name="searchOption">其中一個列舉值，指定搜尋作業應該只包含目前目錄還是包含所有子目錄。 預設值是 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />。</param>
        <summary>傳回符合指定之搜尋模式和搜尋子目錄選項的檔案資訊的可列舉集合。</summary>
        <returns>傳回符合 <paramref name="searchPattern" /> 和 <paramref name="searchOption" /> 的檔案的可列舉集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 可以是常值與萬用字元字元的組合，但它不支援規則運算式。 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元規範|符合|  
|------------------------|-------------|  
|* (星號)|在該位置的零或多個字元。|  
|? （問號）|該位置中的零個或一個字元。|  
  
 非萬用字元的字元是常值字元。 例如，字串"* t 」 中以字母"t"結尾的所有名稱的搜尋。 ". `searchPattern`字串"s\*」 中的所有名稱搜尋`path`開頭為字母"s"。  
  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>和<xref:System.IO.DirectoryInfo.GetFiles%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>，您可以開始列舉的集合<xref:System.IO.FileInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetFiles%2A>，您必須等到整個陣列<xref:System.IO.FileInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>可能會更有效率。  
  
 這個方法會預先填入下列值<xref:System.IO.FileInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
 不會快取傳回的集合;每次呼叫<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>集合上的方法將會啟動新的列舉型別。  
  
   
  
## Examples  
 下列範例會示範如何使用不同的搜尋選項列舉目錄中的檔案。 此範例假設目錄名為具有名為 log1.txt、 log2.txt、 test1.txt、 test2.txt、 test3.txt 和名為 SubFile.txt 檔案的子目錄的檔案。  
  
 [!code-csharp[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/cs/program2.cs#2)]
 [!code-vb[System.IO.DirectoryInfo.EnumFiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directoryinfo.enumfiles/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> 不是有效的 <see cref="T:System.IO.SearchOption" /> 值。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <see cref="T:System.IO.DirectoryInfo" /> 物件中封裝的路徑無效 (例如它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnumerateFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回目前目錄中檔案系統資訊的可列舉集合。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos () As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : unit -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前目錄中檔案系統資訊的可列舉集合。</summary>
        <returns>目前目錄中檔案系統資訊的可列舉集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>和<xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>，您可以開始列舉的集合<xref:System.IO.FileSystemInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>，您必須等到整個陣列<xref:System.IO.FileSystemInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>可能會更有效率。  
  
 這個方法會預先填入下列值<xref:System.IO.FileSystemInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 不會快取傳回的集合;每次呼叫<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>集合上的方法將會啟動新的列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <see cref="T:System.IO.DirectoryInfo" /> 物件中封裝的路徑無效 (例如它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateFileSystemInfos (searchPattern As String) As IEnumerable(Of FileSystemInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對目錄名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <summary>傳回符合指定之搜尋模式的檔案系統資訊的可列舉集合。</summary>
        <returns>符合 <paramref name="searchPattern" /> 的檔案系統資訊的可列舉集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 可以是常值與萬用字元字元的組合，但它不支援規則運算式。 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元規範|符合|  
|------------------------|-------------|  
|* (星號)|在該位置的零或多個字元。|  
|? （問號）|該位置中的零個或一個字元。|  
  
 非萬用字元的字元是常值字元。 例如，字串"* t 」 中以字母"t"結尾的所有名稱的搜尋。 ". `searchPattern`字串"s\*」 中的所有名稱搜尋`path`開頭為字母"s"。  
  
 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>和<xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>，您可以開始列舉的集合<xref:System.IO.FileSystemInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>，您必須等到整個陣列<xref:System.IO.FileSystemInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>可能會更有效率。  
  
 這個方法會預先填入下列值<xref:System.IO.FileSystemInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 不會快取傳回的集合;每次呼叫<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>集合上的方法將會啟動新的列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <see cref="T:System.IO.DirectoryInfo" /> 物件中封裝的路徑無效 (例如它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.EnumerationOptions -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.IO.FileSystemInfo&gt; EnumerateFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.EnumerateFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::IO::FileSystemInfo ^&gt; ^ EnumerateFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.EnumerateFileSystemInfos : string * System.IO.SearchOption -&gt; seq&lt;System.IO.FileSystemInfo&gt;" Usage="directoryInfo.EnumerateFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.IO.FileSystemInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對目錄名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <param name="searchOption">其中一個列舉值，指定搜尋作業應該只包含目前目錄還是包含所有子目錄。 預設值是 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />。</param>
        <summary>傳回符合指定之搜尋模式和搜尋子目錄選項的檔案系統資訊的可列舉集合。</summary>
        <returns>符合 <paramref name="searchPattern" /> 和 <paramref name="searchOption" /> 的檔案系統資訊的可列舉集合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 可以是常值與萬用字元字元的組合，但它不支援規則運算式。 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元規範|符合|  
|------------------------|-------------|  
|* (星號)|在該位置的零或多個字元。|  
|? （問號）|該位置中的零個或一個字元。|  
  
 非萬用字元的字元是常值字元。 例如，字串"* t 」 中以字母"t"結尾的所有名稱的搜尋。 ". `searchPattern`字串"s\*」 中的所有名稱搜尋`path`開頭為字母"s"。  
  
 <xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>和<xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>，您可以開始列舉的集合<xref:System.IO.FileSystemInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>，您必須等到整個陣列<xref:System.IO.FileSystemInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>可能會更有效率。  
  
 這個方法會預先填入下列值<xref:System.IO.FileSystemInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 不會快取傳回的集合;每次呼叫<xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>集合上的方法將會啟動新的列舉型別。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> 不是有效的 <see cref="T:System.IO.SearchOption" /> 值。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <see cref="T:System.IO.DirectoryInfo" /> 物件中封裝的路徑無效 (例如它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public override bool Exists { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Exists" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Exists" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Exists As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Exists { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Exists : bool" Usage="System.IO.DirectoryInfo.Exists" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出目錄是否存在。</summary>
        <value>如果目錄存在，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.Exists%2A>屬性會傳回`false`如果嘗試判斷指定的檔案是否存在時發生任何錯誤。 可能發生這種情況下，會引發例外狀況，例如傳遞檔名無效的字元或太多字元、 失敗或遺失的磁碟，或如果呼叫端沒有讀取檔案的權限。  
  
   
  
## Examples  
 下列範例示範使用`Exists`將來源目錄複製到目標目錄的內容中的屬性。  
  
 [!code-cpp[DirectoryInfo Usage Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirectoryInfo Usage Example/CPP/copydirectory.cpp#1)]
 [!code-csharp[DirectoryInfo Usage Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirectoryInfo Usage Example/CS/copydirectory.cs#1)]
 [!code-vb[DirectoryInfo Usage Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirectoryInfo Usage Example/VB/copydirectory.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.IO.DirectoryInfo.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目錄的完整路徑。</summary>
        <value>含有完整路徑的字串。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得目前目錄的存取控制清單 (ACL) 項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.DirectoryInfo.GetAccessControl%2A>方法來擷取存取控制清單 (ACL) 項目目前的檔案。  
  
 如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 物件，該物件會封裝目前 <see cref="T:System.IO.DirectoryInfo" /> 物件所描述的目錄之存取控制清單 (ACL) 項目。</summary>
        <returns>
          <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 物件，封裝目錄的存取控制規則。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫這個方法多載就相當於呼叫<xref:System.IO.Directory.GetAccessControl%2A>方法多載，並指定存取控制區段<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> &#124; <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> `Or` <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType> Visual Basic 中)。  
  
 使用<xref:System.IO.DirectoryInfo.GetAccessControl%2A>方法來擷取目前的檔案存取控制清單 (ACL) 項目。  
  
 ACL 描述個人及/或群組，或沒有，在指定的檔案或目錄上的特定動作的權限。 如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.DirectoryInfo.GetAccessControl%2A>和<xref:System.IO.DirectoryInfo.SetAccessControl%2A>方法來新增，然後再移除存取控制清單 (ACL) 項目，從目錄。  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">找不到目錄或無法修改目錄。</exception>
        <exception cref="T:System.UnauthorizedAccessException">目錄是唯讀的。  或這個作業在目前平台不受支援。  或呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.IOException">開啟目錄時發生 I/O 錯誤。</exception>
        <exception cref="T:System.PlatformNotSupportedException">目前的作業系統不是 Microsoft Windows 2000 (含) 以後版本。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">若要列舉目錄存取控制清單 (ACL) 的權限。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />， <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.DirectorySecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.DirectorySecurity GetAccessControl(valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl (includeSections As AccessControlSections) As DirectorySecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::DirectorySecurity ^ GetAccessControl(System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.DirectorySecurity" Usage="directoryInfo.GetAccessControl includeSections" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="includeSections">其中一個 <see cref="T:System.Security.AccessControl.AccessControlSections" /> 值，指定要接收的存取控制清單 (ACL) 資訊之類型。</param>
        <summary>取得 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 物件，該物件會封裝目前 <see cref="T:System.IO.DirectoryInfo" /> 物件所描述的目錄之指定類型的存取控制清單 (ACL) 項目。</summary>
        <returns>
          <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 物件，該物件會封裝 <paramref name="path" /> 參數所描述之檔案的存取控制規則。  例外狀況 <list type="table"><listheader><term> 例外狀況類型 </term><description> 狀況 </description></listheader><item><term><see cref="T:System.SystemException" /></term><description> 找不到目錄或無法修改目錄。</description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> 目前的處理序不具有開啟目錄的存取權。</description></item><item><term><see cref="T:System.IO.IOException" /></term><description> 開啟目錄時發生 I/O 錯誤。</description></item><item><term><see cref="T:System.PlatformNotSupportedException" /></term><description> 目前的作業系統不是 Microsoft Windows 2000 (含) 以後版本。</description></item><item><term><see cref="T:System.UnauthorizedAccessException" /></term><description> 目錄是唯讀的。 或這個作業在目前平台不受支援。 或呼叫端沒有必要的權限。 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.DirectoryInfo.GetAccessControl%2A>方法來擷取目前的檔案存取控制清單 (ACL) 項目。  
  
 ACL 描述個人及/或群組，或沒有，在指定的檔案或目錄上的特定動作的權限。 如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">若要列舉目錄存取控制清單 (ACL) 的權限。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />， <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>傳回目前目錄的子目錄。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories () As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories();" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : unit -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回目前目錄的子目錄。</summary>
        <returns>
          <see cref="T:System.IO.DirectoryInfo" /> 物件的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不有任何子目錄，則這個方法會傳回空陣列。 這個方法不是遞迴。  
  
 這個方法會預先填入下列值<xref:System.IO.DirectoryInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 下列範例會擷取在根目錄中的所有目錄，並顯示目錄名稱。  
  
 [!code-cpp[directoryinfogetdirectories#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfogetdirectories/CPP/directoryinfogetdirectories.cpp#1)]
 [!code-csharp[directoryinfogetdirectories#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetdirectories/CS/directoryinfogetdirectories.cs#1)]
 [!code-vb[directoryinfogetdirectories#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetdirectories/VB/directoryinfogetdirectories.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">封裝在 <see cref="T:System.IO.DirectoryInfo" /> 物件中的路徑無效，例如位在未對應的磁碟上。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取目錄。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (searchPattern As String) As DirectoryInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對目錄名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <summary>傳回在目前 <see cref="T:System.IO.DirectoryInfo" /> 中，符合指定的搜尋準則的目錄陣列。</summary>
        <returns>
          <see langword="DirectoryInfo" /> 類型的陣列，符合 <paramref name="searchPattern" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 可以是常值與萬用字元字元的組合，但它不支援規則運算式。 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元規範|符合|  
|------------------------|-------------|  
|* (星號)|在該位置的零或多個字元。|  
|? （問號）|該位置中的零個或一個字元。|  
  
 非萬用字元的字元是常值字元。 例如，字串"* t 」 中以字母"t"結尾的所有名稱的搜尋。 ". `searchPattern`字串"s\*」 中的所有名稱搜尋`path`開頭為字母"s"。  
  
 這個方法會預先填入下列值<xref:System.IO.DirectoryInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 下列範例會計算的目錄路徑中包含所指定的字母。  
  
 [!code-cpp[DirInfo GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/DirInfo GetDirs2/CPP/dirinfo getdirs2.cpp#1)]
 [!code-csharp[DirInfo GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetDirs2/CS/dirinfo getdirs2.cs#1)]
 [!code-vb[DirInfo GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetDirs2/VB/dirinfo getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> 包含一或多個 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <see langword="DirectoryInfo" /> 物件中封裝的路徑無效 (例如它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取檔案和目錄和路徑的存取權。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.EnumerationOptions -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo[] GetDirectories (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.DirectoryInfo[] GetDirectories(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetDirectories(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::DirectoryInfo ^&gt; ^ GetDirectories(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * System.IO.SearchOption -&gt; System.IO.DirectoryInfo[]" Usage="directoryInfo.GetDirectories (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對目錄名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <param name="searchOption">其中一個列舉值，指定搜尋作業應該只包含目前目錄還是包含所有子目錄。</param>
        <summary>傳回目前 <see cref="T:System.IO.DirectoryInfo" /> 中的目錄陣列，這些目錄符合指定的搜尋準則並使用值來判斷是否搜尋子目錄。</summary>
        <returns>
          <see langword="DirectoryInfo" /> 類型的陣列，符合 <paramref name="searchPattern" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 可以是常值與萬用字元字元的組合，但它不支援規則運算式。 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元規範|符合|  
|------------------------|-------------|  
|* (星號)|在該位置的零或多個字元。|  
|? （問號）|該位置中的零個或一個字元。|  
  
 非萬用字元的字元是常值字元。 例如，字串"* t 」 中以字母"t"結尾的所有名稱的搜尋。 ". `searchPattern`字串"s\*」 中的所有名稱搜尋`path`開頭為字母"s"。  
  
 如果不有任何子目錄中，或任何子目錄符合`searchPattern`參數，這個方法會傳回空陣列。  
  
 這個方法會預先填入下列值<xref:System.IO.DirectoryInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 下列範例會列出所有開頭為字母"c"的檔案與目錄在"c:\\"。  
  
 [!code-cpp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cpp/searchoption.cpp#00)]
 [!code-csharp[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/cs/searchoption.cs#00)]
 [!code-vb[System.IO.DirectoryInfo_SearchOptions#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryInfo_SearchOptions/vb/searchoption.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> 包含一或多個 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> 不是有效的 <see cref="T:System.IO.SearchOption" /> 值。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">在 <see langword="DirectoryInfo" /> 物件中封裝的路徑無效 (例如它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取檔案和目錄和路徑的存取權。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>從目前的目錄傳回檔案清單。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles () As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="member this.GetFiles : unit -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從目前的目錄傳回檔案清單。</summary>
        <returns>類型為 <see cref="T:System.IO.FileInfo" /> 的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>和<xref:System.IO.DirectoryInfo.GetFiles%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>，您可以開始列舉的集合<xref:System.IO.FileInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetFiles%2A>，您必須等到整個陣列<xref:System.IO.FileInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>可能會更有效率。  
  
 如果沒有任何檔案在<xref:System.IO.DirectoryInfo>，這個方法會傳回空陣列。  
  
 不保證的順序傳回的檔案名稱;使用<xref:System.Array.Sort%2A>是否需要特定的排序次序的方法。  
  
 這個方法會預先填入下列值<xref:System.IO.FileInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 下列範例示範如何從目錄取得一份檔案，以使用不同的搜尋選項。 此範例假設目錄名為具有名為 log1.txt、 log2.txt、 test1.txt、 test2.txt、 test3.txt 和名為 SubFile.txt 檔案的子目錄的檔案。  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">路徑無效，例如位於未對應的磁碟機上。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取目錄。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (searchPattern As String) As FileInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對檔案名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <summary>從目前目錄傳回符合指定之搜尋模式的檔案清單。</summary>
        <returns>類型為 <see cref="T:System.IO.FileInfo" /> 的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 可以是常值與萬用字元字元的組合，但它不支援規則運算式。 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元規範|符合|  
|------------------------|-------------|  
|* (星號)|在該位置的零或多個字元。|  
|? （問號）|該位置中的零個或一個字元。|  
  
 非萬用字元的字元是常值字元。 例如，字串"* t 」 中以字母"t"結尾的所有名稱的搜尋。 `searchPattern`字串"s\*」 中的所有名稱搜尋`path`開頭為字母"s"。  
  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>和<xref:System.IO.DirectoryInfo.GetFiles%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>，您可以開始列舉的集合<xref:System.IO.FileInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetFiles%2A>，您必須等到整個陣列<xref:System.IO.FileInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>可能會更有效率。  
  
 如果沒有任何檔案在<xref:System.IO.DirectoryInfo>，這個方法會傳回空陣列。  
  
 允許使用下列萬用字元規範`searchPattern`參數。  
  
|萬用字元|描述|  
|------------------------|-----------------|  
|*|零或多個字元。|  
|?|剛好零個或一個字元。|  
  
 不保證的順序傳回的檔案名稱;使用<xref:System.Array.Sort%2A>是否需要特定的排序次序的方法。  
  
 允許使用萬用字元。 比方說，`searchPattern`字串"*.txt"的搜尋，所有檔案擁有的"txt"延伸模組的名稱。 `searchPattern`字串"s\*"會搜尋所有檔案名稱開頭為字母"s"。 如果有任何檔案或沒有檔案符合`searchPattern`字串中<xref:System.IO.DirectoryInfo>，這個方法會傳回空陣列。  
  
> [!NOTE]
>  當使用星號萬用字元在`searchPattern`(例如，"*.txt")，比對行為會根據指定的副檔名的長度而有所不同。 A`searchPattern`檔案的剛好三個字元的延伸模組會傳回前三個字元要比對中指定的副檔名的檔案副檔名為三個或多個字元， `searchPattern`。 A`searchPattern`檔案的其中一個、 兩個或三個以上的字元的延伸模組會傳回具有該長度為完全符合在指定的檔案副檔名的副檔名的檔案`searchPattern`。 當使用問號萬用字元，則這個方法會傳回符合指定的副檔名的檔案。 例如，假設兩個檔案的目錄、"file1.txt"和"file1.txtother"，搜尋模式的 「 檔案？。txt"傳回只有第一個檔案，同時搜尋模式的 「 檔案\*.txt"會傳回這兩個檔案。  
  
> [!NOTE]
>  因為這個方法會檢查使用 8.3 檔案名稱格式和長時間的檔案名稱格式的檔案名稱，搜尋模式類似於 「 * 1\*.txt 」 可能會傳回未預期的檔案名稱。 例如，使用搜尋模式的 「\*1\*.txt"會傳回 「 longfilename.txt"，因為對等的 8.3 檔案名稱格式會是"longf~1.txt 」。  
  
 這個方法會預先填入下列值<xref:System.IO.FileInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
-   <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 下列範例示範如何從目錄取得一份檔案，以使用不同的搜尋選項。 此範例假設目錄名為具有名為 log1.txt、 log2.txt、 test1.txt、 test2.txt、 test3.txt 和名為 SubFile.txt 檔案的子目錄的檔案。  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> 包含一或多個 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對至路徑和檔案和目錄的讀取存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.EnumerationOptions -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo[] GetFiles (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileInfo[] GetFiles(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFiles(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileInfo ^&gt; ^ GetFiles(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * System.IO.SearchOption -&gt; System.IO.FileInfo[]" Usage="directoryInfo.GetFiles (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對檔案名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <param name="searchOption">其中一個列舉值，指定搜尋作業應該只包含目前目錄還是包含所有子目錄。</param>
        <summary>從目前目錄傳回符合指定搜尋模式的檔案清單，並使用值來判斷是否搜尋子目錄。</summary>
        <returns>類型為 <see cref="T:System.IO.FileInfo" /> 的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>和<xref:System.IO.DirectoryInfo.GetFiles%2A>方法的差異，如下所示：  
  
-   當您使用<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>，您可以開始列舉的集合<xref:System.IO.FileInfo>物件之前則會傳回整個集合。  
  
-   當您使用<xref:System.IO.DirectoryInfo.GetFiles%2A>，您必須等到整個陣列<xref:System.IO.FileInfo>才能存取陣列，要傳回的物件。  
  
 因此，當您使用許多檔案和目錄、<xref:System.IO.DirectoryInfo.EnumerateFiles%2A>可能會更有效率。  
  
 如果沒有任何檔案在<xref:System.IO.DirectoryInfo>，這個方法會傳回空陣列。  
  
 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元|描述|  
|------------------------|-----------------|  
|* (星號)|零或多個字元。|  
|? （問號）|剛好零個或一個字元。|  
  
 不保證的順序傳回的檔案名稱;使用<xref:System.Array.Sort%2A>是否需要特定的排序次序的方法。  
  
 允許使用萬用字元。 比方說，`searchPattern`字串"*.txt"的搜尋，所有檔案擁有的"txt"延伸模組的名稱。 `searchPattern`字串"s\*"會搜尋所有檔案名稱開頭為字母"s"。 如果有任何檔案或沒有檔案符合`searchPattern`字串中<xref:System.IO.DirectoryInfo>，這個方法會傳回空陣列。  
  
> [!NOTE]
>  當使用星號萬用字元在`searchPattern`(例如，"*.txt")，比對行為會根據指定的副檔名的長度而有所不同。 A`searchPattern`檔案的剛好三個字元的延伸模組會傳回前三個字元要比對中指定的副檔名的檔案副檔名為三個或多個字元， `searchPattern`。 A`searchPattern`檔案的其中一個、 兩個或三個以上的字元的延伸模組會傳回具有該長度為完全符合在指定的檔案副檔名的副檔名的檔案`searchPattern`。 當使用問號萬用字元，則這個方法會傳回符合指定的副檔名的檔案。 例如，假設兩個檔案的目錄、"file1.txt"和"file1.txtother"，搜尋模式的 「 檔案？。txt"傳回只有第一個檔案，同時搜尋模式的 「 檔案\*.txt"會傳回這兩個檔案。  
  
 下列清單顯示長度不同的行為`searchPattern`參數：  
  
-   "*.abc 」 會傳回檔案具有副檔名 of.abc,.abcd,.abcde,.abcdef，依此類推。  
  
-   「 *.abcd"會傳回具有延伸模組 of.abcd 的檔案。  
  
-   「 *.abcde"會傳回具有延伸模組 of.abcde 的檔案。  
  
-   「 *.abcdef"會傳回具有延伸模組 of.abcdef 的檔案。  
  
> [!NOTE]
>  因為這個方法會檢查使用 8.3 檔案名稱格式和長時間的檔案名稱格式的檔案名稱，搜尋模式類似於 「 * 1\*.txt 」 可能會傳回未預期的檔案名稱。 例如，使用搜尋模式的 「\*1\*.txt"會傳回 「 longfilename.txt"，因為對等的 8.3 檔案名稱格式會是"longf~1.txt 」。  
  
 這個方法會預先填入下列值<xref:System.IO.FileInfo>屬性：  
  
1.  <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
2.  <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
3.  <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
4.  <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
5.  <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
6.  <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
7.  <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
8.  <xref:System.IO.FileInfo.Length%2A>  
  
   
  
## Examples  
 下列範例示範如何從目錄取得一份檔案，以使用不同的搜尋選項。 此範例假設目錄名為具有名為 log1.txt、 log2.txt、 test1.txt、 test2.txt、 test3.txt 和名為 SubFile.txt 檔案的子目錄的檔案。  
  
 [!code-csharp[directoryinfogetfiles#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfogetfiles/CS/directoryinfogetfiles2.cs#2)]
 [!code-vb[directoryinfogetfiles#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfogetfiles/VB/directoryinfogetfiles2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> 包含一或多個 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> 不是有效的 <see cref="T:System.IO.SearchOption" /> 值。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對至路徑和檔案和目錄的讀取存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileSystemInfos">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>擷取強式類型 <see cref="T:System.IO.FileSystemInfo" /> 物件的陣列，代表目前目錄的檔案與子目錄。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos () As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos();" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : unit -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回強類型 <see cref="T:System.IO.FileSystemInfo" /> 項目的陣列，表示目錄中的所有檔案和子目錄。</summary>
        <returns>強類型 (Strongly Typed) <see cref="T:System.IO.FileSystemInfo" /> 項目的陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果沒有任何檔案或目錄<xref:System.IO.DirectoryInfo>，這個方法會傳回空陣列。 這個方法不是遞迴。  
  
 為子目錄<xref:System.IO.FileSystemInfo>這個方法所傳回的物件可以轉換成衍生類別<xref:System.IO.DirectoryInfo>。 使用<xref:System.IO.FileAttributes>所傳回的值<xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType>屬性來判斷是否<xref:System.IO.FileSystemInfo>代表檔案或目錄。  
  
 這個方法會預先填入下列值<xref:System.IO.FileSystemInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 下列範例會計算的檔案和目錄底下指定的目錄。  
  
 [!code-csharp[FSizeSort#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSizeSort/CS/fsizesort.cs#1)]
 [!code-vb[FSizeSort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSizeSort/VB/fsizesort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileSystemInfos (searchPattern As String) As FileSystemInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對目錄及檔案名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <summary>擷取強類型 <see cref="T:System.IO.FileSystemInfo" /> 物件的陣列，代表符合指定之搜尋準則的檔案和子目錄。</summary>
        <returns>強類型 <see langword="FileSystemInfo" /> 物件的陣列，符合搜尋準則。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 可以是常值與萬用字元字元的組合，但它不支援規則運算式。 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元規範|符合|  
|------------------------|-------------|  
|* (星號)|在該位置的零或多個字元。|  
|? （問號）|該位置中的零個或一個字元。|  
  
 非萬用字元的字元是常值字元。 例如，字串"* t 」 中以字母"t"結尾的所有名稱的搜尋。 ". `searchPattern`字串"s\*」 中的所有名稱搜尋`path`開頭為字母"s"。  
  
 這個方法不是遞迴。  
  
 為子目錄<xref:System.IO.FileSystemInfo>這個方法所傳回的物件可以轉換成衍生類別<xref:System.IO.DirectoryInfo>。 使用<xref:System.IO.FileAttributes>所傳回的值<xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType>屬性來判斷是否<xref:System.IO.FileSystemInfo>代表檔案或目錄。  
  
 允許使用萬用字元。 例如，`searchPattern`字串"* t 」 中的所有目錄名稱的搜尋`path`結尾字母"t"。 `searchPattern`字串"s\*」 中的所有目錄名稱的搜尋`path`開頭為字母"s"。  
  
 字串".."僅適用於在`searchPattern`如果它的一部分有效目錄名稱，例如中指定的目錄名稱 」。。b"。 它不能在目錄階層中向上移動。 如果不有任何檔案或目錄，或任何檔案或目錄符合`searchPattern`字串中<xref:System.IO.DirectoryInfo>，這個方法會傳回空陣列。  
  
 這個方法會預先填入下列值<xref:System.IO.FileSystemInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
   
  
## Examples  
 下列範例會計算符合指定的搜尋模式的目錄與檔案。  
  
 [!code-csharp[DirInfo GetFileSysInfos2#1](~/samples/snippets/csharp/VS_Snippets_CLR/DirInfo GetFileSysInfos2/CS/dirinfo getfilesysinfos2.cs#1)]
 [!code-vb[DirInfo GetFileSysInfos2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DirInfo GetFileSysInfos2/VB/dirinfo getfilesysinfos2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> 包含一或多個 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取檔案和目錄和路徑的存取權。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="T:System.IO.FileSystemInfo" />
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.EnumerationOptions enumerationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, class System.IO.EnumerationOptions enumerationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.EnumerationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::EnumerationOptions ^ enumerationOptions);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.EnumerationOptions -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, enumerationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="enumerationOptions" Type="System.IO.EnumerationOptions" />
      </Parameters>
      <Docs>
        <param name="searchPattern">To be added.</param>
        <param name="enumerationOptions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemInfos">
      <MemberSignature Language="C#" Value="public System.IO.FileSystemInfo[] GetFileSystemInfos (string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.GetFileSystemInfos(System.String,System.IO.SearchOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::IO::FileSystemInfo ^&gt; ^ GetFileSystemInfos(System::String ^ searchPattern, System::IO::SearchOption searchOption);" />
      <MemberSignature Language="F#" Value="member this.GetFileSystemInfos : string * System.IO.SearchOption -&gt; System.IO.FileSystemInfo[]" Usage="directoryInfo.GetFileSystemInfos (searchPattern, searchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="searchPattern">要比對目錄及檔案名稱的搜尋字串。  這個參數可以包含有效常值路徑與萬用 (* 和 ?) 字元的組合，但是不支援規則運算式。</param>
        <param name="searchOption">其中一個列舉值，指定搜尋作業應該只包含目前目錄還是包含所有子目錄。 預設值是 <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />。</param>
        <summary>擷取 <see cref="T:System.IO.FileSystemInfo" /> 物件的陣列，這些物件代表符合指定之搜尋準則的檔案和子目錄。</summary>
        <returns>陣列，包含符合搜尋準則的檔案系統項目。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` 可以是常值與萬用字元字元的組合，但它不支援規則運算式。 允許使用下列萬用字元規範`searchPattern`。  
  
|萬用字元規範|符合|  
|------------------------|-------------|  
|* (星號)|在該位置的零或多個字元。|  
|? （問號）|該位置中的零個或一個字元。|  
  
 非萬用字元的字元是常值字元。 例如，字串"* t 」 中以字母"t"結尾的所有名稱的搜尋。 ". `searchPattern`字串"s\*」 中的所有名稱搜尋`path`開頭為字母"s"。  
  
 為子目錄<xref:System.IO.FileSystemInfo>這個方法所傳回的物件可以轉換成衍生類別<xref:System.IO.DirectoryInfo>。 使用<xref:System.IO.FileAttributes>所傳回的值<xref:System.IO.FileSystemInfo.Attributes%2A?displayProperty=nameWithType>屬性來判斷是否<xref:System.IO.FileSystemInfo>代表檔案或目錄。  
  
 這個方法會預先填入下列值<xref:System.IO.FileSystemInfo>屬性：  
  
-   <xref:System.IO.FileSystemInfo.Attributes%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.CreationTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastAccessTimeUtc%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTime%2A>  
  
-   <xref:System.IO.FileSystemInfo.LastWriteTimeUtc%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="searchPattern" /> 包含一或多個 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="searchPattern" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> 不是有效的 <see cref="T:System.IO.SearchOption" /> 值。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.MoveTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (destDirName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::String ^ destDirName);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : string -&gt; unit" Usage="directoryInfo.MoveTo destDirName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="destDirName">要將這個目錄移至的目的名稱和路徑。 目的端不可以是另一個磁碟區，或者是名稱完全相同的目錄。 它可以是您要將這個目錄加入做為子目錄的現有目錄。</param>
        <summary>移動 <see cref="T:System.IO.DirectoryInfo" /> 執行個體和其內容至新的路徑。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會擲回<xref:System.IO.IOException>如果，比方說，您嘗試將 c:\mydir\ 移至 c:\public，而且 c:\public 已經存在。 您必須指定"c:\\\public\\\mydir"作為`destDirName`參數，或指定新的目錄名稱，例如"c:\\\newdir"。  
  
 這個方法允許將目錄移至唯讀的目錄。 沒有目錄的讀取/寫入屬性會受到影響。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範移動目錄。  
  
 [!code-cpp[directoryinfomoveto#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfomoveto/CPP/directoryinfomoveto.cpp#1)]
 [!code-csharp[directoryinfomoveto#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfomoveto/CS/directoryinfomoveto.cs#1)]
 [!code-vb[directoryinfomoveto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfomoveto/VB/directoryinfomoveto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destDirName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="destDirName" /> 為空字串 ("")。</exception>
        <exception cref="T:System.IO.IOException">嘗試將目錄移至不同的磁碟區。  或 <paramref name="destDirName" /> 已存在。  或您未取得存取這個路徑的授權。  或正在移動的目錄和目的地目錄具有相同的名稱。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">找不到目的地目錄。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入檔案和目錄和目的地目錄的存取權。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.DirectoryInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.IO.DirectoryInfo" /> 執行個體的名稱。</summary>
        <value>目錄名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這<xref:System.IO.DirectoryInfo.Name%2A>屬性會傳回如"Bin"目錄的名稱。 若要取得的完整路徑，例如 「 c:\public\Bin"，使用<xref:System.IO.FileSystemInfo.FullName%2A>屬性。  
  
 <xref:System.IO.DirectoryInfo.Name%2A>的屬性<xref:System.IO.DirectoryInfo>需要任何權限 (超過建構所需的目錄的讀取權限<xref:System.IO.DirectoryInfo.Exists%2A>)，但可以提供目錄名稱。 如有必要交給 out<xref:System.IO.DirectoryInfo>密碼編譯安全的名稱與受保護的目錄，建立未受信任的程式碼使用的虛擬目錄。  
  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例顯示的目前名稱`DirectoryInfo`只執行個體。  
  
 [!code-cpp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DirectoryInfo.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/CS/source.cs#1)]
 [!code-vb[Classic DirectoryInfo.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic DirectoryInfo.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemInfo.FullName" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Parent" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Parent { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得指定子目錄的父代 (Parent) 目錄。</summary>
        <value>父目錄，或<see langword="null" />如果路徑是 null 或者檔案路徑代表根目錄 (例如"\\"，"C:"或 *"\\\server\share")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需一般 I/O 工作的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例將示範參考指定的目錄的上層目錄。  
  
 [!code-cpp[directoryinfoparent#1](~/samples/snippets/cpp/VS_Snippets_CLR/directoryinfoparent/CPP/directoryinfoparent.cpp#1)]
 [!code-csharp[directoryinfoparent#1](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinfoparent/CS/directoryinfoparent.cs#1)]
 [!code-vb[directoryinfoparent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinfoparent/VB/directoryinfoparent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取檔案和目錄和路徑的存取權。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />， <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Root">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo Root { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.DirectoryInfo Root" />
      <MemberSignature Language="DocId" Value="P:System.IO.DirectoryInfo.Root" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Root As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::DirectoryInfo ^ Root { System::IO::DirectoryInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Root : System.IO.DirectoryInfo" Usage="System.IO.DirectoryInfo.Root" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目錄的根目錄部分。</summary>
        <value>表示根目錄的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下列範例會顯示指定的目錄的根位置。  
  
 [!code-csharp[directoryinforoot#2](~/samples/snippets/csharp/VS_Snippets_CLR/directoryinforoot/CS/directoryinforoot2.cs#2)]
 [!code-vb[directoryinforoot#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/directoryinforoot/VB/directoryinforoot2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取檔案和目錄和路徑的存取權。 相關聯的列舉型別： <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />， <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.SetAccessControl(System.Security.AccessControl.DirectorySecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::DirectorySecurity ^ directorySecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.DirectorySecurity -&gt; unit" Usage="directoryInfo.SetAccessControl directorySecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="directorySecurity">物件，描述要套用至 <c>path</c> 參數所描述之目錄的 ACL 項目。</param>
        <summary>將 <see cref="T:System.Security.AccessControl.DirectorySecurity" /> 物件所描述的存取控制清單 (ACL) 項目套用至目前 <see cref="T:System.IO.DirectoryInfo" /> 物件所描述的目錄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 存取控制清單 (ACL) 會描述個人及/或群組，或沒有，在指定的檔案或目錄上的特定動作的權限。 如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 <xref:System.IO.DirectoryInfo.SetAccessControl%2A>方法適用於代表 noninherited 的 ACL 清單的檔案的 ACL 項目。  
  
> [!CAUTION]
>  指定 ACL`directorySecurity`會取代現有目錄的 ACL。 若要新增之新使用者的權限，請使用<xref:System.IO.DirectoryInfo.GetAccessControl%2A>方法來取得現有的 ACL，並修改它。  
  
 <xref:System.IO.DirectoryInfo.SetAccessControl%2A>方法仍然只存在<xref:System.Security.AccessControl.DirectorySecurity>物件建立後已修改的物件。  如果<xref:System.Security.AccessControl.DirectorySecurity>不修改物件，它不會保存至檔案。  因此，不可以擷取<xref:System.Security.AccessControl.DirectorySecurity>物件從一個檔案，並重新套用到另一個檔案的相同的物件。  
  
 若要將 ACL 資訊從一個檔案複製到另一個：  
  
1.  使用<xref:System.IO.DirectoryInfo.GetAccessControl%2A>方法來擷取<xref:System.Security.AccessControl.DirectorySecurity>從原始程式檔的物件。  
  
2.  建立新<xref:System.Security.AccessControl.DirectorySecurity>目的地檔案的物件。  
  
3.  使用<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>或是<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>來源方法<xref:System.Security.AccessControl.DirectorySecurity>擷取 ACL 資訊的物件。  
  
4.  使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>或是<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法，以將資訊複製到目的地的步驟 3 中所擷取<xref:System.Security.AccessControl.DirectorySecurity>物件。  
  
5.  設定目的地<xref:System.Security.AccessControl.DirectorySecurity>目的地檔案使用的物件<xref:System.IO.DirectoryInfo.SetAccessControl%2A>方法。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.DirectoryInfo.GetAccessControl%2A>和<xref:System.IO.DirectoryInfo.SetAccessControl%2A>方法來新增，然後再移除存取控制清單 (ACL) 項目，從目錄。  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="directorySecurity" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.SystemException">找不到或無法修改檔案。</exception>
        <exception cref="T:System.UnauthorizedAccessException">目前的處理序不具有開啟檔案的存取權。</exception>
        <exception cref="T:System.PlatformNotSupportedException">目前的作業系統不是 Microsoft Windows 2000 (含) 以後版本。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">若要列舉目錄的存取控制清單 (ACL) 的權限。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />， <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.DirectoryInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="directoryInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回已由使用者傳遞的原始路徑。</summary>
        <returns>傳回已由使用者傳遞的原始路徑。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>