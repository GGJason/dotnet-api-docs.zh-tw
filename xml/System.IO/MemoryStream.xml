<Type Name="MemoryStream" FullName="System.IO.MemoryStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8d9947ae94be62e7254a094d4b51a66bea5f63a6" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52612704" /></Metadata><TypeSignature Language="C#" Value="public class MemoryStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit MemoryStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryStream" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type MemoryStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="f4559-101">建立支援的存放區為記憶體的資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-101">Creates a stream whose backing store is memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-102">資料流目前位置位於作業開始執行下一個讀取或寫入作業的位置。</span><span class="sxs-lookup"><span data-stu-id="f4559-102">The current position of a stream is the position at which the next read or write operation could take place.</span></span> <span data-ttu-id="f4559-103">目前的位置可以擷取，或透過設定<xref:System.IO.MemoryStream.Seek%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f4559-103">The current position can be retrieved or set through the <xref:System.IO.MemoryStream.Seek%2A> method.</span></span> <span data-ttu-id="f4559-104">新執行個體時<xref:System.IO.MemoryStream>建立時，目前位置設定為零。</span><span class="sxs-lookup"><span data-stu-id="f4559-104">When a new instance of <xref:System.IO.MemoryStream> is created, the current position is set to zero.</span></span>  
  
[!INCLUDE[note_unnecessary_dispose](~/includes/note-unnecessary-dispose.md)]
  
 <span data-ttu-id="f4559-105">建立具有不帶正負號的位元組陣列的記憶體資料流提供資料的不可調整大小資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-105">Memory streams created with an unsigned byte array provide a non-resizable stream of the data.</span></span> <span data-ttu-id="f4559-106">當使用位元組陣列時，您可以不附加或壓縮資料流，雖然您可以修改現有的內容傳入建構函式的參數而定。</span><span class="sxs-lookup"><span data-stu-id="f4559-106">When using a byte array, you can neither append to nor shrink the stream, although you might be able to modify the existing contents depending on the parameters passed into the constructor.</span></span> <span data-ttu-id="f4559-107">空白的記憶體資料流是可調整大小，並可以寫入和讀取。</span><span class="sxs-lookup"><span data-stu-id="f4559-107">Empty memory streams are resizable, and can be written to and read from.</span></span>  
  
 <span data-ttu-id="f4559-108">如果<xref:System.IO.MemoryStream>物件會新增至 ResX 檔案或.resources 檔案，請呼叫<xref:System.Resources.ResourceManager.GetStream%2A>在執行階段來擷取它的方法。</span><span class="sxs-lookup"><span data-stu-id="f4559-108">If a <xref:System.IO.MemoryStream> object is added to a ResX file or a .resources file, call the <xref:System.Resources.ResourceManager.GetStream%2A> method at runtime to retrieve it.</span></span>  
  
 <span data-ttu-id="f4559-109">如果<xref:System.IO.MemoryStream>物件會序列化為資源檔，它實際上會序列化為<xref:System.IO.UnmanagedMemoryStream>。</span><span class="sxs-lookup"><span data-stu-id="f4559-109">If a <xref:System.IO.MemoryStream> object is serialized to a resource file it will actually be serialized as an <xref:System.IO.UnmanagedMemoryStream>.</span></span> <span data-ttu-id="f4559-110">此行為提供更佳的效能，以及能夠取得的指標將資料直接，而不需要經歷<xref:System.IO.Stream>方法。</span><span class="sxs-lookup"><span data-stu-id="f4559-110">This behavior provides better performance, as well as the ability to get a pointer to the data directly, without having to go through <xref:System.IO.Stream> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4559-111">下列程式碼範例示範如何讀取及寫入使用記憶體做為備份存放區的資料。</span><span class="sxs-lookup"><span data-stu-id="f4559-111">The following code example shows how to read and write data using memory as a backing store.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#1)]
 [!code-csharp[System.IO.MemoryStream#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#1)]
 [!code-vb[System.IO.MemoryStream#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-112">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-112">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-113">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-113">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-114">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-114">How to: Write Text to a File</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f4559-115">初始化 <see cref="T:System.IO.MemoryStream" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="f4559-115">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f4559-116">使用初始化為零的可擴展容量，初始化 <see cref="T:System.IO.MemoryStream" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="f4559-116">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-117"><xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，並<xref:System.IO.MemoryStream.CanWrite%2A>屬性都設為`true`。</span><span class="sxs-lookup"><span data-stu-id="f4559-117">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="f4559-118">當您使用時，自動會增加目前資料流容量<xref:System.IO.MemoryStream.SetLength%2A>方法來設定為值的長度大於目前的資料流容量。</span><span class="sxs-lookup"><span data-stu-id="f4559-118">The capacity of the current stream automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span>  
  
 <span data-ttu-id="f4559-119">這個建構函式會公開基礎資料流，其中<xref:System.IO.MemoryStream.GetBuffer%2A>傳回。</span><span class="sxs-lookup"><span data-stu-id="f4559-119">This constructor exposes the underlying stream, which <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-120">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-120">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-121">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-121">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-122">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-122">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream buffer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f4559-123">用於建立目前資料流之不帶正負號位元組的陣列。</span><span class="sxs-lookup"><span data-stu-id="f4559-123">The array of unsigned bytes from which to create the current stream.</span></span></param>
        <summary><span data-ttu-id="f4559-124">根據指定的位元組陣列，初始化 <see cref="T:System.IO.MemoryStream" /> 類別之不可調整大小的執行個體。</span><span class="sxs-lookup"><span data-stu-id="f4559-124">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-125"><xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，並<xref:System.IO.MemoryStream.CanWrite%2A>屬性都設為`true`。</span><span class="sxs-lookup"><span data-stu-id="f4559-125">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span> <span data-ttu-id="f4559-126"><xref:System.IO.MemoryStream.Capacity%2A> 設定為指定的位元組陣列的長度。</span><span class="sxs-lookup"><span data-stu-id="f4559-126"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span> <span data-ttu-id="f4559-127">新的資料流可寫入，但不是可調整大小。</span><span class="sxs-lookup"><span data-stu-id="f4559-127">The new stream can be written to, but is not resizable.</span></span>  
  
 <span data-ttu-id="f4559-128">資料流的長度不能設定的值大於指定的位元組陣列; 的初始長度不過，資料流可能會被截斷 (請參閱<xref:System.IO.MemoryStream.SetLength%2A>)。</span><span class="sxs-lookup"><span data-stu-id="f4559-128">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="f4559-129">這個建構函式不會公開基礎資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-129">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="f4559-130"><xref:System.IO.MemoryStream.GetBuffer%2A> 會擲回<xref:System.UnauthorizedAccessException>。</span><span class="sxs-lookup"><span data-stu-id="f4559-130"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f4559-131"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-131"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-132">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-132">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-133">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-133">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-134">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-134">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(int capacity);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : int -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="f4559-135">內部陣列的初始大小，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="f4559-135">The initial size of the internal array in bytes.</span></span></param>
        <summary><span data-ttu-id="f4559-136">使用初始化為指定的可擴展容量，初始化 <see cref="T:System.IO.MemoryStream" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="f4559-136">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class with an expandable capacity initialized as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-137"><xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，並<xref:System.IO.MemoryStream.CanWrite%2A>屬性都設為`true`。</span><span class="sxs-lookup"><span data-stu-id="f4559-137">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`.</span></span>  
  
 <span data-ttu-id="f4559-138">當您使用時，自動會增加容量<xref:System.IO.MemoryStream.SetLength%2A>方法來設定為值的長度大於目前的資料流容量。</span><span class="sxs-lookup"><span data-stu-id="f4559-138">The capacity automatically increases when you use the <xref:System.IO.MemoryStream.SetLength%2A> method to set the length to a value larger than the capacity of the current stream.</span></span> <span data-ttu-id="f4559-139">除了`MemoryStream`byte [] 參數以建構，寫入作業結尾處`MemoryStream`展開`MemoryStream`。</span><span class="sxs-lookup"><span data-stu-id="f4559-139">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
 <span data-ttu-id="f4559-140">這個建構函式會公開基礎資料流<xref:System.IO.MemoryStream.GetBuffer%2A>傳回。</span><span class="sxs-lookup"><span data-stu-id="f4559-140">This constructor exposes the underlying stream that <xref:System.IO.MemoryStream.GetBuffer%2A> returns.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4559-141">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.MemoryStream>類別。</span><span class="sxs-lookup"><span data-stu-id="f4559-141">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#2)]
 [!code-csharp[System.IO.MemoryStream#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#2)]
 [!code-vb[System.IO.MemoryStream#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-142"><paramref name="capacity" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="f4559-142"><paramref name="capacity" /> is negative.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-143">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-143">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-144">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-144">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-145">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-145">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, bool writable);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, writable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f4559-146">用於建立這個資料流之不帶正負號位元組的陣列。</span><span class="sxs-lookup"><span data-stu-id="f4559-146">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="writable"><span data-ttu-id="f4559-147"><see cref="P:System.IO.MemoryStream.CanWrite" /> 屬性的設定，決定資料流是否支援寫入。</span><span class="sxs-lookup"><span data-stu-id="f4559-147">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <summary><span data-ttu-id="f4559-148">根據具有指定的 <see cref="P:System.IO.MemoryStream.CanWrite" /> 屬性設定之位元組陣列，來初始化 <see cref="T:System.IO.MemoryStream" /> 類別之新的不可調整大小的執行個體。</span><span class="sxs-lookup"><span data-stu-id="f4559-148">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified byte array with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-149"><xref:System.IO.MemoryStream.CanRead%2A>並<xref:System.IO.MemoryStream.CanSeek%2A>屬性都設為`true`。</span><span class="sxs-lookup"><span data-stu-id="f4559-149">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="f4559-150"><xref:System.IO.MemoryStream.Capacity%2A> 設定為指定的位元組陣列的長度。</span><span class="sxs-lookup"><span data-stu-id="f4559-150"><xref:System.IO.MemoryStream.Capacity%2A> is set to the length of the specified byte array.</span></span>  
  
 <span data-ttu-id="f4559-151">資料流的長度不能設定的值大於指定的位元組陣列; 的初始長度不過，資料流可能會被截斷 (請參閱<xref:System.IO.MemoryStream.SetLength%2A>)。</span><span class="sxs-lookup"><span data-stu-id="f4559-151">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="f4559-152">這個建構函式不會公開基礎資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-152">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="f4559-153"><xref:System.IO.MemoryStream.GetBuffer%2A> 會擲回<xref:System.UnauthorizedAccessException>。</span><span class="sxs-lookup"><span data-stu-id="f4559-153"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f4559-154"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-154"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-155">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-155">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-156">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-156">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-157">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-157">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f4559-158">用於建立這個資料流之不帶正負號位元組的陣列。</span><span class="sxs-lookup"><span data-stu-id="f4559-158">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="f4559-159"><paramref name="buffer" /> 中資料流開始處的索引。</span><span class="sxs-lookup"><span data-stu-id="f4559-159">The index into <paramref name="buffer" /> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="f4559-160">資料流的長度，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="f4559-160">The length of the stream in bytes.</span></span></param>
        <summary><span data-ttu-id="f4559-161">根據位元組陣列的指定區域 (索引)，來初始化 <see cref="T:System.IO.MemoryStream" /> 類別之新的不可調整大小的執行個體。</span><span class="sxs-lookup"><span data-stu-id="f4559-161">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region (index) of a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-162"><xref:System.IO.MemoryStream.CanRead%2A>， <xref:System.IO.MemoryStream.CanSeek%2A>，並<xref:System.IO.MemoryStream.CanWrite%2A>屬性都設為`true`，但無法變更容量。</span><span class="sxs-lookup"><span data-stu-id="f4559-162">The <xref:System.IO.MemoryStream.CanRead%2A>, <xref:System.IO.MemoryStream.CanSeek%2A>, and <xref:System.IO.MemoryStream.CanWrite%2A> properties are all set to `true`, but the capacity cannot be changed.</span></span> <span data-ttu-id="f4559-163"><xref:System.IO.MemoryStream.Capacity%2A> 設定為 `count`。</span><span class="sxs-lookup"><span data-stu-id="f4559-163"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="f4559-164">資料流的長度不能設定的值大於指定的位元組陣列; 的初始長度不過，資料流可能會被截斷 (請參閱<xref:System.IO.MemoryStream.SetLength%2A>)。</span><span class="sxs-lookup"><span data-stu-id="f4559-164">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="f4559-165">這個建構函式不會公開基礎資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-165">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="f4559-166"><xref:System.IO.MemoryStream.GetBuffer%2A> 會擲回<xref:System.UnauthorizedAccessException>。</span><span class="sxs-lookup"><span data-stu-id="f4559-166"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="f4559-167">不過，您可以撰寫資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-167">However, you can write to the stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f4559-168"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-168"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-169"><paramref name="index" /> 或 <paramref name="count" /> 小於零。</span><span class="sxs-lookup"><span data-stu-id="f4559-169"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f4559-170">緩衝區長度減去 <paramref name="index" /> 會小於 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-170">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-171">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-171">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-172">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-172">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-173">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-173">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count, writable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f4559-174">用於建立這個資料流之不帶正負號位元組的陣列。</span><span class="sxs-lookup"><span data-stu-id="f4559-174">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="f4559-175"><paramref name="buffer" /> 中資料流開始處的索引。</span><span class="sxs-lookup"><span data-stu-id="f4559-175">The index in <paramref name="buffer" /> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="f4559-176">資料流的長度，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="f4559-176">The length of the stream in bytes.</span></span></param>
        <param name="writable"><span data-ttu-id="f4559-177"><see cref="P:System.IO.MemoryStream.CanWrite" /> 屬性的設定，決定資料流是否支援寫入。</span><span class="sxs-lookup"><span data-stu-id="f4559-177">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <summary><span data-ttu-id="f4559-178">根據位元組陣列的指定區域 (且該區域使用依指定所設定的 <see cref="P:System.IO.MemoryStream.CanWrite" /> 屬性)，來初始化 <see cref="T:System.IO.MemoryStream" /> 類別之新的不可調整大小的執行個體。</span><span class="sxs-lookup"><span data-stu-id="f4559-178">Initializes a new non-resizable instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-179"><xref:System.IO.MemoryStream.CanRead%2A>並<xref:System.IO.MemoryStream.CanSeek%2A>屬性都設為`true`。</span><span class="sxs-lookup"><span data-stu-id="f4559-179">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="f4559-180"><xref:System.IO.MemoryStream.Capacity%2A> 設定為 `count`。</span><span class="sxs-lookup"><span data-stu-id="f4559-180"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="f4559-181">資料流的長度不能設定的值大於指定的位元組陣列; 的初始長度不過，資料流可能會被截斷 (請參閱<xref:System.IO.MemoryStream.SetLength%2A>)。</span><span class="sxs-lookup"><span data-stu-id="f4559-181">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 <span data-ttu-id="f4559-182">這個建構函式不會公開基礎資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-182">This constructor does not expose the underlying stream.</span></span> <span data-ttu-id="f4559-183"><xref:System.IO.MemoryStream.GetBuffer%2A> 會擲回<xref:System.UnauthorizedAccessException>。</span><span class="sxs-lookup"><span data-stu-id="f4559-183"><xref:System.IO.MemoryStream.GetBuffer%2A> throws <xref:System.UnauthorizedAccessException>.</span></span> <span data-ttu-id="f4559-184">不過，您可以寫入資料流如果`writable`是`true`。</span><span class="sxs-lookup"><span data-stu-id="f4559-184">However, you can write to the stream if `writable` is `true`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f4559-185"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-185"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-186"><paramref name="index" /> 或 <paramref name="count" /> 為負值。</span><span class="sxs-lookup"><span data-stu-id="f4559-186"><paramref name="index" /> or <paramref name="count" /> are negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f4559-187">緩衝區長度減去 <paramref name="index" /> 會小於 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-187">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-188">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-188">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-189">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-189">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-190">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-190">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryStream (byte[] buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 index, int32 count, bool writable, bool publiclyVisible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), index As Integer, count As Integer, writable As Boolean, publiclyVisible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryStream(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count, bool writable, bool publiclyVisible);" />
      <MemberSignature Language="F#" Value="new System.IO.MemoryStream : byte[] * int * int * bool * bool -&gt; System.IO.MemoryStream" Usage="new System.IO.MemoryStream (buffer, index, count, writable, publiclyVisible)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="writable" Type="System.Boolean" />
        <Parameter Name="publiclyVisible" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f4559-191">用於建立這個資料流之不帶正負號位元組的陣列。</span><span class="sxs-lookup"><span data-stu-id="f4559-191">The array of unsigned bytes from which to create this stream.</span></span></param>
        <param name="index"><span data-ttu-id="f4559-192"><paramref name="buffer" /> 中資料流開始處的索引。</span><span class="sxs-lookup"><span data-stu-id="f4559-192">The index into <paramref name="buffer" /> at which the stream begins.</span></span></param>
        <param name="count"><span data-ttu-id="f4559-193">資料流的長度，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="f4559-193">The length of the stream in bytes.</span></span></param>
        <param name="writable"><span data-ttu-id="f4559-194"><see cref="P:System.IO.MemoryStream.CanWrite" /> 屬性的設定，決定資料流是否支援寫入。</span><span class="sxs-lookup"><span data-stu-id="f4559-194">The setting of the <see cref="P:System.IO.MemoryStream.CanWrite" /> property, which determines whether the stream supports writing.</span></span></param>
        <param name="publiclyVisible"><span data-ttu-id="f4559-195">啟用 <see cref="M:System.IO.MemoryStream.GetBuffer" /> (傳回從其中建立資料流的不帶正負號的位元組陣列)，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-195"><see langword="true" /> to enable <see cref="M:System.IO.MemoryStream.GetBuffer" />, which returns the unsigned byte array from which the stream was created; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f4559-196">根據指定的位元組陣列區域 (且該區域使用依指定所設定的 <see cref="P:System.IO.MemoryStream.CanWrite" /> 屬性和依指定所設定的呼叫 <see cref="M:System.IO.MemoryStream.GetBuffer" /> 的能力)，來初始化 <see cref="T:System.IO.MemoryStream" /> 類別的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="f4559-196">Initializes a new instance of the <see cref="T:System.IO.MemoryStream" /> class based on the specified region of a byte array, with the <see cref="P:System.IO.MemoryStream.CanWrite" /> property set as specified, and the ability to call <see cref="M:System.IO.MemoryStream.GetBuffer" /> set as specified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-197"><xref:System.IO.MemoryStream.CanRead%2A>並<xref:System.IO.MemoryStream.CanSeek%2A>屬性都設為`true`。</span><span class="sxs-lookup"><span data-stu-id="f4559-197">The <xref:System.IO.MemoryStream.CanRead%2A> and <xref:System.IO.MemoryStream.CanSeek%2A> properties are both set to `true`.</span></span> <span data-ttu-id="f4559-198"><xref:System.IO.MemoryStream.Capacity%2A> 設定為 `count`。</span><span class="sxs-lookup"><span data-stu-id="f4559-198"><xref:System.IO.MemoryStream.Capacity%2A> is set to `count`.</span></span>  
  
 <span data-ttu-id="f4559-199">新的資料流執行個體可以寫入，但<xref:System.IO.MemoryStream.Capacity%2A>的基礎位元組陣列不能變更。</span><span class="sxs-lookup"><span data-stu-id="f4559-199">The new stream instance can be written to, but the <xref:System.IO.MemoryStream.Capacity%2A> of the underlying byte array cannot be changed.</span></span> <span data-ttu-id="f4559-200">資料流的長度不能設定的值大於指定的位元組陣列; 的初始長度不過，資料流可能會被截斷 (請參閱<xref:System.IO.MemoryStream.SetLength%2A>)。</span><span class="sxs-lookup"><span data-stu-id="f4559-200">The length of the stream cannot be set to a value greater than the initial length of the specified byte array; however, the stream can be truncated (see <xref:System.IO.MemoryStream.SetLength%2A>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f4559-201"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-201"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-202"><paramref name="index" /> 或 <paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="f4559-202"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f4559-203">緩衝區長度減去 <paramref name="index" /> 會小於 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-203">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-204">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-204">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-205">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-205">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-206">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-206">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="memoryStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="memoryStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.MemoryStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f4559-207">取得表示目前資料流是否支援讀取的值。</span><span class="sxs-lookup"><span data-stu-id="f4559-207">Gets a value indicating whether the current stream supports reading.</span></span></summary>
        <value><span data-ttu-id="f4559-208"><see langword="true" />，如果資料流已開啟。</span><span class="sxs-lookup"><span data-stu-id="f4559-208"><see langword="true" /> if the stream is open.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-209">如果類別衍生自<xref:System.IO.Stream>不支援讀取，呼叫<xref:System.IO.MemoryStream.Read%2A>並<xref:System.IO.MemoryStream.ReadByte%2A>方法會擲回<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="f4559-209">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.MemoryStream.Read%2A> and <xref:System.IO.MemoryStream.ReadByte%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="f4559-210">如果資料流已關閉，則這個屬性會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="f4559-210">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-211">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-211">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-212">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-212">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-213">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-213">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.MemoryStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f4559-214">取得表示目前資料流是否支援搜尋的值。</span><span class="sxs-lookup"><span data-stu-id="f4559-214">Gets a value indicating whether the current stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="f4559-215"><see langword="true" />，如果資料流已開啟。</span><span class="sxs-lookup"><span data-stu-id="f4559-215"><see langword="true" /> if the stream is open.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-216">如果類別衍生自<xref:System.IO.Stream>不支援搜尋，呼叫<xref:System.IO.MemoryStream.Length%2A>， <xref:System.IO.MemoryStream.SetLength%2A>， <xref:System.IO.MemoryStream.Position%2A>，並<xref:System.IO.MemoryStream.Seek%2A>擲回<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="f4559-216">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.MemoryStream.Length%2A>, <xref:System.IO.MemoryStream.SetLength%2A>, <xref:System.IO.MemoryStream.Position%2A>, and <xref:System.IO.MemoryStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="f4559-217">如果資料流已關閉，則這個屬性會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="f4559-217">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-218">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-218">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-219">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-219">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-220">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-220">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.MemoryStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f4559-221">取得表示目前資料流是否支援寫入的值。</span><span class="sxs-lookup"><span data-stu-id="f4559-221">Gets a value indicating whether the current stream supports writing.</span></span></summary>
        <value><span data-ttu-id="f4559-222">如果資料流支援寫入，則為 <see langword="true" />；否則，為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-222"><see langword="true" /> if the stream supports writing; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-223">如果類別衍生自<xref:System.IO.Stream>不支援寫入，呼叫<xref:System.IO.Stream.SetLength%2A>， <xref:System.IO.Stream.Write%2A>，或<xref:System.IO.Stream.WriteByte%2A>就會擲回<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="f4559-223">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Write%2A>, or <xref:System.IO.Stream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="f4559-224">如果資料流已關閉，則這個屬性會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="f4559-224">If the stream is closed, this property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-225">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-226">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-227">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public virtual int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.IO.MemoryStream.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f4559-228">取得或設定配置給這個資料流的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="f4559-228">Gets or sets the number of bytes allocated for this stream.</span></span></summary>
        <value><span data-ttu-id="f4559-229">資料流緩衝區可使用部分的長度。</span><span class="sxs-lookup"><span data-stu-id="f4559-229">The length of the usable portion of the buffer for the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-230">`Capacity` 是系統提供的位元組陣列的緩衝區長度。</span><span class="sxs-lookup"><span data-stu-id="f4559-230">`Capacity` is the buffer length for system-provided byte arrays.</span></span> <span data-ttu-id="f4559-231">`Capacity` 無法設定為小於目前的資料流長度的值。</span><span class="sxs-lookup"><span data-stu-id="f4559-231">`Capacity` cannot be set to a value less than the current length of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4559-232">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.MemoryStream>類別。</span><span class="sxs-lookup"><span data-stu-id="f4559-232">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-233">設定的容量為負數或小於資料流目前的長度。</span><span class="sxs-lookup"><span data-stu-id="f4559-233">A capacity is set that is negative or less than the current length of the stream.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-234">目前的資料流已關閉。</span><span class="sxs-lookup"><span data-stu-id="f4559-234">The current stream is closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f4559-235"><see langword="set" /> 在無法修改其容量的資料流上被叫用 (Invoke)。</span><span class="sxs-lookup"><span data-stu-id="f4559-235"><see langword="set" /> is invoked on a stream whose capacity cannot be modified.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-236">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-236">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-237">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-237">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-238">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-238">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="memoryStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f4559-239">關閉資料流以讀取和寫入。</span><span class="sxs-lookup"><span data-stu-id="f4559-239">Closes the stream for reading and writing.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="f4559-240">這個方法會覆寫 <xref:System.IO.Stream.Close?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f4559-240">This method overrides <xref:System.IO.Stream.Close?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="f4559-241">緩衝區是仍位於<xref:System.IO.MemoryStream>一旦關閉資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-241">The buffer is still available on a <xref:System.IO.MemoryStream> once the stream has been closed.</span></span>

<span data-ttu-id="f4559-242">排清資料流不會清除其基礎的編碼器，除非您明確地呼叫<xref:System.IO.MemoryStream.Flush>或`Close`。</span><span class="sxs-lookup"><span data-stu-id="f4559-242">Flushing the stream will not flush its underlying encoder unless you explicitly call <xref:System.IO.MemoryStream.Flush> or `Close`.</span></span> <span data-ttu-id="f4559-243">設定<xref:System.IO.StreamWriter.AutoFlush>，則為 true，表示資料會從排清緩衝區資料流，但並不會清除編碼器的狀態。</span><span class="sxs-lookup"><span data-stu-id="f4559-243">Setting <xref:System.IO.StreamWriter.AutoFlush> to true means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="f4559-244">這可讓編碼器，讓它可以正確編碼字元的下一個區塊保持其狀態 （部分的字元）。</span><span class="sxs-lookup"><span data-stu-id="f4559-244">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="f4559-245">UTF8，UTF7，其中某些字元可以只編碼編碼器接收或多個相鄰的字元後，會影響此案例。</span><span class="sxs-lookup"><span data-stu-id="f4559-245">This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</span></span>

<span data-ttu-id="f4559-246">嘗試將操作資料流已關閉之後可能會擲回<xref:System.ObjectDisposedException>。</span><span class="sxs-lookup"><span data-stu-id="f4559-246">Attempting to manipulate a stream after it has been closed might throw an <xref:System.ObjectDisposedException>.</span></span>

## Examples  
<span data-ttu-id="f4559-247">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.MemoryStream>類別。</span><span class="sxs-lookup"><span data-stu-id="f4559-247">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>

```vb
Finally
    memStream.Close()
End Try
```

]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-248">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-248">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-249">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-249">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-250">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-250">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="memoryStream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bufferSize">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="f4559-251">目前資料流的內容將複製到其中的資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-251">The stream to which the contents of the current stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="f4559-252">緩衝區的大小 (以位元組為單位)。</span><span class="sxs-lookup"><span data-stu-id="f4559-252">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="f4559-253">這個值必須大於零。</span><span class="sxs-lookup"><span data-stu-id="f4559-253">This value must be greater than zero.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f4559-254">用來監視是否有取消要求的語彙基元。</span><span class="sxs-lookup"><span data-stu-id="f4559-254">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="f4559-255">使用指定的緩衝區大小和取消語彙基元，以非同步的方式從目前資料流讀取所有位元組，並將其寫入另一個資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-255">Asynchronously reads all the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="f4559-256">表示非同步複製作業的工作。</span><span class="sxs-lookup"><span data-stu-id="f4559-256">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f4559-257"><paramref name="destination" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-257"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-258"><paramref name="buffersize" /> 為負值或零。</span><span class="sxs-lookup"><span data-stu-id="f4559-258"><paramref name="buffersize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-259">目前資料流或目的資料流已處置。</span><span class="sxs-lookup"><span data-stu-id="f4559-259">Either the current stream or the destination stream is disposed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f4559-260">目前資料流不支援讀取，或目的資料流不支援寫入。</span><span class="sxs-lookup"><span data-stu-id="f4559-260">The current stream does not support reading, or the destination stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="memoryStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="f4559-261"><see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="f4559-261"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="f4559-262">釋放 <see cref="T:System.IO.MemoryStream" /> 類別所使用的 Unmanaged 資源，並選擇性地釋放 Managed 資源。</span><span class="sxs-lookup"><span data-stu-id="f4559-262">Releases the unmanaged resources used by the <see cref="T:System.IO.MemoryStream" /> class and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-263">這個方法會呼叫公用<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f4559-263">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="f4559-264"><xref:System.ComponentModel.Component.Dispose%2A> 叫用受保護<xref:System.IO.MemoryStream.Dispose%2A>方法`disposing`參數設為`true`。</span><span class="sxs-lookup"><span data-stu-id="f4559-264"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.MemoryStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="f4559-265"><xref:System.Object.Finalize%2A> 叫用<xref:System.IO.MemoryStream.Dispose%2A>具有`disposing`設定為`false`。</span><span class="sxs-lookup"><span data-stu-id="f4559-265"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.MemoryStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="f4559-266">`disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.IO.MemoryStream> 參考的任何 Managed 物件所掌握的資源。</span><span class="sxs-lookup"><span data-stu-id="f4559-266">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.MemoryStream> references.</span></span> <span data-ttu-id="f4559-267">這個方法會叫用每個參考物件的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="f4559-267">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="f4559-268">
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以被其他物件呼叫多次。</span><span class="sxs-lookup"><span data-stu-id="f4559-268">
            <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="f4559-269">當覆寫<see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />小心不要參考先前處置好的呼叫中的物件<see cref="M:System.ComponentModel.Component.Dispose" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-269">When overriding <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />.</span></span> <span data-ttu-id="f4559-270">如需有關如何實作<see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />，請參閱 &lt;&lt;c2&gt; [ 實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="f4559-270">For more information about how to implement <see cref="M:System.IO.MemoryStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="f4559-271">如需詳細資訊<see cref="M:System.ComponentModel.Component.Dispose" />並<see cref="M:System.Object.Finalize" />，請參閱[清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="f4559-271">For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="memoryStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="memoryStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="memoryStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f4559-272">覆寫 <see cref="M:System.IO.Stream.Flush" /> 方法，以便不執行任何動作。</span><span class="sxs-lookup"><span data-stu-id="f4559-272">Overrides the <see cref="M:System.IO.Stream.Flush" /> method so that no action is performed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-273">這個方法會覆寫<xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="f4559-273">This method overrides the <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f4559-274">因為寫入任何資料<xref:System.IO.MemoryStream>物件寫入的 RAM，此方法是多餘的。</span><span class="sxs-lookup"><span data-stu-id="f4559-274">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-275">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-275">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-276">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-276">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-277">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-277">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="f4559-278">用來監視是否有取消要求的語彙基元。</span><span class="sxs-lookup"><span data-stu-id="f4559-278">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="f4559-279">非同步清除這個資料流的所有緩衝區，並監視取消要求。</span><span class="sxs-lookup"><span data-stu-id="f4559-279">Asynchronously clears all buffers for this stream, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="f4559-280">表示非同步排清作業的工作。</span><span class="sxs-lookup"><span data-stu-id="f4559-280">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-281">因為寫入任何資料<xref:System.IO.MemoryStream>物件寫入的 RAM，此方法是多餘的。</span><span class="sxs-lookup"><span data-stu-id="f4559-281">Because any data written to a <xref:System.IO.MemoryStream> object is written into RAM, this method is redundant.</span></span>  
  
 <span data-ttu-id="f4559-282">如果在作業取消之前完成，傳回的工作就會包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="f4559-282">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="f4559-283">您可以藉由建立的執行個體建立的取消語彙基元<xref:System.Threading.CancellationTokenSource>類別，並傳遞<xref:System.Threading.CancellationTokenSource.Token%2A>屬性設為`cancellationToken`參數。</span><span class="sxs-lookup"><span data-stu-id="f4559-283">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-284">資料流已經處置。</span><span class="sxs-lookup"><span data-stu-id="f4559-284">The stream has been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md"><span data-ttu-id="f4559-285">取消</span><span class="sxs-lookup"><span data-stu-id="f4559-285">Cancellation</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetBuffer">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.GetBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBuffer () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBuffer();" />
      <MemberSignature Language="F#" Value="abstract member GetBuffer : unit -&gt; byte[]&#xA;override this.GetBuffer : unit -&gt; byte[]" Usage="memoryStream.GetBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f4559-286">傳回用於建立這個資料流之不帶正負號位元組的陣列。</span><span class="sxs-lookup"><span data-stu-id="f4559-286">Returns the array of unsigned bytes from which this stream was created.</span></span></summary>
        <returns><span data-ttu-id="f4559-287">位元組陣列 (建立這個資料流的來源) 或基礎陣列 (如果沒有在目前執行個體的建構期間將位元組陣列提供給 <see cref="T:System.IO.MemoryStream" /> 建構函式)。</span><span class="sxs-lookup"><span data-stu-id="f4559-287">The byte array from which this stream was created, or the underlying array if a byte array was not provided to the <see cref="T:System.IO.MemoryStream" /> constructor during construction of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-288">請注意，緩衝區會包含配置的位元組數，這可能是未使用。</span><span class="sxs-lookup"><span data-stu-id="f4559-288">Note that the buffer contains allocated bytes which might be unused.</span></span> <span data-ttu-id="f4559-289">例如，如果字串為"test"會寫入<xref:System.IO.MemoryStream>物件、 從傳回的緩衝區長度<xref:System.IO.MemoryStream.GetBuffer%2A>是 256，而不是 4，未使用 252 個位元組。</span><span class="sxs-lookup"><span data-stu-id="f4559-289">For example, if the string "test" is written into the <xref:System.IO.MemoryStream> object, the length of the buffer returned from <xref:System.IO.MemoryStream.GetBuffer%2A> is 256, not 4, with 252 bytes unused.</span></span> <span data-ttu-id="f4559-290">若要取得緩衝區中的資料，請使用<xref:System.IO.MemoryStream.ToArray%2A>方法; 不過，<xref:System.IO.MemoryStream.ToArray%2A>記憶體中建立一份資料。</span><span class="sxs-lookup"><span data-stu-id="f4559-290">To obtain only the data in the buffer, use the <xref:System.IO.MemoryStream.ToArray%2A> method; however, <xref:System.IO.MemoryStream.ToArray%2A> creates a copy of the data in memory.</span></span>  
  
 <span data-ttu-id="f4559-291">也可以是緩衝區`null`。</span><span class="sxs-lookup"><span data-stu-id="f4559-291">The buffer can also be `null`.</span></span>  
  
 <span data-ttu-id="f4559-292">若要建立`MemoryStream`使用公開可見的緩衝區，使用的執行個體<xref:System.IO.MemoryStream.%23ctor%2A>， <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>，或<xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>。</span><span class="sxs-lookup"><span data-stu-id="f4559-292">To create a `MemoryStream` instance with a publicly visible buffer, use <xref:System.IO.MemoryStream.%23ctor%2A>, <xref:System.IO.MemoryStream.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Boolean%29>, or <xref:System.IO.MemoryStream.%23ctor%28System.Int32%29>.</span></span> <span data-ttu-id="f4559-293">如果目前資料流為可調整大小，兩個呼叫此方法不會傳回相同的陣列如果呼叫的間隔調整基礎位元組陣列的大小。</span><span class="sxs-lookup"><span data-stu-id="f4559-293">If the current stream is resizable, two calls to this method do not return the same array if the underlying byte array is resized between calls.</span></span> <span data-ttu-id="f4559-294">如需詳細資訊，請參閱 <xref:System.IO.MemoryStream.Capacity%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4559-294">For additional information, see <xref:System.IO.MemoryStream.Capacity%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4559-295">此方法適用於記憶體資料流已關閉的情況。</span><span class="sxs-lookup"><span data-stu-id="f4559-295">This method works when the memory stream is closed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="f4559-296"><see langword="MemoryStream" /> 執行個體沒有使用公開可見的緩衝區來建立。</span><span class="sxs-lookup"><span data-stu-id="f4559-296">The <see langword="MemoryStream" /> instance was not created with a publicly visible buffer.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-297">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-297">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-298">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-298">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-299">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-299">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.MemoryStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f4559-300">取得資料流的長度，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="f4559-300">Gets the length of the stream in bytes.</span></span></summary>
        <value><span data-ttu-id="f4559-301">資料流的長度，以位元組為單位。</span><span class="sxs-lookup"><span data-stu-id="f4559-301">The length of the stream in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f4559-302">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.MemoryStream>類別。</span><span class="sxs-lookup"><span data-stu-id="f4559-302">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-303">資料流已關閉。</span><span class="sxs-lookup"><span data-stu-id="f4559-303">The stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-304">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-304">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-305">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-305">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-306">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-306">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected override void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ObjectInvariant" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ObjectInvariant ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ObjectInvariant();" />
      <MemberSignature Language="F#" Value="override this.ObjectInvariant : unit -&gt; unit" Usage="memoryStream.ObjectInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f4559-307">提供 <see cref="T:System.Diagnostics.Contracts.Contract" /> 的支援。</span><span class="sxs-lookup"><span data-stu-id="f4559-307">Provides support for a <see cref="T:System.Diagnostics.Contracts.Contract" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.MemoryStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f4559-308">取得或設定資料流中目前的位置。</span><span class="sxs-lookup"><span data-stu-id="f4559-308">Gets or sets the current position within the stream.</span></span></summary>
        <value><span data-ttu-id="f4559-309">在資料流的目前位置。</span><span class="sxs-lookup"><span data-stu-id="f4559-309">The current position within the stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="f4559-310">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.MemoryStream>類別。</span><span class="sxs-lookup"><span data-stu-id="f4559-310">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#5)]
 [!code-csharp[System.IO.MemoryStream#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#5)]
 [!code-vb[System.IO.MemoryStream#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-311">位置設為負數值或大於 <see cref="F:System.Int32.MaxValue" /> 的值。</span><span class="sxs-lookup"><span data-stu-id="f4559-311">The position is set to a negative value or a value greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-312">資料流已關閉。</span><span class="sxs-lookup"><span data-stu-id="f4559-312">The stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-313">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-313">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-314">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-314">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-315">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-315">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="memoryStream.Read destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="memoryStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f4559-316">當這個方法傳回時，會包含指定的位元組陣列，這個陣列具有介於 <paramref name="offset" /> 到 (<paramref name="offset" /> + <paramref name="count" /> - 1) 之間的值，已由讀取自目前資料流的字元所取代。</span><span class="sxs-lookup"><span data-stu-id="f4559-316">When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the characters read from the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="f4559-317"><paramref name="buffer" /> 中以零為起始的位元組位移，用來開始儲存讀取自目前資料流的資料。</span><span class="sxs-lookup"><span data-stu-id="f4559-317">The zero-based byte offset in <paramref name="buffer" /> at which to begin storing data from the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="f4559-318">要讀取的最大位元組數。</span><span class="sxs-lookup"><span data-stu-id="f4559-318">The maximum number of bytes to read.</span></span></param>
        <summary><span data-ttu-id="f4559-319">從目前的資料流讀取位元組區塊，並且將資料寫入緩衝區。</span><span class="sxs-lookup"><span data-stu-id="f4559-319">Reads a block of bytes from the current stream and writes the data to a buffer.</span></span></summary>
        <returns><span data-ttu-id="f4559-320">寫入至緩衝區的總位元組數。</span><span class="sxs-lookup"><span data-stu-id="f4559-320">The total number of bytes written into the buffer.</span></span> <span data-ttu-id="f4559-321">如果目前無法提供那麼多的位元組數目，則這個數目可能小於所要求的位元組數目，或如果在讀取任何資料之前已經到達資料流末端，則為零。</span><span class="sxs-lookup"><span data-stu-id="f4559-321">This can be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached before any bytes are read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-322">這個方法會覆寫 <xref:System.IO.Stream.Read%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4559-322">This method overrides <xref:System.IO.Stream.Read%2A>.</span></span>  
  
 <span data-ttu-id="f4559-323">`offset`參數會提供在中的第一個位元組的位移`buffer`若要從目前資料流資料寫入。</span><span class="sxs-lookup"><span data-stu-id="f4559-323">The `offset` parameter gives the offset of the first byte in `buffer` to which data from the current stream is written.</span></span> <span data-ttu-id="f4559-324">`count`參數會提供要從目前的資料流讀取的位元組數目上限。</span><span class="sxs-lookup"><span data-stu-id="f4559-324">The `count` parameter gives the maximum number of bytes to read from the current stream.</span></span> <span data-ttu-id="f4559-325">如果已到達資料流結尾，傳回的值會是位元組讀取，則為零的實際數目。</span><span class="sxs-lookup"><span data-stu-id="f4559-325">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span>  
  
 <span data-ttu-id="f4559-326">讀取的作業成功時，讀取的位元組數目進階資料流中目前的位置。</span><span class="sxs-lookup"><span data-stu-id="f4559-326">If the read operation is successful, the current position within the stream advances by the number of bytes read.</span></span> <span data-ttu-id="f4559-327">如果發生例外狀況，資料流中目前的位置會保持不變。</span><span class="sxs-lookup"><span data-stu-id="f4559-327">If an exception occurs, the current position within the stream remains unchanged.</span></span>  
  
 <span data-ttu-id="f4559-328">`Read`方法會傳回零，只有當資料流結尾為止。</span><span class="sxs-lookup"><span data-stu-id="f4559-328">The `Read` method will return zero only if the end of the stream is reached.</span></span> <span data-ttu-id="f4559-329">在其他情況下，`Read`一律從資料流讀取至少一個位元組，再傳回。</span><span class="sxs-lookup"><span data-stu-id="f4559-329">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="f4559-330">根據定義，如果沒有資料可用的呼叫時，資料流`Read`，則`Read`方法會傳回的零 （自動到達資料流末端）。</span><span class="sxs-lookup"><span data-stu-id="f4559-330">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns zero (the end of the stream is reached automatically).</span></span> <span data-ttu-id="f4559-331">實作可以自由地傳回比要求更少個位元組，即使尚未達到資料流結尾。</span><span class="sxs-lookup"><span data-stu-id="f4559-331">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="f4559-332">使用<xref:System.IO.BinaryReader>讀取基本資料型別。</span><span class="sxs-lookup"><span data-stu-id="f4559-332">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f4559-333">如果在指定的位元組陣列`buffer`參數是所傳回的基礎緩衝區<xref:System.IO.MemoryStream.GetBuffer%2A>方法，陣列內容會覆寫，而且會擲回任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f4559-333">If the byte array specified in the `buffer` parameter is the underlying buffer returned by the <xref:System.IO.MemoryStream.GetBuffer%2A> method, the array contents are overwritten, and no exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4559-334">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.MemoryStream>類別。</span><span class="sxs-lookup"><span data-stu-id="f4559-334">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#7)]
 [!code-csharp[System.IO.MemoryStream#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#7)]
 [!code-vb[System.IO.MemoryStream#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f4559-335"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-335"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-336"><paramref name="offset" /> 或 <paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="f4559-336"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f4559-337">緩衝區的長度減去 <paramref name="offset" /> 小於 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-337"><paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-338">目前的資料流執行個體已關閉。</span><span class="sxs-lookup"><span data-stu-id="f4559-338">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-339">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-339">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-340">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-340">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-341">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-341">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; destination, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; destination, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="memoryStream.ReadAsync (destination, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Memory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="memoryStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f4559-342">寫入資料的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="f4559-342">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="f4559-343">開始於此處自資料流寫入資料的 <paramref name="buffer" /> 中的位元組位移。</span><span class="sxs-lookup"><span data-stu-id="f4559-343">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="f4559-344">要讀取的最大位元組數。</span><span class="sxs-lookup"><span data-stu-id="f4559-344">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f4559-345">用來監視是否有取消要求的語彙基元。</span><span class="sxs-lookup"><span data-stu-id="f4559-345">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="f4559-346">預設值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-346">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="f4559-347">以非同步的方式從目前資料流讀取一連串的位元組、依所讀取的位元組數目進階資料流中的位置，以及監視取消要求。</span><span class="sxs-lookup"><span data-stu-id="f4559-347">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="f4559-348">表示非同步讀取作業的工作。</span><span class="sxs-lookup"><span data-stu-id="f4559-348">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="f4559-349"><paramref name="TResult" /> 參數的值會包含讀取至緩衝區的位元組總數。</span><span class="sxs-lookup"><span data-stu-id="f4559-349">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="f4559-350">如果目前可供使用的位元組數目少於所要求的數目，結果值可能會小於所要求的位元組數目，或者如果已經到達資料流末端，則可能為 0 (零)。</span><span class="sxs-lookup"><span data-stu-id="f4559-350">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-351">如果在作業取消之前完成，傳回的工作就會包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="f4559-351">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="f4559-352">您可以藉由建立的執行個體建立的取消語彙基元<xref:System.Threading.CancellationTokenSource>類別，並傳遞<xref:System.Threading.CancellationTokenSource.Token%2A>屬性設為`cancellationToken`參數。</span><span class="sxs-lookup"><span data-stu-id="f4559-352">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f4559-353"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-353"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-354"><paramref name="offset" /> 或 <paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="f4559-354"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f4559-355"><paramref name="offset" /> 和 <paramref name="count" /> 的總和大於緩衝區長度。</span><span class="sxs-lookup"><span data-stu-id="f4559-355">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f4559-356">資料流不支援讀取。</span><span class="sxs-lookup"><span data-stu-id="f4559-356">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-357">資料流已經處置。</span><span class="sxs-lookup"><span data-stu-id="f4559-357">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f4559-358">之前的讀取作業目前正在使用資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-358">The stream is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="memoryStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f4559-359">從目前的資料流讀取位元組。</span><span class="sxs-lookup"><span data-stu-id="f4559-359">Reads a byte from the current stream.</span></span></summary>
        <returns><span data-ttu-id="f4559-360">轉型為 <see cref="T:System.Int32" /> 的位元組；如果已經到達資料流的末端，則為 -1。</span><span class="sxs-lookup"><span data-stu-id="f4559-360">The byte cast to a <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-361">這個方法會覆寫 <xref:System.IO.Stream.ReadByte%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4559-361">This method overrides <xref:System.IO.Stream.ReadByte%2A>.</span></span>  
  
 <span data-ttu-id="f4559-362">讀取的作業成功時，資料流中目前的位置會前移一個位元組。</span><span class="sxs-lookup"><span data-stu-id="f4559-362">If the read operation is successful, the current position within the stream is advanced by one byte.</span></span> <span data-ttu-id="f4559-363">如果發生例外狀況，資料流目前位置不變。</span><span class="sxs-lookup"><span data-stu-id="f4559-363">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4559-364">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.MemoryStream>類別。</span><span class="sxs-lookup"><span data-stu-id="f4559-364">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#8)]
 [!code-csharp[System.IO.MemoryStream#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#8)]
 [!code-vb[System.IO.MemoryStream#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-365">目前的資料流執行個體已關閉。</span><span class="sxs-lookup"><span data-stu-id="f4559-365">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-366">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-366">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-367">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-367">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-368">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-368">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, loc As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin loc);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="memoryStream.Seek (offset, loc)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="loc" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="f4559-369">資料流中的新位置。</span><span class="sxs-lookup"><span data-stu-id="f4559-369">The new position within the stream.</span></span> <span data-ttu-id="f4559-370">這是相對於 <paramref name="loc" /> 參數，並且可能是正數或負數。</span><span class="sxs-lookup"><span data-stu-id="f4559-370">This is relative to the <paramref name="loc" /> parameter, and can be positive or negative.</span></span></param>
        <param name="loc"><span data-ttu-id="f4559-371"><see cref="T:System.IO.SeekOrigin" /> 類型的值，做為搜尋參考點。</span><span class="sxs-lookup"><span data-stu-id="f4559-371">A value of type <see cref="T:System.IO.SeekOrigin" />, which acts as the seek reference point.</span></span></param>
        <summary><span data-ttu-id="f4559-372">將目前資料流中的位置設定為指定的數值。</span><span class="sxs-lookup"><span data-stu-id="f4559-372">Sets the position within the current stream to the specified value.</span></span></summary>
        <returns><span data-ttu-id="f4559-373">資料流中的新位置，是組合初始的參考點和位移計算出來的。</span><span class="sxs-lookup"><span data-stu-id="f4559-373">The new position within the stream, calculated by combining the initial reference point and the offset.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-374">這個方法會覆寫 <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="f4559-374">This method overrides <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f4559-375">支援搜尋超過資料流長度的任何位置。</span><span class="sxs-lookup"><span data-stu-id="f4559-375">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 <span data-ttu-id="f4559-376">請勿使用<xref:System.IO.MemoryStream.Seek%2A>方法，以判斷資料流中的新位置，如果<xref:System.IO.MemoryStream>初始化使用非零的位移。</span><span class="sxs-lookup"><span data-stu-id="f4559-376">Do not use the <xref:System.IO.MemoryStream.Seek%2A> method to determine the new position in the stream if the <xref:System.IO.MemoryStream> was initialized with a non-zero offset.</span></span> <span data-ttu-id="f4559-377">如果您這樣做，<xref:System.IO.MemoryStream.Seek%2A>會傳回不正確的值。</span><span class="sxs-lookup"><span data-stu-id="f4559-377">If you do, <xref:System.IO.MemoryStream.Seek%2A> will return an inaccurate value.</span></span> <span data-ttu-id="f4559-378">請改用<xref:System.IO.MemoryStream.Position%2A>屬性來取得資料流的新位置。</span><span class="sxs-lookup"><span data-stu-id="f4559-378">Instead, use the <xref:System.IO.MemoryStream.Position%2A> property to get the new position of the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4559-379">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.MemoryStream>類別。</span><span class="sxs-lookup"><span data-stu-id="f4559-379">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#6)]
 [!code-csharp[System.IO.MemoryStream#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#6)]
 [!code-vb[System.IO.MemoryStream#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f4559-380">在資料流開始之前嘗試搜尋。</span><span class="sxs-lookup"><span data-stu-id="f4559-380">Seeking is attempted before the beginning of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-381"><paramref name="offset" /> 大於 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-381"><paramref name="offset" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f4559-382">有無效的 <see cref="T:System.IO.SeekOrigin" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-382">There is an invalid <see cref="T:System.IO.SeekOrigin" />.</span></span>  
  
<span data-ttu-id="f4559-383">-或-</span><span class="sxs-lookup"><span data-stu-id="f4559-383">-or-</span></span> 
 <span data-ttu-id="f4559-384"><paramref name="offset" /> 造成了算術溢位。</span><span class="sxs-lookup"><span data-stu-id="f4559-384"><paramref name="offset" /> caused an arithmetic overflow.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-385">目前的資料流執行個體已關閉。</span><span class="sxs-lookup"><span data-stu-id="f4559-385">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-386">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-386">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-387">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-387">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-388">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-388">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="memoryStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="f4559-389">要設定長度的數值。</span><span class="sxs-lookup"><span data-stu-id="f4559-389">The value at which to set the length.</span></span></param>
        <summary><span data-ttu-id="f4559-390">將目前資料流的長度設定為指定的數值。</span><span class="sxs-lookup"><span data-stu-id="f4559-390">Sets the length of the current stream to the specified value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-391">這個方法會覆寫 <xref:System.IO.Stream.SetLength%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4559-391">This method overrides <xref:System.IO.Stream.SetLength%2A>.</span></span>  
  
 <span data-ttu-id="f4559-392">如果指定的值小於目前資料流的長度，則會截斷資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-392">If the specified value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="f4559-393">如果資料流目前位置是超過結尾的資料流之後截斷,<xref:System.IO.MemoryStream.ReadByte%2A>方法會傳回-1，<xref:System.IO.MemoryStream.Read%2A>方法會將零位元組讀入提供的位元組陣列，並<xref:System.IO.MemoryStream.Write%2A>和<xref:System.IO.MemoryStream.WriteByte%2A>方法附加指定資料流，並增加其長度結尾處的位元組。</span><span class="sxs-lookup"><span data-stu-id="f4559-393">If after the truncation the current position within the stream is past the end of the stream, the <xref:System.IO.MemoryStream.ReadByte%2A> method returns -1, the <xref:System.IO.MemoryStream.Read%2A> method reads zero bytes into the provided byte array, and <xref:System.IO.MemoryStream.Write%2A> and <xref:System.IO.MemoryStream.WriteByte%2A> methods append specified bytes at the end of the stream, increasing its length.</span></span> <span data-ttu-id="f4559-394">如果指定的值大於目前的容量，且可調整大小資料流，增加容量，並將資料流中目前的位置不會變更。</span><span class="sxs-lookup"><span data-stu-id="f4559-394">If the specified value is larger than the current capacity and the stream is resizable, the capacity is increased, and the current position within the stream is unchanged.</span></span> <span data-ttu-id="f4559-395">如果長度會增加，舊和新的長度之間的資料流的內容會初始化為零。</span><span class="sxs-lookup"><span data-stu-id="f4559-395">If the length is increased, the contents of the stream between the old and the new length are initialized to zeros.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4559-396">A<xref:System.IO.MemoryStream>執行個體都必須支援寫入，此方法才能運作。</span><span class="sxs-lookup"><span data-stu-id="f4559-396">A <xref:System.IO.MemoryStream> instance must support writing for this method to work.</span></span> <span data-ttu-id="f4559-397">使用<xref:System.IO.MemoryStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入。</span><span class="sxs-lookup"><span data-stu-id="f4559-397">Use the <xref:System.IO.MemoryStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="f4559-398">如需詳細資訊，請參閱 <xref:System.IO.Stream.CanWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4559-398">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f4559-399">目前的資料流不是可調整大小的，並且 <paramref name="value" /> 大於目前的容量。</span><span class="sxs-lookup"><span data-stu-id="f4559-399">The current stream is not resizable and <paramref name="value" /> is larger than the current capacity.</span></span>  
  
<span data-ttu-id="f4559-400">-或-</span><span class="sxs-lookup"><span data-stu-id="f4559-400">-or-</span></span> 
<span data-ttu-id="f4559-401">目前的資料流不支援寫入。</span><span class="sxs-lookup"><span data-stu-id="f4559-401">The current stream does not support writing.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-402"><paramref name="value" /> 為負，或大於 <see cref="T:System.IO.MemoryStream" /> 的最大長度，最大長度是 (<see cref="F:System.Int32.MaxValue" /> - 原點)，原點是資料流開始的基礎緩衝區索引。</span><span class="sxs-lookup"><span data-stu-id="f4559-402"><paramref name="value" /> is negative or is greater than the maximum length of the <see cref="T:System.IO.MemoryStream" />, where the maximum length is(<see cref="F:System.Int32.MaxValue" /> - origin), and origin is the index into the underlying buffer at which the stream starts.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-403">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-403">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-404">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-404">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-405">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-405">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual byte[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="abstract member ToArray : unit -&gt; byte[]&#xA;override this.ToArray : unit -&gt; byte[]" Usage="memoryStream.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f4559-406">不論 <see cref="P:System.IO.MemoryStream.Position" /> 屬性為何，將資料流內容寫入位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="f4559-406">Writes the stream contents to a byte array, regardless of the <see cref="P:System.IO.MemoryStream.Position" /> property.</span></span></summary>
        <returns><span data-ttu-id="f4559-407">新的位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="f4559-407">A new byte array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-408">這個方法會省略中的未使用的位元組<xref:System.IO.MemoryStream>陣列中。</span><span class="sxs-lookup"><span data-stu-id="f4559-408">This method omits unused bytes in <xref:System.IO.MemoryStream> from the array.</span></span> <span data-ttu-id="f4559-409">若要取得整個緩衝區，使用<xref:System.IO.MemoryStream.GetBuffer%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f4559-409">To get the entire buffer, use the <xref:System.IO.MemoryStream.GetBuffer%2A> method.</span></span>  
  
 <span data-ttu-id="f4559-410">這個方法會傳回一份內容<xref:System.IO.MemoryStream>做為位元組陣列。</span><span class="sxs-lookup"><span data-stu-id="f4559-410">This method returns a copy of the contents of the <xref:System.IO.MemoryStream> as a byte array.</span></span> <span data-ttu-id="f4559-411">如果目前的執行個體建構在提供的位元組陣列，則會傳回這個執行個體有權存取陣列的區段複本。</span><span class="sxs-lookup"><span data-stu-id="f4559-411">If the current instance was constructed on a provided byte array, a copy of the section of the array to which this instance has access is returned.</span></span> <span data-ttu-id="f4559-412">請參閱<xref:System.IO.MemoryStream.%23ctor%2A>建構函式，如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="f4559-412">See the <xref:System.IO.MemoryStream.%23ctor%2A> constructor for details.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4559-413">這個方法適用於當<xref:System.IO.MemoryStream>已關閉。</span><span class="sxs-lookup"><span data-stu-id="f4559-413">This method works when the <xref:System.IO.MemoryStream> is closed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-414">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-414">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-415">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-415">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-416">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-416">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryGetBuffer">
      <MemberSignature Language="C#" Value="public virtual bool TryGetBuffer (out ArraySegment&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetBuffer([out] valuetype System.ArraySegment`1&lt;unsigned int8&gt;&amp; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.TryGetBuffer(System.ArraySegment{System.Byte}@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetBuffer (ByRef buffer As ArraySegment(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetBuffer([Runtime::InteropServices::Out] ArraySegment&lt;System::Byte&gt; % buffer);" />
      <MemberSignature Language="F#" Value="abstract member TryGetBuffer :  -&gt; bool&#xA;override this.TryGetBuffer :  -&gt; bool" Usage="memoryStream.TryGetBuffer buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ArraySegment&lt;System.Byte&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f4559-417">從其中建立此資料流的位元組陣列區段。</span><span class="sxs-lookup"><span data-stu-id="f4559-417">The byte array segment from which this stream was created.</span></span></param>
        <summary><span data-ttu-id="f4559-418">傳回用於建立這個資料流之不帶正負號位元組的陣列。</span><span class="sxs-lookup"><span data-stu-id="f4559-418">Returns the array of unsigned bytes from which this stream was created.</span></span> <span data-ttu-id="f4559-419">指出轉換是否成功的傳回值。</span><span class="sxs-lookup"><span data-stu-id="f4559-419">The return value indicates whether the conversion succeeded.</span></span></summary>
        <returns><span data-ttu-id="f4559-420">如果轉換成功，則為 <see langword="true" />；否則為 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-420"><see langword="true" /> if the conversion was successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="memoryStream.Write source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="memoryStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f4559-421">寫入資料的來源緩衝區。</span><span class="sxs-lookup"><span data-stu-id="f4559-421">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="f4559-422"><paramref name="buffer" /> 中以零起始的位元組位移，即開始將位元組複製到目前資料流的位置。</span><span class="sxs-lookup"><span data-stu-id="f4559-422">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="f4559-423">寫入的最大位元組數。</span><span class="sxs-lookup"><span data-stu-id="f4559-423">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="f4559-424">使用讀取自緩衝區的資料，將位元組區塊寫入至目前的資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-424">Writes a block of bytes to the current stream using data read from a buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-425">這個方法會覆寫 <xref:System.IO.Stream.Write%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4559-425">This method overrides <xref:System.IO.Stream.Write%2A>.</span></span>  
  
 <span data-ttu-id="f4559-426">`offset`參數會提供在中的第一個位元組的位移`buffer`撰寫，而`count`參數會提供要寫入的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="f4559-426">The `offset` parameter gives the offset of the first byte in `buffer` to write from, and the `count` parameter gives the number of bytes to write.</span></span> <span data-ttu-id="f4559-427">寫入作業成功時，寫入的位元組數目進階資料流中目前的位置。</span><span class="sxs-lookup"><span data-stu-id="f4559-427">If the write operation is successful, the current position within the stream is advanced by the number of bytes written.</span></span> <span data-ttu-id="f4559-428">如果發生例外狀況，資料流目前位置不變。</span><span class="sxs-lookup"><span data-stu-id="f4559-428">If an exception occurs, the current position within the stream is unchanged.</span></span>  
  
 <span data-ttu-id="f4559-429">除了`MemoryStream`byte [] 參數以建構，寫入作業結尾處`MemoryStream`展開`MemoryStream`。</span><span class="sxs-lookup"><span data-stu-id="f4559-429">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4559-430">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.MemoryStream>類別。</span><span class="sxs-lookup"><span data-stu-id="f4559-430">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#3)]
 [!code-csharp[System.IO.MemoryStream#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#3)]
 [!code-vb[System.IO.MemoryStream#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f4559-431"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-431"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f4559-432">資料流不支援寫入。</span><span class="sxs-lookup"><span data-stu-id="f4559-432">The stream does not support writing.</span></span> <span data-ttu-id="f4559-433">如需詳細資訊，請參閱 <see cref="P:System.IO.Stream.CanWrite" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-433">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span></span>  
  
<span data-ttu-id="f4559-434">-或-</span><span class="sxs-lookup"><span data-stu-id="f4559-434">-or-</span></span> 
<span data-ttu-id="f4559-435">和 <paramref name="count" /> 位元組相比，目前的位置更接近資料流末端，並且容量無法修改。</span><span class="sxs-lookup"><span data-stu-id="f4559-435">The current position is closer than <paramref name="count" /> bytes to the end of the stream, and the capacity cannot be modified.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f4559-436">緩衝區的長度減去 <paramref name="offset" /> 小於 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-436"><paramref name="offset" /> subtracted from the buffer length is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-437"><paramref name="offset" /> 或 <paramref name="count" /> 為負值。</span><span class="sxs-lookup"><span data-stu-id="f4559-437"><paramref name="offset" /> or <paramref name="count" /> are negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="f4559-438">發生 I/O 錯誤。</span><span class="sxs-lookup"><span data-stu-id="f4559-438">An I/O error occurs.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-439">目前的資料流執行個體已關閉。</span><span class="sxs-lookup"><span data-stu-id="f4559-439">The current stream instance is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-440">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-440">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-441">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-441">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-442">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-442">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; source, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; source, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="memoryStream.WriteAsync (source, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="memoryStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f4559-443">寫入資料的來源緩衝區。</span><span class="sxs-lookup"><span data-stu-id="f4559-443">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="f4559-444"><paramref name="buffer" /> 中以零起始的位元組位移，要從其中開始將位元組複製至資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-444">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="f4559-445">寫入的最大位元組數。</span><span class="sxs-lookup"><span data-stu-id="f4559-445">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="f4559-446">用來監視是否有取消要求的語彙基元。</span><span class="sxs-lookup"><span data-stu-id="f4559-446">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="f4559-447">預設值是 <see cref="P:System.Threading.CancellationToken.None" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-447">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="f4559-448">以非同步的方式將一連串的位元組寫入目前的資料流，由這個資料流中目前的位置前移寫入的位元組數目，並且監視取消要求。</span><span class="sxs-lookup"><span data-stu-id="f4559-448">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="f4559-449">表示非同步寫入作業的工作。</span><span class="sxs-lookup"><span data-stu-id="f4559-449">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-450">如果在作業取消之前完成，傳回的工作就會包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="f4559-450">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  
  
 <span data-ttu-id="f4559-451">您可以藉由建立的執行個體建立的取消語彙基元<xref:System.Threading.CancellationTokenSource>類別，並傳遞<xref:System.Threading.CancellationTokenSource.Token%2A>屬性設為`cancellationToken`參數。</span><span class="sxs-lookup"><span data-stu-id="f4559-451">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f4559-452"><paramref name="buffer" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-452"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f4559-453"><paramref name="offset" /> 或 <paramref name="count" /> 為負。</span><span class="sxs-lookup"><span data-stu-id="f4559-453"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f4559-454"><paramref name="offset" /> 和 <paramref name="count" /> 的總和大於緩衝區長度。</span><span class="sxs-lookup"><span data-stu-id="f4559-454">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f4559-455">資料流不支援寫入。</span><span class="sxs-lookup"><span data-stu-id="f4559-455">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-456">已處置此資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-456">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f4559-457">之前的寫入作業目前正在使用資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-457">The stream is currently in use by a previous write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="memoryStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="f4559-458">要寫入的位元組。</span><span class="sxs-lookup"><span data-stu-id="f4559-458">The byte to write.</span></span></param>
        <summary><span data-ttu-id="f4559-459">寫入位元組至資料流目前位置。</span><span class="sxs-lookup"><span data-stu-id="f4559-459">Writes a byte to the current stream at the current position.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-460">這個方法會覆寫 <xref:System.IO.Stream.WriteByte%2A>。</span><span class="sxs-lookup"><span data-stu-id="f4559-460">This method overrides <xref:System.IO.Stream.WriteByte%2A>.</span></span>  
  
 <span data-ttu-id="f4559-461">除了`MemoryStream`byte [] 參數以建構，寫入作業結尾處`MemoryStream`展開`MemoryStream`。</span><span class="sxs-lookup"><span data-stu-id="f4559-461">Except for a `MemoryStream` constructed with a byte[] parameter, write operations at the end of a `MemoryStream` expand the `MemoryStream`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4559-462">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.MemoryStream>類別。</span><span class="sxs-lookup"><span data-stu-id="f4559-462">This code example is part of a larger example provided for the <xref:System.IO.MemoryStream> class.</span></span>  
  
 [!code-cpp[System.IO.MemoryStream#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.MemoryStream/CPP/memstream.cpp#4)]
 [!code-csharp[System.IO.MemoryStream#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.MemoryStream/CS/memstream.cs#4)]
 [!code-vb[System.IO.MemoryStream#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.MemoryStream/VB/memstream.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f4559-463">資料流不支援寫入。</span><span class="sxs-lookup"><span data-stu-id="f4559-463">The stream does not support writing.</span></span> <span data-ttu-id="f4559-464">如需詳細資訊，請參閱 <see cref="P:System.IO.Stream.CanWrite" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-464">For additional information see <see cref="P:System.IO.Stream.CanWrite" />.</span></span>  
  
<span data-ttu-id="f4559-465">-或-</span><span class="sxs-lookup"><span data-stu-id="f4559-465">-or-</span></span> 
<span data-ttu-id="f4559-466">目前的位置在資料流結尾，並且無法修改容量。</span><span class="sxs-lookup"><span data-stu-id="f4559-466">The current position is at the end of the stream, and the capacity cannot be modified.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-467">目前的資料流已關閉。</span><span class="sxs-lookup"><span data-stu-id="f4559-467">The current stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-468">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-468">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-469">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-469">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-470">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-470">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public virtual void WriteTo (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryStream.WriteTo(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void WriteTo(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="abstract member WriteTo : System.IO.Stream -&gt; unit&#xA;override this.WriteTo : System.IO.Stream -&gt; unit" Usage="memoryStream.WriteTo stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="f4559-471">要寫入這個記憶體資料流的資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-471">The stream to write this memory stream to.</span></span></param>
        <summary><span data-ttu-id="f4559-472">將這個記憶體資料流的整個內容寫入另一個資料流。</span><span class="sxs-lookup"><span data-stu-id="f4559-472">Writes the entire contents of this memory stream to another stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4559-473">開啟目前的資料流時，這個方法就相當於呼叫<xref:System.IO.Stream.Write%2A?displayProperty=nameWithType>上此資料流的基礎緩衝區。</span><span class="sxs-lookup"><span data-stu-id="f4559-473">When the current stream is open, this method is equivalent to calling <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> on the underlying buffer of this stream.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f4559-474"><paramref name="stream" /> 為 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="f4559-474"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f4559-475">目前的資料流或目標資料流已經關閉。</span><span class="sxs-lookup"><span data-stu-id="f4559-475">The current or target stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="f4559-476">檔案和資料流 I/O</span><span class="sxs-lookup"><span data-stu-id="f4559-476">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="f4559-477">如何：從檔案讀取文字</span><span class="sxs-lookup"><span data-stu-id="f4559-477">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="f4559-478">如何：將文字寫入檔案</span><span class="sxs-lookup"><span data-stu-id="f4559-478">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>