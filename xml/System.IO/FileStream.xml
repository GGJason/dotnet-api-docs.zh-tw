<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a1270f501ef9faaea438d5520f0e0455a33f21ad" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31910839" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>為檔案提供 <see cref="T:System.IO.Stream" />，同時支援同步與非同步讀取和寫入作業。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileStream>類別來讀取、 寫入，開啟和關閉檔案在檔案系統上，以及管理其他檔案相關的作業系統控制代碼，包括管道、 標準的輸入和標準輸出。 您可以使用<xref:System.IO.FileStream.Read%2A>， <xref:System.IO.FileStream.Write%2A>， <xref:System.IO.Stream.CopyTo%2A>，和<xref:System.IO.FileStream.Flush%2A>方法，用以執行同步作業時，或<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>執行非同步的方法作業。 使用非同步方法，而不會封鎖主執行緒中執行需要大量資源的檔案作業。 這項效能考量對於 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 應用程式而言特別重要，尤其是針對耗時的資料流作業可能會阻礙 UI 執行緒，使應用程式看起來像是停止運作的情況。 <xref:System.IO.FileStream> 輸入緩衝區和輸出，以提升效能。  
  
> [!IMPORTANT]
>  此類型會實作<xref:System.IDisposable>介面。 當您完成使用類型時，您應該會處置它直接或間接。 若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。 若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。  
  
 <xref:System.IO.FileStream.IsAsync%2A>屬性會偵測是否為非同步開啟檔案控制代碼。 當您建立的執行個體時，指定這個值<xref:System.IO.FileStream>類別使用的建構函式`isAsync`， `useAsync`，或`options`參數。 若屬性是`true`，資料流使用重疊的 I/O，以非同步方式執行檔案作業。 不過，<xref:System.IO.FileStream.IsAsync%2A>屬性不一定要`true`呼叫<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。 當<xref:System.IO.FileStream.IsAsync%2A>屬性是`false`和呼叫的非同步讀取和寫入作業，仍不封鎖 UI 執行緒，但實際的 I/O 作業會以同步方式執行。  
  
 <xref:System.IO.FileStream.Seek%2A>方法支援隨機存取檔案。 <xref:System.IO.FileStream.Seek%2A> 允許讀取/寫入位置移到檔案中的任何位置。 做法是使用位元組位移的參考點參數。 位元組位移是相對於可以開頭、 目前的位置或基礎的檔案，結尾所表示的三個成員的搜尋參考點<xref:System.IO.SeekOrigin>列舉型別。  
  
> [!NOTE]
>  磁碟檔案一定會支援隨機存取。 在建構時<xref:System.IO.FileStream.CanSeek%2A>屬性值設定為`true`或`false`根據基礎的檔案類型。如果基礎的檔案類型是 FILE_TYPE_DISK，定義在 winbase.h，<xref:System.IO.FileStream.CanSeek%2A>屬性值是`true`。 否則，<xref:System.IO.FileStream.CanSeek%2A>屬性值是`false`。  
  
 如果處理程序會終止，並鎖定檔案的一部分，或關閉具有未處理的鎖定的檔案，則行為是未定義。  
  
 目錄作業及其他檔案的作業，請參閱<xref:System.IO.File>， <xref:System.IO.Directory>，和<xref:System.IO.Path>類別。 <xref:System.IO.File>類別是公用程式類別的靜態方法主要是用於建立<xref:System.IO.FileStream>物件為基礎的檔案路徑。 <xref:System.IO.MemoryStream>類別從位元組陣列中建立的資料流，類似於<xref:System.IO.FileStream>類別。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
## <a name="detection-of-stream-position-changes"></a>偵測資料流位置變更  
 當<xref:System.IO.FileStream>物件沒有其控制代碼的獨佔的按住不放，另一個執行緒可能同時存取的檔案控制代碼和變更的檔案控制代碼相關聯的作業系統的檔案指標的位置。 在此情況下，快取的位置中<xref:System.IO.FileStream>物件和快取的緩衝區中的資料可能會遭到洩露。 <xref:System.IO.FileStream>物件定期執行檢查存取快取的緩衝區，以確保作業系統的控制代碼的位置與快取所使用的位置相同的方法上<xref:System.IO.FileStream>物件。  
  
 如果呼叫中偵測到未預期的變更控制代碼的位置中<xref:System.IO.FileStream.Read%2A>方法時，.NET Framework 會捨棄緩衝區的內容，並再次從檔案讀取資料流。 這可能會影響效能，大小的檔案和任何其他處理程序可能會影響檔案資料流的位置而定。  
  
 如果呼叫中偵測到未預期的變更控制代碼的位置中<xref:System.IO.FileStream.Write%2A>方法，將緩衝區的內容會被捨棄，<xref:System.IO.IOException>擲回例外狀況。  
  
 A<xref:System.IO.FileStream>物件並不會獨佔的按住不放上其控制代碼時任一<xref:System.IO.FileStream.SafeFileHandle%2A>要公開控制代碼存取屬性或<xref:System.IO.FileStream>物件會得到<xref:System.IO.FileStream.SafeFileHandle%2A>其建構函式中的屬性。  
  
   
  
## Examples  
 下列範例會示範部分<xref:System.IO.FileStream>建構函式。  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 下列範例會示範如何以非同步方式寫入至檔案。 具有名為 u 和 連接到名為 Button_Click Click 事件處理常式按鈕 TextBlock 的 WPF 應用程式中執行此程式碼。 檔案路徑必須變更為比結束的電腦上的檔案。  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">目前 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <summary>使用指定的讀取/寫入權限，初始化指定檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.IO.Stream.Close%2A>是呼叫，此控制代碼，也會關閉和檔案的控制碼計數會遞減。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的欄位。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">目前 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <summary>使用指定的讀取/寫入權限，初始化指定檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.IO.Stream.Close%2A>是呼叫，此控制代碼，也會關閉和檔案的控制碼計數會遞減。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的欄位。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <summary>使用指定的路徑和建立模式初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑的裝置名稱，例如"\\\\。 \PHYSICALDRIVE0"。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
 建構函式可以讀取/寫入存取檔案，並開啟共用讀取權限 (亦即，若要開啟檔案以供寫入這個或另一個處理序將失敗，直到要求`FileStream`物件已關閉，但嘗試讀取則會成功)。  
  
 您無法使用這個建構函式來開啟唯讀檔案;相反地，您必須使用的建構函式可接受`FileAccess`參數值設為`FileAccess.Read`。  
  
 緩衝區大小設定為 4096 個位元組 (4 KB) 的預設大小。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟上的檔案它可以是系統支援透過資料流存取的任何部分。 例如，根據系統，此類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`指出不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>上產生屬性<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。  
  
 建構函式不含<xref:System.IO.FileAccess>參數，如果`mode`參數設定為<xref:System.IO.FileMode.Append>，<xref:System.IO.FileAccess.Write>是預設存取權。 否則，將存取權設定為<xref:System.IO.FileAccess.ReadWrite>。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何寫入資料到檔案時，位元組，並確認資料已正確寫入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
 -或-  
  
 <paramref name="path" /> 是指非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> 包含無效的值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">目前 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">
          <see cref="T:System.IO.FileAccess" /> 常數，它會設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <summary>使用指定的讀取/寫入權限和緩衝區大小，初始化指定的檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> 參數是無效的控制代碼。  
  
 -或-  
  
 <paramref name="handle" /> 參數是同步控制代碼，且已非同步使用。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 參數為負數。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">目前 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <param name="ownsHandle">
          如果這個 <see langword="FileStream" /> 執行個體將擁有檔案控制代碼，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>使用指定的讀取/寫入權限和 <see langword="FileStream" /> 執行個體擁有權，初始化指定檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`物件會得到的指定的存取檔案。 控制代碼的擁有權會依指定。 如果此程序擁有的控制代碼，呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉此控制代碼，而檔案控制碼計數會遞減。 `FileStream`物件會得到預設緩衝區大小為 4096 位元組。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫的方法以外`Close`完成之後使用此控制代碼。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的欄位。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="access">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。 這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。 如果「路徑」<c></c>指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</param>
        <summary>使用指定路徑、建立模式和讀取/寫入權限，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑的裝置名稱，例如"\\\\。 \PHYSICALDRIVE0"。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
 建構函式可以讀取/寫入存取檔案，並開啟共用讀取權限 (亦即，若要開啟檔案以供寫入這個或另一個處理序將失敗，直到要求`FileStream`物件已關閉，但嘗試讀取則會成功)。 緩衝區大小設定為 4096 個位元組 (4 KB) 的預設大小。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟上的檔案它可以是系統支援透過資料流存取的任何部分。 例如，根據系統，此類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`指出不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>上產生屬性<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
 -或-  
  
 <paramref name="path" /> 是指非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.IO.FileNotFoundException">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> 包含無效的值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">這個 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="isAsync">
          如果控制代碼為非同步開啟 (也就是，在重疊 I/O 模式)，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>使用指定的讀取/寫入權限、緩衝區大小和同步或非同步狀態，初始化指定的檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您設定`isAsync`參數`true`以非同步方式開啟檔案控制代碼。 當參數是`true`，資料流使用重疊的 I/O，以非同步方式執行檔案作業。 不過，有參數不是`true`呼叫<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。 當`isAsync`參數是`false`和呼叫的非同步讀取和寫入作業，仍不封鎖 UI 執行緒，但實際的 I/O 作業會以同步方式執行。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> 參數是無效的控制代碼。  
  
 -或-  
  
 <paramref name="handle" /> 參數是同步控制代碼，且已非同步使用。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 參數為負數。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼的權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">這個 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <param name="ownsHandle">
          如果這個 <see langword="FileStream" /> 執行個體將擁有檔案控制代碼，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <summary>使用指定的讀取/寫入權限、<see langword="FileStream" /> 執行個體擁有權和緩衝區大小，初始化指定檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`物件會得到的指定的存取檔案。 控制代碼的擁有權會依指定。 如果這個`FileStream`擁有的控制代碼呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉此控制代碼。 特別是，檔案的控制碼計數會遞減。 `FileStream`物件會得到在指定的緩衝區大小。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 為負。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="access">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。 這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。 如果「路徑」<c></c>指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</param>
        <param name="share">常數，決定處理程序如何共用檔案。</param>
        <summary>使用指定路徑、建立模式、讀取/寫入權限和共用權限，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑的裝置名稱，例如"\\\\。 \PHYSICALDRIVE0"。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
 建構函式可以讀取/寫入存取檔案，並開啟共用讀取權限 (亦即，若要開啟檔案以供寫入這個或另一個處理序將失敗，直到要求`FileStream`物件已關閉，但嘗試讀取則會成功)。 緩衝區大小設定為 4096 個位元組 (4 KB) 的預設大小。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟上的檔案它可以是系統支援透過資料流存取的任何部分。 例如，根據系統，此類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`指出不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>上產生屬性<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.IO.FileStream.Lock%2A>方法。  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
 -或-  
  
 <paramref name="path" /> 是指非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.IO.FileNotFoundException">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。  
  
 -或-  
  
 系統在執行 Windows 98 或 Windows 98 SE，且 <paramref name="share" /> 設定為 <see langword="FileShare.Delete" />。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> 包含無效的值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">這個 <see langword="FileStream" /> 物件將會封裝之檔案的檔案控制代碼。</param>
        <param name="access">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</param>
        <param name="ownsHandle">
          如果這個 <see langword="FileStream" /> 執行個體將擁有檔案控制代碼，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="isAsync">
          如果控制代碼為非同步開啟 (也就是，在重疊 I/O 模式)，則為 <see langword="true" />；否則為 <see langword="false" />。</param>
        <summary>使用指定的讀取/寫入權限、<see langword="FileStream" /> 執行個體擁有權、緩衝區大小和同步或非同步狀態，初始化指定檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`物件會得到的指定的存取檔案。 控制代碼的擁有權會依指定。 如果這個`FileStream`擁有的控制代碼呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉此控制代碼。 特別是，檔案的控制碼計數會遞減。 `FileStream`物件會得到在指定的緩衝區大小。  
  
 `FileStream` 假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。  
  
 `FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="access" /> 小於 <see langword="FileAccess.Read" /> 或大於 <see langword="FileAccess.ReadWrite" /> 或者 <paramref name="bufferSize" /> 小於或等於 0。</exception>
        <exception cref="T:System.ArgumentException">控制代碼無效。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如磁碟錯誤。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用於存取 unmanaged 程式碼。 關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="access">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。 這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。 如果「路徑」<c></c>指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</param>
        <param name="share">常數，決定處理程序如何共用檔案。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <summary>使用指定路徑、建立模式、讀取/寫入與共用權限與緩衝區大小，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑的裝置名稱，例如"\\\\。 \PHYSICALDRIVE0"。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟上的檔案它可以是系統支援透過資料流存取的任何部分。 例如，根據系統，此類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`指出不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>上產生屬性<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
 -或-  
  
 <paramref name="path" /> 是指非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 為負值或零。  
  
 -或-  
  
 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。  
  
 -或-  
  
 系統在執行 Windows 98 或 Windows 98 SE，且 <paramref name="share" /> 設定為 <see langword="FileShare.Delete" />。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="access">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。 這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。 如果「路徑」<c></c>指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</param>
        <param name="share">常數，決定處理程序如何共用檔案。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="useAsync">指定要使用非同步 I/O 或同步 I/O。 但是，請注意：基礎作業系統可能並不支援非同步 I/O，所以在指定 <see langword="true" /> 時，可能會視平台以同步方式開啟控制代碼。 在以非同步方式開啟時，<see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 與 <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 方法對大量讀取或寫入的作業會有較佳的效能，但對於少量讀取和寫入的作業卻會比較慢。 如果要將應用程式設計成使用非同步 I/O，請將 <c>useAsync</c> 參數設定為 <see langword="true" />。 正確地使用非同步 I/O，可以讓應用程式的執行快上十倍，但如果沒有配合非同步 I/O 的需求重新設計應用程式，卻會降低十倍的效能。</param>
        <summary>使用指定路徑、建立模式、讀取/寫入與共用權限、緩衝大小與同步或非同步狀態，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑的裝置名稱，例如"\\\\。 \PHYSICALDRIVE0"。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟上的檔案它可以是系統支援透過資料流存取的任何部分。 例如，根據系統，此類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`指出不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>上產生屬性<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何以非同步方式將資料寫入檔案，然後確認 資料已正確地寫入。 A`State`物件是用來將資訊從主執行緒`EndReadCallback`和`EndWriteCallback`方法。  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
 -或-  
  
 <paramref name="path" /> 是指非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 為負值或零。  
  
 -或-  
  
 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。  
  
 -或-  
  
 系統在執行 Windows 98 或 Windows 98 SE，且 <paramref name="share" /> 設定為 <see langword="FileShare.Delete" />。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
        <altmember cref="T:System.IO.File" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="access">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。 這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。 如果「路徑」<c></c>指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</param>
        <param name="share">常數，決定處理程序如何共用檔案。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="options">值，指定其他檔案選項。</param>
        <summary>使用指定的路徑、建立模式、讀取/寫入與共用權限、其他 FileStream 對同一檔案的存取權、緩衝區大小和其他檔案選項，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑的裝置名稱，例如"\\\\。 \PHYSICALDRIVE0"。  
  
 `fileOptions`參數用來提供更進階的作業，可以在建立時運用的存取權<xref:System.IO.FileStream>物件。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟上的檔案它可以是系統支援透過資料流存取的任何部分。 例如，根據系統，此類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`指出不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>上產生屬性<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會將資料寫入至檔案，然後讀取 使用資料<xref:System.IO.FileStream>物件。  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
 -或-  
  
 <paramref name="path" /> 是指非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 為負值或零。  
  
 -或-  
  
 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。  
  
 -或-  
  
 <see cref="F:System.IO.FileOptions.Encrypted" /> 是指定給 <paramref name="options" />，但目前平台上不支援檔案加密。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see cref="T:System.IO.FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="rights">常數，決定建立檔案的存取和稽核規則時要使用的存取權。</param>
        <param name="share">常數，決定處理程序如何共用檔案。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="options">常數，指定其他檔案選項。</param>
        <summary>使用指定的路徑、建立模式、存取權與共用權限、緩衝區大小和其他檔案選項，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑的裝置名稱，例如"\\\\。 \PHYSICALDRIVE0"。  
  
 使用此<xref:System.IO.FileStream.%23ctor%2A>建構函式來將存取權套用權限時建立檔案的檔案。 若要存取或修改現有的檔案上的權限，請考慮使用<xref:System.IO.File.GetAccessControl%2A>和<xref:System.IO.File.SetAccessControl%2A>方法。  
  
 `fileOptions`參數用來提供更進階的作業，可以在建立時運用的存取權<xref:System.IO.FileStream>物件。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟上的檔案它可以是系統支援透過資料流存取的任何部分。 例如，根據系統，此類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`指出不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>上產生屬性<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
 -或-  
  
 <paramref name="path" /> 是指非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 為負值或零。  
  
 -或-  
  
 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.PlatformNotSupportedException">目前的作業系統不是 Windows NT 或更新版本。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。  
  
 -或-  
  
 <see cref="F:System.IO.FileOptions.Encrypted" /> 是指定給 <paramref name="options" />，但目前平台上不支援檔案加密。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的 <paramref name="path" />、檔案名稱或兩者都超過系統定義的最大長度。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">目前 <see cref="T:System.IO.FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</param>
        <param name="mode">常數，決定如何開啟或建立檔案。</param>
        <param name="rights">常數，決定建立檔案的存取和稽核規則時要使用的存取權。</param>
        <param name="share">常數，決定處理程序如何共用檔案。</param>
        <param name="bufferSize">大於 0 的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。 預設緩衝區大小為 4096。</param>
        <param name="options">常數，指定其他檔案選項。</param>
        <param name="fileSecurity">常數，決定檔案的存取控制和稽核安全性。</param>
        <summary>使用指定的路徑、建立模式、存取權與共用權限、緩衝區大小、其他檔案選項、存取控制和稽核安全性，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework 不支援直接存取實體磁碟，透過路徑的裝置名稱，例如"\\\\。 \PHYSICALDRIVE0"。  
  
 使用此<xref:System.IO.FileStream.%23ctor%2A>建構函式來將存取權套用權限時建立檔案的檔案。 若要存取或修改現有的檔案上的權限，請考慮使用<xref:System.IO.File.GetAccessControl%2A>和<xref:System.IO.File.SetAccessControl%2A>方法。  
  
 `fileOptions`參數用來提供更進階的作業，可以在建立時運用的存取權<xref:System.IO.FileStream>物件。  
  
 `path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。  
  
> [!NOTE]
>  `path` 不需要是儲存在磁碟上的檔案它可以是系統支援透過資料流存取的任何部分。 例如，根據系統，此類別可以存取實體裝置。  
  
 <xref:System.IO.Stream.CanSeek%2A> 是`true`所有<xref:System.IO.FileStream>封裝檔案的物件。 如果`path`指出不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>上產生屬性<xref:System.IO.FileStream>是`false`。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A>。  
  
> [!CAUTION]
>  當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會造成擲回例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會將資料寫入至檔案，然後讀取 使用資料<xref:System.IO.FileStream>物件。  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為空字串 ("")，只包含空格或包含一或多個無效字元。  
  
 -或-  
  
 <paramref name="path" /> 是指非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> 為負值或零。  
  
 -或-  
  
 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。 這些模式中必須有此檔案。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。  
  
 -或-  
  
 資料流已關閉。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效，例如位於未對應的磁碟機上。</exception>
        <exception cref="T:System.UnauthorizedAccessException">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。  
  
 -或-  
  
 <see cref="F:System.IO.FileOptions.Encrypted" /> 是指定給 <paramref name="options" />，但目前平台上不支援檔案加密。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的 <paramref name="path" />、檔案名稱或兩者都超過系統定義的最大長度。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.PlatformNotSupportedException">目前的作業系統不是 Windows NT 或更新版本。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取、 寫入和附加至檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">要讀取資料的緩衝區。</param>
        <param name="buffer">To be added.</param>
        <param name="offset">「陣列」<c></c>中的位元組位移，即開始讀取的位置。</param>
        <param name="numBytes">要讀取的最大位元組數。</param>
        <param name="count">To be added.</param>
        <param name="userCallback">在非同步讀取作業完成時所呼叫的方法。</param>
        <param name="callback">To be added.</param>
        <param name="stateObject">使用者所提供的物件，其可以從其他要求中區分出這個特定非同步讀取的要求。</param>
        <param name="state">To be added.</param>
        <summary>開始非同步的讀取作業。 (請考慮用 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> 替代。)</summary>
        <returns>物件，參考非同步讀取。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 4 和舊版中，您必須使用下列方法<xref:System.IO.FileStream.BeginRead%2A>和<xref:System.IO.FileStream.EndRead%2A>實作非同步檔案作業。 這些方法都仍有[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。  
  
 <xref:System.IO.FileStream.EndRead%2A> 必須針對每次呼叫一次呼叫<xref:System.IO.FileStream.BeginRead%2A>。 若要開始另一次讀取之前結束讀取的處理序失敗，可能會導致非預期的行為，例如死結。  
  
 <xref:System.IO.FileStream> 提供兩個不同的作業模式： I/O 同步和非同步 I/O。 雖然可以用來，基礎作業系統資源可能只有其中一個這些模式中允許存取。 根據預設，<xref:System.IO.FileStream>以同步方式開啟的作業系統控制代碼。 在 Windows 中，這會略微減慢非同步方法。 如果使用非同步方法，使用<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanRead%2A>屬性來判斷目前的執行個體是否支援讀取。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanRead%2A>。  
  
 如果資料流已關閉，或是您傳遞了無效的引數，會擲回例外狀況立即從<xref:System.IO.FileStream.BeginRead%2A>。 非同步讀取要求，例如磁碟失敗期間的 IO 要求期間發生的錯誤發生在執行緒集區執行緒，並且呼叫時變成可見<xref:System.IO.FileStream.EndRead%2A>。  
  
 <xref:System.IO.Stream.EndRead%2A> 必須先呼叫與這個<xref:System.IAsyncResult>找出多少位元組被讀取。  
  
 多個同時進行非同步要求轉譯要求完成順序不確定。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">陣列長度減去 <paramref name="offset" /> 會小於 <paramref name="numBytes" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="numBytes" /> 是負數。</exception>
        <exception cref="T:System.IO.IOException">在超過檔案結尾處嘗試了非同步讀取。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">包含要寫入目前資料流之資料的緩衝區。</param>
        <param name="buffer">To be added.</param>
        <param name="offset">「陣列」<c></c>中以零為起始的位元組位移，即要開始將位元組複製到目前資料流的位置。</param>
        <param name="numBytes">寫入的最大位元組數。</param>
        <param name="count">To be added.</param>
        <param name="userCallback">在非同步寫入作業完成時所呼叫的方法。</param>
        <param name="callback">To be added.</param>
        <param name="stateObject">使用者所提供的物件，其可以從其他要求中區分出這個特定非同步寫入的要求。</param>
        <param name="state">To be added.</param>
        <summary>開始非同步的寫入作業。 (請考慮用 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> 替代。)</summary>
        <returns>物件，參考非同步寫入。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 4 和舊版中，您必須使用下列方法<xref:System.IO.FileStream.BeginWrite%2A>和<xref:System.IO.FileStream.EndWrite%2A>實作非同步檔案作業。 這些方法都仍有[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。  
  
 <xref:System.IO.FileStream.EndWrite%2A> 必須正好一次上呼叫每個<xref:System.IAsyncResult>從<xref:System.IO.FileStream.BeginWrite%2A>。 <xref:System.IO.FileStream.EndWrite%2A> 將會封鎖，直到 I/O 作業完成為止。  
  
 這個方法覆寫 <xref:System.IO.Stream.BeginWrite%2A>。  
  
 <xref:System.IO.FileStream> 提供兩個不同的作業模式： I/O 同步和非同步 I/O。 雖然可以用來，基礎作業系統資源可能只有其中一個這些模式中允許存取。 根據預設，<xref:System.IO.FileStream>以同步方式開啟的作業系統控制代碼。 在 Windows 中，這會略微減慢非同步方法。 如果使用非同步方法，使用<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
 如果資料流已關閉，或是您傳遞了無效的引數，會擲回例外狀況立即從<xref:System.IO.FileStream.BeginWrite%2A>。 非同步寫入要求，例如磁碟失敗期間的 IO 要求期間發生的錯誤發生在執行緒集區執行緒，並且呼叫時變成可見<xref:System.IO.FileStream.EndWrite%2A>。  
  
 多個同時進行非同步要求轉譯要求完成順序不確定。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 長度減 <paramref name="offset" /> 小於 <paramref name="numBytes" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="numBytes" /> 為負。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援寫入。</exception>
        <exception cref="T:System.ObjectDisposedException">資料流已關閉。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示目前資料流是否支援讀取的值。</summary>
        <value>
          如果資料流支援讀取，則為 <see langword="true" />；如果資料流已關閉或以唯寫存取開啟，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類別衍生自<xref:System.IO.Stream>不支援讀取，但呼叫<xref:System.IO.FileStream.Read%2A>， <xref:System.IO.FileStream.ReadByte%2A>，和<xref:System.IO.FileStream.BeginRead%2A>方法會擲回<xref:System.NotSupportedException>。  
  
 如果資料流已關閉，則這個屬性會傳回`false`。  
  
   
  
## Examples  
 下列範例會示範使用`CanRead`屬性。 此程式碼的輸出是"MyFile.txt 沒有可寫入 」。 若要取得輸出訊息"MyFile.txt 可被寫入和讀取。 」，變更`FileAccess`參數`ReadWrite`中`FileStream`建構函式。  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示目前資料流是否支援搜尋的值。</summary>
        <value>
          如果資料流支援搜尋，則為 <see langword="true" />；如果資料流已關閉或如果 <see langword="FileStream" /> 是從作業系統控制代碼 (例如管道或主控台的輸出) 建構，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類別衍生自<xref:System.IO.Stream>不支援搜尋，但呼叫<xref:System.IO.FileStream.Length%2A>， <xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Position%2A>，和<xref:System.IO.FileStream.Seek%2A>擲回<xref:System.NotSupportedException>。  
  
 如果資料流已關閉，則這個屬性會傳回`false`。  
  
   
  
## Examples  
 下列範例會使用`CanSeek`回資料流是否支援搜尋的屬性。  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示目前資料流是否支援寫入的值。</summary>
        <value>
          如果資料流支援寫入，則為 <see langword="true" />；如果資料流已關閉或以唯讀存取開啟，則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果類別衍生自<xref:System.IO.Stream>不支援寫入，呼叫<xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Write%2A>， <xref:System.IO.FileStream.BeginWrite%2A>，或<xref:System.IO.FileStream.WriteByte%2A>會擲回<xref:System.NotSupportedException>。  
  
 如果資料流已關閉，則這個屬性會傳回`false`。  
  
   
  
## Examples  
 下列範例會使用`CanWrite`回資料流是否支援寫入的屬性。  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 下列是範例使用`CanWrite`屬性。 此程式碼的輸出是"MyFile.txt 可寫入 」。 若要取得輸出訊息"MyFile.txt 可被寫入和讀取。 」，變更`FileAccess`參數`ReadWrite`中`FileStream`建構函式。  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.IO.FileStream" /> 所使用的 Unmanaged 資源，並選擇性地釋放 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。 <xref:System.ComponentModel.Component.Dispose%2A> 叫用受保護<xref:System.IO.FileStream.Dispose%2A>方法`disposing`參數設定為`true`。 <xref:System.Object.Finalize%2A> 叫用<xref:System.IO.FileStream.Dispose%2A>與`disposing`設`false`。  
  
 `disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.IO.FileStream> 參考的任何 Managed 物件所掌握的資源。 這個方法會叫用每個參考物件的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以被其他物件呼叫多次。 在覆寫<see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />小心不要參考物件已處置過的早期呼叫中<see cref="M:System.ComponentModel.Component.Dispose" />。 如需有關如何實作<see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />，請參閱[實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
 如需有關<see cref="M:System.ComponentModel.Component.Dispose" />和<see cref="M:System.Object.Finalize" />，請參閱[清除 Unmanaged 資源上](~/docs/standard/garbage-collection/unmanaged.md)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">要等候的暫止非同步要求的參考。</param>
        <summary>等候暫止的非同步讀取作業完成。 (請考慮用 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> 替代。)</summary>
        <returns>自資料流讀取的位元組數，在 0 和您所要求的位元組數目之間。 在資料流末端資料流只傳回 0，否則，他們應該封鎖直到至少有 1 位元組可用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 4 和舊版中，您必須使用下列方法<xref:System.IO.FileStream.BeginRead%2A>和<xref:System.IO.FileStream.EndRead%2A>實作非同步檔案作業。 這些方法都仍有[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。  
  
 <xref:System.IO.FileStream.EndRead%2A> 每次呼叫必須剛好呼叫<xref:System.IO.FileStream.BeginRead%2A>。 若要開始另一次讀取之前結束讀取的處理序失敗，可能會導致非預期的行為，例如死結。  
  
 這個方法覆寫 <xref:System.IO.Stream.EndRead%2A>。  
  
 <xref:System.IO.FileStream.EndRead%2A> 可呼叫每個<xref:System.IAsyncResult>從<xref:System.IO.FileStream.BeginRead%2A>。 呼叫<xref:System.IO.FileStream.EndRead%2A>會告訴您多少位元組被讀取從資料流。 <xref:System.IO.FileStream.EndRead%2A> 將會封鎖，直到 I/O 作業完成為止。  
  
   
  
## Examples  
 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">這個 <see cref="T:System.IAsyncResult" /> 物件不是透過對這個類別呼叫 <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 所建立。</exception>
        <exception cref="T:System.InvalidOperationException">
          多次呼叫 <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.IO.IOException">資料流已關閉或發生內部錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">暫止的非同步 I/O 要求。</param>
        <summary>結束非同步寫入作業並封鎖，直到 I/O 作業完成。 (請考慮用 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> 替代。)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在.NET Framework 4 和舊版中，您必須使用下列方法<xref:System.IO.FileStream.BeginWrite%2A>和<xref:System.IO.FileStream.EndWrite%2A>實作非同步檔案作業。 這些方法都仍有[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。  
  
 這個方法覆寫 <xref:System.IO.Stream.EndWrite%2A>。  
  
 <xref:System.IO.FileStream.EndWrite%2A> 必須正好一次上呼叫每個<xref:System.IAsyncResult>從<xref:System.IO.FileStream.BeginWrite%2A>。 <xref:System.IO.FileStream.EndWrite%2A> 將會封鎖，直到 I/O 作業完成為止。  
  
   
  
## Examples  
 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">這個 <see cref="T:System.IAsyncResult" /> 物件不是透過對這個類別呼叫 <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 所建立。</exception>
        <exception cref="T:System.InvalidOperationException">
          多次呼叫 <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />。</exception>
        <exception cref="T:System.IO.IOException">資料流已關閉或發生內部錯誤。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>確認釋出資源，並在記憶體回收行程再利用 <see langword="FileStream" /> 時執行其他清除作業。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 記憶體回收行程呼叫`Finalize`準備最終處理而將目前的物件時。 `Finalize` 關閉`FileStream`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>清除這個資料流的緩衝區，讓所有緩衝資料全部寫入檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>清除這個資料流的緩衝區，讓所有緩衝資料全部寫入檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>。  
  
 當您呼叫<xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType>也會排清方法時，作業系統 I/O 緩衝區。  
  
 除非您明確地呼叫無法排清資料流編碼器<xref:System.IO.FileStream.Flush%2A>或處置物件。 設定<xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType>至`true`表示從緩衝區資料流，清除資料，但並不會清除編碼器狀態。 這可讓編碼器將保存其狀態 （部分字元），讓它可以正確編碼字元的下一個區塊。 這種情況下會影響 UTF8 及 UTF7 其中某些字元可以只編碼的編碼器接收或多個相鄰的字元之後。  
  
 因為緩衝區可供讀取或寫入，<xref:System.IO.FileStream.Flush>執行下列兩個功能：  
  
-   任何之前寫入緩衝區的資料複製到檔案，除了其編碼器狀態清除緩衝區。  
  
-   如果<xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType>是`true`資料先前已從檔案複製到讀取的緩衝區，檔案中目前的位置也會減少在緩衝區中讀取的位元組數目。 然後會清除緩衝區。  
  
 使用<xref:System.IO.FileStream.Flush%28System.Boolean%29>方法多載，當您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。  
  
   
  
## Examples  
 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.IO.FileStream.Lock%2A>方法。  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
        <exception cref="T:System.ObjectDisposedException">資料流已關閉。</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" /> 表示排清所有中繼檔案緩衝區；否則為 <see langword="false" />。</param>
        <summary>清除此資料流的緩衝區，讓所有緩衝資料全部寫入檔案，同時也清除所有的中繼檔案緩衝區。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個多載，當您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。  
  
 當您呼叫<xref:System.IO.FileStream.Flush%2A>也會排清方法時，作業系統 I/O 緩衝區。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">用來監視是否有取消要求的語彙基元。</param>
        <summary>以非同步的方式清除這個資料流的所有緩衝區，造成任何緩衝資料都寫入基礎裝置，並且監視取消要求。</summary>
        <returns>表示非同步排清作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當您呼叫<xref:System.IO.FileStream.FlushAsync%2A>也會排清方法時，作業系統 I/O 緩衝區。  
  
 如果在作業完成之前將其取消，則傳回的工作包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。 如果已處置的檔案控制代碼，則傳回的工作包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">資料流已經處置。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件，該物件會封裝目前 <see cref="T:System.IO.FileStream" /> 物件所描述的檔案之存取控制清單 (ACL) 項目。</summary>
        <returns>封裝目前 <see cref="T:System.IO.FileStream" /> 物件所描述檔案之存取控制設定的物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然<xref:System.IO.FileStream>類別和<xref:System.IO.FileStream.GetAccessControl%2A>可用來擷取現有檔案的存取控制清單 (ACL) 項目，請考慮使用<xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType>方法，因為它比較容易使用。  
  
 使用<xref:System.IO.FileStream.GetAccessControl%2A>方法來擷取檔案的 ACL 項目。  
  
 ACL 描述個人及/或群組，讓他們已經有或沒有，在指定的檔案上採取特定動作的權限。 如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">檔案已關閉。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.SystemException">找不到檔案。</exception>
        <exception cref="T:System.UnauthorizedAccessException">這個作業在目前平台不受支援。  
  
 -或-  
  
 呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得目前 <see langword="FileStream" /> 物件封裝之檔案的作業系統檔案控制代碼。</summary>
        <value>這個 <see langword="FileStream" /> 物件所封裝的檔案之作業系統檔案控制代碼；如果 <see langword="FileStream" /> 已關閉，則為 -1。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性是用於操作-系統提供的系統呼叫作業系統的控制代碼 (例如`ReadFile`Windows 上)。 它不適用於 C 程式庫函式預期的檔案描述項，例如`fread`。  
  
 作業系統控制代碼可能已經開啟同步或非同步方式，依據`FileStream`建構函式呼叫。 使用<xref:System.IO.FileStream.IsAsync%2A>屬性以探索此控制代碼是否以非同步方式開啟。 在 Win32 中，這表示控制代碼已開啟重疊的 io，而且它需要不同的參數`ReadFile`和`WriteFile`。  
  
> [!CAUTION]
>  如果，可能會發生資料損毀`FileStream`已建立，其控制代碼傳遞時，某些作業移動控制代碼的檔案指標，然後`FileStream`會再次使用。 多個執行緒安全地無法同時寫入相同的檔案和`FileStream`緩衝處理程式碼會假設它以獨佔方式控制控制代碼。 `FileStream` 可能會擲回<xref:System.IO.IOException>如果`FileStream`偵測到某些其他處理序已移動檔案指標。 若要避免這個問題，請勿不寫入任何資料檔案的一部分，`FileStream`可能必須緩衝處理，並在上次呼叫了方法時發生的位置還原的檔案指標`FileStream`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供存取 unmanaged 程式碼的能力。 列舉型別相關聯：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />。</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，指出 <see langword="FileStream" /> 為非同步或同步開啟。</summary>
        <value>
          如果 <see langword="FileStream" /> 是非同步開啟，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsAsync`屬性會偵測是否`FileStream`控制代碼開啟時以非同步的方式，讓您的程式碼使用<xref:System.IO.FileStream.Handle%2A>屬性正確。 在 Win32 中，`IsAsync`正在 true 表示控制代碼的重疊 I/O，已開啟，並因此而需要不同的參數來`ReadFile`和`WriteFile`。  
  
 當您建立的執行個體時，指定這個值<xref:System.IO.FileStream>類別使用的建構函式`isAsync`， `useAsync`，或`options`參數。 若屬性是`true`，資料流使用重疊的 I/O，以非同步方式執行檔案作業。 不過，<xref:System.IO.FileStream.IsAsync%2A>屬性不一定要`true`呼叫<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。 當<xref:System.IO.FileStream.IsAsync%2A>屬性是`false`和呼叫的非同步讀取和寫入作業，仍不封鎖 UI 執行緒，但實際的 I/O 作業會以同步方式執行。  
  
   
  
## Examples  
 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得資料流的位元組長度。</summary>
        <value>代表資料流長度的長數值 (以位元組為單位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會使用`Length`和`Position`屬性，以檢查檔案結尾條件。  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          這個資料流的 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="false" />。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤，例如檔案已關閉。</exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">鎖定的範圍開頭。 這個參數的值必須等於或大於零 (0)。</param>
        <param name="length">要鎖定的範圍。</param>
        <summary>防止其他處理程序讀取或寫入 <see cref="T:System.IO.FileStream" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 鎖定某個範圍的檔案資料流可讓執行緒的鎖定的處理程序的獨佔存取該範圍的檔案資料流。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何鎖定檔案的一部分，因此即使檔案有讀取/寫入存取另一個處理序無法存取該檔案的一部分。 在不同的命令視窗中同時執行的程式，並調查使用不同的主控台輸入的選項。  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> 或 <paramref name="length" /> 為負。</exception>
        <exception cref="T:System.ObjectDisposedException">檔案已關閉。</exception>
        <exception cref="T:System.IO.IOException">處理序無法存取檔案，因為其他處理序鎖定了該檔案的一部分。</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得傳遞給建構函式的 <see langword="FileStream" /> 名稱。</summary>
        <value>
          <see langword="FileStream" /> 名稱的字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">為路徑的存取權。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定這個資料流的目前位置。</summary>
        <value>這個資料流的目前位置。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 支援搜尋到的任何位置超出資料流的長度。  當您搜尋檔案的長度超過檔案大小會成長。  在 Microsoft Windows NT 及更新版本，新增至檔案結尾的所有資料都設為零。  在 Microsoft Windows 98 或更早版本，新增至檔案結尾的所有資料未設定為零，表示先前已刪除的資料會顯示資料流。 將資料流的位置設定為較大的值，在 Windows 98 或更早版本的資料流的結尾之外，可能會導致引發例外狀況。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會使用`Length`和`Position`屬性，以檢查檔案結尾條件。  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">資料流不支援搜尋。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。  
  
 \-或-  
  
 位置設為非常大的值，超出 Windows 98 或更早版本的資料流結尾。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">嘗試將位置設為負數值。</exception>
        <exception cref="T:System.IO.EndOfStreamException">嘗試搜尋超過資料流的結尾，但不支援此作業。</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">當這個方法傳回時，會包含其值介於 <c>offset</c> 和 (<c>offset</c> + <c>count</c> - 1<c>)</c> 之間，並由讀取自目前來源的位元組取代的指定位元組陣列。</param>
        <param name="offset">「陣列」<c></c>中的位元組位移，即放置讀取位元組的位置。</param>
        <param name="count">要讀取的最大位元組數。</param>
        <summary>從資料流讀取位元組區塊，並將資料寫入指定緩衝區。</summary>
        <returns>緩衝區所讀取的總位元組數。 如果目前無法提供那麼多的位元組數目，則這個數目可能小於所要求的位元組數；如果已經到達資料流末端，則為零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.Read%2A>。  
  
 `offset`參數會提供中的位元組位移`array`（緩衝區索引） 中要開始閱讀，而`count`參數指定要從這個資料流讀取的位元組數目上限。 如果已到達資料流結尾，傳回的值會是個位元組，則為零的實際數目。 如果在讀取的作業成功，讀取的位元組數目進階資料流的目前位置。 如果發生例外狀況，目前資料流的位置不變。  
  
 <xref:System.IO.FileStream.Read%2A>方法會傳回零只到達資料流結尾之後。 否則，<xref:System.IO.FileStream.Read%2A>一律會讀取至少一個位元組資料流後再傳回。 如果沒有資料可從呼叫時，資料流<xref:System.IO.FileStream.Read%2A>，方法會封鎖直到至少一個位元組的資料可能會傳回。 實作可以自由地傳回比要求的位元組更少，即使尚未達到資料流結尾。  
  
 使用<xref:System.IO.BinaryReader>讀取基本資料型別。  
  
 不會中斷正在執行讀取的作業的執行緒。 雖然應用程式或許可以順利執行之後，執行緒會封鎖，您的應用程式效能和可靠性，就可能會降低發生中斷。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會讀取內容從<xref:System.IO.FileStream>並將它寫入至另一個<xref:System.IO.FileStream>。  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 為負。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援讀取。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 和 <paramref name="count" /> 描述 <paramref name="array" /> 中的無效範圍。</exception>
        <exception cref="T:System.ObjectDisposedException">關閉資料流後呼叫了方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">寫入資料的緩衝區。</param>
        <param name="offset">「緩衝區」<c></c> 中的位元組位移，即要開始從資料流寫入資料的位置。</param>
        <param name="count">要讀取的最大位元組數。</param>
        <param name="cancellationToken">用來監視是否有取消要求的語彙基元。</param>
        <summary>以非同步的方式從目前資料流讀取一連串的位元組、依所讀取的位元組數目進階資料流中的位置，以及監視取消要求。</summary>
        <returns>表示非同步讀取作業的工作。 <paramref name="TResult" /> 參數的值會包含讀取至緩衝區的位元組總數。 如果目前可供使用的位元組數目少於所要求的數目，結果值可能會小於所要求的位元組數目，或者如果已經到達資料流末端，則可能為 0 (零)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.ReadAsync%2A>方法可讓您執行需要大量資源的檔案作業，而不會封鎖主執行緒。 這項效能考量對於 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 應用程式而言特別重要，尤其是針對耗時的資料流作業可能會阻礙 UI 執行緒，使應用程式看起來像是停止運作的情況。 非同步方法會用於搭配`async`和`await`Visual Basic 和 C# 中的關鍵字。  
  
 使用<xref:System.IO.FileStream.CanRead%2A>屬性來判斷目前的執行個體是否支援讀取。  
  
 如果在作業完成之前將其取消，則傳回的工作包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。 如果已處置的檔案控制代碼，則傳回的工作包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。  
  
   
  
## Examples  
 下列範例會示範如何以非同步方式從檔案讀取。  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 為負。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 和 <paramref name="count" /> 的總和大於緩衝區長度。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援讀取。</exception>
        <exception cref="T:System.ObjectDisposedException">資料流已經處置。</exception>
        <exception cref="T:System.InvalidOperationException">之前的讀取作業目前正在使用資料流。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>從檔案讀取一個位元組，並將讀取位置前移一個位元組。</summary>
        <returns>轉換為 <see cref="T:System.Int32" /> 的位元組，如果已經到達資料流的末端，則為 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.ReadByte%2A>。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanRead%2A>屬性來判斷目前的執行個體是否支援讀取。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanRead%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何寫入資料到檔案時，位元組，並確認資料已正確寫入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">目前的資料流不支援讀取。</exception>
        <exception cref="T:System.ObjectDisposedException">目前的資料流已關閉。</exception>
        <block subset="none" type="overrides">
          <para>上的預設實作<see langword="Stream" />建立新的單一位元組陣列，然後呼叫<see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />。 雖然這是正式正確，就沒有效率。 任何內部緩衝區的資料流應該覆寫這個方法，並提供更有效率的版本會直接讀取緩衝區，避免在每次呼叫配置額外的陣列。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> 物件，這個物件代表目前的 <see cref="T:System.IO.FileStream" /> 物件封裝之檔案的作業系統檔案控制代碼。</summary>
        <value>代表目前 <see cref="T:System.IO.FileStream" /> 物件封裝之檔案的作業系統檔案控制代碼的物件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.SafeFileHandle%2A>屬性自動排清資料流，並將目前資料流位置設定為 0。  這可讓要移動檔案或另一個資料流使用會重設資料流位置<xref:System.IO.FileStream.SafeFileHandle%2A>這個屬性所傳回。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">呼叫 unmanaged 程式碼的權限。  
  
 安全性動作： 連結要求  
  
 相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要完全信任立即呼叫者。 這個成員無法供部分信任或安全性透明程式碼。</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">相對於「原點」<c></c>的搜尋起點。</param>
        <param name="origin">使用類型 <see cref="T:System.IO.SeekOrigin" /> 的值，指定開頭、結尾或目前位置作為「位移」<c></c>的參考點。</param>
        <summary>設定這個資料流的目前位置為指定的數值。</summary>
        <returns>資料流中的新位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType>屬性來判斷目前的執行個體是否支援搜尋。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>。  
  
 您可以搜尋到的任何位置超出資料流的長度。 當您搜尋檔案的長度超過檔案大小會成長。 在 Windows NT 和更新版本中，資料檔案的結尾處加入設為零。 在 Windows 98 或更早版本中，新增到檔案結尾的資料未設定為零，表示先前已刪除的資料會顯示資料流。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會示範如何寫入資料到檔案時，位元組，並確認資料已正確寫入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 下列範例會使用各種檔案結尾開頭的檔案，請從讀取文字方向會相反，<xref:System.IO.SeekOrigin>值與<xref:System.IO.FileStream.Seek%2A>方法。  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援搜尋，例如，如果 <see langword="FileStream" /> 為從管道或主控台輸出所建構。</exception>
        <exception cref="T:System.ArgumentException">在資料流開始之前嘗試搜尋。</exception>
        <exception cref="T:System.ObjectDisposedException">關閉資料流後呼叫了方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">物件，描述要套用至目前檔案的 ACL 項目。</param>
        <summary>將 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件所描述的存取控制清單 (ACL) 項目套用至目前 <see cref="T:System.IO.FileStream" /> 物件所描述的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然<xref:System.IO.FileStream>類別和<xref:System.IO.FileStream.SetAccessControl%2A>可以用於現有的檔案，請考慮使用<xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType>方法，因為它比較容易使用。  
  
 <xref:System.IO.FileStream.SetAccessControl%2A>方法適用於代表 noninherited 的 ACL 清單的檔案存取控制清單 (ACL) 項目。  
  
> [!CAUTION]
>  指定 ACL`fileSecurity`參數已取代現有檔案的 ACL。 若要加入之新使用者的權限，請使用<xref:System.IO.FileStream.GetAccessControl%2A>方法來取得現有的 ACL，修改它，然後使用<xref:System.IO.FileStream.SetAccessControl%2A>套用回到檔案。  
  
 ACL 描述個人及/或群組，讓他們已經有或沒有，在指定的檔案上採取特定動作的權限。 如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">檔案已關閉。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileSecurity" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.SystemException">找不到或無法修改檔案。</exception>
        <exception cref="T:System.UnauthorizedAccessException">目前的處理序不具有開啟檔案的存取權。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">資料流的新長度。</param>
        <summary>設定這個資料流長度為指定的數值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.SetLength%2A>。  
  
 如果指定的值小於目前資料流的長度，則會截斷資料流。 在此案例中，如果目前的位置是新的長度大於目前的位置會移至最後一個資料流的位元組。 如果目前資料流的長度大於指定的值，擴充的資料流，及目前的位置維持不變。 如果展開資料流時，舊之間的新長度的資料流的內容會是未定義。  
  
 資料流必須支援寫入和搜尋的`SetLength`運作。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入，而<xref:System.IO.FileStream.CanSeek%2A>屬性來判斷是否支援搜尋。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanWrite%2A> 和 <xref:System.IO.Stream.CanSeek%2A>。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援寫入和搜尋。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">嘗試將 <paramref name="value" /> 參數設定為小於 0。</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">解除鎖定範圍的開頭。</param>
        <param name="length">要解除鎖定的範圍。</param>
        <summary>允許其他處理程序存取先前鎖定之檔案的全部或一部分。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列程式碼範例示範如何鎖定檔案的一部分，因此另一個處理序無法存取該檔案的一部分，即使檔案有讀取/寫入存取，然後解除鎖定檔案的指定的部分。 在不同的命令視窗中同時執行的程式，並調查使用不同的主控台輸入的選項。  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> 或 <paramref name="length" /> 為負。</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">包含要寫入資料流之資料的緩衝區。</param>
        <param name="offset">「陣列」<c></c>中以零為起始的位元組位移，即要開始將位元組複製到資料流的來源位置。</param>
        <param name="count">寫入的最大位元組數。</param>
        <summary>將位元組區塊寫入檔案資料流中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.Write%2A>。  
  
 `offset`參數會提供中的位元組位移`array`（緩衝區索引） 中要開始複製，而`count`參數指定將寫入資料流的位元組數目。 如果作業成功時，寫入的位元組數目進階資料流的目前位置。 如果發生例外狀況，目前資料流的位置不變。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanWrite%2A>。  
  
 不會中斷正在執行寫入作業的執行緒。 雖然應用程式或許可以順利執行之後，執行緒會封鎖，您的應用程式效能和可靠性，就可能會降低發生中斷。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 這個程式碼範例是針對所提供之較大範例的一部分<xref:System.IO.FileStream.Lock%2A>方法。  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 和 <paramref name="count" /> 描述 <paramref name="array" /> 中的無效範圍。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 為負。</exception>
        <exception cref="T:System.IO.IOException">發生 I/O 錯誤。  
  
 \-或-  
  
 另一個執行緒可能會在作業系統之檔案控制代碼的位置，造成未預期的變更。</exception>
        <exception cref="T:System.ObjectDisposedException">資料流已關閉。</exception>
        <exception cref="T:System.NotSupportedException">目前的資料流執行個體不支援寫入。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">寫入資料的來源緩衝區。</param>
        <param name="offset">「緩衝區」<c></c>中以零為起始的位元組位移，即要開始將位元組複製到資料流的來源位置。</param>
        <param name="count">寫入的最大位元組數。</param>
        <param name="cancellationToken">用來監視是否有取消要求的語彙基元。</param>
        <summary>以非同步的方式將一連串的位元組寫入目前的資料流，由這個資料流中目前的位置前移寫入的位元組數目，並且監視取消要求。</summary>
        <returns>表示非同步寫入作業的工作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream.WriteAsync%2A>方法可讓您執行需要大量資源的檔案作業，而不會封鎖主執行緒。 這項效能考量對於 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 應用程式而言特別重要，尤其是針對耗時的資料流作業可能會阻礙 UI 執行緒，使應用程式看起來像是停止運作的情況。 非同步方法會用於搭配`async`和`await`Visual Basic 和 C# 中的關鍵字。  
  
 使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援讀取。  
  
 如果在作業完成之前將其取消，則傳回的工作包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。 如果已處置的檔案控制代碼，則傳回的工作包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。  
  
   
  
## Examples  
 下列範例會示範如何以非同步方式寫入檔案。  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> 或 <paramref name="count" /> 為負。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> 和 <paramref name="count" /> 的總和大於緩衝區長度。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援寫入。</exception>
        <exception cref="T:System.ObjectDisposedException">已處置此資料流。</exception>
        <exception cref="T:System.InvalidOperationException">之前的寫入作業目前正在使用資料流。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要寫入資料流的位元組。</param>
        <summary>寫入一個位元組到檔案資料流中的目前位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法覆寫 <xref:System.IO.Stream.WriteByte%2A>。  
  
 使用`WriteByte`寫入一個位元組至`FileStream`有效率。 如果資料流已關閉或沒有可寫入，就會擲回例外狀況。  
  
> [!NOTE]
>  使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入。 如需詳細資訊，請參閱 <xref:System.IO.Stream.CanWrite%2A>。  
  
   
  
## Examples  
 下列程式碼範例示範如何寫入資料到檔案時，位元組，並確認資料已正確寫入。  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">資料流已關閉。</exception>
        <exception cref="T:System.NotSupportedException">資料流不支援寫入。</exception>
        <block subset="none" type="overrides">
          <para>上的預設實作<see langword="Stream" />建立新的單一位元組陣列，然後呼叫<see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />。 雖然這是正式正確，就沒有效率。 任何內部緩衝區的資料流應該覆寫這個方法，並提供更有效率的版本會直接讀取緩衝區，避免在每次呼叫配置額外的陣列。  
  
 如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>