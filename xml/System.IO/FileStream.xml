<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9f964f0f32602678adcd930dd6bbbd74bdd8e487" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37652863" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="02ff0-101">為檔案提供 <see cref="T:System.IO.Stream" />，同時支援同步與非同步讀取和寫入作業。</span>
      <span class="sxs-lookup">
        <span data-stu-id="02ff0-101">Provides a <see cref="T:System.IO.Stream" /> for a file, supporting both synchronous and asynchronous read and write operations.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-102">使用<xref:System.IO.FileStream>類別來讀取、 寫入來開啟和關閉檔案，在檔案系統上，以及操作包括管道、 標準的輸入和標準輸出其他檔案相關的作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-102">Use the <xref:System.IO.FileStream> class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output.</span></span> <span data-ttu-id="02ff0-103">您可以使用<xref:System.IO.FileStream.Read%2A>， <xref:System.IO.FileStream.Write%2A>， <xref:System.IO.Stream.CopyTo%2A>，和<xref:System.IO.FileStream.Flush%2A>方法來執行同步作業，或<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>執行非同步方法作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-103">You can use the <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations.</span></span> <span data-ttu-id="02ff0-104">使用非同步的方法來執行需要大量資源的檔案作業，而不會封鎖主執行緒。</span><span class="sxs-lookup"><span data-stu-id="02ff0-104">Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread.</span></span> <span data-ttu-id="02ff0-105">這項效能考量對於 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 應用程式而言特別重要，尤其是針對耗時的資料流作業可能會阻礙 UI 執行緒，使應用程式看起來像是停止運作的情況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-105">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="02ff0-106"><xref:System.IO.FileStream> 輸入緩衝區和輸出更好的效能。</span><span class="sxs-lookup"><span data-stu-id="02ff0-106"><xref:System.IO.FileStream> buffers input and output for better performance.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="02ff0-107">此類型會實作<xref:System.IDisposable>介面。</span><span class="sxs-lookup"><span data-stu-id="02ff0-107">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="02ff0-108">當您完成使用型別時，您應該處置它直接或間接。</span><span class="sxs-lookup"><span data-stu-id="02ff0-108">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="02ff0-109">若要直接處置型別，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="02ff0-109">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="02ff0-110">若要處置它間接，使用的語言建構這類`using`（在 C# 中) 或`Using`（在 Visual Basic)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-110">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="02ff0-111">如需詳細資訊，請參閱 「 使用物件，實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。</span><span class="sxs-lookup"><span data-stu-id="02ff0-111">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="02ff0-112"><xref:System.IO.FileStream.IsAsync%2A>屬性可讓您偵測是否以非同步方式開啟檔案控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-112">The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously.</span></span> <span data-ttu-id="02ff0-113">當您建立的執行個體時，指定這個值<xref:System.IO.FileStream>類別的建構函式`isAsync`， `useAsync`，或`options`參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-113">You specify this value when you create an instance of the <xref:System.IO.FileStream> class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter.</span></span> <span data-ttu-id="02ff0-114">若屬性是`true`，資料流使用重疊的 I/O，以非同步方式執行檔案作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-114">When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously.</span></span> <span data-ttu-id="02ff0-115">不過，<xref:System.IO.FileStream.IsAsync%2A>屬性不一定要`true`來呼叫<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-115">However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method.</span></span> <span data-ttu-id="02ff0-116">當<xref:System.IO.FileStream.IsAsync%2A>屬性是`false`和您呼叫的非同步讀取和寫入作業，仍不封鎖 UI 執行緒，但實際的 I/O 作業以同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="02ff0-116">When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</span></span>  
  
 <span data-ttu-id="02ff0-117"><xref:System.IO.FileStream.Seek%2A>方法支援隨機存取檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-117">The <xref:System.IO.FileStream.Seek%2A> method supports random access to files.</span></span> <span data-ttu-id="02ff0-118"><xref:System.IO.FileStream.Seek%2A> 允許的讀取/寫入位置移到檔案中的任何位置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-118"><xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file.</span></span> <span data-ttu-id="02ff0-119">這是與位元組位移的參考點參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-119">This is done with byte offset reference point parameters.</span></span> <span data-ttu-id="02ff0-120">是相對於搜尋參考點，可以是開頭、 目前的位置或基礎檔案中，結尾的三個成員所表示的位元組位移<xref:System.IO.SeekOrigin>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="02ff0-120">The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-121">磁碟檔案一律會支援隨機存取。</span><span class="sxs-lookup"><span data-stu-id="02ff0-121">Disk files always support random access.</span></span> <span data-ttu-id="02ff0-122">在建構時<xref:System.IO.FileStream.CanSeek%2A>屬性值設定為`true`或`false`取決於基礎檔案類型。如果基礎檔案類型是 FILE_TYPE_DISK，定義 winbase.h，於<xref:System.IO.FileStream.CanSeek%2A>屬性值是`true`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-122">At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`.</span></span> <span data-ttu-id="02ff0-123">否則，請<xref:System.IO.FileStream.CanSeek%2A>屬性值是`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-123">Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.</span></span>  
  
 <span data-ttu-id="02ff0-124">如果處理程序會終止並鎖定檔案的一部分，或關閉具有未完成的鎖定的檔案，則行為會是未定義。</span><span class="sxs-lookup"><span data-stu-id="02ff0-124">If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.</span></span>  
  
 <span data-ttu-id="02ff0-125">目錄作業和其他檔案作業，請參閱<xref:System.IO.File>， <xref:System.IO.Directory>，和<xref:System.IO.Path>類別。</span><span class="sxs-lookup"><span data-stu-id="02ff0-125">For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes.</span></span> <span data-ttu-id="02ff0-126"><xref:System.IO.File>類別是具有主要是針對建立的靜態方法的公用程式類別<xref:System.IO.FileStream>物件為基礎的檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="02ff0-126">The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of <xref:System.IO.FileStream> objects based on file paths.</span></span> <span data-ttu-id="02ff0-127"><xref:System.IO.MemoryStream>類別從位元組陣列建立的資料流，類似於<xref:System.IO.FileStream>類別。</span><span class="sxs-lookup"><span data-stu-id="02ff0-127">The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the <xref:System.IO.FileStream> class.</span></span>  
  
 <span data-ttu-id="02ff0-128">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-128">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
## <a name="detection-of-stream-position-changes"></a><span data-ttu-id="02ff0-129">偵測 Stream 位置變更</span><span class="sxs-lookup"><span data-stu-id="02ff0-129">Detection of Stream Position Changes</span></span>  
 <span data-ttu-id="02ff0-130">當<xref:System.IO.FileStream>物件沒有其控制代碼的獨佔的按住不放，另一個執行緒可以同時存取的檔案控制代碼及變更作業系統檔案控制代碼相關聯的檔案指標的位置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-130">When a <xref:System.IO.FileStream> object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle.</span></span> <span data-ttu-id="02ff0-131">在此情況下，快取的位置中<xref:System.IO.FileStream>物件和快取的緩衝區中的資料可能會外洩。</span><span class="sxs-lookup"><span data-stu-id="02ff0-131">In this case, the cached position in the <xref:System.IO.FileStream> object and the cached data in the buffer could be compromised.</span></span> <span data-ttu-id="02ff0-132"><xref:System.IO.FileStream>物件會定期執行檢查存取快取的緩衝區，以確保作業系統的控制代碼的位置與快取所使用的位置相同的方法上<xref:System.IO.FileStream>物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-132">The <xref:System.IO.FileStream> object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="02ff0-133">如果偵測到的呼叫中的控制代碼的位置中有未預期的變更<xref:System.IO.FileStream.Read%2A>方法中，.NET Framework 會捨棄緩衝區的內容，並再次從檔案讀取資料流。</span><span class="sxs-lookup"><span data-stu-id="02ff0-133">If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again.</span></span> <span data-ttu-id="02ff0-134">這可能會影響效能，取決於大小的檔案和任何其他處理程序可能會影響檔案資料流的位置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-134">This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.</span></span>  
  
 <span data-ttu-id="02ff0-135">如果偵測到的呼叫中的控制代碼的位置中有未預期的變更<xref:System.IO.FileStream.Write%2A>方法，將緩衝區的內容都會被捨棄和<xref:System.IO.IOException>擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-135">If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.</span></span>  
  
 <span data-ttu-id="02ff0-136">A<xref:System.IO.FileStream>物件並不會獨佔的按住不放上其控制代碼時任一<xref:System.IO.FileStream.SafeFileHandle%2A>公開控制代碼存取屬性或<xref:System.IO.FileStream>物件會得到<xref:System.IO.FileStream.SafeFileHandle%2A>其建構函式中的屬性。</span><span class="sxs-lookup"><span data-stu-id="02ff0-136">A <xref:System.IO.FileStream> object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the <xref:System.IO.FileStream> object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-137">下列範例示範一些<xref:System.IO.FileStream>建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-137">The following example demonstrates some of the <xref:System.IO.FileStream> constructors.</span></span>  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 <span data-ttu-id="02ff0-138">下列範例示範如何以非同步方式寫入檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-138">The following example shows how to write to a file asynchronously.</span></span> <span data-ttu-id="02ff0-139">在具有 TextBlock，名為 u 和 連接到名為 Button_Click Click 事件處理常式按鈕的 WPF 應用程式中，執行此程式碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-139">This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click.</span></span> <span data-ttu-id="02ff0-140">檔案路徑，就必須變更為比結束的電腦上的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-140">The file path needs to be changed to a file than exits on the computer.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-141">初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-141">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="02ff0-142">目前 <see langword="FileStream" /> 物件將會封裝的檔案之檔案控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-142">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-143">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-143">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-144">使用指定的讀取/寫入使用權限，來初始化指定檔案控制代碼的 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-144">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-145">當<xref:System.IO.Stream.Close%2A>是呼叫，控制代碼，也會關閉和檔案的控制代碼計數會遞減。</span><span class="sxs-lookup"><span data-stu-id="02ff0-145">When <xref:System.IO.Stream.Close%2A> is called, the handle is also closed and the file's handle count is decremented.</span></span>  
  
 <span data-ttu-id="02ff0-146">`FileStream` 假設它有控制代碼的專有控制權。</span><span class="sxs-lookup"><span data-stu-id="02ff0-146">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="02ff0-147">讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。</span><span class="sxs-lookup"><span data-stu-id="02ff0-147">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="02ff0-148">針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-148">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-149">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-149">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-150">`FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-150">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
 <span data-ttu-id="02ff0-151">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-151">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-152">
            <paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-152">
              <paramref name="access" /> is not a field of <see cref="T:System.IO.FileAccess" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-153">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-153">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-154">發生 I/O 錯誤，例如磁碟錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-154">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-155">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-155">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-156">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-156">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-157">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-157">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-158">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-158">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="02ff0-159">目前 <see langword="FileStream" /> 物件將會封裝的檔案之檔案控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-159">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-160">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-160">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-161">使用指定的讀取/寫入使用權限，來初始化指定檔案控制代碼的 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-161">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-162">當<xref:System.IO.Stream.Close%2A>是呼叫，控制代碼，也會關閉和檔案的控制代碼計數會遞減。</span><span class="sxs-lookup"><span data-stu-id="02ff0-162">When <xref:System.IO.Stream.Close%2A> is called, the handle is also closed and the file's handle count is decremented.</span></span>  
  
 <span data-ttu-id="02ff0-163">`FileStream` 假設它有控制代碼的專有控制權。</span><span class="sxs-lookup"><span data-stu-id="02ff0-163">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="02ff0-164">讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。</span><span class="sxs-lookup"><span data-stu-id="02ff0-164">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="02ff0-165">針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-165">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-166">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-166">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-167">`FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-167">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
 <span data-ttu-id="02ff0-168">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-168">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-169">
            <paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-169">
              <paramref name="access" /> is not a field of <see cref="T:System.IO.FileAccess" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-170">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-170">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-171">發生 I/O 錯誤，例如磁碟錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-171">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-172">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-172">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-173">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-173">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-174">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-174">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-175">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-175">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="02ff0-176">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-176">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="02ff0-177">常數，決定如何開啟或建立檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-177">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-178">使用指定的路徑和建立模式來初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-178">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path and creation mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-179">.NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。</span><span class="sxs-lookup"><span data-stu-id="02ff0-179">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="02ff0-180">`path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-180">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="02ff0-181">建構函式有讀取/寫入權限到檔案，並開啟共用讀取權限 (亦即，若要開啟檔案以供寫入這個或另一個處理序將失敗，直到要求`FileStream`物件已關閉，但嘗試讀取則會成功)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-181">The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).</span></span>  
  
 <span data-ttu-id="02ff0-182">您無法使用這個建構函式來開啟唯讀檔案;相反地，您必須使用建構函式接受`FileAccess`參數值設為`FileAccess.Read`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-182">You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.</span></span>  
  
 <span data-ttu-id="02ff0-183">緩衝區大小設定為 4096 個位元組 (4 KB) 的預設大小。</span><span class="sxs-lookup"><span data-stu-id="02ff0-183">The buffer size is set to the default size of 4096 bytes (4 KB).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-184">`path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。</span><span class="sxs-lookup"><span data-stu-id="02ff0-184">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="02ff0-185">例如，根據系統中，這個類別可以存取實體裝置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-185">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="02ff0-186"><xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-186"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="02ff0-187">如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-187">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="02ff0-188">如需詳細資訊，請參閱<xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-188">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-189">`FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-189">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
 <span data-ttu-id="02ff0-190">建構函式，而不需要<xref:System.IO.FileAccess>參數，如果`mode`參數設為<xref:System.IO.FileMode.Append>，<xref:System.IO.FileAccess.Write>是預設存取權。</span><span class="sxs-lookup"><span data-stu-id="02ff0-190">For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> is the default access.</span></span> <span data-ttu-id="02ff0-191">否則，將存取設為<xref:System.IO.FileAccess.ReadWrite>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-191">Otherwise, the access is set to <xref:System.IO.FileAccess.ReadWrite>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-192">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-192">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-193">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-193">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-194">下列程式碼範例示範如何將資料寫入至檔案時，位元組，並確認資料已正確地寫入。</span><span class="sxs-lookup"><span data-stu-id="02ff0-194">The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-195">
            <paramref name="path" /> 為空字串 ("")、只包含泛空白字元，或包含一個或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-195">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="02ff0-196">或 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-196">-or-  <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-197">
            <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-197">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-198">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-198">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-199">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-199">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="02ff0-200">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-200">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="02ff0-201">這些模式中必須有此檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-201">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-202">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-202">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-203">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-203">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="02ff0-204">指定的路徑無效，例如位在未對應的磁碟上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-204">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="02ff0-205">指定的路徑、檔案名稱或兩者都超過系統定義的最大長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-205">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-206">
            <paramref name="mode" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-206">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-207">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-207">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-208">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-208">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="02ff0-209">目前 <see langword="FileStream" /> 物件將會封裝的檔案之檔案控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-209">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-210">
            <see cref="T:System.IO.FileAccess" /> 常數，它會設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-210">A <see cref="T:System.IO.FileAccess" /> constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="02ff0-211">大於零的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-211">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="02ff0-212">預設緩衝區大小為 4096。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-212">The default buffer size is 4096.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-213">使用指定的讀取/寫入使用權限和緩衝區大小，初始化指定的檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-213">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, and buffer size.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-214">`FileStream` 假設它有控制代碼的專有控制權。</span><span class="sxs-lookup"><span data-stu-id="02ff0-214">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="02ff0-215">讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。</span><span class="sxs-lookup"><span data-stu-id="02ff0-215">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="02ff0-216">針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-216">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="02ff0-217">或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-217">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="02ff0-218">`FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-218">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-219">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-219">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-220">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-220">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-221">
            <paramref name="handle" /> 參數是無效的控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-221">The <paramref name="handle" /> parameter is an invalid handle.</span>
          </span>
          <span data-ttu-id="02ff0-222">或 <paramref name="handle" /> 參數是同步的控制代碼，且曾以非同步方式使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-222">-or-  The <paramref name="handle" /> parameter is a synchronous handle and it was used asynchronously.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-223">
            <paramref name="bufferSize" /> 參數為負數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-223">The <paramref name="bufferSize" /> parameter is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-224">發生 I/O 錯誤，例如磁碟錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-224">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-225">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-225">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-226">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-226">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-227">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-227">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-228">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-228">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-229">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-229">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="02ff0-230">呼叫 unmanaged 程式碼的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-230">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="02ff0-231">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-231">Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="02ff0-232">目前 <see langword="FileStream" /> 物件將會封裝的檔案之檔案控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-232">A file handle for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-233">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-233">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <param name="ownsHandle">
          <span data-ttu-id="02ff0-234">如果這個 <see langword="true" /> 執行個體將擁有檔案控制代碼，則為 <see langword="FileStream" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-234">
              <see langword="true" /> if the file handle will be owned by this <see langword="FileStream" /> instance; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-235">使用指定的讀取/寫入使用權限和 <see langword="FileStream" /> 執行個體擁有權，來初始化指定檔案控制代碼的 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-235">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission and <see langword="FileStream" /> instance ownership.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-236">`FileStream`物件給指定的存取權的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-236">The `FileStream` object is given the specified access to the file.</span></span> <span data-ttu-id="02ff0-237">將會擁有權的控制代碼所指定。</span><span class="sxs-lookup"><span data-stu-id="02ff0-237">The ownership of the handle will be as specified.</span></span> <span data-ttu-id="02ff0-238">如果此程序擁有的控制代碼，呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉控制代碼，而檔案的控制代碼計數會遞減。</span><span class="sxs-lookup"><span data-stu-id="02ff0-238">If this process owns the handle, a call to the <xref:System.IO.Stream.Close%2A> method will also close the handle and the file's handle count is decremented.</span></span> <span data-ttu-id="02ff0-239">`FileStream`物件會得到預設緩衝區大小為 4096 位元組。</span><span class="sxs-lookup"><span data-stu-id="02ff0-239">The `FileStream` object is given the default buffer size of 4096 bytes.</span></span>  
  
 <span data-ttu-id="02ff0-240">`FileStream` 假設它有控制代碼的專有控制權。</span><span class="sxs-lookup"><span data-stu-id="02ff0-240">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="02ff0-241">讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。</span><span class="sxs-lookup"><span data-stu-id="02ff0-241">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="02ff0-242">針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫的方法以外`Close`完成之後使用控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-242">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling methods other than `Close` after you are done using the handle.</span></span>  
  
 <span data-ttu-id="02ff0-243">`FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-243">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-244">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-244">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-245">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-245">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-246">
            <paramref name="access" /> 不是 <see cref="T:System.IO.FileAccess" /> 的欄位。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-246">
              <paramref name="access" /> is not a field of <see cref="T:System.IO.FileAccess" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-247">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-247">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-248">發生 I/O 錯誤，例如磁碟錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-248">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-249">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-249">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-250">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-250">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-251">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-251">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-252">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-252">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="02ff0-253">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-253">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="02ff0-254">常數，決定如何開啟或建立檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-254">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-255">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-255">A constant that determines how the file can be accessed by the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="02ff0-256">這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-256">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="02ff0-257">如果「路徑」<c></c>指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-257">
              <see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <c>path</c> specifies a disk file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-258">使用指定路徑、建立模式和讀取/寫入使用權限，來初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-258">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, and read/write permission.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-259">.NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。</span><span class="sxs-lookup"><span data-stu-id="02ff0-259">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="02ff0-260">`path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-260">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="02ff0-261">建構函式有讀取/寫入權限到檔案，並開啟共用讀取權限 (亦即，若要開啟檔案以供寫入這個或另一個處理序將失敗，直到要求`FileStream`物件已關閉，但嘗試讀取則會成功)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-261">The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).</span></span> <span data-ttu-id="02ff0-262">緩衝區大小設定為 4096 個位元組 (4 KB) 的預設大小。</span><span class="sxs-lookup"><span data-stu-id="02ff0-262">The buffer size is set to the default size of 4096 bytes (4 KB).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-263">`path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。</span><span class="sxs-lookup"><span data-stu-id="02ff0-263">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="02ff0-264">例如，根據系統中，這個類別可以存取實體裝置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-264">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="02ff0-265"><xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-265"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="02ff0-266">如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-266">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="02ff0-267">如需詳細資訊，請參閱<xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-267">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-268">`FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-268">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-269">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-269">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-270">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-270">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-271">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-271">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-272">
            <paramref name="path" /> 為空字串 ("")、只包含泛空白字元，或包含一個或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-272">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="02ff0-273">或 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-273">-or-  <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-274">
            <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-274">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="02ff0-275">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-275">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="02ff0-276">這些模式中必須有此檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-276">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-277">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-277">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-278">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-278">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-279">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-279">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="02ff0-280">指定的路徑無效，例如位在未對應的磁碟上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-280">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-281">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-281">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="02ff0-282">指定的路徑、檔案名稱或兩者都超過系統定義的最大長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-282">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-283">
            <paramref name="mode" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-283">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-284">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-284">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-285">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-285">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="02ff0-286">這個 <see langword="FileStream" /> 物件將會封裝的檔案之檔案控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-286">A file handle for the file that this <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-287">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-287">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="02ff0-288">大於零的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-288">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="02ff0-289">預設緩衝區大小為 4096。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-289">The default buffer size is 4096.</span>
          </span>
        </param>
        <param name="isAsync">
          <span data-ttu-id="02ff0-290">如果控制代碼為非同步開啟 (也就是，在重疊 I/O 模式)，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-290">
              <see langword="true" /> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-291">使用指定的讀取/寫入使用權限、緩衝區大小和同步或非同步狀態，初始化指定的檔案控制代碼之 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-291">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, buffer size, and synchronous or asynchronous state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-292">您設定`isAsync`參數來`true`以非同步方式開啟檔案控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-292">You set the `isAsync` parameter to `true` to open the file handle asynchronously.</span></span> <span data-ttu-id="02ff0-293">當參數是`true`，資料流使用重疊的 I/O，以非同步方式執行檔案作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-293">When the parameter is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously.</span></span> <span data-ttu-id="02ff0-294">不過，此參數不一定要`true`來呼叫<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-294">However, the parameter does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method.</span></span> <span data-ttu-id="02ff0-295">當`isAsync`參數是`false`和您呼叫的非同步讀取和寫入作業，仍不封鎖 UI 執行緒，但實際的 I/O 作業以同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="02ff0-295">When the `isAsync` parameter is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</span></span>  
  
 <span data-ttu-id="02ff0-296">`FileStream` 假設它有控制代碼的專有控制權。</span><span class="sxs-lookup"><span data-stu-id="02ff0-296">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="02ff0-297">讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。</span><span class="sxs-lookup"><span data-stu-id="02ff0-297">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="02ff0-298">針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-298">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="02ff0-299">或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-299">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="02ff0-300">`FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-300">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-301">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-301">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-302">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-302">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-303">
            <paramref name="handle" /> 參數是無效的控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-303">The <paramref name="handle" /> parameter is an invalid handle.</span>
          </span>
          <span data-ttu-id="02ff0-304">或 <paramref name="handle" /> 參數是同步的控制代碼，且曾以非同步方式使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-304">-or-  The <paramref name="handle" /> parameter is a synchronous handle and it was used asynchronously.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-305">
            <paramref name="bufferSize" /> 參數為負數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-305">The <paramref name="bufferSize" /> parameter is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-306">發生 I/O 錯誤，例如磁碟錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-306">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-307">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-307">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-308">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-308">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-309">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-309">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-310">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-310">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-311">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-311">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="02ff0-312">呼叫 unmanaged 程式碼的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-312">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="02ff0-313">相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-313">Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="02ff0-314">這個 <see langword="FileStream" /> 物件將會封裝的檔案之檔案控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-314">A file handle for the file that this <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-315">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-315">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <param name="ownsHandle">
          <span data-ttu-id="02ff0-316">如果這個 <see langword="true" /> 執行個體將擁有檔案控制代碼，則為 <see langword="FileStream" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-316">
              <see langword="true" /> if the file handle will be owned by this <see langword="FileStream" /> instance; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="02ff0-317">大於零的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-317">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="02ff0-318">預設緩衝區大小為 4096。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-318">The default buffer size is 4096.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-319">使用指定的讀取/寫入使用權限、<see langword="FileStream" /> 執行個體擁有權和緩衝區大小，來初始化指定檔案控制代碼的 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-319">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, <see langword="FileStream" /> instance ownership, and buffer size.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-320">`FileStream`物件給指定的存取權的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-320">The `FileStream` object is given the specified access to the file.</span></span> <span data-ttu-id="02ff0-321">將會擁有權的控制代碼所指定。</span><span class="sxs-lookup"><span data-stu-id="02ff0-321">The ownership of the handle will be as specified.</span></span> <span data-ttu-id="02ff0-322">如果這個`FileStream`擁有的控制代碼呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-322">If this `FileStream` owns the handle, a call to the <xref:System.IO.Stream.Close%2A> method will also close the handle.</span></span> <span data-ttu-id="02ff0-323">特別是，檔案的控制碼計數會遞減。</span><span class="sxs-lookup"><span data-stu-id="02ff0-323">In particular, the file's handle count is decremented.</span></span> <span data-ttu-id="02ff0-324">`FileStream`物件有指定的緩衝區大小。</span><span class="sxs-lookup"><span data-stu-id="02ff0-324">The `FileStream` object is given the specified buffer size.</span></span>  
  
 <span data-ttu-id="02ff0-325">`FileStream` 假設它有控制代碼的專有控制權。</span><span class="sxs-lookup"><span data-stu-id="02ff0-325">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="02ff0-326">讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。</span><span class="sxs-lookup"><span data-stu-id="02ff0-326">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="02ff0-327">針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-327">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="02ff0-328">或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-328">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="02ff0-329">`FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-329">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-330">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-330">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-331">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-331">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-332">
            <paramref name="bufferSize" /> 為負值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-332">
              <paramref name="bufferSize" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-333">發生 I/O 錯誤，例如磁碟錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-333">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-334">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-334">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-335">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-335">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-336">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-336">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-337">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-337">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-338">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-338">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="02ff0-339">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-339">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="02ff0-340">常數，決定如何開啟或建立檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-340">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-341">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-341">A constant that determines how the file can be accessed by the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="02ff0-342">這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-342">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="02ff0-343">如果「路徑」<c></c>指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-343">
              <see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <c>path</c> specifies a disk file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="02ff0-344">常數，決定處理序如何共用檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-344">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-345">使用指定路徑、建立模式、讀取/寫入使用權限和共用使用權限，來初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-345">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write permission, and sharing permission.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-346">.NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。</span><span class="sxs-lookup"><span data-stu-id="02ff0-346">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="02ff0-347">`path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-347">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="02ff0-348">建構函式有讀取/寫入權限到檔案，並開啟共用讀取權限 (亦即，若要開啟檔案以供寫入這個或另一個處理序將失敗，直到要求`FileStream`物件已關閉，但嘗試讀取則會成功)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-348">The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).</span></span> <span data-ttu-id="02ff0-349">緩衝區大小設定為 4096 個位元組 (4 KB) 的預設大小。</span><span class="sxs-lookup"><span data-stu-id="02ff0-349">The buffer size is set to the default size of 4096 bytes (4 KB).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-350">`path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。</span><span class="sxs-lookup"><span data-stu-id="02ff0-350">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="02ff0-351">例如，根據系統中，這個類別可以存取實體裝置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-351">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="02ff0-352"><xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-352"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="02ff0-353">如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-353">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="02ff0-354">如需詳細資訊，請參閱<xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-354">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-355">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-355">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-356">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-356">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-357">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.Lock%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-357">This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-358">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-358">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-359">
            <paramref name="path" /> 為空字串 ("")、只包含泛空白字元，或包含一個或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-359">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="02ff0-360">或 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-360">-or-  <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-361">
            <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-361">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="02ff0-362">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-362">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="02ff0-363">這些模式中必須有此檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-363">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-364">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-364">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-365">或系統正在執行 Windows 98 或 Windows 98 Second Edition，而 <paramref name="share" /> 設定為 <see langword="FileShare.Delete" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-365">-or-  The system is running Windows 98 or Windows 98 Second Edition and <paramref name="share" /> is set to <see langword="FileShare.Delete" />.</span>
          </span>
          <span data-ttu-id="02ff0-366">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-366">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-367">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-367">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="02ff0-368">指定的路徑無效，例如位在未對應的磁碟上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-368">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-369">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-369">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="02ff0-370">指定的路徑、檔案名稱或兩者都超過系統定義的最大長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-370">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-371">
            <paramref name="mode" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-371">
              <paramref name="mode" /> contains an invalid value.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-372">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-372">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-373">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-373">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="02ff0-374">這個 <see langword="FileStream" /> 物件將會封裝的檔案之檔案控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-374">A file handle for the file that this <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-375">常數，設定 <see langword="FileStream" /> 物件的 <see cref="P:System.IO.FileStream.CanRead" /> 和 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-375">A constant that sets the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
        </param>
        <param name="ownsHandle">
          <span data-ttu-id="02ff0-376">如果這個 <see langword="true" /> 執行個體將擁有檔案控制代碼，則為 <see langword="FileStream" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-376">
              <see langword="true" /> if the file handle will be owned by this <see langword="FileStream" /> instance; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="02ff0-377">大於零的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-377">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="02ff0-378">預設緩衝區大小為 4096。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-378">The default buffer size is 4096.</span>
          </span>
        </param>
        <param name="isAsync">
          <span data-ttu-id="02ff0-379">如果控制代碼為非同步開啟 (也就是，在重疊 I/O 模式)，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-379">
              <see langword="true" /> if the handle was opened asynchronously (that is, in overlapped I/O mode); otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-380">使用指定的讀取/寫入使用權限、<see langword="FileStream" /> 執行個體擁有權、緩衝區大小和同步或非同步狀態，來初始化指定檔案控制代碼的 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-380">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class for the specified file handle, with the specified read/write permission, <see langword="FileStream" /> instance ownership, buffer size, and synchronous or asynchronous state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-381">`FileStream`物件給指定的存取權的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-381">The `FileStream` object is given the specified access to the file.</span></span> <span data-ttu-id="02ff0-382">將會擁有權的控制代碼所指定。</span><span class="sxs-lookup"><span data-stu-id="02ff0-382">The ownership of the handle will be as specified.</span></span> <span data-ttu-id="02ff0-383">如果這個`FileStream`擁有的控制代碼呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-383">If this `FileStream` owns the handle, a call to the <xref:System.IO.Stream.Close%2A> method will also close the handle.</span></span> <span data-ttu-id="02ff0-384">特別是，檔案的控制碼計數會遞減。</span><span class="sxs-lookup"><span data-stu-id="02ff0-384">In particular, the file's handle count is decremented.</span></span> <span data-ttu-id="02ff0-385">`FileStream`物件有指定的緩衝區大小。</span><span class="sxs-lookup"><span data-stu-id="02ff0-385">The `FileStream` object is given the specified buffer size.</span></span>  
  
 <span data-ttu-id="02ff0-386">`FileStream` 假設它有控制代碼的專有控制權。</span><span class="sxs-lookup"><span data-stu-id="02ff0-386">`FileStream` assumes that it has exclusive control over the handle.</span></span> <span data-ttu-id="02ff0-387">讀取、 寫入，或同時搜尋`FileStream`也持有控制代碼可能會導致資料損毀。</span><span class="sxs-lookup"><span data-stu-id="02ff0-387">Reading, writing, or seeking while a `FileStream` is also holding a handle could result in data corruption.</span></span> <span data-ttu-id="02ff0-388">針對資料安全，呼叫<xref:System.IO.FileStream.Flush%2A>之前使用控制代碼，並避免呼叫任何方法以外`Close`完成之後使用控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-388">For data safety, call <xref:System.IO.FileStream.Flush%2A> before using the handle, and avoid calling any methods other than `Close` after you are done using the handle.</span></span> <span data-ttu-id="02ff0-389">或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-389">Alternately, read and write to the handle before calling this `FileStream` constructor.</span></span>  
  
 <span data-ttu-id="02ff0-390">`FileShare.Read` 這些是預設值<xref:System.IO.FileStream>建構函式，而不需要`FileShare`參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-390">`FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-391">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-391">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-392">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-392">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-393">
            <paramref name="access" /> 小於 <see langword="FileAccess.Read" /> 或大於 <see langword="FileAccess.ReadWrite" /> 或者 <paramref name="bufferSize" /> 小於或等於 0。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-393">
              <paramref name="access" /> is less than <see langword="FileAccess.Read" /> or greater than <see langword="FileAccess.ReadWrite" /> or <paramref name="bufferSize" /> is less than or equal to 0.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-394">控制代碼無效。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-394">The handle is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-395">發生 I/O 錯誤，例如磁碟錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-395">An I/O error, such as a disk error, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-396">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-396">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-397">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-397">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-398">指定之檔案控制代碼的作業系統不允許所要求的 <paramref name="access" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，而檔案控制代碼設定成唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-398">The <paramref name="access" /> requested is not permitted by the operating system for the specified file handle, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file handle is set for read-only access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="02ff0-399">用於存取 unmanaged 程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-399">for access to unmanaged code.</span>
          </span>
          <span data-ttu-id="02ff0-400">關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-400">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="02ff0-401">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-401">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="02ff0-402">常數，決定如何開啟或建立檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-402">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-403">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-403">A constant that determines how the file can be accessed by the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="02ff0-404">這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-404">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="02ff0-405">如果「路徑」<c></c>指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-405">
              <see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <c>path</c> specifies a disk file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="02ff0-406">常數，決定處理序如何共用檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-406">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="02ff0-407">大於零的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-407">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="02ff0-408">預設緩衝區大小為 4096。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-408">The default buffer size is 4096.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-409">使用指定路徑、建立模式、讀取/寫入與共用使用權限、緩衝區大小，來初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-409">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, and buffer size.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-410">.NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。</span><span class="sxs-lookup"><span data-stu-id="02ff0-410">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="02ff0-411">`path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-411">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-412">`path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。</span><span class="sxs-lookup"><span data-stu-id="02ff0-412">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="02ff0-413">例如，根據系統中，這個類別可以存取實體裝置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-413">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="02ff0-414"><xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-414"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="02ff0-415">如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-415">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="02ff0-416">如需詳細資訊，請參閱<xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-416">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-417">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-417">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-418">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-418">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-419">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-419">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-420">
            <paramref name="path" /> 為空字串 ("")、只包含泛空白字元，或包含一個或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-420">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="02ff0-421">或 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-421">-or-  <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-422">
            <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-422">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-423">
            <paramref name="bufferSize" /> 為負值或零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-423">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="02ff0-424">或 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-424">-or-  <paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="02ff0-425">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-425">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="02ff0-426">這些模式中必須有此檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-426">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-427">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-427">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-428">或系統正在執行 Windows 98 或 Windows 98 Second Edition，而 <paramref name="share" /> 設定為 <see langword="FileShare.Delete" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-428">-or-  The system is running Windows 98 or Windows 98 Second Edition and <paramref name="share" /> is set to <see langword="FileShare.Delete" />.</span>
          </span>
          <span data-ttu-id="02ff0-429">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-429">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-430">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-430">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="02ff0-431">指定的路徑無效，例如位在未對應的磁碟上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-431">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-432">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-432">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="02ff0-433">指定的路徑、檔案名稱或兩者都超過系統定義的最大長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-433">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-434">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-434">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-435">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-435">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="02ff0-436">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-436">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="02ff0-437">常數，決定如何開啟或建立檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-437">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-438">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-438">A constant that determines how the file can be accessed by the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="02ff0-439">這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-439">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="02ff0-440">如果「路徑」<c></c>指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-440">
              <see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <c>path</c> specifies a disk file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="02ff0-441">常數，決定處理序如何共用檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-441">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="02ff0-442">大於零的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-442">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="02ff0-443">預設緩衝區大小為 4096。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-443">The default buffer size is 4096..</span>
          </span>
        </param>
        <param name="useAsync">
          <span data-ttu-id="02ff0-444">指定要使用非同步 I/O 或同步 I/O。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-444">Specifies whether to use asynchronous I/O or synchronous I/O.</span>
          </span>
          <span data-ttu-id="02ff0-445">但是，請注意：基礎作業系統可能並不支援非同步 I/O，所以在指定 <see langword="true" /> 時，可能會視平台以同步方式開啟控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-445">However, note that the underlying operating system might not support asynchronous I/O, so when specifying <see langword="true" />, the handle might be opened synchronously depending on the platform.</span>
          </span>
          <span data-ttu-id="02ff0-446">在以非同步方式開啟時，<see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 與 <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 方法對大量讀取或寫入的作業會有較佳的效能，但對於少量讀取和寫入的作業卻會比較慢。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-446">When opened asynchronously, the <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> and <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> methods perform better on large reads or writes, but they might be much slower for small reads or writes.</span>
          </span>
          <span data-ttu-id="02ff0-447">如果要將應用程式設計成使用非同步 I/O，請將 <c>useAsync</c> 參數設定為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-447">If the application is designed to take advantage of asynchronous I/O, set the <c>useAsync</c> parameter to <see langword="true" />.</span>
          </span>
          <span data-ttu-id="02ff0-448">正確地使用非同步 I/O，可以讓應用程式的執行快上十倍，但如果沒有配合非同步 I/O 的需求重新設計應用程式，卻會降低十倍的效能。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-448">Using asynchronous I/O correctly can speed up applications by as much as a factor of 10, but using it without redesigning the application for asynchronous I/O can decrease performance by as much as a factor of 10.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-449">使用指定路徑、建立模式、讀取/寫入與共用使用權限、緩衝大小、同步或非同步狀態，來初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-449">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, buffer size, and synchronous or asynchronous state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-450">.NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。</span><span class="sxs-lookup"><span data-stu-id="02ff0-450">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="02ff0-451">`path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-451">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-452">`path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。</span><span class="sxs-lookup"><span data-stu-id="02ff0-452">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="02ff0-453">例如，根據系統中，這個類別可以存取實體裝置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-453">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="02ff0-454"><xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-454"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="02ff0-455">如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-455">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="02ff0-456">如需詳細資訊，請參閱<xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-456">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-457">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-457">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-458">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-458">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-459">下列程式碼範例示範如何以非同步方式將資料寫入檔案，然後確認資料已正確地寫入。</span><span class="sxs-lookup"><span data-stu-id="02ff0-459">The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly.</span></span> <span data-ttu-id="02ff0-460">A`State`會建立物件來將資訊從主執行緒傳遞`EndReadCallback`和`EndWriteCallback`方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-460">A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-461">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-461">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-462">
            <paramref name="path" /> 為空字串 ("")、只包含泛空白字元，或包含一個或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-462">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="02ff0-463">或 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-463">-or-  <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-464">
            <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-464">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-465">
            <paramref name="bufferSize" /> 為負值或零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-465">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="02ff0-466">或 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-466">-or-  <paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="02ff0-467">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-467">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="02ff0-468">這些模式中必須有此檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-468">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-469">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-469">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-470">或系統正在執行 Windows 98 或 Windows 98 Second Edition，而 <paramref name="share" /> 設定為 <see langword="FileShare.Delete" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-470">-or-  The system is running Windows 98 or Windows 98 Second Edition and <paramref name="share" /> is set to <see langword="FileShare.Delete" />.</span>
          </span>
          <span data-ttu-id="02ff0-471">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-471">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-472">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-472">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="02ff0-473">指定的路徑無效，例如位在未對應的磁碟上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-473">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-474">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-474">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="02ff0-475">指定的路徑、檔案名稱或兩者都超過系統定義的最大長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-475">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-476">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-476">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-477">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-477">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.IO.File" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="02ff0-478">目前 <see langword="FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-478">A relative or absolute path for the file that the current <see langword="FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="02ff0-479">常數，決定如何開啟或建立檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-479">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="access">
          <span data-ttu-id="02ff0-480">常數，決定 <see langword="FileStream" /> 物件如何存取檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-480">A constant that determines how the file can be accessed by the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="02ff0-481">這也可以判斷 <see langword="FileStream" /> 物件之 <see cref="P:System.IO.FileStream.CanRead" /> 與 <see cref="P:System.IO.FileStream.CanWrite" /> 屬性傳回的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-481">This also determines the values returned by the <see cref="P:System.IO.FileStream.CanRead" /> and <see cref="P:System.IO.FileStream.CanWrite" /> properties of the <see langword="FileStream" /> object.</span>
          </span>
          <span data-ttu-id="02ff0-482">如果「路徑」<c></c>指定了磁碟檔案，則 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="true" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-482">
              <see cref="P:System.IO.FileStream.CanSeek" /> is <see langword="true" /> if <c>path</c> specifies a disk file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="02ff0-483">常數，決定處理序如何共用檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-483">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="02ff0-484">大於零的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-484">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="02ff0-485">預設緩衝區大小為 4096。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-485">The default buffer size is 4096.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="02ff0-486">值，指定其他檔案選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-486">A value that specifies additional file options.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-487">使用指定的路徑、建立模式、讀取/寫入與共用使用權限、其他 FileStream 可對同一檔案進行存取的存取權、緩衝區大小和其他檔案選項，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-487">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, read/write and sharing permission, the access other FileStreams can have to the same file, the buffer size, and additional file options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-488">.NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。</span><span class="sxs-lookup"><span data-stu-id="02ff0-488">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="02ff0-489">`fileOptions`參數用來提供更進階的作業建立時可運用的存取權<xref:System.IO.FileStream>物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-489">The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="02ff0-490">`path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-490">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-491">`path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。</span><span class="sxs-lookup"><span data-stu-id="02ff0-491">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="02ff0-492">例如，根據系統中，這個類別可以存取實體裝置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-492">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="02ff0-493"><xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-493"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="02ff0-494">如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-494">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="02ff0-495">如需詳細資訊，請參閱<xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-495">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-496">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-496">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-497">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-497">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-498">下列範例會將資料寫入至檔案，並接著會讀取資料使用<xref:System.IO.FileStream>物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-498">The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.</span></span>  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-499">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-499">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-500">
            <paramref name="path" /> 為空字串 ("")、只包含泛空白字元，或包含一個或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-500">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="02ff0-501">或 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-501">-or-  <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-502">
            <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-502">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-503">
            <paramref name="bufferSize" /> 為負值或零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-503">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="02ff0-504">或 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-504">-or-  <paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="02ff0-505">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-505">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="02ff0-506">這些模式中必須有此檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-506">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-507">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-507">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-508">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-508">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-509">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-509">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="02ff0-510">指定的路徑無效，例如位在未對應的磁碟上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-510">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-511">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-511">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
          <span data-ttu-id="02ff0-512">或針對 <paramref name="options" /> 指定了 <see cref="F:System.IO.FileOptions.Encrypted" />，但目前平台不支援檔案加密。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-512">-or-  <see cref="F:System.IO.FileOptions.Encrypted" /> is specified for <paramref name="options" />, but file encryption is not supported on the current platform.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="02ff0-513">指定的路徑、檔案名稱或兩者都超過系統定義的最大長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-513">The specified path, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-514">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-514">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-515">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-515">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="02ff0-516">目前 <see cref="T:System.IO.FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-516">A relative or absolute path for the file that the current <see cref="T:System.IO.FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="02ff0-517">常數，決定如何開啟或建立檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-517">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="02ff0-518">常數，決定建立檔案的存取和稽核規則時要使用的存取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-518">A constant that determines the access rights to use when creating access and audit rules for the file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="02ff0-519">常數，決定處理序如何共用檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-519">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="02ff0-520">大於零的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-520">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="02ff0-521">預設緩衝區大小為 4096。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-521">The default buffer size is 4096.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="02ff0-522">常數，指定其他檔案選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-522">A constant that specifies additional file options.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-523">使用指定的路徑、建立模式、存取權限與共用使用權限、緩衝區大小和其他檔案選項，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-523">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, access rights and sharing permission, the buffer size, and additional file options.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-524">.NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。</span><span class="sxs-lookup"><span data-stu-id="02ff0-524">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="02ff0-525">使用此<xref:System.IO.FileStream.%23ctor%2A>建構函式來套用存取權限時建立檔案的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-525">Use this <xref:System.IO.FileStream.%23ctor%2A> constructor to apply access rights at the point of creation of a file.</span></span> <span data-ttu-id="02ff0-526">若要存取或修改現有的檔案上的權限，請考慮使用<xref:System.IO.File.GetAccessControl%2A>和<xref:System.IO.File.SetAccessControl%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-526">To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="02ff0-527">`fileOptions`參數用來提供更進階的作業建立時可運用的存取權<xref:System.IO.FileStream>物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-527">The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="02ff0-528">`path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-528">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-529">`path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。</span><span class="sxs-lookup"><span data-stu-id="02ff0-529">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="02ff0-530">例如，根據系統中，這個類別可以存取實體裝置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-530">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="02ff0-531"><xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-531"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="02ff0-532">如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-532">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="02ff0-533">如需詳細資訊，請參閱<xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-533">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-534">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-534">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-535">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-535">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-536">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-536">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-537">
            <paramref name="path" /> 為空字串 ("")、只包含泛空白字元，或包含一個或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-537">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="02ff0-538">或 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-538">-or-  <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-539">
            <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-539">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-540">
            <paramref name="bufferSize" /> 為負值或零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-540">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="02ff0-541">或 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-541">-or-  <paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="02ff0-542">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-542">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="02ff0-543">檔案必須已在這些模式中存在。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-543">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="02ff0-544">目前的作業系統不是 Windows NT (含) 以後版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-544">The current operating system is not Windows NT or later.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-545">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-545">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-546">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-546">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-547">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-547">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="02ff0-548">指定的路徑無效，例如位在未對應的磁碟上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-548">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-549">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-549">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
          <span data-ttu-id="02ff0-550">或針對 <paramref name="options" /> 指定了 <see cref="F:System.IO.FileOptions.Encrypted" />，但目前平台不支援檔案加密。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-550">-or-  <see cref="F:System.IO.FileOptions.Encrypted" /> is specified for <paramref name="options" />, but file encryption is not supported on the current platform.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="02ff0-551">指定的 <paramref name="path" />、檔案名稱或兩者都超過系統定義的最大長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-551">The specified <paramref name="path" />, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-552">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-552">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-553">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-553">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">
          <span data-ttu-id="02ff0-554">目前 <see cref="T:System.IO.FileStream" /> 物件將會封裝之檔案的相對或絕對路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-554">A relative or absolute path for the file that the current <see cref="T:System.IO.FileStream" /> object will encapsulate.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="02ff0-555">常數，決定如何開啟或建立檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-555">A constant that determines how to open or create the file.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="02ff0-556">常數，決定建立檔案的存取和稽核規則時要使用的存取權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-556">A constant that determines the access rights to use when creating access and audit rules for the file.</span>
          </span>
        </param>
        <param name="share">
          <span data-ttu-id="02ff0-557">常數，決定處理序如何共用檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-557">A constant that determines how the file will be shared by processes.</span>
          </span>
        </param>
        <param name="bufferSize">
          <span data-ttu-id="02ff0-558">大於零的 <see cref="T:System.Int32" /> 正值，指出緩衝區大小。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-558">A positive <see cref="T:System.Int32" /> value greater than 0 indicating the buffer size.</span>
          </span>
          <span data-ttu-id="02ff0-559">預設緩衝區大小為 4096。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-559">The default buffer size is 4096.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="02ff0-560">常數，指定其他檔案選項。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-560">A constant that specifies additional file options.</span>
          </span>
        </param>
        <param name="fileSecurity">
          <span data-ttu-id="02ff0-561">常數，決定檔案的存取控制和稽核安全性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-561">A constant that determines the access control and audit security for the file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-562">使用指定的路徑、建立模式、讀存取權限與共用使用權限、緩衝區大小、其他檔案選項、存取控制和稽核安全性，初始化 <see cref="T:System.IO.FileStream" /> 類別的新執行個體。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-562">Initializes a new instance of the <see cref="T:System.IO.FileStream" /> class with the specified path, creation mode, access rights and sharing permission, the buffer size, additional file options, access control and audit security.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-563">.NET Framework 不支援直接存取實體磁碟，透過路徑是裝置名稱，例如，「\\\\。 \PHYSICALDRIVE0"。</span><span class="sxs-lookup"><span data-stu-id="02ff0-563">The .NET Framework does not support direct access to physical disks through paths that are device names, such as "\\\\.\PHYSICALDRIVE0 ".</span></span>  
  
 <span data-ttu-id="02ff0-564">使用此<xref:System.IO.FileStream.%23ctor%2A>建構函式來套用存取權限時建立檔案的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-564">Use this <xref:System.IO.FileStream.%23ctor%2A> constructor to apply access rights at the point of creation of a file.</span></span> <span data-ttu-id="02ff0-565">若要存取或修改現有的檔案上的權限，請考慮使用<xref:System.IO.File.GetAccessControl%2A>和<xref:System.IO.File.SetAccessControl%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-565">To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="02ff0-566">`fileOptions`參數用來提供更進階的作業建立時可運用的存取權<xref:System.IO.FileStream>物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-566">The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.</span></span>  
  
 <span data-ttu-id="02ff0-567">`path`參數可以是檔案名稱，包括通用命名慣例 (UNC) 共用上的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-567">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-568">`path` 不需要是儲存在磁碟; 上的檔案它可以是支援透過資料流存取系統的任何部分。</span><span class="sxs-lookup"><span data-stu-id="02ff0-568">`path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams.</span></span> <span data-ttu-id="02ff0-569">例如，根據系統中，這個類別可以存取實體裝置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-569">For example, depending on the system, this class can access a physical device.</span></span>  
  
 <span data-ttu-id="02ff0-570"><xref:System.IO.Stream.CanSeek%2A> 已`true`所有<xref:System.IO.FileStream>封裝檔案的物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-570"><xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files.</span></span> <span data-ttu-id="02ff0-571">如果`path`表示不支援搜尋，裝置<xref:System.IO.FileStream.CanSeek%2A>屬性產生<xref:System.IO.FileStream>是`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-571">If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`.</span></span> <span data-ttu-id="02ff0-572">如需詳細資訊，請參閱<xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-572">For additional information, see <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-573">當您編譯以特定的文化特性設定的一組字元，並擷取這些相同的字元，以不同的文化特性設定時，字元可能無法解譯，而且可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-573">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="02ff0-574">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-574">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-575">下列範例會將資料寫入至檔案，並接著會讀取資料使用<xref:System.IO.FileStream>物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-575">The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.</span></span>  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-576">
            <paramref name="path" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-576">
              <paramref name="path" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-577">
            <paramref name="path" /> 為空字串 ("")、只包含泛空白字元，或包含一個或多個無效的字元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-577">
              <paramref name="path" /> is an empty string (""), contains only white space, or contains one or more invalid characters.</span>
          </span>
          <span data-ttu-id="02ff0-578">或 <paramref name="path" /> 的參考對象為非檔案裝置，例如 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-578">-or-  <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in an NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-579">
            <paramref name="path" /> 是指非檔案裝置，例如非 NTFS 環境中的 "con:"、"com1:"、"lpt1:" 等。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-579">
              <paramref name="path" /> refers to a non-file device, such as "con:", "com1:", "lpt1:", etc. in a non-NTFS environment.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-580">
            <paramref name="bufferSize" /> 為負值或零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-580">
              <paramref name="bufferSize" /> is negative or zero.</span>
          </span>
          <span data-ttu-id="02ff0-581">或 <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 包含無效的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-581">-or-  <paramref name="mode" />, <paramref name="access" />, or <paramref name="share" /> contain an invalid value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="02ff0-582">無法找到檔案，例如，當 <paramref name="mode" /> 為 <see langword="FileMode.Truncate" /> 或 <see langword="FileMode.Open" />，而且 <paramref name="path" /> 指定的檔案不存在的時候。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-582">The file cannot be found, such as when <paramref name="mode" /> is <see langword="FileMode.Truncate" /> or <see langword="FileMode.Open" />, and the file specified by <paramref name="path" /> does not exist.</span>
          </span>
          <span data-ttu-id="02ff0-583">這些模式中必須有此檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-583">The file must already exist in these modes.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-584">發生 I/O 錯誤，例如在 <paramref name="path" /> 指定的檔案已經存在時指定 <see langword="FileMode.CreateNew" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-584">An I/O error, such as specifying <see langword="FileMode.CreateNew" /> when the file specified by <paramref name="path" /> already exists, occurred.</span>
          </span>
          <span data-ttu-id="02ff0-585">或資料流已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-585">-or-  The stream has been closed.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-586">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-586">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <span data-ttu-id="02ff0-587">指定的路徑無效，例如位在未對應的磁碟上。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-587">The specified path is invalid, such as being on an unmapped drive.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-588">指定之 <paramref name="access" /> 的作業系統不允許所要求的 <paramref name="path" />，例如，當 <paramref name="access" /> 為 <see langword="Write" /> 或 <see langword="ReadWrite" />，且檔案或目錄設定為唯讀存取時。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-588">The <paramref name="access" /> requested is not permitted by the operating system for the specified <paramref name="path" />, such as when <paramref name="access" /> is <see langword="Write" /> or <see langword="ReadWrite" /> and the file or directory is set for read-only access.</span>
          </span>
          <span data-ttu-id="02ff0-589">或針對 <paramref name="options" /> 指定了 <see cref="F:System.IO.FileOptions.Encrypted" />，但目前平台不支援檔案加密。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-589">-or-  <see cref="F:System.IO.FileOptions.Encrypted" /> is specified for <paramref name="options" />, but file encryption is not supported on the current platform.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.PathTooLongException">
          <span data-ttu-id="02ff0-590">指定的 <paramref name="path" />、檔案名稱或兩者都超過系統定義的最大長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-590">The specified <paramref name="path" />, file name, or both exceed the system-defined maximum length.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="02ff0-591">目前的作業系統不是 Windows NT (含) 以後版本。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-591">The current operating system is not Windows NT or later.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-592">用於讀取、 寫入和附加至檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-592">for reading, writing, and appending to files.</span>
          </span>
          <span data-ttu-id="02ff0-593">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />，和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-593">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="02ff0-594">要讀取資料的緩衝區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-594">The buffer to read data into.</span>
          </span>
        </param>
        <param name="buffer">To be added.</param>
        <param name="offset">
          <span data-ttu-id="02ff0-595">「陣列」<c></c>中的位元組位移，即開始讀取的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-595">The byte offset in <c>array</c> at which to begin reading.</span>
          </span>
        </param>
        <param name="numBytes">
          <span data-ttu-id="02ff0-596">要讀取的最大位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-596">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="count">To be added.</param>
        <param name="userCallback">
          <span data-ttu-id="02ff0-597">在非同步讀取作業完成時所呼叫的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-597">The method to be called when the asynchronous read operation is completed.</span>
          </span>
        </param>
        <param name="callback">To be added.</param>
        <param name="stateObject">
          <span data-ttu-id="02ff0-598">使用者所提供的物件，其可以從其他要求中區分出這個特定非同步讀取的要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-598">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span>
          </span>
        </param>
        <param name="state">To be added.</param>
        <summary>
          <span data-ttu-id="02ff0-599">開始非同步的讀取作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-599">Begins an asynchronous read operation.</span>
          </span>
          <span data-ttu-id="02ff0-600">(請考慮用 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> 替代。)</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-600">(Consider using <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="02ff0-601">物件，參考非同步讀取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-601">An object that references the asynchronous read.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-602">在.NET Framework 4 和更早版本中，您必須使用方法，例如<xref:System.IO.FileStream.BeginRead%2A>和<xref:System.IO.FileStream.EndRead%2A>實作非同步檔案作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-602">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.FileStream.BeginRead%2A> and <xref:System.IO.FileStream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="02ff0-603">這些方法是中仍然可用[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-603">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="02ff0-604"><xref:System.IO.FileStream.EndRead%2A> 每次呼叫必須正好一次呼叫<xref:System.IO.FileStream.BeginRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-604"><xref:System.IO.FileStream.EndRead%2A> must be called exactly once for every call to <xref:System.IO.FileStream.BeginRead%2A>.</span></span> <span data-ttu-id="02ff0-605">若要開始另一次讀取之前結束讀取的處理序失敗，可能會導致非預期的行為，例如死結。</span><span class="sxs-lookup"><span data-stu-id="02ff0-605">Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</span></span>  
  
 <span data-ttu-id="02ff0-606"><xref:System.IO.FileStream> 提供兩個不同的作業模式： 同步 I/O 和非同步 I/O。</span><span class="sxs-lookup"><span data-stu-id="02ff0-606"><xref:System.IO.FileStream> provides two different modes of operation: synchronous I/O and asynchronous I/O.</span></span> <span data-ttu-id="02ff0-607">雖然您可以使用其中一個，基礎作業系統資源可能會允許存取，在這些模式其中之一。</span><span class="sxs-lookup"><span data-stu-id="02ff0-607">While either can be used, the underlying operating system resources might allow access in only one of these modes.</span></span> <span data-ttu-id="02ff0-608">根據預設，<xref:System.IO.FileStream>以同步方式開啟的作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-608">By default, <xref:System.IO.FileStream> opens the operating system handle synchronously.</span></span> <span data-ttu-id="02ff0-609">在 Windows，這會略微減慢非同步方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-609">In Windows, this slows down asynchronous methods.</span></span> <span data-ttu-id="02ff0-610">如果使用非同步方法，使用<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-610">If asynchronous methods are used, use the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-611">使用<xref:System.IO.FileStream.CanRead%2A>屬性來判斷目前的執行個體是否支援讀取。</span><span class="sxs-lookup"><span data-stu-id="02ff0-611">Use the <xref:System.IO.FileStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="02ff0-612">如需詳細資訊，請參閱<xref:System.IO.Stream.CanRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-612">For additional information, see <xref:System.IO.Stream.CanRead%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-613">如果資料流已關閉，或您傳遞無效的引數，會擲回例外狀況立即從<xref:System.IO.FileStream.BeginRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-613">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <xref:System.IO.FileStream.BeginRead%2A>.</span></span> <span data-ttu-id="02ff0-614">非同步的讀取要求時，例如，在 IO 要求期間的磁碟失敗期間發生的錯誤在執行緒集區執行緒上發生，並呼叫時變成可見<xref:System.IO.FileStream.EndRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-614">Errors that occur during an asynchronous read request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <xref:System.IO.FileStream.EndRead%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-615"><xref:System.IO.Stream.EndRead%2A> 必須先呼叫與這個<xref:System.IAsyncResult>找出多少位元組被讀取。</span><span class="sxs-lookup"><span data-stu-id="02ff0-615"><xref:System.IO.Stream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 <span data-ttu-id="02ff0-616">多個同時的非同步要求轉譯要求完成順序不確定。</span><span class="sxs-lookup"><span data-stu-id="02ff0-616">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="02ff0-617">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-617">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-618">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-618">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-619">陣列長度減去 <paramref name="offset" /> 小於 <paramref name="numBytes" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-619">The array length minus <paramref name="offset" /> is less than <paramref name="numBytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-620">
            <paramref name="array" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-620">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-621">
            <paramref name="offset" /> 或 <paramref name="numBytes" /> 是負數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-621">
              <paramref name="offset" /> or <paramref name="numBytes" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-622">嘗試超過檔案結尾進行非同步讀取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-622">An asynchronous read was attempted past the end of the file.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="02ff0-623">包含要寫入至目前資料流之資料的緩衝區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-623">The buffer containing data to write to the current stream.</span>
          </span>
        </param>
        <param name="buffer">To be added.</param>
        <param name="offset">
          <span data-ttu-id="02ff0-624">「陣列」<c></c>中以零為起始的位元組位移，即要開始將位元組複製到目前資料流的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-624">The zero-based byte offset in <c>array</c> at which to begin copying bytes to the current stream.</span>
          </span>
        </param>
        <param name="numBytes">
          <span data-ttu-id="02ff0-625">寫入的最大位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-625">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="count">To be added.</param>
        <param name="userCallback">
          <span data-ttu-id="02ff0-626">在非同步寫入作業完成時所呼叫的方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-626">The method to be called when the asynchronous write operation is completed.</span>
          </span>
        </param>
        <param name="callback">To be added.</param>
        <param name="stateObject">
          <span data-ttu-id="02ff0-627">使用者所提供的物件，其可以從其他要求中區分出這個特定非同步寫入的要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-627">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span>
          </span>
        </param>
        <param name="state">To be added.</param>
        <summary>
          <span data-ttu-id="02ff0-628">開始非同步的寫入作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-628">Begins an asynchronous write operation.</span>
          </span>
          <span data-ttu-id="02ff0-629">(請考慮用 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> 替代。)</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-629">(Consider using <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="02ff0-630">物件，參考非同步寫入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-630">An object that references the asynchronous write.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-631">在.NET Framework 4 和更早版本中，您必須使用方法，例如<xref:System.IO.FileStream.BeginWrite%2A>和<xref:System.IO.FileStream.EndWrite%2A>實作非同步檔案作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-631">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.FileStream.BeginWrite%2A> and <xref:System.IO.FileStream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="02ff0-632">這些方法是中仍然可用[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-632">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="02ff0-633"><xref:System.IO.FileStream.EndWrite%2A> 必須正好一次上呼叫每個<xref:System.IAsyncResult>從<xref:System.IO.FileStream.BeginWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-633"><xref:System.IO.FileStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.FileStream.BeginWrite%2A>.</span></span> <span data-ttu-id="02ff0-634"><xref:System.IO.FileStream.EndWrite%2A> 將會封鎖直到 I/O 作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="02ff0-634"><xref:System.IO.FileStream.EndWrite%2A> will block until the I/O operation has completed.</span></span>  
  
 <span data-ttu-id="02ff0-635">這個方法覆寫 <xref:System.IO.Stream.BeginWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-635">This method overrides <xref:System.IO.Stream.BeginWrite%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-636"><xref:System.IO.FileStream> 提供兩個不同的作業模式： 同步 I/O 和非同步 I/O。</span><span class="sxs-lookup"><span data-stu-id="02ff0-636"><xref:System.IO.FileStream> provides two different modes of operation: synchronous I/O and asynchronous I/O.</span></span> <span data-ttu-id="02ff0-637">雖然您可以使用其中一個，基礎作業系統資源可能會允許存取，在這些模式其中之一。</span><span class="sxs-lookup"><span data-stu-id="02ff0-637">While either can be used, the underlying operating system resources might allow access in only one of these modes.</span></span> <span data-ttu-id="02ff0-638">根據預設，<xref:System.IO.FileStream>以同步方式開啟的作業系統控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-638">By default, <xref:System.IO.FileStream> opens the operating system handle synchronously.</span></span> <span data-ttu-id="02ff0-639">在 Windows，這會略微減慢非同步方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-639">In Windows, this slows down asynchronous methods.</span></span> <span data-ttu-id="02ff0-640">如果使用非同步方法，使用<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-640">If asynchronous methods are used, use the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 <span data-ttu-id="02ff0-641">如果資料流已關閉，或您傳遞無效的引數，會擲回例外狀況立即從<xref:System.IO.FileStream.BeginWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-641">If a stream is closed or you pass an invalid argument, exceptions are thrown immediately from <xref:System.IO.FileStream.BeginWrite%2A>.</span></span> <span data-ttu-id="02ff0-642">非同步寫入要求，例如，在 IO 要求期間的磁碟失敗期間發生的錯誤在執行緒集區執行緒上發生，並呼叫時變成可見<xref:System.IO.FileStream.EndWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-642">Errors that occur during an asynchronous write request, such as a disk failure during the IO request, occur on the thread pool thread and become visible upon a call to <xref:System.IO.FileStream.EndWrite%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-643">多個同時的非同步要求轉譯要求完成順序不確定。</span><span class="sxs-lookup"><span data-stu-id="02ff0-643">Multiple simultaneous asynchronous requests render the request completion order uncertain.</span></span>  
  
 <span data-ttu-id="02ff0-644">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-644">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-645">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-645">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-646">
            <paramref name="array" /> 長度減 <paramref name="offset" /> 小於 <paramref name="numBytes" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-646">
              <paramref name="array" /> length minus <paramref name="offset" /> is less than <paramref name="numBytes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-647">
            <paramref name="array" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-647">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-648">
            <paramref name="offset" /> 或 <paramref name="numBytes" /> 為負值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-648">
              <paramref name="offset" /> or <paramref name="numBytes" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-649">資料流不支援寫入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-649">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-650">已關閉資料流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-650">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-651">發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-651">An I/O error occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-652">取得值，表示目前資料流是否支援讀取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-652">Gets a value indicating whether the current stream supports reading.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="02ff0-653">如果資料流支援讀取，則為 <see langword="true" />；如果資料流關閉或以唯寫存取開啟，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-653">
              <see langword="true" /> if the stream supports reading; <see langword="false" /> if the stream is closed or was opened with write-only access.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-654">如果類別衍生自<xref:System.IO.Stream>不支援讀取，呼叫<xref:System.IO.FileStream.Read%2A>， <xref:System.IO.FileStream.ReadByte%2A>，以及<xref:System.IO.FileStream.BeginRead%2A>方法會擲回<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-654">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, and <xref:System.IO.FileStream.BeginRead%2A> methods throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="02ff0-655">如果資料流已關閉，則這個屬性會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-655">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-656">下列範例示範使用`CanRead`屬性。</span><span class="sxs-lookup"><span data-stu-id="02ff0-656">The following example demonstrates a use of the `CanRead` property.</span></span> <span data-ttu-id="02ff0-657">此程式碼的輸出會是 「 MyFile.txt 不是可寫入。 」</span><span class="sxs-lookup"><span data-stu-id="02ff0-657">The output of this code is "MyFile.txt is not writable."</span></span> <span data-ttu-id="02ff0-658">若要取得的輸出訊息"MyFile.txt 可被寫入和讀取。"，變更`FileAccess`參數來`ReadWrite`在`FileStream`建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-658">To get the output message "MyFile.txt can be both written to and read from.", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.</span></span>  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-659">取得表示目前資料流是否支援搜尋的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-659">Gets a value indicating whether the current stream supports seeking.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="02ff0-660">如果資料流支援搜尋，則為 <see langword="true" />；如果資料流已關閉或如果 <see langword="FileStream" /> 是從作業系統控制代碼 (例如管道或主控台的輸出) 建構，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-660">
              <see langword="true" /> if the stream supports seeking; <see langword="false" /> if the stream is closed or if the <see langword="FileStream" /> was constructed from an operating-system handle such as a pipe or output to the console.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-661">如果類別衍生自<xref:System.IO.Stream>不支援搜尋，呼叫<xref:System.IO.FileStream.Length%2A>， <xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Position%2A>，並<xref:System.IO.FileStream.Seek%2A>擲回<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-661">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, and <xref:System.IO.FileStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="02ff0-662">如果資料流已關閉，則這個屬性會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-662">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-663">下列範例會使用`CanSeek`檢查資料流是否支援搜尋的屬性。</span><span class="sxs-lookup"><span data-stu-id="02ff0-663">The following example uses the `CanSeek` property to check whether a stream supports seeking.</span></span>  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-664">取得表示目前資料流是否支援寫入的值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-664">Gets a value indicating whether the current stream supports writing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="02ff0-665">如果資料流支援寫入，則為 <see langword="true" />；如果資料流關閉或以唯讀存取開啟，則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-665">
              <see langword="true" /> if the stream supports writing; <see langword="false" /> if the stream is closed or was opened with read-only access.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-666">如果類別衍生自<xref:System.IO.Stream>不支援寫入，呼叫<xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Write%2A>， <xref:System.IO.FileStream.BeginWrite%2A>，或<xref:System.IO.FileStream.WriteByte%2A>就會擲回<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-666">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, or <xref:System.IO.FileStream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="02ff0-667">如果資料流已關閉，則這個屬性會傳回`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-667">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-668">下列範例會使用`CanWrite`檢查資料流是否支援寫入的屬性。</span><span class="sxs-lookup"><span data-stu-id="02ff0-668">The following example uses the `CanWrite` property to check whether a stream supports writing.</span></span>  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 <span data-ttu-id="02ff0-669">以下是範例使用`CanWrite`屬性。</span><span class="sxs-lookup"><span data-stu-id="02ff0-669">The following is an example using the `CanWrite` property.</span></span> <span data-ttu-id="02ff0-670">此程式碼的輸出會是 MyFile.txt 可寫入。 」</span><span class="sxs-lookup"><span data-stu-id="02ff0-670">The output of this code is "MyFile.txt is writable."</span></span> <span data-ttu-id="02ff0-671">若要取得的輸出訊息"MyFile.txt 可被寫入和讀取。"，變更`FileAccess`參數來`ReadWrite`在`FileStream`建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-671">To get the output message "MyFile.txt can be both written to and read from.", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.</span></span>  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="02ff0-672">
            <see langword="true" /> 表示會同時釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-672">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-673">釋放 <see cref="T:System.IO.FileStream" /> 所使用的 Unmanaged 資源，並選擇性釋放 Managed 資源。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-673">Releases the unmanaged resources used by the <see cref="T:System.IO.FileStream" /> and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-674">這個方法會呼叫公用<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-674">This method is called by the public <xref:System.ComponentModel.Component.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="02ff0-675"><xref:System.ComponentModel.Component.Dispose%2A> 叫用受保護<xref:System.IO.FileStream.Dispose%2A>方法`disposing`參數設為`true`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-675"><xref:System.ComponentModel.Component.Dispose%2A> invokes the protected <xref:System.IO.FileStream.Dispose%2A> method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="02ff0-676"><xref:System.Object.Finalize%2A> 叫用<xref:System.IO.FileStream.Dispose%2A>具有`disposing`設定為`false`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-676"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.FileStream.Dispose%2A> with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="02ff0-677">`disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.IO.FileStream> 參考的任何 Managed 物件所掌握的資源。</span><span class="sxs-lookup"><span data-stu-id="02ff0-677">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.IO.FileStream> references.</span></span> <span data-ttu-id="02ff0-678">這個方法會叫用每個參考物件的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-678">This method invokes the <xref:System.ComponentModel.Component.Dispose%2A> method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="02ff0-679">
            <para>
              <see cref="M:System.ComponentModel.Component.Dispose" /> 可以多次呼叫的其他物件。當覆寫<see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />小心不要參考先前處置好的呼叫中的物件<see cref="M:System.ComponentModel.Component.Dispose" />。如需有關如何實作<see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />，請參閱 [實作 Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md)。如需詳細資訊<see cref="M:System.ComponentModel.Component.Dispose" />和<see cref="M:System.Object.Finalize" />，請參閱 [總未受管理的 Resources](~/docs/standard/garbage-collection/unmanaged.md) 清除。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-679">
              <para>
                <see cref="M:System.ComponentModel.Component.Dispose" /> can be called multiple times by other objects. When overriding <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> be careful not to reference objects that have been previously disposed of in an earlier call to <see cref="M:System.ComponentModel.Component.Dispose" />. For more information about how to implement <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  For more information about <see cref="M:System.ComponentModel.Component.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="02ff0-680">要等候的暫止非同步要求的參考。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-680">The reference to the pending asynchronous request to wait for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-681">等候暫止的非同步讀取作業完成。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-681">Waits for the pending asynchronous read operation to complete.</span>
          </span>
          <span data-ttu-id="02ff0-682">(請考慮用 <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> 替代。)</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-682">(Consider using <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="02ff0-683">自資料流讀取的位元組數，在 0 和您所要求的位元組數目之間。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-683">The number of bytes read from the stream, between 0 and the number of bytes you requested.</span>
          </span>
          <span data-ttu-id="02ff0-684">在資料流末端資料流只傳回 0，否則，他們應該停止直到至少有 1 位元組可用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-684">Streams only return 0 at the end of the stream, otherwise, they should block until at least 1 byte is available.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-685">在.NET Framework 4 和更早版本中，您必須使用方法，例如<xref:System.IO.FileStream.BeginRead%2A>和<xref:System.IO.FileStream.EndRead%2A>實作非同步檔案作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-685">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.FileStream.BeginRead%2A> and <xref:System.IO.FileStream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="02ff0-686">這些方法是中仍然可用[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-686">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="02ff0-687"><xref:System.IO.FileStream.EndRead%2A> 每次呼叫必須剛好呼叫<xref:System.IO.FileStream.BeginRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-687"><xref:System.IO.FileStream.EndRead%2A> must be called exactly for every call to <xref:System.IO.FileStream.BeginRead%2A>.</span></span> <span data-ttu-id="02ff0-688">若要開始另一次讀取之前結束讀取的處理序失敗，可能會導致非預期的行為，例如死結。</span><span class="sxs-lookup"><span data-stu-id="02ff0-688">Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</span></span>  
  
 <span data-ttu-id="02ff0-689">這個方法覆寫 <xref:System.IO.Stream.EndRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-689">This method overrides <xref:System.IO.Stream.EndRead%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-690"><xref:System.IO.FileStream.EndRead%2A> 可呼叫每個<xref:System.IAsyncResult>從<xref:System.IO.FileStream.BeginRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-690"><xref:System.IO.FileStream.EndRead%2A> can be called on every <xref:System.IAsyncResult> from <xref:System.IO.FileStream.BeginRead%2A>.</span></span> <span data-ttu-id="02ff0-691">呼叫<xref:System.IO.FileStream.EndRead%2A>會告訴您從資料流讀取多少個位元組。</span><span class="sxs-lookup"><span data-stu-id="02ff0-691">Calling <xref:System.IO.FileStream.EndRead%2A> tells you how many bytes were read from the stream.</span></span> <span data-ttu-id="02ff0-692"><xref:System.IO.FileStream.EndRead%2A> 將會封鎖直到 I/O 作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="02ff0-692"><xref:System.IO.FileStream.EndRead%2A> will block until the I/O operation has completed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-693">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-693">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-694">
            <paramref name="asyncResult" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-694">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-695">這個 <see cref="T:System.IAsyncResult" /> 物件不是透過對這個類別呼叫 <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-695">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="02ff0-696">多次呼叫 <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-696">
              <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> is called multiple times.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-697">此資料流已關閉或是發生內部錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-697">The stream is closed or an internal error has occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <span data-ttu-id="02ff0-698">暫止的非同步 I/O 要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-698">The pending asynchronous I/O request.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-699">結束非同步寫入作業並封鎖，直到 I/O 作業完成。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-699">Ends an asynchronous write operation and blocks until the I/O operation is complete.</span>
          </span>
          <span data-ttu-id="02ff0-700">(請考慮用 <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> 替代。)</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-700">(Consider using <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-701">在.NET Framework 4 和更早版本中，您必須使用方法，例如<xref:System.IO.FileStream.BeginWrite%2A>和<xref:System.IO.FileStream.EndWrite%2A>實作非同步檔案作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-701">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.FileStream.BeginWrite%2A> and <xref:System.IO.FileStream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="02ff0-702">這些方法是中仍然可用[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-702">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="02ff0-703">這個方法覆寫 <xref:System.IO.Stream.EndWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-703">This method overrides <xref:System.IO.Stream.EndWrite%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-704"><xref:System.IO.FileStream.EndWrite%2A> 必須正好一次上呼叫每個<xref:System.IAsyncResult>從<xref:System.IO.FileStream.BeginWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-704"><xref:System.IO.FileStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.FileStream.BeginWrite%2A>.</span></span> <span data-ttu-id="02ff0-705"><xref:System.IO.FileStream.EndWrite%2A> 將會封鎖直到 I/O 作業完成為止。</span><span class="sxs-lookup"><span data-stu-id="02ff0-705"><xref:System.IO.FileStream.EndWrite%2A> will block until the I/O operation has completed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-706">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-706">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-707">
            <paramref name="asyncResult" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-707">
              <paramref name="asyncResult" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-708">這個 <see cref="T:System.IAsyncResult" /> 物件不是透過對這個類別呼叫 <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> 所建立。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-708">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="02ff0-709">多次呼叫 <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-709">
              <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> is called multiple times.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-710">此資料流已關閉或是發生內部錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-710">The stream is closed or an internal error has occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-711">確認釋出資源，並在記憶體回收行程再利用 <see langword="FileStream" /> 時執行其他清除作業。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-711">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see langword="FileStream" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-712">記憶體回收行程呼叫`Finalize`時準備好完成目前的物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-712">The garbage collector calls `Finalize` when the current object is ready to be finalized.</span></span> <span data-ttu-id="02ff0-713">`Finalize` 關閉`FileStream`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-713">`Finalize` closes the `FileStream`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-714">清除這個資料流的緩衝區，讓所有緩衝資料全部寫入檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-714">Clears buffers for this stream and causes any buffered data to be written to the file.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-715">清除這個資料流的緩衝區，讓所有緩衝資料全部寫入檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-715">Clears buffers for this stream and causes any buffered data to be written to the file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-716">這個方法覆寫 <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-716">This method overrides <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="02ff0-717">當您呼叫<xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType>作業系統 I/O 緩衝區的方法，也會排清。</span><span class="sxs-lookup"><span data-stu-id="02ff0-717">When you call the <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> method, the operating system I/O buffer is also flushed.</span></span>  
  
 <span data-ttu-id="02ff0-718">除非您明確地呼叫未排清資料流編碼器<xref:System.IO.FileStream.Flush%2A>或處置物件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-718">A stream’s encoder is not flushed unless you explicitly call <xref:System.IO.FileStream.Flush%2A> or dispose of the object.</span></span> <span data-ttu-id="02ff0-719">設定<xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType>至`true`表示資料會從排清緩衝區資料流，但並不會清除編碼器的狀態。</span><span class="sxs-lookup"><span data-stu-id="02ff0-719">Setting <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> to `true` means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="02ff0-720">這可讓編碼器，讓它可以正確編碼字元的下一個區塊保持其狀態 （部分的字元）。</span><span class="sxs-lookup"><span data-stu-id="02ff0-720">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="02ff0-721">UTF8，UTF7，其中某些字元可以只編碼編碼器接收或多個相鄰的字元後，會影響此案例。</span><span class="sxs-lookup"><span data-stu-id="02ff0-721">This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</span></span>  
  
 <span data-ttu-id="02ff0-722">因為緩衝區可供讀取或寫入，<xref:System.IO.FileStream.Flush>會執行下列兩個函式：</span><span class="sxs-lookup"><span data-stu-id="02ff0-722">Because a buffer can be used for either reading or writing, <xref:System.IO.FileStream.Flush> performs the following two functions:</span></span>  
  
-   <span data-ttu-id="02ff0-723">任何先前寫入緩衝區的資料複製到檔案，除了其編碼器狀態清除緩衝區。</span><span class="sxs-lookup"><span data-stu-id="02ff0-723">Any data previously written to the buffer is copied to the file and the buffer is cleared except for its encoder state.</span></span>  
  
-   <span data-ttu-id="02ff0-724">如果<xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType>是`true`資料先前已從檔案複製到讀取的緩衝區，檔案中目前的位置也會減少在緩衝區中未讀取的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="02ff0-724">If <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> is `true` and data was previously copied from the file to the buffer for reading, the current position within the file is decremented by the number of unread bytes in the buffer.</span></span> <span data-ttu-id="02ff0-725">然後清除緩衝區。</span><span class="sxs-lookup"><span data-stu-id="02ff0-725">The buffer is then cleared.</span></span>  
  
 <span data-ttu-id="02ff0-726">使用<xref:System.IO.FileStream.Flush%28System.Boolean%29>方法多載時您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。</span><span class="sxs-lookup"><span data-stu-id="02ff0-726">Use the <xref:System.IO.FileStream.Flush%28System.Boolean%29> method overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-727">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.Lock%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-727">This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-728">發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-728">An I/O error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-729">已關閉資料流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-729">The stream is closed.</span>
          </span>
        </exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <span data-ttu-id="02ff0-730">
            <see langword="true" /> 表示清除所有中繼檔案緩衝區，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-730">
              <see langword="true" /> to flush all intermediate file buffers; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-731">清除此資料流的緩衝區，讓所有緩衝資料全部寫入檔案，同時也清除所有的中繼檔案緩衝區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-731">Clears buffers for this stream and causes any buffered data to be written to the file, and also clears all intermediate file buffers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-732">使用這個多載，當您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。</span><span class="sxs-lookup"><span data-stu-id="02ff0-732">Use this overload when you want to ensure that all buffered data in intermediate file buffers is written to disk.</span></span>  
  
 <span data-ttu-id="02ff0-733">當您呼叫<xref:System.IO.FileStream.Flush%2A>作業系統 I/O 緩衝區的方法，也會排清。</span><span class="sxs-lookup"><span data-stu-id="02ff0-733">When you call the <xref:System.IO.FileStream.Flush%2A> method, the operating system I/O buffer is also flushed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">
          <span data-ttu-id="02ff0-734">用來監視是否有取消要求的語彙基元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-734">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-735">以非同步的方式清除這個資料流的所有緩衝區，造成任何緩衝資料都寫入基礎裝置，並且監視取消要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-735">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="02ff0-736">表示非同步清除作業的工作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-736">A task that represents the asynchronous flush operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-737">當您呼叫<xref:System.IO.FileStream.FlushAsync%2A>作業系統 I/O 緩衝區的方法，也會排清。</span><span class="sxs-lookup"><span data-stu-id="02ff0-737">When you call the <xref:System.IO.FileStream.FlushAsync%2A> method, the operating system I/O buffer is also flushed.</span></span>  
  
 <span data-ttu-id="02ff0-738">如果在作業取消之前完成，傳回的工作就會包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="02ff0-738">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="02ff0-739">如果已處置之檔案的控制代碼，傳回的工作會包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="02ff0-739">If the handle to the file is disposed, the returned task contains the <xref:System.ObjectDisposedException> exception in the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-740">已處置資料流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-740">The stream has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-741">取得 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件，該物件會封裝目前 <see cref="T:System.IO.FileStream" /> 物件所描述的檔案之存取控制清單 (ACL) 項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-741">Gets a <see cref="T:System.Security.AccessControl.FileSecurity" /> object that encapsulates the access control list (ACL) entries for the file described by the current <see cref="T:System.IO.FileStream" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="02ff0-742">物件，封裝目前 <see cref="T:System.IO.FileStream" /> 物件所描述之檔案的存取控制設定。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-742">An object that encapsulates the access control settings for the file described by the current <see cref="T:System.IO.FileStream" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-743">雖然<xref:System.IO.FileStream>類別以及<xref:System.IO.FileStream.GetAccessControl%2A>可用來擷取現有的檔案的存取控制清單 (ACL) 項目，請考慮使用<xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType>方法，因為它比較容易使用。</span><span class="sxs-lookup"><span data-stu-id="02ff0-743">While the <xref:System.IO.FileStream> class and <xref:System.IO.FileStream.GetAccessControl%2A> can be used to retrieve the access control list (ACL) entries of an existing file, consider using <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> method, as it is easier to use.</span></span>  
  
 <span data-ttu-id="02ff0-744">使用<xref:System.IO.FileStream.GetAccessControl%2A>方法來擷取檔案的 ACL 項目。</span><span class="sxs-lookup"><span data-stu-id="02ff0-744">Use the <xref:System.IO.FileStream.GetAccessControl%2A> method to retrieve the ACL entries for a file.</span></span>  
  
 <span data-ttu-id="02ff0-745">ACL 描述個人及/或群組，或沒有，在指定的檔案上的特定動作的權限。</span><span class="sxs-lookup"><span data-stu-id="02ff0-745">An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</span></span> <span data-ttu-id="02ff0-746">如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-746">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-747">檔案已經關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-747">The file is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-748">開啟檔案時發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-748">An I/O error occurred while opening the file.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="02ff0-749">找不到檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-749">The file could not be found.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-750">這個作業在目前平台不受支援。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-750">This operation is not supported on the current platform.</span>
          </span>
          <span data-ttu-id="02ff0-751">或呼叫端沒有必要的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-751">-or-  The caller does not have the required permission.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-752">取得目前 <see langword="FileStream" /> 物件封裝的檔案之作業系統檔案控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-752">Gets the operating system file handle for the file that the current <see langword="FileStream" /> object encapsulates.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="02ff0-753">這個 <see langword="FileStream" /> 物件所封裝的檔案之作業系統檔案控制代碼；如果 <see langword="FileStream" /> 已關閉，則為 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-753">The operating system file handle for the file encapsulated by this <see langword="FileStream" /> object, or -1 if the <see langword="FileStream" /> has been closed.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-754">這個屬性是用於操作-系統提供的系統呼叫作業系統控制代碼 (例如`ReadFile`在 Windows 上)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-754">This property is an operating system handle for use with operating-system-provided system calls (such as `ReadFile` on Windows).</span></span> <span data-ttu-id="02ff0-755">不適用於 C 程式庫函式預期的檔案描述項，例如`fread`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-755">It will not work with C library functions that expect a file descriptor, such as `fread`.</span></span>  
  
 <span data-ttu-id="02ff0-756">作業系統控制代碼可能已經開啟同步或非同步的方式，依據`FileStream`呼叫建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-756">The operating system handle might have been opened synchronously or asynchronously, depending on which `FileStream` constructor was called.</span></span> <span data-ttu-id="02ff0-757">使用<xref:System.IO.FileStream.IsAsync%2A>屬性探索是否以非同步方式開啟此控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-757">Use the <xref:System.IO.FileStream.IsAsync%2A> property to discover whether this handle was opened asynchronously.</span></span> <span data-ttu-id="02ff0-758">在 Win32 中，這表示重疊 IO 的開啟控制代碼，而且需要不同的參數，來`ReadFile`和`WriteFile`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-758">In Win32, this means the handle was opened for overlapped IO, and it requires different parameters to `ReadFile` and `WriteFile`.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-759">如果，可能會發生資料損毀`FileStream`會建立，其控制代碼傳遞、 某項作業移動控制代碼的檔案指標，然後`FileStream`會再次使用。</span><span class="sxs-lookup"><span data-stu-id="02ff0-759">Data corruption might occur if a `FileStream` is created, its handle is passed, some operation moves the handle's file pointer, and then the `FileStream` is used again.</span></span> <span data-ttu-id="02ff0-760">多個執行緒無法安全地寫入相同的檔案，同時並`FileStream`緩衝處理程式碼會假設它以獨佔方式控制控制代碼。</span><span class="sxs-lookup"><span data-stu-id="02ff0-760">Multiple threads cannot safely write to the same file simultaneously, and `FileStream` buffering code assumes that it exclusively controls the handle.</span></span> <span data-ttu-id="02ff0-761">`FileStream` 可能會擲回<xref:System.IO.IOException>如果`FileStream`偵測到某些其他處理序已移動檔案指標。</span><span class="sxs-lookup"><span data-stu-id="02ff0-761">`FileStream` might throw an <xref:System.IO.IOException> if `FileStream` detects that some other process has moved the file pointer.</span></span> <span data-ttu-id="02ff0-762">若要避免這個問題，不寫入任何資料到檔案的一部分，`FileStream`可能會有經過緩衝處理，並將檔案指標還原上一次上呼叫方法時發生的位置`FileStream`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-762">To avoid this, do not write any data into a portion of the file that `FileStream` might have buffered, and restore the file pointer to the location it had when methods were last called on `FileStream`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="02ff0-763">呼叫端沒有必要的使用權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-763">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="02ff0-764">提供存取 unmanaged 程式碼的能力。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-764">for the ability to access unmanaged code.</span>
          </span>
          <span data-ttu-id="02ff0-765">相關聯的列舉型別：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-765">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Security action: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="02ff0-766">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-766">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="02ff0-767">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-767">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-768">取得值，指出 <see langword="FileStream" /> 是否為非同步或同步開啟。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-768">Gets a value indicating whether the <see langword="FileStream" /> was opened asynchronously or synchronously.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="02ff0-769">如果 <see langword="FileStream" /> 是非同步開啟，則為 <see langword="true" />，否則為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-769">
              <see langword="true" /> if the <see langword="FileStream" /> was opened asynchronously; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-770">`IsAsync`屬性會偵測是否`FileStream`控制代碼已啟用程式碼以使用以非同步方式開啟<xref:System.IO.FileStream.Handle%2A>屬性正確。</span><span class="sxs-lookup"><span data-stu-id="02ff0-770">The `IsAsync` property detects whether the `FileStream` handle was opened asynchronously, enabling your code to use the <xref:System.IO.FileStream.Handle%2A> property correctly.</span></span> <span data-ttu-id="02ff0-771">在 Win32 中，`IsAsync`正在 true 表示控制代碼已針對重疊 I/O 開啟，並因此需要不同的參數，才能`ReadFile`和`WriteFile`。</span><span class="sxs-lookup"><span data-stu-id="02ff0-771">In Win32, `IsAsync` being true means the handle was opened for overlapped I/O, and thus requires different parameters to `ReadFile` and `WriteFile`.</span></span>  
  
 <span data-ttu-id="02ff0-772">當您建立的執行個體時，指定這個值<xref:System.IO.FileStream>類別的建構函式`isAsync`， `useAsync`，或`options`參數。</span><span class="sxs-lookup"><span data-stu-id="02ff0-772">You specify this value when you create an instance of the <xref:System.IO.FileStream> class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter.</span></span> <span data-ttu-id="02ff0-773">若屬性是`true`，資料流使用重疊的 I/O，以非同步方式執行檔案作業。</span><span class="sxs-lookup"><span data-stu-id="02ff0-773">When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously.</span></span> <span data-ttu-id="02ff0-774">不過，<xref:System.IO.FileStream.IsAsync%2A>屬性不一定要`true`來呼叫<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-774">However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method.</span></span> <span data-ttu-id="02ff0-775">當<xref:System.IO.FileStream.IsAsync%2A>屬性是`false`和您呼叫的非同步讀取和寫入作業，仍不封鎖 UI 執行緒，但實際的 I/O 作業以同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="02ff0-775">When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-776">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-776">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-777">取得資料流的位元組長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-777">Gets the length in bytes of the stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="02ff0-778">代表資料流位元組長度的長數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-778">A long value representing the length of the stream in bytes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-779">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-779">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-780">下列範例會使用`Length`和`Position`屬性來檢查檔案結尾條件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-780">The following example uses the `Length` and `Position` properties to check for an end-of-file condition.</span></span>  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-781">這個資料流的 <see cref="P:System.IO.FileStream.CanSeek" /> 為 <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-781">
              <see cref="P:System.IO.FileStream.CanSeek" /> for this stream is <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-782">發生 I/O 錯誤，例如檔案已經關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-782">An I/O error, such as the file being closed, occurred.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">
          <span data-ttu-id="02ff0-783">鎖定的範圍開頭。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-783">The beginning of the range to lock.</span>
          </span>
          <span data-ttu-id="02ff0-784">這個參數的值必須等於或大於零 (0)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-784">The value of this parameter must be equal to or greater than zero (0).</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="02ff0-785">要鎖定的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-785">The range to be locked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-786">防止其他處理序讀取或寫入 <see cref="T:System.IO.FileStream" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-786">Prevents other processes from reading from or writing to the <see cref="T:System.IO.FileStream" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-787">鎖定某個範圍的檔案資料流可讓該範圍的檔案資料流的鎖定處理程序的獨佔存取權的執行緒。</span><span class="sxs-lookup"><span data-stu-id="02ff0-787">Locking a range of a file stream gives the threads of the locking process exclusive access to that range of the file stream.</span></span>  
  
 <span data-ttu-id="02ff0-788">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-788">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-789">下列程式碼範例示範如何鎖定檔案的一部分，讓另一個處理序無法存取該檔案的一部分，即使它具有讀取/寫入檔案存取權。</span><span class="sxs-lookup"><span data-stu-id="02ff0-789">The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file.</span></span> <span data-ttu-id="02ff0-790">在不同的命令視窗中，同時執行程式，並調查使用不同的主控台輸入的選項。</span><span class="sxs-lookup"><span data-stu-id="02ff0-790">Run the program simultaneously in different command windows and investigate using the different console input options.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-791">
            <paramref name="position" /> 或 <paramref name="length" /> 為負值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-791">
              <paramref name="position" /> or <paramref name="length" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-792">檔案已關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-792">The file is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-793">處理序無法存取檔案，因為其他處理序已鎖定檔案的一部分。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-793">The process cannot access the file because another process has locked a portion of the file.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-794">取得傳遞給建構函式的 <see langword="FileStream" /> 的名稱。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-794">Gets the name of the <see langword="FileStream" /> that was passed to the constructor.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="02ff0-795">
            <see langword="FileStream" /> 名稱的字串。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-795">A string that is the name of the <see langword="FileStream" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-796">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-796">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-797">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-797">This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.</span></span>  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">
          <span data-ttu-id="02ff0-798">存取路徑。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-798">for access to the path.</span>
          </span>
          <span data-ttu-id="02ff0-799">相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-799">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-800">取得或設定這個資料流的目前位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-800">Gets or sets the current position of this stream.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="02ff0-801">這個資料流的目前位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-801">The current position of this stream.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-802">支援搜尋超過資料流長度的任何位置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-802">Seeking to any location beyond the length of the stream is supported.</span></span>  <span data-ttu-id="02ff0-803">當您尋找檔案的長度超過檔案大小將會成長。</span><span class="sxs-lookup"><span data-stu-id="02ff0-803">When you seek beyond the length of the file, the file size grows.</span></span>  <span data-ttu-id="02ff0-804">在 Microsoft Windows NT 及更新版本，任何新增至檔案結尾的資料是設定為零。</span><span class="sxs-lookup"><span data-stu-id="02ff0-804">In Microsoft Windows NT and newer, any data added to the end of the file is set to zero.</span></span>  <span data-ttu-id="02ff0-805">在 Microsoft Windows 98 或更早版本，任何新增至檔案結尾的資料不會設定為零，表示先前已刪除的資料會顯示資料流。</span><span class="sxs-lookup"><span data-stu-id="02ff0-805">In Microsoft Windows 98 or earlier, any data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</span></span> <span data-ttu-id="02ff0-806">將資料流的位置設定為較大的值，在 Windows 98 或更早版本的資料流結尾以外的位置，可能會導致引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-806">Setting the position of the stream to a large value beyond the end of the stream in Windows 98 or earlier may result in an exception being raised.</span></span>  
  
 <span data-ttu-id="02ff0-807">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-807">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-808">下列範例會使用`Length`和`Position`屬性來檢查檔案結尾條件。</span><span class="sxs-lookup"><span data-stu-id="02ff0-808">The following example uses the `Length` and `Position` properties to check for an end-of-file condition.</span></span>  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-809">資料流不支援搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-809">The stream does not support seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-810">發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-810">An I/O error occurred.</span>
          </span>
          <span data-ttu-id="02ff0-811">\- 或位置設定為非常大的值，超出 Windows 98 或更早版本的資料流結尾。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-811">\- or -  The position was set to a very large value beyond the end of the stream in Windows 98 or earlier.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-812">嘗試將位置設定為負值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-812">Attempted to set the position to a negative value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.EndOfStreamException">
          <span data-ttu-id="02ff0-813">嘗試搜尋超出資料流長度 (不支援此)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-813">Attempted seeking past the end of a stream that does not support this.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="02ff0-814">當這個方法傳回時，會包含其值介於 <c>offset</c> 和 (<c>offset</c> + <c>count</c> - 1<c>)</c> 之間，並由讀取自目前來源的位元組取代的指定位元組陣列。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-814">When this method returns, contains the specified byte array with the values between <c>offset</c> and (<c>offset</c> + <c>count</c> - 1<c>)</c> replaced by the bytes read from the current source.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="02ff0-815">「陣列」<c></c>中的位元組位移，即放置讀取位元組的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-815">The byte offset in <c>array</c> at which the read bytes will be placed.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="02ff0-816">要讀取的最大位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-816">The maximum number of bytes to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-817">從資料流讀取位元組區塊，並將資料寫入指定緩衝區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-817">Reads a block of bytes from the stream and writes the data in a given buffer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="02ff0-818">緩衝區所讀取的總位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-818">The total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="02ff0-819">如果目前無法提供那麼多的位元組數目，則這個數目可能小於所要求的位元組數；如果已經到達資料流末端，則為零。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-819">This might be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-820">這個方法覆寫 <xref:System.IO.Stream.Read%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-820">This method overrides <xref:System.IO.Stream.Read%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-821">`offset`參數會提供中的位元組位移`array`（緩衝區索引） 中要開始讀取，而`count`參數會提供要從這個資料流讀取的位元組數目上限。</span><span class="sxs-lookup"><span data-stu-id="02ff0-821">The `offset` parameter gives the offset of the byte in `array` (the buffer index) at which to begin reading, and the `count` parameter gives the maximum number of bytes to be read from this stream.</span></span> <span data-ttu-id="02ff0-822">如果已到達資料流結尾，傳回的值會是位元組讀取，則為零的實際數目。</span><span class="sxs-lookup"><span data-stu-id="02ff0-822">The returned value is the actual number of bytes read, or zero if the end of the stream is reached.</span></span> <span data-ttu-id="02ff0-823">讀取的作業成功時，讀取的位元組數目進階資料流的目前位置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-823">If the read operation is successful, the current position of the stream is advanced by the number of bytes read.</span></span> <span data-ttu-id="02ff0-824">如果發生例外狀況，資料流的目前位置不變。</span><span class="sxs-lookup"><span data-stu-id="02ff0-824">If an exception occurs, the current position of the stream is unchanged.</span></span>  
  
 <span data-ttu-id="02ff0-825"><xref:System.IO.FileStream.Read%2A>方法會傳回零，只有在到達資料流結尾之後。</span><span class="sxs-lookup"><span data-stu-id="02ff0-825">The <xref:System.IO.FileStream.Read%2A> method returns zero only after reaching the end of the stream.</span></span> <span data-ttu-id="02ff0-826">否則，<xref:System.IO.FileStream.Read%2A>一律從資料流讀取至少一個位元組，再傳回。</span><span class="sxs-lookup"><span data-stu-id="02ff0-826">Otherwise, <xref:System.IO.FileStream.Read%2A> always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="02ff0-827">沒有資料是否可用，從呼叫時，資料流<xref:System.IO.FileStream.Read%2A>，此方法將會封鎖直到至少一個位元組的資料可以傳回。</span><span class="sxs-lookup"><span data-stu-id="02ff0-827">If no data is available from the stream upon a call to <xref:System.IO.FileStream.Read%2A>, the method will block until at least one byte of data can be returned.</span></span> <span data-ttu-id="02ff0-828">實作可以自由地傳回比要求更少個位元組，即使尚未達到資料流結尾。</span><span class="sxs-lookup"><span data-stu-id="02ff0-828">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="02ff0-829">使用<xref:System.IO.BinaryReader>讀取基本資料型別。</span><span class="sxs-lookup"><span data-stu-id="02ff0-829">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
 <span data-ttu-id="02ff0-830">不會中斷正在執行讀取的作業的執行緒。</span><span class="sxs-lookup"><span data-stu-id="02ff0-830">Do not interrupt a thread that is performing a read operation.</span></span> <span data-ttu-id="02ff0-831">雖然應用程式可能會出現以解除封鎖的執行緒之後，請執行成功，您的應用程式效能和可靠性，就可能會降低中斷時間。</span><span class="sxs-lookup"><span data-stu-id="02ff0-831">Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</span></span>  
  
 <span data-ttu-id="02ff0-832">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-832">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-833">下列範例會讀取來自的內容<xref:System.IO.FileStream>並將它寫入至另一個<xref:System.IO.FileStream>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-833">The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.</span></span>  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-834">
            <paramref name="array" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-834">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-835">
            <paramref name="offset" /> 或 <paramref name="count" /> 為負值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-835">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-836">資料流不支援讀取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-836">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-837">發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-837">An I/O error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-838">
            <paramref name="offset" /> 和 <paramref name="count" /> 描述 <paramref name="array" /> 中的無效範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-838">
              <paramref name="offset" /> and <paramref name="count" /> describe an invalid range in <paramref name="array" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-839">在資料流關閉後，會呼叫方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-839">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="02ff0-840">要將資料寫入至的緩衝區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-840">The buffer to write the data into.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="02ff0-841">「緩衝區」<c></c> 中的位元組位移，即要開始從資料流寫入資料的位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-841">The byte offset in <c>buffer</c> at which to begin writing data from the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="02ff0-842">要讀取的最大位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-842">The maximum number of bytes to read.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="02ff0-843">用來監視是否有取消要求的語彙基元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-843">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-844">以非同步的方式從目前資料流讀取一連串的位元組、依所讀取的位元組數目進階資料流中的位置，以及監視取消要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-844">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="02ff0-845">表示非同步讀取作業的工作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-845">A task that represents the asynchronous read operation.</span>
          </span>
          <span data-ttu-id="02ff0-846">
            <paramref name="TResult" /> 參數的值會包含讀取至緩衝區的位元組總數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-846">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span>
          </span>
          <span data-ttu-id="02ff0-847">如果目前可供使用的位元組數目少於所要求的數目，結果值可能會小於所要求的位元組數目，或者如果已經到達資料流末端，則可能為 0（零）。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-847">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-848"><xref:System.IO.FileStream.ReadAsync%2A>方法可讓您執行需要大量資源的檔案作業，而不會封鎖主執行緒。</span><span class="sxs-lookup"><span data-stu-id="02ff0-848">The <xref:System.IO.FileStream.ReadAsync%2A> method enables you to perform resource-intensive file operations without blocking the main thread.</span></span> <span data-ttu-id="02ff0-849">這項效能考量對於 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 應用程式而言特別重要，尤其是針對耗時的資料流作業可能會阻礙 UI 執行緒，使應用程式看起來像是停止運作的情況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-849">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="02ff0-850">非同步方法會用於搭配`async`和`await`Visual Basic 和 C# 中的關鍵字。</span><span class="sxs-lookup"><span data-stu-id="02ff0-850">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="02ff0-851">使用<xref:System.IO.FileStream.CanRead%2A>屬性來判斷目前的執行個體是否支援讀取。</span><span class="sxs-lookup"><span data-stu-id="02ff0-851">Use the <xref:System.IO.FileStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="02ff0-852">如果在作業取消之前完成，傳回的工作就會包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="02ff0-852">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="02ff0-853">如果已處置之檔案的控制代碼，傳回的工作會包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="02ff0-853">If the handle to the file is disposed, the returned task contains the <xref:System.ObjectDisposedException> exception in the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-854">下列範例示範如何以非同步方式從檔案讀取。</span><span class="sxs-lookup"><span data-stu-id="02ff0-854">The following example shows how to read from a file asynchronously.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-855">
            <paramref name="buffer" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-855">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-856">
            <paramref name="offset" /> 或 <paramref name="count" /> 為負。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-856">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-857">
            <paramref name="offset" /> 和 <paramref name="count" /> 的總和大於緩衝區的長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-857">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-858">資料流不支援讀取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-858">The stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-859">已處置資料流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-859">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="02ff0-860">資料流目前由先前讀取作業所使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-860">The stream is currently in use by a previous read operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-861">從檔案讀取一個位元組，並將讀取位置前移一個位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-861">Reads a byte from the file and advances the read position one byte.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="02ff0-862">轉換為 <see cref="T:System.Int32" /> 的位元組，如果已經到達資料流的末端，則為 -1。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-862">The byte, cast to an <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-863">這個方法覆寫 <xref:System.IO.Stream.ReadByte%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-863">This method overrides <xref:System.IO.Stream.ReadByte%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-864">使用<xref:System.IO.FileStream.CanRead%2A>屬性來判斷目前的執行個體是否支援讀取。</span><span class="sxs-lookup"><span data-stu-id="02ff0-864">Use the <xref:System.IO.FileStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="02ff0-865">如需詳細資訊，請參閱<xref:System.IO.Stream.CanRead%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-865">For additional information, see <xref:System.IO.Stream.CanRead%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-866">下列程式碼範例示範如何將資料寫入至檔案時，位元組，並確認資料已正確地寫入。</span><span class="sxs-lookup"><span data-stu-id="02ff0-866">The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-867">目前資料流不支援讀取。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-867">The current stream does not support reading.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-868">目前的資料流已經關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-868">The current stream is closed.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="02ff0-869">
            <para>上的預設實作<see langword="Stream" />建立新的單一位元組陣列，然後呼叫<see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />。雖然這是正式正確，但卻效率不佳。任何具有內部緩衝區的資料流應該覆寫這個方法，並提供更有效率的版本直接讀取緩衝區，避免在每次呼叫配置額外的陣列。如需常見的檔案和目錄作業的清單，請參閱 [常見 I/O Tasks](~/docs/standard/io/common-i-o-tasks.md)。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-869">
              <para>The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.  For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="02ff0-870">取得 <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> 物件，這個物件代表目前的 <see cref="T:System.IO.FileStream" /> 物件封裝的檔案之作業系統檔案控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-870">Gets a <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> object that represents the operating system file handle for the file that the current <see cref="T:System.IO.FileStream" /> object encapsulates.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="02ff0-871">物件，代表目前 <see cref="T:System.IO.FileStream" /> 物件封裝之檔案的作業系統檔案控制代碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-871">An object that represents the operating system file handle for the file that the current <see cref="T:System.IO.FileStream" /> object encapsulates.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-872"><xref:System.IO.FileStream.SafeFileHandle%2A>屬性自動清除資料流，並將目前的資料流位置設為 0。</span><span class="sxs-lookup"><span data-stu-id="02ff0-872">The <xref:System.IO.FileStream.SafeFileHandle%2A> property automatically flushes the stream and sets the current stream position to 0.</span></span>  <span data-ttu-id="02ff0-873">這可讓要移動檔案或另一個資料流使用重設資料流位置<xref:System.IO.FileStream.SafeFileHandle%2A>這個屬性傳回。</span><span class="sxs-lookup"><span data-stu-id="02ff0-873">This allows the file to be moved or the stream position to be reset by another stream using the <xref:System.IO.FileStream.SafeFileHandle%2A> returned by this property.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="02ff0-874">呼叫 unmanaged 程式碼的權限。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-874">for permission to call unmanaged code.</span>
          </span>
          <span data-ttu-id="02ff0-875">安全性動作： 連結需求相關聯的列舉型別： <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-875">Security action: Link Demand  Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="02ff0-876">需要完全信任立即呼叫端。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-876">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="02ff0-877">此成員不能由部分信任或不透明的程式碼。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-877">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">
          <span data-ttu-id="02ff0-878">相對於「原點」<c></c>的搜尋起點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-878">The point relative to <c>origin</c> from which to begin seeking.</span>
          </span>
        </param>
        <param name="origin">
          <span data-ttu-id="02ff0-879">使用類型 <see cref="T:System.IO.SeekOrigin" /> 的值，指定開頭、結尾或目前位置作為「位移」<c></c>的參考點。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-879">Specifies the beginning, the end, or the current position as a reference point for <c>offset</c>, using a value of type <see cref="T:System.IO.SeekOrigin" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-880">設定這個資料流的目前位置為指定的數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-880">Sets the current position of this stream to the given value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="02ff0-881">資料流中的新位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-881">The new position in the stream.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-882">這個方法覆寫 <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-882">This method overrides <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-883">使用<xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType>屬性來判斷目前的執行個體是否支援搜尋。</span><span class="sxs-lookup"><span data-stu-id="02ff0-883">Use the <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> property to determine whether the current instance supports seeking.</span></span> <span data-ttu-id="02ff0-884">如需詳細資訊，請參閱<xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-884">For additional information, see <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="02ff0-885">您可以搜尋超過資料流長度的任何位置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-885">You can seek to any location beyond the length of the stream.</span></span> <span data-ttu-id="02ff0-886">當您尋找檔案的長度超過檔案大小將會成長。</span><span class="sxs-lookup"><span data-stu-id="02ff0-886">When you seek beyond the length of the file, the file size grows.</span></span> <span data-ttu-id="02ff0-887">在 Windows NT 和更新版本中，新增至檔案結尾的資料是設定為零。</span><span class="sxs-lookup"><span data-stu-id="02ff0-887">In Windows NT and later versions, data added to the end of the file is set to zero.</span></span> <span data-ttu-id="02ff0-888">在 Windows 98 或更早版本中，新增至檔案結尾的資料未設定為零，表示先前已刪除的資料會顯示資料流。</span><span class="sxs-lookup"><span data-stu-id="02ff0-888">In Windows 98 or earlier versions, data added to the end of the file is not set to zero, which means that previously deleted data is visible to the stream.</span></span>  
  
 <span data-ttu-id="02ff0-889">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-889">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-890">下列範例示範如何將資料寫入至檔案時，位元組，並確認資料已正確地寫入。</span><span class="sxs-lookup"><span data-stu-id="02ff0-890">The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 <span data-ttu-id="02ff0-891">下列範例會使用各種檔案結尾開頭的檔案，請從讀取文字方向會相反，<xref:System.IO.SeekOrigin>值與<xref:System.IO.FileStream.Seek%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-891">The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the <xref:System.IO.FileStream.Seek%2A> method.</span></span>  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-892">發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-892">An I/O error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-893">資料流不支援搜尋，例如，如果 <see langword="FileStream" /> 為從管道或主控台輸出所建構。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-893">The stream does not support seeking, such as if the <see langword="FileStream" /> is constructed from a pipe or console output.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-894">在資料流開始之前嘗試搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-894">Seeking is attempted before the beginning of the stream.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-895">在資料流關閉後，會呼叫方法。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-895">Methods were called after the stream was closed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">
          <span data-ttu-id="02ff0-896">物件，描述要套用至目前檔案的 ACL 項目。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-896">An object that describes an ACL entry to apply to the current file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-897">將 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件所描述的存取控制清單 (ACL) 項目套用至目前 <see cref="T:System.IO.FileStream" /> 物件所描述的檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-897">Applies access control list (ACL) entries described by a <see cref="T:System.Security.AccessControl.FileSecurity" /> object to the file described by the current <see cref="T:System.IO.FileStream" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-898">雖然<xref:System.IO.FileStream>類別以及<xref:System.IO.FileStream.SetAccessControl%2A>可以用在現有的檔案，請考慮使用<xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType>方法，因為它比較容易使用。</span><span class="sxs-lookup"><span data-stu-id="02ff0-898">While the <xref:System.IO.FileStream> class and <xref:System.IO.FileStream.SetAccessControl%2A> can be used on an existing file, consider using the <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> method as it is easier to use.</span></span>  
  
 <span data-ttu-id="02ff0-899"><xref:System.IO.FileStream.SetAccessControl%2A>方法適用於存取控制清單 (ACL) 項目代表 noninherited 的 ACL 清單的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-899">The <xref:System.IO.FileStream.SetAccessControl%2A> method applies access control list (ACL) entries to a file that represents the noninherited ACL list.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="02ff0-900">指定 ACL`fileSecurity`參數已取代現有檔案的 ACL。</span><span class="sxs-lookup"><span data-stu-id="02ff0-900">The ACL specified for the `fileSecurity` parameter replaces the existing ACL for the file.</span></span> <span data-ttu-id="02ff0-901">若要新增之新使用者的權限，請使用<xref:System.IO.FileStream.GetAccessControl%2A>方法，以取得現有的 ACL，修改它，然後再使用<xref:System.IO.FileStream.SetAccessControl%2A>套用回到檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-901">To add permissions for a new user, use the <xref:System.IO.FileStream.GetAccessControl%2A> method to obtain the existing ACL, modify it, and then use <xref:System.IO.FileStream.SetAccessControl%2A> to apply it back to the file.</span></span>  
  
 <span data-ttu-id="02ff0-902">ACL 描述個人及/或群組，或沒有，在指定的檔案上的特定動作的權限。</span><span class="sxs-lookup"><span data-stu-id="02ff0-902">An ACL describes individuals and/or groups who have, or do not have, rights to specific actions on the given file.</span></span> <span data-ttu-id="02ff0-903">如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-903">For more information, see [How to: Add or Remove Access Control List Entries](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-904">檔案已經關閉。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-904">The file is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-905">
            <paramref name="fileSecurity" /> 參數為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-905">The <paramref name="fileSecurity" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="02ff0-906">找不到或無法修改檔案。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-906">The file could not be found or modified.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="02ff0-907">目前的處理序沒有開啟檔案的存取權。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-907">The current process does not have access to open the file.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="02ff0-908">資料流的新長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-908">The new length of the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-909">設定這個資料流長度為指定的數值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-909">Sets the length of this stream to the given value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-910">這個方法覆寫 <xref:System.IO.Stream.SetLength%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-910">This method overrides <xref:System.IO.Stream.SetLength%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-911">如果指定的值小於目前資料流的長度，則會截斷資料流。</span><span class="sxs-lookup"><span data-stu-id="02ff0-911">If the given value is less than the current length of the stream, the stream is truncated.</span></span> <span data-ttu-id="02ff0-912">在此案例中，目前位置是否大於新的長度，目前位置移到資料流的最後一個位元組。</span><span class="sxs-lookup"><span data-stu-id="02ff0-912">In this scenario, if the current position is greater than the new length, the current position is moved to the last byte of the stream.</span></span> <span data-ttu-id="02ff0-913">如果指定的值大於目前的資料流的長度，展開 資料流時，和目前的位置維持不變。</span><span class="sxs-lookup"><span data-stu-id="02ff0-913">If the given value is larger than the current length of the stream, the stream is expanded, and the current position remains the same.</span></span> <span data-ttu-id="02ff0-914">如果資料流已展開，舊和新的長度之間的資料流的內容為未定義。</span><span class="sxs-lookup"><span data-stu-id="02ff0-914">If the stream is expanded, the contents of the stream between the old and the new length are undefined.</span></span>  
  
 <span data-ttu-id="02ff0-915">資料流必須支援寫入和搜尋的`SetLength`運作。</span><span class="sxs-lookup"><span data-stu-id="02ff0-915">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-916">使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入，而<xref:System.IO.FileStream.CanSeek%2A>屬性來判斷是否支援搜尋。</span><span class="sxs-lookup"><span data-stu-id="02ff0-916">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing, and the <xref:System.IO.FileStream.CanSeek%2A> property to determine whether seeking is supported.</span></span> <span data-ttu-id="02ff0-917">如需其他資訊，請參閱 <xref:System.IO.Stream.CanWrite%2A> 和 <xref:System.IO.Stream.CanSeek%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-917">For additional information, see <xref:System.IO.Stream.CanWrite%2A> and <xref:System.IO.Stream.CanSeek%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-918">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-918">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-919">發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-919">An I/O error has occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-920">資料流不支援寫入和搜尋。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-920">The stream does not support both writing and seeking.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-921">嘗試將 <paramref name="value" /> 參數設定為小於 0。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-921">Attempted to set the <paramref name="value" /> parameter to less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">
          <span data-ttu-id="02ff0-922">解除鎖定範圍的開頭。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-922">The beginning of the range to unlock.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="02ff0-923">要解除鎖定的範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-923">The range to be unlocked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-924">允許其他處理序存取先前鎖定的檔案的全部或一部分。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-924">Allows access by other processes to all or part of a file that was previously locked.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-925">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-925">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-926">下列程式碼範例示範如何鎖定檔案的一部分，因此無法存取該檔案的一部分，即使它具有讀取/寫入檔案存取權，另一個處理序，並將其再解除鎖定指定的組件的檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-926">The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file .</span></span> <span data-ttu-id="02ff0-927">在不同的命令視窗中，同時執行程式，並調查使用不同的主控台輸入的選項。</span><span class="sxs-lookup"><span data-stu-id="02ff0-927">Run the program simultaneously in different command windows and investigate using the different console input options.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-928">
            <paramref name="position" /> 或 <paramref name="length" /> 為負值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-928">
              <paramref name="position" /> or <paramref name="length" /> is negative.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="02ff0-929">包含要寫入至資料流之資料的緩衝區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-929">The buffer containing data to write to the stream.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="02ff0-930">「陣列」<c></c>中以零為起始的位元組位移，即要開始將位元組複製到資料流的來源位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-930">The zero-based byte offset in <c>array</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="02ff0-931">寫入的最大位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-931">The maximum number of bytes to write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-932">將位元組區塊寫入至檔案資料流中。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-932">Writes a block of bytes to the file stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-933">這個方法覆寫 <xref:System.IO.Stream.Write%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-933">This method overrides <xref:System.IO.Stream.Write%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-934">`offset`參數會提供中的位元組位移`array`（緩衝區索引） 中要開始複製，而`count`參數會提供將寫入資料流的位元組數目。</span><span class="sxs-lookup"><span data-stu-id="02ff0-934">The `offset` parameter gives the offset of the byte in `array` (the buffer index) at which to begin copying, and the `count` parameter gives the number of bytes that will be written to the stream.</span></span> <span data-ttu-id="02ff0-935">如果寫入作業成功，寫入的位元組數目進階資料流的目前位置。</span><span class="sxs-lookup"><span data-stu-id="02ff0-935">If the write operation is successful, the current position of the stream is advanced by the number of bytes written.</span></span> <span data-ttu-id="02ff0-936">如果發生例外狀況，資料流的目前位置不變。</span><span class="sxs-lookup"><span data-stu-id="02ff0-936">If an exception occurs, the current position of the stream is unchanged.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-937">使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入。</span><span class="sxs-lookup"><span data-stu-id="02ff0-937">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="02ff0-938">如需詳細資訊，請參閱<xref:System.IO.Stream.CanWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-938">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-939">不會中斷正在執行寫入作業的執行緒。</span><span class="sxs-lookup"><span data-stu-id="02ff0-939">Do not interrupt a thread that is performing a write operation.</span></span> <span data-ttu-id="02ff0-940">雖然應用程式可能會出現以解除封鎖的執行緒之後，請執行成功，您的應用程式效能和可靠性，就可能會降低中斷時間。</span><span class="sxs-lookup"><span data-stu-id="02ff0-940">Although the application may appear to run successfully after the thread is unblocked, the interruption can decrease your application's performance and reliability.</span></span>  
  
 <span data-ttu-id="02ff0-941">如需常見的檔案和目錄作業的清單，請參閱 <<c0> [ 一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="02ff0-941">For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-942">此程式碼範例是針對提供之較大範例的一部分<xref:System.IO.FileStream.Lock%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="02ff0-942">This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.</span></span>  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-943">
            <paramref name="array" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-943">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-944">
            <paramref name="offset" /> 和 <paramref name="count" /> 描述 <paramref name="array" /> 中的無效範圍。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-944">
              <paramref name="offset" /> and <paramref name="count" /> describe an invalid range in <paramref name="array" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-945">
            <paramref name="offset" /> 或 <paramref name="count" /> 為負值。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-945">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="02ff0-946">發生 I/O 錯誤。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-946">An I/O error occurred.</span>
          </span>
          <span data-ttu-id="02ff0-947">\- 或另一個執行緒可能會在作業系統之檔案控制代碼的位置，造成非預期的變更。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-947">\- or -  Another thread may have caused an unexpected change in the position of the operating system's file handle.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-948">已關閉資料流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-948">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-949">目前的資料流執行個體不支援寫入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-949">The current stream instance does not support writing.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="02ff0-950">寫入資料的來源緩衝區。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-950">The buffer to write data from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="02ff0-951">「緩衝區」<c></c>中以零為起始的位元組位移，即要開始將位元組複製到資料流的來源位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-951">The zero-based byte offset in <c>buffer</c> from which to begin copying bytes to the stream.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="02ff0-952">寫入的最大位元組數。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-952">The maximum number of bytes to write.</span>
          </span>
        </param>
        <param name="cancellationToken">
          <span data-ttu-id="02ff0-953">用來監視是否有取消要求的語彙基元。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-953">The token to monitor for cancellation requests.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-954">以非同步的方式將一連串的位元組寫入目前的資料流，由這個資料流中目前的位置前移寫入的位元組數目，並且監視取消要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-954">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="02ff0-955">表示非同步寫入作業的工作。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-955">A task that represents the asynchronous write operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-956"><xref:System.IO.FileStream.WriteAsync%2A>方法可讓您執行需要大量資源的檔案作業，而不會封鎖主執行緒。</span><span class="sxs-lookup"><span data-stu-id="02ff0-956">The <xref:System.IO.FileStream.WriteAsync%2A> method enables you to perform resource-intensive file operations without blocking the main thread.</span></span> <span data-ttu-id="02ff0-957">這項效能考量對於 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 應用程式或 [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] 應用程式而言特別重要，尤其是針對耗時的資料流作業可能會阻礙 UI 執行緒，使應用程式看起來像是停止運作的情況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-957">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="02ff0-958">非同步方法會用於搭配`async`和`await`Visual Basic 和 C# 中的關鍵字。</span><span class="sxs-lookup"><span data-stu-id="02ff0-958">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  
  
 <span data-ttu-id="02ff0-959">使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入。</span><span class="sxs-lookup"><span data-stu-id="02ff0-959">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>  
  
 <span data-ttu-id="02ff0-960">如果在作業取消之前完成，傳回的工作就會包含<xref:System.Threading.Tasks.TaskStatus.Canceled>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="02ff0-960">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="02ff0-961">如果已處置之檔案的控制代碼，傳回的工作會包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="02ff0-961">If the handle to the file is disposed, the returned task contains the <xref:System.ObjectDisposedException> exception in the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-962">下列範例示範如何以非同步方式寫入檔案。</span><span class="sxs-lookup"><span data-stu-id="02ff0-962">The following example shows how to write asynchronously to a file.</span></span>  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="02ff0-963">
            <paramref name="buffer" /> 為 <see langword="null" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-963">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="02ff0-964">
            <paramref name="offset" /> 或 <paramref name="count" /> 為負。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-964">
              <paramref name="offset" /> or <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="02ff0-965">
            <paramref name="offset" /> 和 <paramref name="count" /> 的總和大於緩衝區長度。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-965">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-966">資料流不支援寫入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-966">The stream does not support writing.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-967">已處置此資料流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-967">The stream has been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="02ff0-968">資料流目前由先前寫入作業所使用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-968">The stream is currently in use by a previous write operation.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="02ff0-969">要寫入至資料流的位元組。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-969">A byte to write to the stream.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="02ff0-970">寫入一個位元組到檔案資料流中的目前位置。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-970">Writes a byte to the current position in the file stream.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="02ff0-971">這個方法覆寫 <xref:System.IO.Stream.WriteByte%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-971">This method overrides <xref:System.IO.Stream.WriteByte%2A>.</span></span>  
  
 <span data-ttu-id="02ff0-972">使用`WriteByte`寫入一個位元組來`FileStream`有效率的方式。</span><span class="sxs-lookup"><span data-stu-id="02ff0-972">Use `WriteByte` to write a byte to a `FileStream` efficiently.</span></span> <span data-ttu-id="02ff0-973">如果已關閉或無法寫入資料流，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="02ff0-973">If the stream is closed or not writable, an exception will be thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="02ff0-974">使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入。</span><span class="sxs-lookup"><span data-stu-id="02ff0-974">Use the <xref:System.IO.FileStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="02ff0-975">如需詳細資訊，請參閱<xref:System.IO.Stream.CanWrite%2A>。</span><span class="sxs-lookup"><span data-stu-id="02ff0-975">For additional information, see <xref:System.IO.Stream.CanWrite%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="02ff0-976">下列程式碼範例示範如何將資料寫入至檔案時，位元組，並確認資料已正確地寫入。</span><span class="sxs-lookup"><span data-stu-id="02ff0-976">The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.</span></span>  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="02ff0-977">已關閉資料流。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-977">The stream is closed.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="02ff0-978">資料流不支援寫入。</span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-978">The stream does not support writing.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="02ff0-979">
            <para>上的預設實作<see langword="Stream" />建立新的單一位元組陣列，然後呼叫<see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />。雖然這是正式正確，但卻效率不佳。任何具有內部緩衝區的資料流應該覆寫這個方法，並提供更有效率的版本直接讀取緩衝區，避免在每次呼叫配置額外的陣列。如需常見的檔案和目錄作業的清單，請參閱 [常見 I/O Tasks](~/docs/standard/io/common-i-o-tasks.md)。</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="02ff0-979">
              <para>The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. While this is formally correct, it is inefficient. Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.  For a list of common file and directory operations, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>