<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e87b26ec400399826b4f5e5b8d1daf942933af86" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36485077" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Listens to the file system change notifications and raises events when a directory, or file in a directory, changes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileSystemWatcher>監看的指定目錄中的變更。 您可以監看檔案與指定之目錄的子目錄中的變更。 您可以建立監看檔案在本機電腦、 網路磁碟機或遠端電腦上的元件。  
  
 若要監看所有檔案中的變更，將<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為空字串 ("") 或使用萬用字元 ("*。\*")。 若要觀察特定的檔案，將<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為檔案名稱。 例如，若要觀看檔案 MyDoc.txt 中變更，設定<xref:System.IO.FileSystemWatcher.Filter%2A>"MyDoc.txt"的屬性。 您也可以觀看中特定檔案類型的變更。 例如，若要監看的文字檔案中的變更，將<xref:System.IO.FileSystemWatcher.Filter%2A>屬性為"\*.txt"。  
  
 有幾種類型的變更，您可以監看目錄或檔案中。 例如，您可以觀看中變更`Attributes`、`LastWrite`日期和時間，或`Size`檔案或目錄。 這是藉由設定<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>屬性設為其中的<xref:System.IO.NotifyFilters>值。 多個您可以監看的變更類型資訊，請參閱<xref:System.IO.NotifyFilters>。  
  
 您可以觀看重新命名、 刪除或建立檔案或目錄。 例如，若要觀看的文字檔案重新命名，設定<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為"*.txt 」 並呼叫<xref:System.IO.FileSystemWatcher.WaitForChanged%2A>方法<xref:System.IO.WatcherChangeTypes.Renamed>其參數所指定。  
  
 Windows 作業系統會通知您的元件所建立的緩衝區中的檔案變更的<xref:System.IO.FileSystemWatcher>。 如果短時間內有許多變更，緩衝區會溢位。 這會導致遺失的目錄中的變更追蹤的元件，它只會提供概括性的告知。 增加內部緩衝區大小<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性是高度耗費資源，因為它來自非分頁記憶體無法空出給磁碟，所以較小的緩衝區尚未大型足以不會遺漏任何檔案會變更事件。 若要避免緩衝區溢位，請使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>屬性，因此您可以篩選掉不必要的變更通知。  
  
 如需執行個體的初始屬性值的清單<xref:System.IO.FileSystemWatcher>，請參閱<xref:System.IO.FileSystemWatcher.%23ctor%2A>建構函式。  
  
 使用時，請注意下列<xref:System.IO.FileSystemWatcher>類別。  
  
-   隱藏的檔案不會忽略。  
  
-   在某些系統上，<xref:System.IO.FileSystemWatcher>使用簡短的 8.3 檔案名稱格式的檔案來報告變更。 例如，"LongFileName.LongExtension 」 的變更無法回報為 「 LongFil ~。Lon"。  
  
-   這個類別包含的連結要求和繼承要求套用到所有成員的類別層級。 A<xref:System.Security.SecurityException>立即呼叫者或衍生的類別並沒有完全信任權限時，會擲回。 如需安全性需求的詳細資訊，請參閱[連結要求](~/docs/framework/misc/link-demands.md)。  
  
-   您可以設定的大小上限<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性透過網路監視的目錄是 64 KB。  
  
> [!NOTE]
>  執行<xref:System.IO.FileSystemWatcher>不支援 Windows 98 上。  
  
## <a name="copying-and-moving-folders"></a>複製和移動資料夾  
 作業系統和<xref:System.IO.FileSystemWatcher>物件解譯剪下和貼上動作或 move 動作做為重新命名動作的資料夾及其內容。 如果您剪下並將資料夾與檔案貼到正在監看資料夾<xref:System.IO.FileSystemWatcher>物件會報告的資料夾做為新的但不是其內容因為基本上只重新命名。  
  
 若要收到通知資料夾的內容已移動或複製到監看資料夾中，提供<xref:System.IO.FileSystemWatcher.OnChanged%2A>和<xref:System.IO.FileSystemWatcher.OnRenamed%2A>依下表中的事件處理常式方法。  
  
|事件處理常式|處理的事件|執行|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|報表中的檔案屬性、 建立的檔案和已刪除之檔案的變更。|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|列出舊的和新的路徑重新命名的檔案和資料夾，視需要展開以遞迴方式。|  
  
## <a name="events-and-buffer-sizes"></a>事件和緩衝區大小  
 請注意，許多因素可能會影響哪些檔案系統變更會引發事件，如以下所述：  
  
-   常見的檔案系統作業可能會引發多個事件。 例如，當檔案移到另一個，有數個目錄從<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引發事件。 移動檔案一種複雜的作業，包含多個簡單的作業，因此會引發多個事件。 同樣地，某些應用程式 （例如，防毒軟體） 可能會造成偵測到的其他檔案系統事件<xref:System.IO.FileSystemWatcher>。  
  
-   <xref:System.IO.FileSystemWatcher>可以觀看磁碟，只要不切換或移除。 <xref:System.IO.FileSystemWatcher>不會引發事件的 Cd 與 Dvd，因為時間戳記和屬性不能變更。 遠端電腦必須有一個必要的平台安裝元件正確運作。  
  
-   若為多個<xref:System.IO.FileSystemWatcher>觀賞物件在 Windows XP Service Pack 1 之前的相同 UNC 路徑，或 Windows 2000 SP2 或更早版本，則只有其中一個物件將會引發事件。 在電腦上執行 Windows XP SP1 和更新版本中，Windows 2000 SP3 或更新版本或 Windows Server 2003，所有<xref:System.IO.FileSystemWatcher>物件將會引發適當的事件。  
  
 請注意，<xref:System.IO.FileSystemWatcher>可能會遺失超過緩衝區大小時的事件。 若要避免遺失事件，請遵循這些指導方針：  
  
-   增加所設定的緩衝區大小<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性。  
  
-   避免監看檔案具有長檔名，因為長檔名作為填滿緩衝區。 請考慮重新命名這些檔案使用較短的名稱。  
  
-   讓事件處理程式碼越短越好。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看在執行階段指定的目錄。 元件會設定為監看的變更在`LastWrite`和`LastAccess`時間、 建立、 刪除、 或重新命名目錄中的文字檔案。 如果變更、 建立或刪除檔案，檔案的路徑會列印到主控台。 重新命名檔案時，新舊路徑列印到主控台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>此範例中的命名空間。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">針對衍生自<see cref="T:System.Diagnostics.ProcessStartInfo" />類別。 要求的值： <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />;具名使用權限集合： <see langword="FullTrust" />。</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您無法監看遠端電腦沒有 Windows NT 或 Windows 2000。 您無法監看遠端 Windows NT 4.0 電腦從 Windows NT 4.0 的電腦。  
  
 下表顯示的執行個體的初始屬性值<xref:System.IO.FileSystemWatcher>。  
  
|屬性|初始值|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|位元 OR 組合的`LastWrite`， `FileName`，和 `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*.\*「 （監看所有檔案。）|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|空字串 ("")|  
  
> [!NOTE]
>  此元件將無法觀賞直到指定的目錄<xref:System.IO.FileSystemWatcher.Path%2A>設定，和<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看的目錄，在執行階段指定的物件。 <xref:System.IO.FileSystemWatcher>物件監看的變更`LastWrite`和`LastAccess`刪除或重新命名的文字，以及建立，檔案的目錄中。 如果變更、 建立或刪除檔案，檔案的路徑會顯示到主控台。 重新命名檔案時對主控台顯示舊的和新的路徑。  
  
 這個範例會使用<xref:System.Diagnostics>和<xref:System.IO>命名空間。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The directory to monitor, in standard or Universal Naming Convention (UNC) notation.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class, given the specified directory to monitor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此元件將無法觀賞直到指定的目錄<xref:System.IO.FileSystemWatcher.Path%2A>設定，和<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 元件可以監看您的個人電腦、 網路磁碟機或遠端電腦上的檔案。  
  
 您無法監看遠端電腦沒有 Windows NT 或 Windows 2000。 您無法監看遠端 Windows NT 4.0 電腦從 Windows NT 4.0 的電腦。 <xref:System.IO.FileSystemWatcher.Filter%2A>屬性由預設設定要監看所有檔案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is an empty string ("").  -or-  The path specified through the <paramref name="path" /> parameter does not exist.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> is too long.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The directory to monitor, in standard or Universal Naming Convention (UNC) notation.</param>
        <param name="filter">The type of files to watch. For example, "*.txt" watches for changes to all text files.</param>
        <summary>Initializes a new instance of the <see cref="T:System.IO.FileSystemWatcher" /> class, given the specified directory and type of files to monitor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此元件將無法觀賞直到指定的目錄<xref:System.IO.FileSystemWatcher.Path%2A>設定，和<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 元件可以監看您的個人電腦、 網路磁碟機或遠端電腦上的檔案。  
  
 您無法監看遠端電腦沒有 Windows NT 或 Windows 2000。 您無法監看遠端 Windows NT 4.0 電腦從 Windows NT 4.0 的電腦。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="path" /> parameter is <see langword="null" />.  -or-  The <paramref name="filter" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter is an empty string ("").  -or-  The path specified through the <paramref name="path" /> parameter does not exist.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> is too long.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫者。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins the initialization of a <see cref="T:System.IO.FileSystemWatcher" /> used on a form or used by another component. The initialization occurs at run time.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]設計環境會使用這個方法來啟動元件的初始化用於表單或另一個元件所使用。 <xref:System.IO.FileSystemWatcher.EndInit%2A>方法結束初始化。 使用<xref:System.IO.FileSystemWatcher.BeginInit%2A>和<xref:System.IO.FileSystemWatcher.EndInit%2A>方法可防止控制項完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is changed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.Changed>大小變更時引發事件時，系統屬性、 上次寫入時間、 上次存取時間或檔案或目錄的安全性權限受監視的目錄中。  
  
> [!NOTE]
>  常見的檔案系統作業可能會引發多個事件。 例如，當檔案移到另一個，有數個目錄從<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引發事件。 移動檔案一種複雜的作業，包含多個簡單的作業，因此會引發多個事件。 同樣地，某些應用程式 （例如，防毒軟體） 可能會造成偵測到的其他檔案系統事件<xref:System.IO.FileSystemWatcher>。  
  
 使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>限制處理此事件時引發的通知數目。  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Changed>檔案重新命名，但在重新命名目錄時，不會引發時非預期地引發事件。 若要觀看重新命名，使用<xref:System.IO.FileSystemWatcher.Renamed>事件。  
  
> [!NOTE]
>  順序<xref:System.IO.FileSystemWatcher.Changed>引發彼此<xref:System.IO.FileSystemWatcher>事件時可能會變更<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>屬性不是`null`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.FileSystemWatcher.Changed>事件，以對主控台顯示的檔案路徑，每當監看的檔案變更時。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一些常見的動作，例如複製或移動檔案或目錄中，執行不直接對應到事件，而這些項目會導致引發的事件。 當您複製檔案或目錄時，系統就會引發<xref:System.IO.FileSystemWatcher.Created>要複製檔案，如果該目錄正在監看的目錄中的事件。 如果您複製的目錄已被另一個執行個體所監看<xref:System.IO.FileSystemWatcher>，就會引發任何事件。 例如，您建立兩個執行個體<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 設定要監看"C:\My Documents"和 FileSystemWatcher2 設定要監看 「 C:\Your 文件 」。 如果您將檔案從 「 我的文件 」 複製到 「 您文件 」 <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，將會引發事件，但不會引發事件的 FileSystemWatcher1。 不同於複製、 移動檔案或目錄將會引發兩個事件。 上述範例中，如果您將檔案從 「 我的文件 」 移到 「 您文件 」，從<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 會引發事件和<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 會引發事件。  
  
> [!NOTE]
>  常見的檔案系統作業可能會引發多個事件。 例如，當檔案移到另一個，有數個目錄從<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引發事件。 移動檔案一種複雜的作業，包含多個簡單的作業，因此會引發多個事件。 同樣地，某些應用程式 （例如，防毒軟體） 可能會造成偵測到的其他檔案系統事件<xref:System.IO.FileSystemWatcher>。  
  
> [!NOTE]
>  順序<xref:System.IO.FileSystemWatcher.Created>引發彼此<xref:System.IO.FileSystemWatcher>事件時可能會變更<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>屬性不是`null`。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>會建立一個檔案時，就會引發事件。 如果正在將檔案複製或傳送到監看的目錄中，<xref:System.IO.FileSystemWatcher.OnCreated%2A>會立即引發事件，後面接著一或多個<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.FileSystemWatcher.Created>事件，以建立保存的檔案時對主控台顯示的檔案路徑。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is deleted.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一些常見的動作，例如複製或移動檔案或目錄中，執行不直接對應到事件，而這些項目會導致引發的事件。 當您複製檔案或目錄時，系統就會引發<xref:System.IO.FileSystemWatcher.Created>要複製檔案，如果該目錄正在監看的目錄中的事件。 如果您複製的目錄已被另一個執行個體所監看<xref:System.IO.FileSystemWatcher>，就會引發任何事件。 例如，您建立兩個執行個體<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 設定要監看"C:\My Documents"和 FileSystemWatcher2 設定要監看 「 C:\Your 文件 」。 如果您將檔案從 「 我的文件 」 複製到 「 您文件 」 <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，將會引發事件，但不會引發事件的 FileSystemWatcher1。 不同於複製、 移動檔案或目錄將會引發兩個事件。 上述範例中，如果您將檔案從 「 我的文件 」 移到 「 您文件 」，從<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 會引發事件和<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 會引發事件。  
  
> [!NOTE]
>  常見的檔案系統作業可能會引發多個事件。 例如，當檔案移到另一個，有數個目錄從<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引發事件。 移動檔案一種複雜的作業，包含多個簡單的作業，因此會引發多個事件。 同樣地，某些應用程式 （例如，防毒軟體） 可能會造成偵測到的其他檔案系統事件<xref:System.IO.FileSystemWatcher>。  
  
> [!NOTE]
>  順序<xref:System.IO.FileSystemWatcher.Deleted>引發彼此<xref:System.IO.FileSystemWatcher>事件時可能會變更<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>屬性不是`null`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.FileSystemWatcher.Deleted>事件，以對主控台顯示的檔案路徑，只要刪除監看的檔案。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.IO.FileSystemWatcher" /> and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。 <xref:System.ComponentModel.Component.Dispose%2A> 叫用受保護<xref:System.IO.FileSystemWatcher.Dispose%2A>方法`disposing`參數設定為`true`。 <xref:System.Object.Finalize%2A> 叫用<xref:System.IO.FileSystemWatcher.Dispose%2A>與`disposing`設`false`。  
  
 `disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.IO.Compression.DeflateStream> 參考的任何 Managed 物件所掌握的資源。 這個方法會叫用每個參考物件的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以被其他物件呼叫多次。在覆寫<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />小心不要參考物件已處置過的早期呼叫中<see cref="M:System.ComponentModel.Component.Dispose" />。如需有關如何實作<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />，請參閱 [實作 Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md)。如需有關<see cref="M:System.ComponentModel.Component.Dispose" />和<see cref="M:System.Object.Finalize" />，請參閱 [總未受管理的 Resources](~/docs/standard/garbage-collection/unmanaged.md) 清除。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether the component is enabled.</summary>
        <value>如果啟用元件，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。 如果您使用元件設計工具中 [！INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]，預設值是<see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元件不會引發事件，除非您將設定<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>至`true`。  
  
> [!NOTE]
>  此元件將無法觀賞直到指定的目錄<xref:System.IO.FileSystemWatcher.Path%2A>屬性已設定和<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 <xref:System.IO.FileSystemWatcher.WaitForChanged%2A>方法可讓事件處理常式被叫用來回應檔案的變更，即使此屬性設定為`false`。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看在執行階段指定的目錄。 元件會設定為監看的變更在`LastWrite`和`LastAccess`時間、 建立、 刪除、 或重新命名目錄中的文字檔案。 如果變更、 建立或刪除檔案，檔案的路徑會列印到主控台。 重新命名檔案時，新舊路徑列印到主控台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>此範例中的命名空間。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.IO.FileSystemWatcher" /> object has been disposed.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The current operating system is not Microsoft Windows NT or later.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The directory specified in <see cref="P:System.IO.FileSystemWatcher.Path" /> could not be found.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.IO.FileSystemWatcher.Path" /> has not been set or is invalid.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends the initialization of a <see cref="T:System.IO.FileSystemWatcher" /> used on a form or used by another component. The initialization occurs at run time.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]設計環境會使用這個方法來結束一個元件的初始化用於表單或另一個元件所使用。 <xref:System.IO.FileSystemWatcher.BeginInit%2A>方法初始化開始。 使用<xref:System.IO.FileSystemWatcher.BeginInit%2A>和<xref:System.IO.FileSystemWatcher.EndInit%2A>方法可防止控制項完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when the instance of <see cref="T:System.IO.FileSystemWatcher" /> is unable to continue monitoring changes or when the internal buffer overflows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 會引發這個事件，只要項目會阻止<xref:System.IO.FileSystemWatcher>從監視變更的物件。 例如，如果物件正在監視遠端目錄中的變更，該目錄的連線已中斷，<xref:System.IO.FileSystemWatcher.Error>就會引發事件。  
  
 系統會通知您的檔案變更，並將這些變更儲存在緩衝區中的元件建立及傳遞至應用程式開發介面。 如果短時間內有許多變更，緩衝區會溢位。 這會導致遺失的目錄中的變更追蹤的元件，它只會提供概括性的告知。 增加緩衝區的大小很高，因為它來自非分頁記憶體無法空出的磁碟，因此保留緩衝區越小越好。 若要避免緩衝區溢位，請使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>， <xref:System.IO.FileSystemWatcher.Filter%2A>，和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>屬性篩選掉不必要的變更通知。  
  
> [!NOTE]
>  常見的檔案系統作業可能會引發多個事件。 例如，當檔案移到另一個，有數個目錄從<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引發事件。 移動檔案一種複雜的作業，包含多個簡單的作業，因此會引發多個事件。 同樣地，某些應用程式 （例如，防毒軟體） 可能會造成偵測到的其他檔案系統事件<xref:System.IO.FileSystemWatcher>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the filter string used to determine what files are monitored in a directory.</summary>
        <value>篩選條件字串。 預設值是"*。\*"（監看所有檔案）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要觀看所有檔案中的變更，設定<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為空字串 ("")。 若要觀察特定的檔案，將<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為檔案名稱。 例如，若要觀看檔案 MyDoc.txt 中變更，設定<xref:System.IO.FileSystemWatcher.Filter%2A>"MyDoc.txt"的屬性。 您也可以觀看中特定檔案類型的變更。 例如，若要監看的任何文字檔案中的變更，將<xref:System.IO.FileSystemWatcher.Filter%2A>"*.txt"的屬性。 使用多個篩選條件，例如"\*.txt&#124;\*.doc"不支援。  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A>之後可以變更屬性<xref:System.IO.FileSystemWatcher>物件已開始接收事件。  
  
 如需篩選出不想要通知的詳細資訊，請參閱<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>， <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>，和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性。  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> 接受萬用字元相符的檔案，如下列範例所示。  
  
|篩選條件字串|監看下列的檔案|  
|-------------------|---------------------------------|  
|*.\*|所有檔案 （預設值）。 空字串 ("") 也會監看所有檔案。|  
|*.txt|副檔名為"txt"的所有檔案。|  
|*recipe.doc|結束 「 配方 」 與 「 文件 」 延伸模組中的所有檔案。|  
|win*.xml|所有檔案開頭為"都 win"的副檔名為"xml"。|  
|銷售 * 200？。xls|符合下列項目：<br /><br /> 銷售年 7 月 2001.xlsSales Aug 2002.xlsSales 年 3 月 2004.xls<br /><br /> 但不符合：<br /><br /> 銷售年 11 月 1999.xls|  
|MyReport.Doc|監看只 MyReport.doc|  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看在執行階段指定的目錄。 元件會設定為監看的變更在`LastWrite`和`LastAccess`時間、 建立、 刪除、 或重新命名目錄中的文字檔案。 如果變更、 建立或刪除檔案，檔案的路徑會列印到主控台。 重新命名檔案時，新舊路徑列印到主控台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>此範例中的命名空間。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether subdirectories within the specified path should be monitored.</summary>
        <value>如果您想要監視子目錄，則為 <see langword="true" />；否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>至`true`當您想要監看的檔案和包含在透過所指定的目錄內的目錄變更通知<xref:System.IO.FileSystemWatcher.Path%2A>屬性，而其子目錄。 設定<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>屬性`false`有助於降低的通知傳送至內部緩衝區數目。 如需有關篩選出不想要通知的詳細資訊，請參閱<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性。  
  
 當`true`，<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>是透過整個子樹狀結構，而不只是直屬子系目錄的遞迴。 檔案或目錄子樹狀結構內的相對路徑會傳回在<xref:System.IO.FileSystemEventArgs.Name%2A>屬性<xref:System.IO.FileSystemEventArgs>和<xref:System.IO.RenamedEventArgs.OldName%2A>屬性<xref:System.IO.RenamedEventArgs>，視您監看的變更。 您可以取得的完整的路徑<xref:System.IO.FileSystemEventArgs.FullPath%2A>屬性<xref:System.IO.FileSystemEventArgs>和<xref:System.IO.RenamedEventArgs.OldFullPath%2A>屬性<xref:System.IO.RenamedEventArgs>，視您監看的變更。  
  
 如果您正在觀賞，目錄的子樹狀目錄中建立目錄和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>是`true`，將會自動保存該目錄。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the size (in bytes) of the internal buffer.</summary>
        <value>內部緩衝區大小 (以位元組為單位)。 預設為 8192 (8 KB)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以設定緩衝區為 4 KB 或更大，但不是能超過 64 KB。 如果您嘗試設定<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>捨棄屬性為小於 4096 個位元組，您的值和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性設定為 4096 個位元組。 為了達到最佳效能，使用 intel 的電腦上的 4 KB 的倍數。  
  
 系統通知檔案變更的元件，並將這些變更儲存在緩衝區中的元件建立及傳遞至應用程式開發介面。 每個事件都可以使用最多 16 個位元組的記憶體，不包括檔案名稱。 如果短時間內有許多變更，緩衝區會溢位。 這會導致遺失的目錄中的變更追蹤的元件，它只會提供概括性的告知。 增加緩衝區的大小，可以防止遺失檔案系統變更事件。 不過，增加緩衝區的大小是昂貴，因為它來自非分頁記憶體無法空出給磁碟，所以讓緩衝區越小越好。 若要避免緩衝區溢位，請使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>屬性篩選掉不必要的變更通知。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the type of changes to watch for.</summary>
        <value>其中一個 <see cref="T:System.IO.NotifyFilters" /> 值。 預設值為 <see langword="LastWrite" />、<see langword="FileName" /> 與 <see langword="DirectoryName" /> 的位元 OR 運算子組合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以結合的成員<xref:System.IO.NotifyFilters>監看一次變更多個類型的列舉。 例如，您可以觀看用於變更中檔案的大小，以及變更`LastWrite`時間。 這會引發事件，每當變更檔案或資料夾的大小或變更`LastWrite`檔案或資料夾的時間。  
  
 這是一種方式篩選掉不必要的通知。 如需有關篩選出不想要通知的詳細資訊，請參閱<xref:System.IO.FileSystemWatcher.Filter%2A>， <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>，和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看在執行階段指定的目錄。 元件會設定為監看的變更在`LastWrite`和`LastAccess`時間、 建立、 刪除、 或重新命名目錄中的文字檔案。 如果變更、 建立或刪除檔案，檔案的路徑會列印到主控台。 重新命名檔案時，新舊路徑列印到主控台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>此範例中的命名空間。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The value is not a valid bitwise OR combination of the <see cref="T:System.IO.NotifyFilters" /> values.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">The value that is being set is not valid.</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.IO.FileSystemWatcher.Changed" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> 變更大小、 系統屬性、 上次寫入時間、 上次存取時間或檔案或目錄中的受監視的目錄的安全性權限時呼叫。  
  
 使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>限制的事件數目的屬性時引發<xref:System.IO.FileSystemWatcher.Changed>處理事件。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>會建立一個檔案時，就會引發事件。 如果正在將檔案複製或傳送到監看的目錄中，<xref:System.IO.FileSystemWatcher.OnCreated%2A>會立即引發事件，後面接著一或多個<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.IO.FileSystemWatcher.Created" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 受監視的目錄中建立檔案或目錄時呼叫。  
  
 一些常見的動作，例如複製或移動檔案或目錄中，執行不直接對應到事件，而這些項目會導致引發的事件。 當您複製檔案或目錄時，系統就會引發<xref:System.IO.FileSystemWatcher.Created>要複製檔案，如果該目錄正在監看的目錄中的事件。 如果您複製的目錄已被另一個執行個體所監看<xref:System.IO.FileSystemWatcher>，就會引發任何事件。 例如，您建立兩個執行個體<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 設定要監看"C:\My Documents"和 FileSystemWatcher2 設定要監看 「 C:\Your 文件 」。 如果您將檔案從 「 我的文件 」 複製並貼到 「 您文件 」<xref:System.IO.FileSystemWatcher.Created>中 FileSystemWatcher2，便會引發事件，但不會引發事件的 FileSystemWatcher1。 不同於複製、 移動檔案或目錄，將會引發兩個事件。 上述範例中，如果您將檔案從 「 我的文件 」 移到 「 您文件 」，從<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 中，會引發事件和<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 中，會引發事件。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>會建立一個檔案時，就會引發事件。 如果正在將檔案複製或傳送到監看的目錄中，<xref:System.IO.FileSystemWatcher.OnCreated%2A>會立即引發事件，後面接著一或多個<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.FileSystemEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.IO.FileSystemWatcher.Deleted" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> 刪除檔案或目錄，在受監視的目錄中時呼叫。  
  
 一些常見的動作，例如複製或移動檔案或目錄中，執行不直接對應到事件，而這些項目會導致引發的事件。 當您複製檔案或目錄時，系統就會引發<xref:System.IO.FileSystemWatcher.Created>要複製檔案，如果該目錄正在監看的目錄中的事件。 如果您複製的目錄已被另一個執行個體所監看<xref:System.IO.FileSystemWatcher>，就會引發任何事件。 例如，您建立兩個執行個體<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 設定要監看"C:\My Documents"和 FileSystemWatcher2 設定要監看 「 C:\Your 文件 」。 如果您將檔案從 「 我的文件 」 複製到 「 您文件 」 <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，將會引發事件，但不會引發事件的 FileSystemWatcher1。 不同於複製、 移動檔案或目錄，將會引發兩個事件。 上述範例中，如果您將檔案從 「 我的文件 」 移到 「 您文件 」，從<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 會引發事件和<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 會引發事件。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">An <see cref="T:System.IO.ErrorEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.IO.FileSystemWatcher.Error" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> 錯誤發生時呼叫。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.IO.RenamedEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.IO.FileSystemWatcher.Renamed" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> 重新命名檔案或目錄內受監視的目錄時呼叫。 其<xref:System.IO.RenamedEventArgs>引數包含在重新命名作業，例如變更、 舊的和新路徑和舊的和新名稱的類型資訊。 請注意，其<xref:System.IO.FileSystemEventArgs.Name>屬性可能是 null 如果重新命名事件<xref:System.IO.FileSystemWatcher>不會取得不符作業系統從舊的和新名稱事件。 
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱[處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>在覆寫<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />在衍生類別中，請務必呼叫基底類別的<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />方法。</para>
        </block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the path of the directory to watch.</summary>
        <value>要監視的路徑。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是目錄的完整的路徑。 如果<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>屬性是`true`，此目錄是的根目錄的系統監控的變更; 否則就只有監看的目錄。 若要觀察特定的檔案，將<xref:System.IO.FileSystemWatcher.Path%2A>至完整的正確目錄中，屬性和<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為檔案名稱。  
  
 <xref:System.IO.FileSystemWatcher.Path%2A>屬性支援的通用命名慣例 (UNC) 路徑。  
  
> [!NOTE]
>  元件可以監看的變更之前，必須設定這個屬性。  
  
 當目錄已重新命名時，<xref:System.IO.FileSystemWatcher>重新本身會自動附加至剛重新命名的項目。 例如，如果您設定<xref:System.IO.FileSystemWatcher.Path%2A>"C:\My Documents"的屬性，然後手動重新命名 「 C:\Your 文件 」 的目錄元件會繼續接聽剛重新命名目錄上的變更通知。 不過，當您尋求<xref:System.IO.FileSystemWatcher.Path%2A>屬性，它含有舊的路徑。 這是因為此元件可讓您判斷監看基礎控制代碼，而不是目錄的名稱。 重新命名並不會影響此控制代碼。 因此，如果您損毀元件，並再重新建立它，而無須更新<xref:System.IO.FileSystemWatcher.Path%2A>屬性，您的應用程式會失敗，因為目錄不再存在。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看在執行階段指定的目錄。 元件會設定為監看的變更在`LastWrite`和`LastAccess`時間、 建立、 刪除、 或重新命名目錄中的文字檔案。 如果變更、 建立或刪除檔案，檔案的路徑會列印到主控台。 重新命名檔案時，新舊路徑列印到主控台。  
  
 使用<xref:System.Diagnostics>和<xref:System.IO>此範例中的命名空間。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The specified path does not exist or could not be found.  -or-  The specified path contains wildcard characters.  -or-  The specified path contains invalid path characters.</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a file or directory in the specified <see cref="P:System.IO.FileSystemWatcher.Path" /> is renamed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Renamed`事件是<xref:System.IO.RenamedEventHandler>具有下列簽章的委派：

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 <xref:System.IO.RenamedEventArgs>物件會提供有關在重新命名作業，例如重新命名的類型資訊 (<xref:System.IO.FileSystemEventArgs.ChangeType>屬性)，舊的和新名稱，而舊的和新的路徑。 請注意，<xref:System.IO.FileSystemEventArgs.Name>屬性可能是 null 如果重新命名事件<xref:System.IO.FileSystemWatcher>不會取得不符作業系統從舊的和新名稱事件。

 您監看的目錄重新命名將不會引發通知。 您監看的目錄內的項目，才會引發通知。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.FileSystemWatcher.Renamed>事件，以對主控台顯示的檔案路徑，每當重新命名保存的檔案。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an <see cref="T:System.ComponentModel.ISite" /> for the <see cref="T:System.IO.FileSystemWatcher" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> 的 <see cref="T:System.IO.FileSystemWatcher" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 站台繫結<xref:System.ComponentModel.Component>至<xref:System.ComponentModel.Design.IDesignerHost.Container%2A>和啟用它們之間的通訊，以及提供容器以管理其元件的方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the object used to marshal the event handler calls issued as a result of a directory change.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" />，代表用以封送處理因目錄變更而發出的事件處理常式呼叫的物件。 預設值為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>是`null`，方法處理<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，和<xref:System.IO.FileSystemWatcher.Renamed>系統執行緒集區的執行緒上呼叫事件。 如需有關系統執行緒集區的詳細資訊，請參閱<xref:System.Threading.ThreadPool>。  
  
 當<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，和<xref:System.IO.FileSystemWatcher.Renamed>事件由處理視覺化的 Windows Form 元件，例如<xref:System.Windows.Forms.Button>，透過系統執行緒集區存取元件可能無法運作，或可能會導致例外狀況。 避免這種設定<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>給 Windows Form 元件時，會導致處理的方法<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，和<xref:System.IO.FileSystemWatcher.Renamed>元件建立所在的相同執行緒上呼叫的事件。  
  
 如果<xref:System.IO.FileSystemWatcher>內使用[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows Form 設計工具中，<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>自動設定為包含的控制項<xref:System.IO.FileSystemWatcher>。 例如，如果您將放置<xref:System.IO.FileSystemWatcher>form1 設計工具上 (繼承自<xref:System.Windows.Forms.Form>)<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>屬性<xref:System.IO.FileSystemWatcher>設為 Form1 的執行個體。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>A synchronous method that returns a structure that contains specific information on the change that occurred.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">The <see cref="T:System.IO.WatcherChangeTypes" /> to watch for.</param>
        <summary>A synchronous method that returns a structure that contains specific information on the change that occurred, given the type of change you want to monitor.</summary>
        <returns>A <see cref="T:System.IO.WaitForChangedResult" /> that contains specific information on the change that occurred.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會等候直到第一個變更，就會發生，然後傳回。 這是使用相同<xref:System.IO.FileSystemWatcher.WaitForChanged%2A>與`timeout`參數設為-1。  
  
> [!NOTE]
>  這個方法可讓事件處理常式被叫用來回應檔案的變更，即使<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>屬性設定為`false`。  
  
 在某些系統上，<xref:System.IO.FileSystemWatcher>使用簡短的 8.3 檔案名稱格式的檔案來報告變更。 例如，"LongFileName.LongExtension 」 的變更無法回報為 「 LongFi ~。Lon"。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">The <see cref="T:System.IO.WatcherChangeTypes" /> to watch for.</param>
        <param name="timeout">The time (in milliseconds) to wait before timing out.</param>
        <summary>A synchronous method that returns a structure that contains specific information on the change that occurred, given the type of change you want to monitor and the time (in milliseconds) to wait before timing out.</summary>
        <returns>A <see cref="T:System.IO.WaitForChangedResult" /> that contains specific information on the change that occurred.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會等候直到發生變更或已逾時。值為-1 代表`timeout`參數表示無限期等候。  
  
> [!NOTE]
>  這個方法可讓事件處理常式被叫用來回應檔案的變更，即使<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>屬性設定為`false`。  
  
 在某些系統上，<xref:System.IO.FileSystemWatcher>使用簡短的 8.3 檔案名稱格式的檔案來報告變更。 例如，"LongFileName.LongExtension 」 的變更無法回報為 「 LongFi ~。Lon"。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>