<Type Name="FileSystemWatcher" FullName="System.IO.FileSystemWatcher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a41171f2bdab9b8632e28360edd7b39f00bce7b7" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56358702" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemWatcher : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileSystemWatcher extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileSystemWatcher" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemWatcher&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemWatcher : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type FileSystemWatcher = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Changed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.IO.IODescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.IO.IODescription("FileSystemWatcherDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>當目錄或目錄內的檔案變更時，接聽 (Listen) 檔案系統變更告知並引發事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileSystemWatcher>監看的指定目錄中的變更。 您可以監看的檔案和指定之目錄的子目錄中的變更。 您可以建立要監看檔案的本機電腦、 網路磁碟機或遠端電腦上的元件。  
  
 若要觀看的所有檔案中的變更，請設定<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為空字串 ("") 或使用萬用字元 ("*。\*")。 若要觀看的特定檔案，設定<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為檔案名稱。 例如，若要觀看 MyDoc.txt 檔案中的變更，請設定<xref:System.IO.FileSystemWatcher.Filter%2A>"MyDoc.txt"的屬性。 您也可以觀看某種類型的檔案中的變更。 例如，若要監看的文字檔案中的變更，將<xref:System.IO.FileSystemWatcher.Filter%2A>屬性為"\*.txt"。  
  
 有數種您可以監看目錄或檔案中的變更。 例如，您可以觀看中的變更`Attributes`，則`LastWrite`日期和時間，或`Size`的檔案或目錄。 這是藉由設定<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>屬性設為其中的<xref:System.IO.NotifyFilters>值。 如需詳細資訊的變更類型可以觀看，請參閱<xref:System.IO.NotifyFilters>。  
  
 您可以觀看的重新命名、 刪除或建立的檔案或目錄。 例如，若要觀看的文字檔案重新命名，設定<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為"*.txt"，並呼叫<xref:System.IO.FileSystemWatcher.WaitForChanged%2A>方法<xref:System.IO.WatcherChangeTypes.Renamed>其參數所指定。  
  
 Windows 作業系統會通知您有在緩衝區中所建立的檔案變更的元件<xref:System.IO.FileSystemWatcher>。 如果在短時間內有許多變更，緩衝區會溢位。 這會導致遺失的目錄中，變更追蹤的元件，它只會提供地毯式通知。 使用緩衝區的大小增加<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性很高，因為它來自無法空出給磁碟，所以還保留較少的緩衝區的非分頁記憶體大型足以不錯過任何檔案變更的事件。 若要避免緩衝區溢位，請使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>屬性，如此您可以篩選掉不必要的變更通知。  
  
 如需執行個體的初始屬性值的清單<xref:System.IO.FileSystemWatcher>，請參閱<xref:System.IO.FileSystemWatcher.%23ctor%2A>建構函式。  
  
 使用時，請注意下列<xref:System.IO.FileSystemWatcher>類別。  
  
-   隱藏的檔案不會被忽略。  
  
-   在某些系統中，<xref:System.IO.FileSystemWatcher>報告變更，使用簡短的 8.3 檔案名稱格式的檔案。 例如，"LongFileName.LongExtension 」 的變更無法回報為 「 LongFil ~。Lon"。  
  
-   這個類別包含的連結要求和繼承要求套用到所有成員的類別層級。 A<xref:System.Security.SecurityException>立即呼叫端或衍生的類別不具有完全信任權限時，會擲回。 如需安全性需求的詳細資訊，請參閱[連結要求](~/docs/framework/misc/link-demands.md)。  
  
-   您可以設定的大小上限<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性透過網路監視的目錄是 64 KB。  
  
> [!NOTE]
>  執行<xref:System.IO.FileSystemWatcher>在 Windows 98 不支援。  
  
## <a name="copying-and-moving-folders"></a>複製和移動資料夾  
 作業系統和<xref:System.IO.FileSystemWatcher>物件解譯剪下和貼上動作或 move 動作的資料夾和其內容重新命名動作。 如果您剪下並將資料夾與檔案貼到正在監看資料夾<xref:System.IO.FileSystemWatcher>物件會報告為新的資料夾，但不是包括其內容因為基本上只重新命名。  
  
 若要收到資料夾的內容已移動或複製到監看的資料夾中，提供<xref:System.IO.FileSystemWatcher.OnChanged%2A>和<xref:System.IO.FileSystemWatcher.OnRenamed%2A>事件處理常式方法下, 表中的建議。  
  
|事件處理常式|處理的事件|執行|  
|-------------------|--------------------|--------------|  
|<xref:System.IO.FileSystemWatcher.OnChanged%2A>|<xref:System.IO.FileSystemWatcher.Changed>, <xref:System.IO.FileSystemWatcher.Created>, <xref:System.IO.FileSystemWatcher.Deleted>|報告檔案屬性、 建立的檔案和已刪除的檔案中的變更。|  
|<xref:System.IO.FileSystemWatcher.OnRenamed%2A>|<xref:System.IO.FileSystemWatcher.Renamed>|列出舊和新的路徑重新命名的檔案和資料夾，如有需要請展開以遞迴方式。|  
  
## <a name="events-and-buffer-sizes"></a>事件和緩衝區大小  
 請注意，數個因素會影響哪些檔案系統變更會引發事件，如以下所述：  
  
-   常見的檔案系統作業可能會引發多個事件。 比方說，當檔案移到另一個、 數個目錄之間<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引發事件。 移動檔案簡單的多個作業所組成的複雜作業，因此會引發多個事件。 同樣地，某些應用程式 （例如，防毒軟體） 可能會導致所偵測到的其他檔案系統事件<xref:System.IO.FileSystemWatcher>。  
  
-   <xref:System.IO.FileSystemWatcher>可以觀看磁碟，只要它們不會切換，或移除。 <xref:System.IO.FileSystemWatcher>不會引發事件的 Cd 與 Dvd，因為時間戳記和屬性無法變更。 遠端電腦必須安裝之元件正確運作所需的平台之一。  
  
-   如果有多個<xref:System.IO.FileSystemWatcher>物件所監看 Windows XP Service Pack 1 之前相同的 UNC 路徑，或 Windows 2000 SP2 或更早版本，則只有其中一個物件，則會引發事件。 在機器上執行 Windows XP SP1 和更新版本中，Windows 2000 SP3 或更新版本或 Windows Server 2003，所有<xref:System.IO.FileSystemWatcher>物件將會引發適當的事件。  
  
 請注意，<xref:System.IO.FileSystemWatcher>可能會遺失超過緩衝區大小時的事件。 若要避免遺失事件，請遵循這些指導方針：  
  
-   藉由設定增加緩衝區大小<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性。  
  
-   避免監看檔案具有長檔名，因為長檔名的層面得以填滿緩衝區。 請考慮重新命名這些檔案，使用較短的名稱。  
  
-   保留您的事件處理程式碼越短越好。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看在執行階段指定的目錄。 元件會設定為監看的變更`LastWrite`和`LastAccess`時間、 建立、 刪除或重新命名的目錄中的文字檔案。 如果變更、 建立，或刪除檔案，檔案的路徑會列印至主控台。 重新命名檔案時，新舊路徑列印到主控台。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">針對衍生自<see cref="T:System.Diagnostics.ProcessStartInfo" />類別。 要求值： <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />;具名使用權限集合： <see langword="FullTrust" />。</permission>
    <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
    <altmember cref="T:System.IO.NotifyFilters" />
    <altmember cref="T:System.IO.FileSystemEventArgs" />
    <altmember cref="T:System.IO.FileSystemEventHandler" />
    <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
    <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
    <altmember cref="T:System.IO.InternalBufferOverflowException" />
    <altmember cref="T:System.IO.RenamedEventArgs" />
    <altmember cref="T:System.IO.RenamedEventHandler" />
    <altmember cref="T:System.IO.WaitForChangedResult" />
    <altmember cref="T:System.IO.WatcherChangeTypes" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Using-a-FileSystemWatcher-4bc97af4">在 Windows Form 中使用 FileSystemWatcher 元件</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.IO.FileSystemWatcher" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.IO.FileSystemWatcher" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您無法查看遠端電腦沒有 Windows NT 或 Windows 2000。 您無法監看遠端的 Windows NT 4.0 電腦從 Windows NT 4.0 的電腦。  
  
 下表顯示的執行個體的初始屬性值<xref:System.IO.FileSystemWatcher>。  
  
|屬性|初始值|  
|--------------|-------------------|  
|<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>|位元 OR 組合`LastWrite`， `FileName`，及 `DirectoryName`|  
|<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.Filter%2A>|"*.\*"（監看所有檔案。）|  
|<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>|`false`|  
|<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>|8192|  
|<xref:System.IO.FileSystemWatcher.Path%2A>|空字串 ("")|  
  
> [!NOTE]
>  元件將無法觀賞到指定的目錄<xref:System.IO.FileSystemWatcher.Path%2A>設定，並<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看在執行階段指定的目錄物件。 <xref:System.IO.FileSystemWatcher>中的變更的物件會監看`LastWrite`和`LastAccess`時間，同時建立、 刪除或重新命名的文字中的檔案目錄。 如果變更、 建立，或刪除檔案，檔案的路徑會顯示到主控台。 當檔案已重新命名時，則會在對主控台顯示的舊和新路徑。  
  
 這個範例會使用<xref:System.Diagnostics>和<xref:System.IO>命名空間。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要監視的目錄，使用標準或通用命名慣例標記法。</param>
        <summary>提供要監視的指定目錄，來初始化 <see cref="T:System.IO.FileSystemWatcher" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  元件將無法觀賞到指定的目錄<xref:System.IO.FileSystemWatcher.Path%2A>設定，並<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 元件可以監看您的個人電腦、 網路磁碟機或遠端電腦上的檔案。  
  
 您無法查看遠端電腦沒有 Windows NT 或 Windows 2000。 您無法監看遠端的 Windows NT 4.0 電腦從 Windows NT 4.0 的電腦。 <xref:System.IO.FileSystemWatcher.Filter%2A>屬性設定預設為監看所有檔案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 參數是空字串 ("")。  
  
-或- 
透過 <paramref name="path" /> 參數指定的路徑不存在。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> 太長。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileSystemWatcher (string path, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, filter As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileSystemWatcher(System::String ^ path, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="new System.IO.FileSystemWatcher : string * string -&gt; System.IO.FileSystemWatcher" Usage="new System.IO.FileSystemWatcher (path, filter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要監視的目錄，使用標準或通用命名慣例標記法。</param>
        <param name="filter">要監看的檔案類型。 例如，"*.txt" 監看所有文字檔的變更。</param>
        <summary>提供要監視的指定目錄和檔案類型，來初始化 <see cref="T:System.IO.FileSystemWatcher" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  元件將無法觀賞到指定的目錄<xref:System.IO.FileSystemWatcher.Path%2A>設定，並<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 元件可以監看您的個人電腦、 網路磁碟機或遠端電腦上的檔案。  
  
 您無法查看遠端電腦沒有 Windows NT 或 Windows 2000。 您無法監看遠端的 Windows NT 4.0 電腦從 Windows NT 4.0 的電腦。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 參數為 <see langword="null" />。  
  
-或- 
<paramref name="filter" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 參數是空字串 ("")。  
  
-或- 
透過 <paramref name="path" /> 參數指定的路徑不存在。</exception>
        <exception cref="T:System.IO.PathTooLongException"><paramref name="path" /> 太長。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">針對完全信任立即呼叫端。 這個成員無法供部分信任的程式碼使用。</permission>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
        <altmember cref="T:System.IO.WaitForChangedResult" />
        <altmember cref="T:System.IO.WatcherChangeTypes" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="fileSystemWatcher.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>開始初始化用於表單或為另一個元件所使用的 <see cref="T:System.IO.FileSystemWatcher" />。 初始化發生於執行階段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]設計環境會使用這個方法來啟動元件的初始化用於表單或另一個元件所使用。 <xref:System.IO.FileSystemWatcher.EndInit%2A>方法結束初始化。 使用<xref:System.IO.FileSystemWatcher.BeginInit%2A>和<xref:System.IO.FileSystemWatcher.EndInit%2A>方法，防止控制項被完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : System.IO.FileSystemEventHandler " Usage="member this.Changed : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory change matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Changed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生在指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 內的檔案或目錄變更時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.Changed>對大小變更時引發事件時，系統屬性、 上次寫入時間、 上次存取時間或檔案或目錄的安全性權限的受監視的目錄中。  
  
> [!NOTE]
>  常見的檔案系統作業可能會引發多個事件。 比方說，當檔案移到另一個、 數個目錄之間<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引發事件。 移動檔案簡單的多個作業所組成的複雜作業，因此會引發多個事件。 同樣地，某些應用程式 （例如，防毒軟體） 可能會導致所偵測到的其他檔案系統事件<xref:System.IO.FileSystemWatcher>。  
  
 使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>限制時處理這個事件引發的通知數目。  
  
> [!NOTE]
>  <xref:System.IO.FileSystemWatcher.Changed>時檔案重新命名，但不是會在重新命名目錄時所引發非預期地引發事件。 若要觀看重新命名，請使用<xref:System.IO.FileSystemWatcher.Renamed>事件。  
  
> [!NOTE]
>  順序<xref:System.IO.FileSystemWatcher.Changed>就會引發事件，與其他<xref:System.IO.FileSystemWatcher>事件可能會變更時<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>屬性不是`null`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.FileSystemWatcher.Changed>事件，以監看的檔案變更時，對主控台顯示的檔案路徑。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Created;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Created" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Created" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Created As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Created;" />
      <MemberSignature Language="F#" Value="member this.Created : System.IO.FileSystemEventHandler " Usage="member this.Created : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory creation matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Created")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生在指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 內的檔案或目錄建立時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一些常見的相符項目，例如複製或移動檔案或目錄中，執行未直接對應到事件，但這些項目，並會造成要引發事件。 當您複製檔案或目錄時，系統就會引發<xref:System.IO.FileSystemWatcher.Created>要將檔案複製，如果該目錄正在監看的目錄中的事件。 如果您複製的目錄就正在由另一個執行個體所監看<xref:System.IO.FileSystemWatcher>，就會引發任何事件。 例如，您會建立兩個執行個體<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 設為觀看"C:\My Documents"，而 FileSystemWatcher2 設觀看 「 C:\Your 文件 」。 如果您將檔案從 「 我的文件 」 複製到 您的文件 」， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，將會引發事件，但不會引發事件的 FileSystemWatcher1。 不同於複製、 移動檔案或目錄將會引發兩個事件。 上述範例中，如果將檔案從 「 我的文件 」 移到 您的文件 」，從<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 會引發事件和<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 會引發事件。  
  
> [!NOTE]
>  常見的檔案系統作業可能會引發多個事件。 比方說，當檔案移到另一個、 數個目錄之間<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引發事件。 移動檔案簡單的多個作業所組成的複雜作業，因此會引發多個事件。 同樣地，某些應用程式 （例如，防毒軟體） 可能會導致所偵測到的其他檔案系統事件<xref:System.IO.FileSystemWatcher>。  
  
> [!NOTE]
>  順序<xref:System.IO.FileSystemWatcher.Created>就會引發事件，與其他<xref:System.IO.FileSystemWatcher>事件可能會變更時<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>屬性不是`null`。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>只要建立檔案時，就會引發事件。 如果正在將檔案複製或傳送到監看的目錄中，<xref:System.IO.FileSystemWatcher.OnCreated%2A>事件會立即引發，後面接著一或多個<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.FileSystemWatcher.Created>事件，以建立監看的檔案時，對主控台顯示的檔案路徑。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Deleted">
      <MemberSignature Language="C#" Value="public event System.IO.FileSystemEventHandler Deleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.FileSystemEventHandler Deleted" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Deleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deleted As FileSystemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::FileSystemEventHandler ^ Deleted;" />
      <MemberSignature Language="F#" Value="member this.Deleted : System.IO.FileSystemEventHandler " Usage="member this.Deleted : System.IO.FileSystemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory deletion matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Deleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.FileSystemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生在指定 <see cref="P:System.IO.FileSystemWatcher.Path" /> 內的檔案或目錄刪除時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一些常見的相符項目，例如複製或移動檔案或目錄中，執行未直接對應到事件，但這些項目，並會造成要引發事件。 當您複製檔案或目錄時，系統就會引發<xref:System.IO.FileSystemWatcher.Created>要將檔案複製，如果該目錄正在監看的目錄中的事件。 如果您複製的目錄就正在由另一個執行個體所監看<xref:System.IO.FileSystemWatcher>，就會引發任何事件。 例如，您會建立兩個執行個體<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 設為觀看"C:\My Documents"，而 FileSystemWatcher2 設觀看 「 C:\Your 文件 」。 如果您將檔案從 「 我的文件 」 複製到 您的文件 」， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，將會引發事件，但不會引發事件的 FileSystemWatcher1。 不同於複製、 移動檔案或目錄將會引發兩個事件。 上述範例中，如果將檔案從 「 我的文件 」 移到 您的文件 」，從<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 會引發事件和<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 會引發事件。  
  
> [!NOTE]
>  常見的檔案系統作業可能會引發多個事件。 比方說，當檔案移到另一個、 數個目錄之間<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引發事件。 移動檔案簡單的多個作業所組成的複雜作業，因此會引發多個事件。 同樣地，某些應用程式 （例如，防毒軟體） 可能會導致所偵測到的其他檔案系統事件<xref:System.IO.FileSystemWatcher>。  
  
> [!NOTE]
>  順序<xref:System.IO.FileSystemWatcher.Deleted>就會引發事件，與其他<xref:System.IO.FileSystemWatcher>事件可能會變更時<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>屬性不是`null`。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.FileSystemWatcher.Deleted>事件，每當刪除監看的檔案時，對主控台顯示的檔案路徑。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="fileSystemWatcher.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileSystemWatcher.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示會同時釋放 Managed 和 Unmanaged 資源，<see langword="false" /> 則表示只釋放 Unmanaged 資源。</param>
        <summary>釋放 <see cref="T:System.IO.FileSystemWatcher" /> 所使用的 Unmanaged 資源，並選擇性地釋放 Managed 資源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會呼叫公用<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。 <xref:System.ComponentModel.Component.Dispose%2A> 叫用受保護<xref:System.IO.FileSystemWatcher.Dispose%2A>方法`disposing`參數設為`true`。 <xref:System.Object.Finalize%2A> 叫用<xref:System.IO.FileSystemWatcher.Dispose%2A>具有`disposing`設定為`false`。  
  
 `disposing` 參數為 `true` 時，這個方法會釋放 <xref:System.IO.Compression.DeflateStream> 參考的任何 Managed 物件所掌握的資源。 這個方法會叫用每個參考物件的 <xref:System.ComponentModel.Component.Dispose%2A> 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> 可以被其他物件呼叫多次。 當覆寫<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />小心不要參考先前處置好的呼叫中的物件<see cref="M:System.ComponentModel.Component.Dispose" />。 如需有關如何實作<see cref="M:System.IO.FileSystemWatcher.Dispose(System.Boolean)" />，請參閱 &lt;&lt;c2&gt; [ 實作 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
如需詳細資訊<see cref="M:System.ComponentModel.Component.Dispose" />並<see cref="M:System.Object.Finalize" />，請參閱[清除 Unmanaged 資源總](~/docs/standard/garbage-collection/unmanaged.md)。</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.IO.FileSystemWatcher.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate if this instance is active")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Enabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定數值，表示是否啟用元件。</summary>
        <value>如果啟用元件，則為 <see langword="true" />，否則，<see langword="false" />。 預設為 <see langword="false" />。 如果您是在 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] 中使用設計工具上的元件，則預設值為 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元件不會引發事件，除非您設定<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>至`true`。  
  
> [!NOTE]
>  元件將無法觀賞到指定的目錄<xref:System.IO.FileSystemWatcher.Path%2A>屬性已設定並<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>是`true`。  
  
 <xref:System.IO.FileSystemWatcher.WaitForChanged%2A>方法可讓事件處理常式被叫用來回應檔案的變更，即使這個屬性設定為`false`。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看在執行階段指定的目錄。 元件會設定為監看的變更`LastWrite`和`LastAccess`時間、 建立、 刪除或重新命名的目錄中的文字檔案。 如果變更、 建立，或刪除檔案，檔案的路徑會列印至主控台。 重新命名檔案時，新舊路徑列印到主控台。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.IO.FileSystemWatcher" /> 物件已經處置。</exception>
        <exception cref="T:System.PlatformNotSupportedException">目前的作業系統不是 Microsoft Windows NT (含) 以後版本。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到在 <see cref="P:System.IO.FileSystemWatcher.Path" /> 中指定的目錄。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.IO.FileSystemWatcher.Path" /> 尚未設定或無效。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="fileSystemWatcher.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>結束用於表單上或用於另一個元件的 <see cref="T:System.IO.FileSystemWatcher" /> 初始化。 初始化發生於執行階段。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]設計環境會使用這個方法最後一個元件的初始化用於表單或另一個元件所使用。 <xref:System.IO.FileSystemWatcher.BeginInit%2A>方法會啟動初始化。 使用<xref:System.IO.FileSystemWatcher.BeginInit%2A>和<xref:System.IO.FileSystemWatcher.EndInit%2A>方法，防止控制項被完全初始化之前使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.IO.ErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.ErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As ErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::ErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.ErrorEventHandler " Usage="member this.Error : System.IO.ErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.ErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.IO.FileSystemWatcher" /> 執行個體無法繼續執行監視變更時或在內部緩衝區溢位時發生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件的引發的項目可防止<xref:System.IO.FileSystemWatcher>從監視變更的物件。 例如，如果物件正在監視遠端目錄中的變更，而且該目錄的連線都會遺失，<xref:System.IO.FileSystemWatcher.Error>就會引發事件。  
  
 系統會通知您的檔案變更，並將那些變更儲存在緩衝區中的元件會建立並傳遞至 Api。 如果在短時間內有許多變更，緩衝區會溢位。 這會導致遺失的目錄中，變更追蹤的元件，它只會提供地毯式通知。 增加緩衝區的大小很高，因為它是來自非分頁記憶體無法空出至磁碟，因此保持越小越好的緩衝區。 若要避免緩衝區溢位，請使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>， <xref:System.IO.FileSystemWatcher.Filter%2A>，和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>篩選掉不必要的屬性變更通知。  
  
> [!NOTE]
>  常見的檔案系統作業可能會引發多個事件。 比方說，當檔案移到另一個、 數個目錄之間<xref:System.IO.FileSystemWatcher.OnChanged%2A>和某些<xref:System.IO.FileSystemWatcher.OnCreated%2A>和<xref:System.IO.FileSystemWatcher.OnDeleted%2A>可能引發事件。 移動檔案簡單的多個作業所組成的複雜作業，因此會引發多個事件。 同樣地，某些應用程式 （例如，防毒軟體） 可能會導致所偵測到的其他檔案系統事件<xref:System.IO.FileSystemWatcher>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.IO.FileSystemWatcher.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("*.*")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("File name filter pattern")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定篩選字串，用以判斷在目錄中監視什麼檔案。</summary>
        <value>篩選條件字串。 預設值是"*。\*"（監看所有檔案）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要觀看的所有檔案中的變更，請設定<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為空字串 ("")。 若要觀看的特定檔案，設定<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為檔案名稱。 例如，若要觀看 MyDoc.txt 檔案中的變更，請設定<xref:System.IO.FileSystemWatcher.Filter%2A>"MyDoc.txt"的屬性。 您也可以觀看某種類型的檔案中的變更。 例如，若要監看的任何文字檔案中的變更，將<xref:System.IO.FileSystemWatcher.Filter%2A>"*.txt"的屬性。 使用多個篩選條件，例如"\*.txt&#124;\*.doc"不支援。  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A>之後，就可以變更屬性<xref:System.IO.FileSystemWatcher>物件已開始接收事件。  
  
 如需有關篩選掉不想要通知的詳細資訊，請參閱<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>， <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>，和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性。  
  
 <xref:System.IO.FileSystemWatcher.Filter%2A> 接受萬用字元相符的檔案，如下列範例所示。  
  
|篩選字串|監看下列的檔案|  
|-------------------|---------------------------------|  
|*.\*|所有檔案 （預設值）。 空字串 ("") 也會監看所有檔案。|  
|*.txt|副檔名為"txt"的所有檔案。|  
|*recipe.doc|結尾為 「 配方 」 與 「 文件 」 延伸模組的所有檔案。|  
|win*.xml|副檔名為"xml"開頭"win"的所有檔案。|  
|銷售 * 200？。xls|符合下列項目：<br /><br /> 銷售年 7 月 2001.xlsSales Aug 2002.xlsSales 年 3 月 2004.xls<br /><br /> 但不符合：<br /><br /> 銷售年 11 月 1999.xls|  
|MyReport.Doc|監看式唯一 MyReport.doc|  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看在執行階段指定的目錄。 元件會設定為監看的變更`LastWrite`和`LastAccess`時間、 建立、 刪除或重新命名的目錄中的文字檔案。 如果變更、 建立，或刪除檔案，檔案的路徑會列印至主控台。 重新命名檔案時，新舊路徑列印到主控台。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="Filters">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;string&gt; Filters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;string&gt; Filters" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Filters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Filters As Collection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ Filters { System::Collections::ObjectModel::Collection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Filters : System.Collections.ObjectModel.Collection&lt;string&gt;" Usage="System.IO.FileSystemWatcher.Filters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileSystemWatcher ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileSystemWatcher ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileSystemWatcher.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeSubdirectories">
      <MemberSignature Language="C#" Value="public bool IncludeSubdirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeSubdirectories" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeSubdirectories As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeSubdirectories { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeSubdirectories : bool with get, set" Usage="System.IO.FileSystemWatcher.IncludeSubdirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate we want to watch subdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_IncludeSubdirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定數值，表示是否應該監視指定路徑內的子目錄。</summary>
        <value>如果您想要監視子目錄，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>要`true`當您想要監看的檔案和目錄包含在透過所指定的目錄內的變更通知<xref:System.IO.FileSystemWatcher.Path%2A>屬性和其子目錄。 設定<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>屬性設`false`有助於降低的通知傳送至內部緩衝區數目。 如需有關篩選掉不想要通知的詳細資訊，請參閱<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性。  
  
 當`true`，<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>是透過整個子樹狀結構，而不只是直屬子目錄遞迴。 中的檔案或目錄子樹狀結構中的相對路徑傳回<xref:System.IO.FileSystemEventArgs.Name%2A>屬性<xref:System.IO.FileSystemEventArgs>並<xref:System.IO.RenamedEventArgs.OldName%2A>屬性<xref:System.IO.RenamedEventArgs>，取決於您所監看的變更。 您可以取得的完整的路徑<xref:System.IO.FileSystemEventArgs.FullPath%2A>屬性<xref:System.IO.FileSystemEventArgs>並<xref:System.IO.RenamedEventArgs.OldFullPath%2A>屬性<xref:System.IO.RenamedEventArgs>，取決於您所監看的變更。  
  
 如果您正在觀賞，目錄的子樹狀目錄中會建立一個目錄並<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>是`true`，自動會監看該目錄。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemEventArgs.FullPath" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldFullPath" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
        <altmember cref="P:System.IO.FileSystemEventArgs.Name" />
        <altmember cref="P:System.IO.RenamedEventArgs.OldName" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="InternalBufferSize">
      <MemberSignature Language="C#" Value="public int InternalBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 InternalBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property InternalBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int InternalBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.InternalBufferSize : int with get, set" Usage="System.IO.FileSystemWatcher.InternalBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(8192)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定內部緩衝區的大小 (以位元組為單位)。</summary>
        <value>內部緩衝區大小 (以位元組為單位)。 預設為 8192 (8 KB)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以設定緩衝區為 4 KB 或更大，但它不能超過 64 KB。 如果您嘗試設定<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>捨棄屬性為小於 4096 個位元組，您的值和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性設定為 4096 個位元組。 為了達到最佳效能，使用 Intel 架構的電腦上的 4 KB 的倍數。  
  
 系統會通知檔案變更的元件，並將這些變更儲存在緩衝區中的元件會建立並傳遞至 Api。 每個事件都可以使用最多 16 個位元組的記憶體，不包括檔案名稱。 如果在短時間內有許多變更，緩衝區會溢位。 這會導致遺失的目錄中，變更追蹤的元件，它只會提供地毯式通知。 增加緩衝區的大小可以避免遺失檔案系統變更事件。 不過，增加緩衝區大小是昂貴，因為它來自無法空出給磁碟，所以讓緩衝區越小越好的非分頁記憶體。 若要避免緩衝區溢位，請使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>和<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>篩選掉不必要的屬性變更通知。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="NotifyFilter">
      <MemberSignature Language="C#" Value="public System.IO.NotifyFilters NotifyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.NotifyFilters NotifyFilter" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyFilter As NotifyFilters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::NotifyFilters NotifyFilter { System::IO::NotifyFilters get(); void set(System::IO::NotifyFilters value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyFilter : System.IO.NotifyFilters with get, set" Usage="System.IO.FileSystemWatcher.NotifyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Flag to indicate which change event we want to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_ChangedFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.NotifyFilters</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要監看的變更類型。</summary>
        <value>其中一個 <see cref="T:System.IO.NotifyFilters" /> 值。 預設值為 <see langword="LastWrite" />、<see langword="FileName" /> 和 <see langword="DirectoryName" /> 的位元的 OR 運算子組合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以結合的成員<xref:System.IO.NotifyFilters>監看的變更一次的一種以上類型的列舉。 例如，您可以在其中觀看變更檔案的大小，以及變更`LastWrite`時間。 這會引發事件，只要變更檔案或資料夾的大小，或變更`LastWrite`檔案或資料夾的時間。  
  
 這是一種方式篩選掉不必要的通知。 如需有關篩選掉不想要通知的詳細資訊，請參閱<xref:System.IO.FileSystemWatcher.Filter%2A>， <xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>，和<xref:System.IO.FileSystemWatcher.InternalBufferSize%2A>屬性。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看在執行階段指定的目錄。 元件會設定為監看的變更`LastWrite`和`LastAccess`時間、 建立、 刪除或重新命名的目錄中的文字檔案。 如果變更、 建立，或刪除檔案，檔案的路徑會列印至主控台。 重新命名檔案時，新舊路徑列印到主控台。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">其值不是 <see cref="T:System.IO.NotifyFilters" /> 值的有效位元的 OR 運算子組合。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">要設定的值無效。</exception>
        <altmember cref="T:System.IO.NotifyFilters" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
        <altmember cref="P:System.IO.FileSystemWatcher.IncludeSubdirectories" />
        <altmember cref="P:System.IO.FileSystemWatcher.InternalBufferSize" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.IO.FileSystemEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.IO.FileSystemWatcher.Changed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnChanged%2A> 變更大小、 系統屬性、 上次寫入時間、 上次存取時間或檔案或目錄中的目錄受監視的安全性權限時呼叫。  
  
 使用<xref:System.IO.FileSystemWatcher.NotifyFilter%2A>限制的事件數目的屬性時引發<xref:System.IO.FileSystemWatcher.Changed>處理事件。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>只要建立檔案時，就會引發事件。 如果正在將檔案複製或傳送到監看的目錄中，<xref:System.IO.FileSystemWatcher.OnCreated%2A>事件會立即引發，後面接著一或多個<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>當覆寫<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />衍生類別時，請務必呼叫基底類別的<see cref="M:System.IO.FileSystemWatcher.OnChanged(System.IO.FileSystemEventArgs)" />方法。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Changed" />
        <altmember cref="P:System.IO.FileSystemWatcher.NotifyFilter" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnCreated">
      <MemberSignature Language="C#" Value="protected void OnCreated (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCreated(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCreated (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCreated(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnCreated : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.IO.FileSystemEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.IO.FileSystemWatcher.Created" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A> 受監視的目錄中建立檔案或目錄時呼叫。  
  
 一些常見的相符項目，例如複製或移動檔案或目錄中，執行未直接對應到事件，但這些項目，並會造成要引發事件。 當您複製檔案或目錄時，系統就會引發<xref:System.IO.FileSystemWatcher.Created>要將檔案複製，如果該目錄正在監看的目錄中的事件。 如果您複製的目錄就正在由另一個執行個體所監看<xref:System.IO.FileSystemWatcher>，就會引發任何事件。 例如，您會建立兩個執行個體<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 設為觀看"C:\My Documents"，而 FileSystemWatcher2 設觀看 「 C:\Your 文件 」。 如果您從 我的文件 複製檔案，並將它貼到 您的文件 」，<xref:System.IO.FileSystemWatcher.Created>中 FileSystemWatcher2，便會引發事件，但不會引發事件的 FileSystemWatcher1。 不同於複製、 移動檔案或目錄，將會引發兩個事件。 上述範例中，如果將檔案從 「 我的文件 」 移到 您的文件 」，從<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 中，會引發事件和<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 中，會引發事件。  
  
 <xref:System.IO.FileSystemWatcher.OnCreated%2A>只要建立檔案時，就會引發事件。 如果正在將檔案複製或傳送到監看的目錄中，<xref:System.IO.FileSystemWatcher.OnCreated%2A>事件會立即引發，後面接著一或多個<xref:System.IO.FileSystemWatcher.OnChanged%2A>事件。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>當覆寫<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />衍生類別時，請務必呼叫基底類別的<see cref="M:System.IO.FileSystemWatcher.OnCreated(System.IO.FileSystemEventArgs)" />方法。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnDeleted">
      <MemberSignature Language="C#" Value="protected void OnDeleted (System.IO.FileSystemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnDeleted(class System.IO.FileSystemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnDeleted (e As FileSystemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnDeleted(System::IO::FileSystemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnDeleted : System.IO.FileSystemEventArgs -&gt; unit" Usage="fileSystemWatcher.OnDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.FileSystemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.IO.FileSystemEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.IO.FileSystemWatcher.Deleted" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnDeleted%2A> 刪除檔案或目錄，在受監視的目錄內時呼叫。  
  
 一些常見的相符項目，例如複製或移動檔案或目錄中，執行未直接對應到事件，但這些項目，並會造成要引發事件。 當您複製檔案或目錄時，系統就會引發<xref:System.IO.FileSystemWatcher.Created>要將檔案複製，如果該目錄正在監看的目錄中的事件。 如果您複製的目錄就正在由另一個執行個體所監看<xref:System.IO.FileSystemWatcher>，就會引發任何事件。 例如，您會建立兩個執行個體<xref:System.IO.FileSystemWatcher>。 FileSystemWatcher1 設為觀看"C:\My Documents"，而 FileSystemWatcher2 設觀看 「 C:\Your 文件 」。 如果您將檔案從 「 我的文件 」 複製到 您的文件 」， <xref:System.IO.FileSystemWatcher.Created> FileSystemWatcher2，將會引發事件，但不會引發事件的 FileSystemWatcher1。 不同於複製、 移動檔案或目錄，將會引發兩個事件。 上述範例中，如果將檔案從 「 我的文件 」 移到 您的文件 」，從<xref:System.IO.FileSystemWatcher.Created>FileSystemWatcher2 會引發事件和<xref:System.IO.FileSystemWatcher.Deleted>FileSystemWatcher1 會引發事件。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>當覆寫<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />衍生類別時，請務必呼叫基底類別的<see cref="M:System.IO.FileSystemWatcher.OnDeleted(System.IO.FileSystemEventArgs)" />方法。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Created" />
        <altmember cref="E:System.IO.FileSystemWatcher.Deleted" />
        <altmember cref="T:System.IO.FileSystemEventArgs" />
        <altmember cref="T:System.IO.FileSystemEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnError">
      <MemberSignature Language="C#" Value="protected void OnError (System.IO.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnError(class System.IO.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnError(System::IO::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnError : System.IO.ErrorEventArgs -&gt; unit" Usage="fileSystemWatcher.OnError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件資料的 <see cref="T:System.IO.ErrorEventArgs" />。</param>
        <summary>引發 <see cref="E:System.IO.FileSystemWatcher.Error" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnError%2A> 發生錯誤時呼叫。  
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>當覆寫<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />衍生類別時，請務必呼叫基底類別的<see cref="M:System.IO.FileSystemWatcher.OnError(System.IO.ErrorEventArgs)" />方法。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Error" />
        <altmember cref="T:System.IO.ErrorEventArgs" />
        <altmember cref="T:System.IO.ErrorEventHandler" />
        <altmember cref="T:System.IO.InternalBufferOverflowException" />
      </Docs>
    </Member>
    <Member MemberName="OnRenamed">
      <MemberSignature Language="C#" Value="protected void OnRenamed (System.IO.RenamedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRenamed(class System.IO.RenamedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRenamed (e As RenamedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRenamed(System::IO::RenamedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRenamed : System.IO.RenamedEventArgs -&gt; unit" Usage="fileSystemWatcher.OnRenamed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IO.RenamedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.IO.RenamedEventArgs" />，其中包含事件資料。</param>
        <summary>引發 <see cref="E:System.IO.FileSystemWatcher.Renamed" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileSystemWatcher.OnRenamed%2A> 檔案或目錄內要監視的目錄已重新命名時呼叫。 其<xref:System.IO.RenamedEventArgs>引數包含在重新命名作業，例如變更、 的舊和新的路徑，以及舊的和新名稱的類型的相關資訊。 請注意，其<xref:System.IO.FileSystemEventArgs.Name>屬性可能為 null 如果重新命名事件<xref:System.IO.FileSystemWatcher>不會取得符合從作業系統的新舊名稱事件。 
  
 引發事件會透過委派叫用此事件處理常式。 如需詳細資訊，請參閱 <<c0> [ 處理和引發事件](~/docs/standard/events/index.md)。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>當覆寫<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />衍生類別時，請務必呼叫基底類別的<see cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />方法。</para></block>
        <altmember cref="E:System.IO.FileSystemWatcher.Renamed" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IO.FileSystemWatcher.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The directory to monitor")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Diagnostics.Design.FSWPathEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定要監看的目錄路徑。</summary>
        <value>要監視的路徑。 預設為空字串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是目錄的完整的路徑。 如果<xref:System.IO.FileSystemWatcher.IncludeSubdirectories%2A>屬性是`true`，此目錄是的根目錄的系統會監看的變更，否則為監看的唯一目錄。 若要觀看的特定檔案，設定<xref:System.IO.FileSystemWatcher.Path%2A>屬性的完整、 正確的目錄，而<xref:System.IO.FileSystemWatcher.Filter%2A>屬性設為檔案名稱。  
  
 <xref:System.IO.FileSystemWatcher.Path%2A>屬性支援通用命名慣例 (UNC) 路徑。  
  
> [!NOTE]
>  必須先設定這個屬性，該元件可以監看的變更。  
  
 當目錄已重新命名時，<xref:System.IO.FileSystemWatcher>自動將本身重新附加至剛重新命名的項目。 例如，如果您設定<xref:System.IO.FileSystemWatcher.Path%2A>"C:\My Documents"的屬性，然後手動重新命名 [C:\Your 文件] 目錄元件仍會繼續接聽剛重新命名的目錄上的變更通知。 不過，當您尋求<xref:System.IO.FileSystemWatcher.Path%2A>屬性，其中包含舊的路徑。 這是因為此元件可讓您判斷監看基礎控制代碼，而不是目錄的名稱。 重新命名並不會影響此控制代碼。 因此，如果您終結的元件，並再重新建立它，而不需要更新<xref:System.IO.FileSystemWatcher.Path%2A>屬性，您的應用程式會失敗，因為目錄不存在。  
  
   
  
## Examples  
 下列範例會建立<xref:System.IO.FileSystemWatcher>監看在執行階段指定的目錄。 元件會設定為監看的變更`LastWrite`和`LastAccess`時間、 建立、 刪除或重新命名的目錄中的文字檔案。 如果變更、 建立，或刪除檔案，檔案的路徑會列印至主控台。 重新命名檔案時，新舊路徑列印到主控台。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定的路徑不存在或找不到該路徑。  
  
-或- 
指定路徑包含萬用字元。  
  
-或- 
指定路徑包含無效路徑字元。</exception>
        <altmember cref="T:System.IO.FileSystemWatcher" />
        <altmember cref="P:System.IO.FileSystemWatcher.Filter" />
      </Docs>
    </Member>
    <Member MemberName="Renamed">
      <MemberSignature Language="C#" Value="public event System.IO.RenamedEventHandler Renamed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.RenamedEventHandler Renamed" />
      <MemberSignature Language="DocId" Value="E:System.IO.FileSystemWatcher.Renamed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Renamed As RenamedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::RenamedEventHandler ^ Renamed;" />
      <MemberSignature Language="F#" Value="member this.Renamed : System.IO.RenamedEventHandler " Usage="member this.Renamed : System.IO.RenamedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("Occurs when a file/directory rename matches the filter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_Renamed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.RenamedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>發生在指定的 <see cref="P:System.IO.FileSystemWatcher.Path" /> 內的檔案或目錄重新命名時。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Renamed`事件是<xref:System.IO.RenamedEventHandler>具有下列簽章的委派：

 ```csharp
public delegate void Renamed(object sender, RenamedEventArgs e);
 ```
 ```vb
Public Delegate Sub RenamedEventHandler(sender As Object, e As RenamedEventArgs)
 ```
 <xref:System.IO.RenamedEventArgs>物件會提供重新命名作業，例如重新命名類型的相關資訊 (<xref:System.IO.FileSystemEventArgs.ChangeType>屬性)，舊的和新名稱，而舊的和新的路徑。 請注意，<xref:System.IO.FileSystemEventArgs.Name>屬性可能為 null 如果重新命名事件<xref:System.IO.FileSystemWatcher>不會取得符合從作業系統的新舊名稱事件。

 重新命名您所監看的目錄將不會引發通知。 如您所監看的目錄內的項目，才會引發通知。  
  
   
  
## Examples  
 下列範例會使用<xref:System.IO.FileSystemWatcher.Renamed>對主控台顯示的檔案路徑，每當監看的檔案已重新命名的事件。  
  
 [!code-cpp[Classic NotifyFilters Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CPP/source.cpp#1)]
 [!code-csharp[Classic NotifyFilters Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic NotifyFilters Example/CS/source.cs#1)]
 [!code-vb[Classic NotifyFilters Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic NotifyFilters Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileSystemWatcher.OnRenamed(System.IO.RenamedEventArgs)" />
        <altmember cref="P:System.IO.FileSystemWatcher.SynchronizingObject" />
        <altmember cref="P:System.IO.FileSystemWatcher.Path" />
        <altmember cref="T:System.IO.RenamedEventArgs" />
        <altmember cref="T:System.IO.RenamedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.IO.FileSystemWatcher.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.ComponentModel.ISite" /> 的 <see cref="T:System.IO.FileSystemWatcher" />。</summary>
        <value>
  <see cref="T:System.ComponentModel.ISite" /> 的 <see cref="T:System.IO.FileSystemWatcher" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 站台繫結<xref:System.ComponentModel.Component>至<xref:System.ComponentModel.Design.IDesignerHost.Container%2A>和啟用它們，之間的通訊，以及提供讓要管理其元件的容器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.IO.FileSystemWatcher.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.IO.IODescription("The object used to marshal the event handler calls resulting from a directory change")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.IO.IODescription("FSW_SynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定物件，用以封送處理因目錄變更而發出的事件處理常式呼叫。</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，表示用以封送處理因目錄變更而發出的事件處理常式呼叫的物件。 預設為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>已`null`，方法處理<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，和<xref:System.IO.FileSystemWatcher.Renamed>系統執行緒集區的執行緒上呼叫事件。 如需有關系統執行緒集區的詳細資訊，請參閱<xref:System.Threading.ThreadPool>。  
  
 當<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，以及<xref:System.IO.FileSystemWatcher.Renamed>事件會由 visual 的 Windows Form 元件，例如<xref:System.Windows.Forms.Button>，透過系統執行緒集區中存取元件可能無法運作，或可能會導致例外狀況。 藉由設定避免這<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>至 Windows Form 元件，這樣會使處理的方法<xref:System.IO.FileSystemWatcher.Changed>， <xref:System.IO.FileSystemWatcher.Created>， <xref:System.IO.FileSystemWatcher.Deleted>，和<xref:System.IO.FileSystemWatcher.Renamed>元件建立所在的相同執行緒上呼叫的事件。  
  
 如果<xref:System.IO.FileSystemWatcher>使用於內部[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]在 Windows Form 設計工具中，<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>會自動將包含的控制項為<xref:System.IO.FileSystemWatcher>。 比方說，如果您放置<xref:System.IO.FileSystemWatcher>Form1 設計工具上 (繼承自<xref:System.Windows.Forms.Form>)<xref:System.IO.FileSystemWatcher.SynchronizingObject%2A>屬性<xref:System.IO.FileSystemWatcher>設為 Form1 的執行個體。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForChanged">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>同步方法，傳回含有發生的變更之特定資訊的結構。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged changeType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
      </Parameters>
      <Docs>
        <param name="changeType">要監看的 <see cref="T:System.IO.WatcherChangeTypes" />。</param>
        <summary>提供想要監視的變更類型，同步方法會傳回含有發生的變更之特定資訊的結構。</summary>
        <returns><see cref="T:System.IO.WaitForChangedResult" />，含有發生的變更之特定資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會等候直到第一項變更，就會發生，並且接著會傳回。 這是使用相同<xref:System.IO.FileSystemWatcher.WaitForChanged%2A>與`timeout`參數設定為-1。  
  
> [!NOTE]
>  這個方法可讓事件處理常式被叫用來回應檔案的變更，即使<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>屬性設定為`false`。  
  
 在某些系統中，<xref:System.IO.FileSystemWatcher>報告變更，使用簡短的 8.3 檔案名稱格式的檔案。 例如，"LongFileName.LongExtension 」 的變更無法回報為 「 LongFi ~。Lon"。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
    <Member MemberName="WaitForChanged">
      <MemberSignature Language="C#" Value="public System.IO.WaitForChangedResult WaitForChanged (System.IO.WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.IO.WaitForChangedResult WaitForChanged(valuetype System.IO.WatcherChangeTypes changeType, int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileSystemWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForChanged (changeType As WatcherChangeTypes, timeout As Integer) As WaitForChangedResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::WaitForChangedResult WaitForChanged(System::IO::WatcherChangeTypes changeType, int timeout);" />
      <MemberSignature Language="F#" Value="member this.WaitForChanged : System.IO.WatcherChangeTypes * int -&gt; System.IO.WaitForChangedResult" Usage="fileSystemWatcher.WaitForChanged (changeType, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem.Watcher</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.WaitForChangedResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeType" Type="System.IO.WatcherChangeTypes" />
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="changeType">要監看的 <see cref="T:System.IO.WatcherChangeTypes" />。</param>
        <param name="timeout">逾時之前的等候時間 (以毫秒計)。</param>
        <summary>提供您想要監視的變更類型和逾時前的等候時間 (以毫秒計)，同步方法會傳回含有發生的變更之特定資訊的結構。</summary>
        <returns><see cref="T:System.IO.WaitForChangedResult" />，含有發生的變更之特定資訊。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會等到發生變更，或它已逾時。值為-1`timeout`參數表示無限期等候。  
  
> [!NOTE]
>  這個方法可讓事件處理常式被叫用來回應檔案的變更，即使<xref:System.IO.FileSystemWatcher.EnableRaisingEvents%2A>屬性設定為`false`。  
  
 在某些系統中，<xref:System.IO.FileSystemWatcher>報告變更，使用簡短的 8.3 檔案名稱格式的檔案。 例如，"LongFileName.LongExtension 」 的變更無法回報為 「 LongFi ~。Lon"。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.WaitForChangedResult" />
      </Docs>
    </Member>
  </Members>
</Type>