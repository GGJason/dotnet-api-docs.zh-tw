<Type Name="File" FullName="System.IO.File">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="33ff20675af33b874a1f85321d5e07899d6d1ef4" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/13/2018" />
    <Meta Name="ms.locfileid" Value="35417273" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class File" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit File extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.File" />
  <TypeSignature Language="VB.NET" Value="Public Class File" />
  <TypeSignature Language="C++ CLI" Value="public ref class File abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供建立、複製、刪除、移動和開啟單一檔案的靜態方法，並協助 <see cref="T:System.IO.FileStream" /> 物件的建立。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.File>一般作業，例如複製、 移動、 重新命名、 建立、 開啟、 刪除和一次附加到單一檔案的類別。 您也可以使用<xref:System.IO.File>類別來取得和設定檔案屬性或<xref:System.DateTime>存取，及建立的相關資訊寫入檔案。 如果您想要在多個檔案上執行作業，請參閱<xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType>或<xref:System.IO.DirectoryInfo.GetFiles%2A?displayProperty=nameWithType>。  
  
 許多<xref:System.IO.File>方法會傳回其他 I/O 類型，當您建立或開啟檔案。 您可以使用這些其他型別來進一步操作檔案。 如需詳細資訊，請參閱特定<xref:System.IO.File>這類成員<xref:System.IO.File.OpenText%2A>， <xref:System.IO.File.CreateText%2A>，或<xref:System.IO.File.Create%2A>。  
  
 因為所有<xref:System.IO.File>方法是靜態的它可能使用更有效率<xref:System.IO.File>方法，而非對應<xref:System.IO.FileInfo>執行個體方法，如果您想要執行單一動作。 所有<xref:System.IO.File>方法需要您操作檔案的路徑。  
  
 靜態方法<xref:System.IO.File>類別執行的所有方法上的安全性檢查。 如果您要重複使用的物件數次，請考慮使用對應的執行個體方法的<xref:System.IO.FileInfo>相反地，因為安全性檢查會不一定有必要。  
  
 根據預設，所有使用者已授都與至新的檔案的完整讀取/寫入存取。  
  
 下表描述用於自訂的各種行為的列舉型別<xref:System.IO.File>方法。  
  
|列舉|描述|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|指定讀取和寫入檔案的存取權。|  
|<xref:System.IO.FileShare>|指定允許已在使用檔案的存取層級。|  
|<xref:System.IO.FileMode>|指定是否保留或覆寫現有檔案的內容和要求以建立現有的檔案是否造成例外狀況。|  
  
> [!NOTE]
>  在接受的路徑做為輸入字串的成員，該路徑必須是格式正確，或例外狀況。 比方說，如果路徑是完整的但以空格開頭，路徑不被修剪中類別的方法。 因此，路徑的格式不正確，而且會引發例外狀況。 同樣地，路徑的組合不被完整的兩倍。 例如，"c:\temp c:\windows 」 也會引發例外狀況在大部分情況下。 請確定您的路徑是語式正確的當您使用接受路徑字串的方法。  
  
 接受路徑的成員，在路徑可以參考到檔案或只是目錄。 指定的路徑也可以參考相對路徑或通用命名慣例 (UNC) 路徑的伺服器和共用的名稱。 例如，下列所有條件都是可接受的路徑：  
  
-   "c:\\\MyDir\\\MyFile.txt 」 以 C# 或 Visual Basic 中的"c:\MyDir\MyFile.txt"。  
  
-   "c:\\\MyDir 」 以 C# 或 Visual Basic 中的"c:\MyDir"。  
  
-   「 MyDir\\\MySubdir 」 以 C# 或 Visual Basic 中的"MyDir\MySubDir"。  
  
-   「\\\\\\\MyServer\\\MyShare 」 在 C# 中，或 「\\\MyServer\MyShare 「 在 Visual Basic 中。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例示範如何使用<xref:System.IO.File>類別來檢查是否存在的檔案，並根據結果，請建立新的檔案，或開啟現有的檔案和讀寫自它。 在之前執行程式碼，建立`c:\temp`資料夾。  
  
 [!code-cpp[File Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Class Example/CPP/file class example.cpp#1)]
 [!code-csharp[File Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Class Example/CS/file class example.cs#1)]
 [!code-vb[File Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Class Example/VB/file class example.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.DriveInfo" />
    <altmember cref="T:System.IO.FileSystemWatcher" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AppendAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在檔案中加入幾行內容，然後關閉檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">要在其中加入幾行內容的檔案。 如果該檔案不存在，則會建立它。</param>
        <param name="contents">要加入檔案的幾行內容。</param>
        <summary>在檔案中加入幾行內容，然後關閉檔案。 如果指定的檔案不存在，則這個方法會建立檔案，將指定的程式行寫入檔案，然後關閉檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它不存在，但它不會建立新的目錄，此方法會建立檔案。 因此，值`path`參數必須包含現有的目錄。  
  
   
  
## Examples  
 下列範例會將範例資料檔中將選取的行寫入檔案，並則會附加更多行。 名為的目錄`temp`順利完成範例必須存在 C 磁碟機上。  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個由 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 或 <paramref name="contents" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> 無效 (例如此目錄不存在或位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="path" /> 所指定的檔案。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> 超過系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫者沒有寫入檔案的權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 會指定唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 是目錄。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">要在其中加入幾行內容的檔案。 如果該檔案不存在，則會建立它。</param>
        <param name="contents">要加入檔案的幾行內容。</param>
        <param name="encoding">要使用的字元編碼。</param>
        <summary>使用指定編碼將指定的幾行內容加入檔案，然後關閉檔案。 如果指定的檔案不存在，則這個方法會建立檔案，將指定的程式行寫入檔案，然後關閉檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果它不存在，但它不會建立新的目錄，此方法會建立檔案。 因此，值`path`參數必須包含現有的目錄。  
  
 您可以使用這個方法來建立包含下列檔案：  
  
-   結果[LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9)取得使用的查詢上的檔案、 行<xref:System.IO.File.ReadLines%2A>方法。  
  
-   集合中實作的內容<xref:System.Collections.Generic.IEnumerable%601>的字串。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個由 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />、<paramref name="contents" /> 或 <paramref name="encoding" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> 無效 (例如此目錄不存在或位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="path" /> 所指定的檔案。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> 超過系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 會指定唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 是目錄。  -或-  呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>將指定字串附加至檔案，如果檔案不存在，請建立一個新檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AppendAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要將指定字串附加至其中的檔案。</param>
        <param name="contents">要附加至檔案的字串。</param>
        <summary>開啟檔案，將指定的字串附加至檔案，然後關閉檔案。 如果檔案不存在，則這個方法會建立檔案，將指定的字串寫入檔案，然後關閉檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定字串和檔案路徑，這個方法開啟指定的檔案、 字串附加至檔案的結尾，然後關閉檔案。 即使引發例外狀況時要使用這個方法，關閉保證的檔案控制代碼。  
  
 如果它不存在，但它不會建立新的目錄，此方法會建立檔案。 因此，值`path`參數必須包含現有的目錄。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.File.AppendAllText%2A>方法將額外的文字新增至檔案結尾。 在此範例中，如果它不存在，並加入文字，會建立檔案。 不過，名為目錄`temp`順利完成範例必須存在 C 磁碟機上。  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定路徑無效 (例如此目錄不存在或位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入檔案或目錄的存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppendAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">要將指定字串附加至其中的檔案。</param>
        <param name="contents">要附加至檔案的字串。</param>
        <param name="encoding">要使用的字元編碼。</param>
        <summary>將指定字串附加至檔案，如果檔案不存在，請建立一個新檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定字串和檔案路徑，這個方法開啟指定的檔案、 字串附加至使用指定的編碼，檔案的結尾，然後關閉檔案。 即使引發例外狀況時要使用這個方法，關閉保證的檔案控制代碼。  
  
 如果它不存在，但它不會建立新的目錄，此方法會建立檔案。 因此，值`path`參數必須包含現有的目錄。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.File.AppendAllText%2A>方法將額外的文字新增至檔案結尾。 在此範例中，如果它不存在，並加入文字，會建立檔案。 不過，名為目錄`temp`順利完成範例必須存在 C 磁碟機上。  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定路徑無效 (例如此目錄不存在或位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入檔案或目錄的存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter AppendText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter AppendText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AppendText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ AppendText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要附加至檔案的路徑。</param>
        <summary>建立會將 UTF-8 編碼的文字附加至現有檔案或新檔案 (如果指定的檔案不存在) 的 <see cref="T:System.IO.StreamWriter" />。</summary>
        <returns>資料流寫入器，會附加 UTF-8 編碼的文字至指定的檔案或新檔案。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法相當於<xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29>建構函式多載。 如果指定的檔案`path`不存在，則會建立它。 如果檔案不存在，寫入作業<xref:System.IO.StreamWriter>將文字附加至檔案。 讀取檔案開啟時，允許額外執行緒。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 `path`參數不區分大小寫。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會將文字附加至檔案。 如果檔案不存在，方法就會建立新的檔案。 不過，名為目錄`temp`順利完成範例必須存在 C 磁碟機上。  
  
 [!code-cpp[File_AppendText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File_AppendText/CPP/file_appendtext.cpp#1)]
 [!code-csharp[File_AppendText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File_AppendText/CS/file_appendtext.cs#1)]
 [!code-vb[File_AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File_AppendText/VB/file_appendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定路徑無效 (例如此目錄不存在或位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">附加至指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
        <altmember cref="T:System.IO.StreamWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>複製現有的檔案到新的檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">要複製的檔案。</param>
        <param name="destFileName">目的檔案的名稱。 這不可以是目錄或現有檔案。</param>
        <summary>複製現有的檔案到新的檔案。 不允許覆寫相同名稱的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法相當於<xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29>方法多載`overwrite`參數設定為`false`。  
  
 `sourceFileName`和`destFileName`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>方法。 這個方法不支援萬用字元參數中。  
  
 複製的檔案會保留原始的檔案的屬性。  
  
   
  
## Examples  
 下列範例會將檔案複製到 C:\archives\2008 備份資料夾。 它會使用兩個多載<xref:System.IO.File.Copy%2A>方法，如下所示：  
  
-   它會先使用<xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法多載來複製文字 (.txt) 檔案。 這個程式碼示範這個多載不允許覆寫已複製的檔案。  
  
-   然後它會使用<xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載來複製的圖片 （.jpg 檔案）。 這個程式碼示範這個多載，並允許覆寫已複製的檔案。  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。  -或-  <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 會指定目錄。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="sourceFileName" />。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> 存在。  -或-  發生 I/O 錯誤。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取<paramref name="sourceFileName" />和寫入<paramref name="destFileName" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceFileName As String, destFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(System::String ^ sourceFileName, System::String ^ destFileName, bool overwrite);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">要複製的檔案。</param>
        <param name="destFileName">目的檔案的名稱。 這不可以是目錄。</param>
        <param name="overwrite">如果可以覆寫目的檔案，則為 <see langword="true" />，否則為 <see langword="false" />。</param>
        <summary>複製現有的檔案到新的檔案。 允許覆寫相同名稱的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceFileName`和`destFileName`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 這個方法不支援萬用字元參數中。  
  
 複製的檔案會保留原始的檔案的屬性。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會將檔案複製到 C:\archives\2008 備份資料夾。 它會使用兩個多載<xref:System.IO.File.Copy%2A>方法，如下所示：  
  
-   它會先使用<xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType>方法多載來複製文字 (.txt) 檔案。 這個程式碼示範這個多載不允許覆寫已複製的檔案。  
  
 然後它會使用<xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>方法多載來複製的圖片 （.jpg 檔案）。 這個程式碼示範這個多載，並允許覆寫已複製的檔案。  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。  -或-  <paramref name="destFileName" /> 是唯讀的。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。  -或-  <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 會指定目錄。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="sourceFileName" />。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> 存在，而且 <paramref name="overwrite" /> 是 <see langword="false" />。  -或-  發生 I/O 錯誤。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取<paramref name="sourceFileName" />和寫入<paramref name="destFileName" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="M:System.IO.Directory.Move(System.String,System.String)" />
        <altmember cref="M:System.IO.File.Move(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定路徑中建立檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要建立的檔案路徑和名稱。</param>
        <summary>在指定的路徑中建立或覆寫檔案。</summary>
        <returns>
          <see cref="T:System.IO.FileStream" />，提供在 <paramref name="path" /> 中指定之檔案的讀取/寫入存取。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream>這個方法所建立的物件都有預設<xref:System.IO.FileShare>值<xref:System.IO.FileShare.None>; 沒有其他處理程序或程式碼可以存取建立的檔案直到原始的檔案控制代碼已關閉。  
  
 這個方法相當於<xref:System.IO.File.Create%28System.String%2CSystem.Int32%29>方法多載使用預設的緩衝區大小。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如果指定的檔案不存在，就會建立;如果檔案存在，而且它不是唯讀，則會覆寫內容。  
  
 根據預設，所有使用者已授都與至新的檔案的完整讀取/寫入存取。 檔案具有讀取/寫入存取開啟時，必須先關閉另一個應用程式可以開啟它。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例中指定的路徑建立檔案、 一些資訊寫入檔案，並從檔案讀取。  
  
 [!code-cpp[File Create1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create1/CPP/file create1.cpp#1)]
 [!code-csharp[File Create1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create1/CS/file create1.cs#1)]
 [!code-vb[File Create1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create1/VB/file create1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。  -或-  <paramref name="path" /> 指定了唯讀的檔案。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">建立檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入所描述之檔案的使用權限<paramref name="path" />參數。 安全性動作： <see cref="F:System.Security.Permissions.SecurityAction.Demand" /> 。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">檔案的檔名。</param>
        <param name="bufferSize">用來緩衝檔案的讀取和寫入的位元組數。</param>
        <summary>建立或覆寫指定檔案。</summary>
        <returns>具有指定之緩衝區大小的 <see cref="T:System.IO.FileStream" />，提供在 <paramref name="path" /> 中指定之檔案的讀取/寫入存取。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileStream>這個方法所建立的物件都有預設<xref:System.IO.FileShare>值<xref:System.IO.FileShare.None>; 沒有其他處理程序或程式碼可以存取建立的檔案直到原始的檔案控制代碼已關閉。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 這個方法相當於<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29>建構函式多載。 如果指定的檔案不存在，就會建立;如果檔案存在，而且它不是唯讀，則會覆寫內容。  
  
 根據預設，所有使用者已授都與至新的檔案的完整讀取/寫入存取。 檔案具有讀取/寫入存取開啟時，必須先關閉另一個應用程式可以開啟它。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會建立具有指定的緩衝區大小的檔案。  
  
 [!code-cpp[File Create2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create2/CPP/file create2.cpp#1)]
 [!code-csharp[File Create2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create2/CS/file create2.cs#1)]
 [!code-vb[File Create2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create2/VB/file create2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。  -或-  <paramref name="path" /> 指定了唯讀的檔案。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">建立檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入所描述之檔案的使用權限<paramref name="path" />參數。 安全性動作： 需求。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, bufferSize As Integer, options As FileOptions) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">檔案的檔名。</param>
        <param name="bufferSize">用來緩衝檔案的讀取和寫入的位元組數。</param>
        <param name="options">其中一個 <see cref="T:System.IO.FileOptions" /> 值，描述如何建立或覆寫檔案。</param>
        <summary>建立或覆寫指定檔案，並指定緩衝區大小以及描述如何建立或覆寫檔案的 <see cref="T:System.IO.FileOptions" /> 值。</summary>
        <returns>具有指定緩衝區大小的新檔案。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 這個方法相當於<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29>建構函式多載。 如果指定的檔案不存在，就會建立;如果檔案存在，而且它不是唯讀，則會覆寫內容。  
  
 根據預設，所有使用者已授都與至新的檔案的完整讀取/寫入存取。 檔案具有讀取/寫入存取開啟時，必須先關閉另一個應用程式可以開啟它。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。  -或-  <paramref name="path" /> 指定了唯讀的檔案。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">建立檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入所描述之檔案的使用權限<paramref name="path" />參數。 安全性動作： 需求。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Create(System::String ^ path, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">檔案的檔名。</param>
        <param name="bufferSize">用來緩衝檔案的讀取和寫入的位元組數。</param>
        <param name="options">其中一個 <see cref="T:System.IO.FileOptions" /> 值，描述如何建立或覆寫檔案。</param>
        <param name="fileSecurity">其中一個 <see cref="T:System.Security.AccessControl.FileSecurity" /> 值，決定檔案的存取控制和稽核安全性。</param>
        <summary>建立或覆寫具有指定緩衝區大小、檔案選項和檔案安全性的指定檔案。</summary>
        <returns>新檔案，具有指定緩衝區大小、檔案選項和檔案安全性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 這個方法相當於<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29>建構函式多載。 如果指定的檔案不存在，就會建立;如果檔案存在，而且它不是唯讀，則會覆寫內容。  
  
 根據預設，所有使用者已授都與至新的檔案的完整讀取/寫入存取。 檔案具有讀取/寫入存取開啟時，必須先關閉另一個應用程式可以開啟它。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。  -或-  <paramref name="path" /> 指定了唯讀的檔案。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">建立檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入所描述之檔案的使用權限<paramref name="path" />參數。 安全性動作： 需求。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter CreateText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter CreateText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.CreateText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateText (path As String) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamWriter ^ CreateText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要被開啟來寫入的檔案。</param>
        <summary>建立或開啟用以寫入 UTF-8 編碼文字的檔案。 如果檔案已經存在，將覆寫其內容。</summary>
        <returns>
          <see cref="T:System.IO.StreamWriter" />，使用 UTF-8 編碼方式寫入指定檔案。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法相當於<xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29>建構函式多載`append`參數設定為`false`。 如果指定的檔案`path`不存在，則會建立它。 如果檔案不存在，則會覆寫其內容。 讀取檔案開啟時，允許額外執行緒。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會建立檔案以進行寫入和讀取的文字。  
  
 [!code-cpp[File CreateText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File CreateText/CPP/file createtext.cpp#1)]
 [!code-csharp[File CreateText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File CreateText/CS/file createtext.cs#1)]
 [!code-vb[File CreateText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File CreateText/VB/file createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入至指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public static void Decrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Decrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Decrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Decrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Decrypt(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">路徑，描述要解密的檔案。</param>
        <summary>解密目前帳戶使用 <see cref="M:System.IO.File.Encrypt(System.String)" /> 方法加密的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Decrypt%2A>方法可讓您將使用加密檔案解密<xref:System.IO.File.Encrypt%2A>方法。  <xref:System.IO.File.Decrypt%2A>方法可以解密使用目前的使用者帳戶已加密的檔案。  
  
 <xref:System.IO.File.Decrypt%2A>方法需要獨佔存取檔案，進行解密，而且會引發例外狀況，如果另一個處理序正在使用檔案。 如果檔案未加密，<xref:System.IO.File.Decrypt%2A>會傳回非零值，表示成功。  
  
 這兩個<xref:System.IO.File.Encrypt%2A>方法和<xref:System.IO.File.Decrypt%2A>方法使用的電腦上安裝並呼叫方法的程序的檔案加密金鑰的密碼編譯服務提供者 (CSP)。  
  
 目前的檔案系統必須格式化為 NTFS，且目前的作業系統必須 Windows NT 或更新版本。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.IO.File.Encrypt%2A>方法和<xref:System.IO.File.Decrypt%2A>來加密和解密的檔案，然後的方法。 檔案必須存在，範例才能運作。  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數為零長度字串，只包含空格或包含一或多個由 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DriveNotFoundException">指定的磁碟機無效。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="path" /> 參數所描述的檔案。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。 例如，加密的檔案已經開啟。  -或-  這個作業在目前平台不受支援。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.PlatformNotSupportedException">目前的作業系統不是 Windows NT 或更新版本。</exception>
        <exception cref="T:System.NotSupportedException">檔案系統不是 NTFS。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 參數指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 參數指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入所描述之檔案的使用權限<paramref name="path" />參數。 安全性動作： 需求。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要刪除的檔案的名稱。 不支援萬用字元。</param>
        <summary>刪除指定的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的檔案名稱的任何相對或絕對路徑資訊`path`參數。 不可包含萬用字元。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如果要刪除的檔案不存在，則會擲不回任何例外狀況。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例複製的 C:\archives\2008 備份資料夾的檔案群組，，然後將它們刪除從來源資料夾。  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">指定的檔案正在使用中。  -或-  檔案上有開啟的控制代碼，而且作業系統是 Windows XP 或之前的版本。 這個開啟的控制代碼可能是列舉目錄和檔案所產生的結果。 如需詳細資訊，請參閱 [如何：列舉目錄和檔案] (~/docs/standard/io/how-to-enumerate-directories-and-files.md)。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。  -或-  檔案是使用中的可執行檔。  -或-  <paramref name="path" /> 是目錄。  -或-  <paramref name="path" /> 指定唯讀檔案。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">刪除指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public static void Encrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Encrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Encrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Encrypt (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Encrypt(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">路徑，描述要加密的檔案。</param>
        <summary>加密檔案，只有使用加密檔案的帳戶才能將其解密。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Encrypt%2A>方法可讓您加密檔案，以便只有呼叫這個方法所使用的帳戶才能將其解密。 使用<xref:System.IO.File.Decrypt%2A>方法來解密加密的檔案<xref:System.IO.File.Encrypt%2A>方法。  
  
 <xref:System.IO.File.Encrypt%2A>方法需要獨佔存取權所加密的檔案，且如果另一個處理序正在使用檔案將會失敗。  
  
 這兩個<xref:System.IO.File.Encrypt%2A>方法和<xref:System.IO.File.Decrypt%2A>方法使用的電腦上安裝並呼叫方法的程序的檔案加密金鑰的密碼編譯服務提供者 (CSP)。  
  
 無法在所有版本的 Windows 上使用這個方法。 例如，不上首頁版本提供。  
  
 目前的檔案系統必須格式化為 NTFS。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.IO.File.Encrypt%2A>方法和<xref:System.IO.File.Decrypt%2A>來加密和解密的檔案，然後的方法。 檔案必須存在，範例才能運作。  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 參數為零長度字串，只包含空格或包含一或多個由 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DriveNotFoundException">指定的磁碟機無效。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="path" /> 參數所描述的檔案。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。  -或-  這個作業在目前平台不受支援。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.PlatformNotSupportedException">目前的作業系統不是 Windows NT 或更新版本。</exception>
        <exception cref="T:System.NotSupportedException">檔案系統不是 NTFS。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 參數指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 參數指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入所描述之檔案的使用權限<paramref name="path" />參數。 安全性動作： 需求。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要檢查的檔案。</param>
        <summary>判斷指定的檔案是否存在。</summary>
        <returns>如果呼叫端擁有必要的使用權限而且 <paramref name="path" /> 含有現有檔案的名稱，則為 <see langword="true" />，否則為 <see langword="false" />。 如果 <see langword="false" /> 是 <paramref name="path" />、無效路徑或長度為零的字串，這個方法也會傳回 <see langword="null" />。 如果呼叫端沒有充足權限讀取指定檔案，沒有例外狀況會擲回，並且不論 <see langword="false" /> 是否存在，方法都會傳回 <paramref name="path" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Exists%2A>方法不應該用於路徑驗證時，這個方法只會檢查中是否指定的檔案`path`存在。 傳遞至無效的路徑<xref:System.IO.File.Exists%2A>傳回`false`。 若要檢查路徑是否包含任何無效的字元，您可以呼叫<xref:System.IO.Path.GetInvalidPathChars%2A>方法來擷取檔案系統無效字元。 您也可以建立規則運算式來測試是否為您的環境的有效路徑。 如需可接受的路徑的範例，請參閱<xref:System.IO.File>。  
  
 若要檢查目錄是否存在，請參閱<xref:System.IO.Directory.Exists%2A?displayProperty=nameWithType>。  
  
 請注意，另一個處理序可以有可能做到的次呼叫之間的檔案<xref:System.IO.File.Exists%2A>方法和執行檔案，另一項作業，例如<xref:System.IO.File.Delete%2A>。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如果`path`描述目錄中，這個方法會傳回`false`。 尾端空白會從`path`參數，然後再判斷如果檔案存在。  
  
 <xref:System.IO.File.Exists%2A>方法會傳回`false`如果發生任何錯誤時嘗試判斷指定的檔案是否存在。 可能發生這種情況下，會引發例外狀況，例如傳遞檔名無效的字元或太多的字元，失敗或遺失的磁碟，或如果呼叫端沒有讀取檔案的權限。  
  
   
  
## Examples  
 下列範例會判斷檔案是否存在。  
  
 [!code-csharp[File Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Exists/CS/program.cs#1)]
 [!code-vb[File Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Exists/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="M:System.IO.Directory.Exists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>取得 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件，該物件封裝指定檔案的存取控制清單 (ACL) 項目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.FileInfo.GetAccessControl%2A>方法來擷取存取控制清單 (ACL) 項目指定的檔案。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">檔案的路徑，包含 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件，並描述檔案的存取控制清單 (ACL) 資訊。</param>
        <summary>取得 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件，該物件封裝指定檔案的存取控制清單 (ACL) 項目。</summary>
        <returns>
          <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件，該物件會封裝 <paramref name="path" /> 參數所描述之檔案的存取控制規則。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.File.GetAccessControl%2A>方法來擷取檔案的存取控制清單 (ACL) 項目。  
  
 ACL 描述個人及/或群組，讓他們已經有或沒有，在指定的檔案上採取特定動作的權限。 如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 在 NTFS 環境中，<xref:System.Security.AccessControl.FileSystemRights.ReadAttributes>和<xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>授與使用者時如果使用者具有<xref:System.Security.AccessControl.FileSystemRights.ListDirectory>父資料夾的權限。 若要拒絕<xref:System.Security.AccessControl.FileSystemRights.ReadAttributes>和<xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>，拒絕<xref:System.Security.AccessControl.FileSystemRights.ListDirectory>父目錄上。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.IO.File.GetAccessControl%2A>和<xref:System.IO.File.SetAccessControl%2A>方法來新增，然後再移除存取控制清單 (ACL) 項目從檔案。  您必須提供有效的使用者或群組帳戶，才能執行這個範例。  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">
          <paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.SystemException">找不到檔案。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 參數指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 參數指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">若要讀取的存取控制清單的權限。 安全性動作： 需求。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />， <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAccessControl (path As String, includeSections As AccessControlSections) As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::AccessControl::FileSecurity ^ GetAccessControl(System::String ^ path, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">檔案的路徑，包含 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件，並描述檔案的存取控制清單 (ACL) 資訊。</param>
        <param name="includeSections">其中一個 <see cref="T:System.Security.AccessControl.AccessControlSections" /> 值，指定要接收的存取控制清單 (ACL) 資訊之類型。</param>
        <summary>取得 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件，該物件會封裝特定檔案之指定類型的存取控制清單 (ACL) 項目。</summary>
        <returns>
          <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件，該物件會封裝 <paramref name="path" /> 參數所描述之檔案的存取控制規則。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.IO.File.GetAccessControl%2A>方法來擷取檔案的存取控制清單 (ACL) 項目。  
  
 ACL 描述個人及/或群組，讓他們已經有或沒有，在指定的檔案上採取特定動作的權限。 如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 在 NTFS 環境中，<xref:System.Security.AccessControl.FileSystemRights.ReadAttributes>和<xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>授與使用者時如果使用者具有<xref:System.Security.AccessControl.FileSystemRights.ListDirectory>父資料夾的權限。 若要拒絕<xref:System.Security.AccessControl.FileSystemRights.ReadAttributes>和<xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>，拒絕<xref:System.Security.AccessControl.FileSystemRights.ListDirectory>父目錄上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">
          <paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.SystemException">找不到檔案。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 參數指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 參數指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">若要讀取的存取控制清單的權限。 安全性動作： 需求。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />， <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.IO.FileAttributes GetAttributes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.IO.FileAttributes GetAttributes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAttributes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAttributes (path As String) As FileAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileAttributes GetAttributes(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAttributes</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">檔案的路徑。</param>
        <summary>取得路徑上檔案的 <see cref="T:System.IO.FileAttributes" />。</summary>
        <returns>路徑上檔案的 <see cref="T:System.IO.FileAttributes" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會示範`GetAttributes`和`SetAttributes`方法藉由套用`Archive`和`Hidden`屬性加入檔案。  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是空的、只包含空格或包含無效字元。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> 表示檔案而且無效，例如，位於未對應的磁碟上，或找不到檔案。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> 表示目錄而且無效，例如，位於未對應的磁碟上，或找不到目錄。</exception>
        <exception cref="T:System.IO.IOException">其他處理序正在使用此檔案。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">讀取檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要取得其建立日期和時間資訊的檔案或目錄。</param>
        <summary>傳回指定檔案或目錄的建立日期和時間。</summary>
        <returns>
          <see cref="T:System.DateTime" /> 結構，設定為指定檔案或目錄的建立日期和時間。 這個值以本地時間表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法可能傳回不正確的值，因為它會使用其值可能不會持續更新作業系統的原生函式。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如果檔案中所述`path`參數不存在，這個方法會傳回午夜 12:00，1601年西元 1 (C.E.)國際標準時間 (UTC)，調整為本地時間。  
  
 NTFS 格式化磁碟機可能會快取檔案，例如一段時間的檔案建立時間的相關資訊。 如此一來，可能需要明確地將設定檔的建立時間，如果您要覆寫或取代現有的檔案。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會示範`GetCreationTime`。  
  
 [!code-vb[System.IO.File.GetCreationTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCreationTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetCreationTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要取得其建立日期和時間資訊的檔案或目錄。</param>
        <summary>傳回指定檔案或目錄的建立日期和時間，格式為國際標準時間 (UTC)。</summary>
        <returns>
          <see cref="T:System.DateTime" /> 結構，設定為指定檔案或目錄的建立日期和時間。 這個值以 UTC 時間表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法可能傳回不正確的值，因為它會使用其值可能不會持續更新作業系統的原生函式。  
  
 如果檔案中所述`path`參數不存在，這個方法會傳回午夜 12:00，1601年西元 1 (C.E.)國際標準時間 (UTC)。  
  
 NTFS 格式化磁碟機可能會快取檔案，例如一段時間的檔案建立時間的相關資訊。 如此一來，可能需要明確地將設定檔的建立時間，如果您要覆寫或取代現有的檔案。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會示範<xref:System.IO.File.GetCreationTimeUtc%2A>方法。  
  
 [!code-vb[System.IO.File.GetCreationTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要取得其存取日期和時間資訊的檔案或目錄。</param>
        <summary>傳回指定檔案或目錄上次被存取的日期和時間。</summary>
        <returns>
          <see cref="T:System.DateTime" /> 結構，設定為指定檔案或目錄的上次存取日期和時間。 這個值以本地時間表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法可能傳回不正確的值，因為它會使用其值可能不會持續更新作業系統的原生函式。  
  
 如果檔案中所述`path`參數不存在，這個方法會傳回午夜 12:00，1601年西元 1 (C.E.)國際標準時間 (UTC)，調整為本地時間。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會示範`GetLastAccessTime`。  
  
 [!code-cpp[File GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastAccess/CPP/file getlastaccess.cpp#1)]
 [!code-csharp[File GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastAccess/CS/file getlastaccess.cs#1)]
 [!code-vb[File GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastAccess/VB/file getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastAccessTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastAccessTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要取得其存取日期和時間資訊的檔案或目錄。</param>
        <summary>傳回指定檔案或目錄上次被存取的日期和時間，格式為國際標準時間 (UTC)。</summary>
        <returns>
          <see cref="T:System.DateTime" /> 結構，設定為指定檔案或目錄的上次存取日期和時間。 這個值以 UTC 時間表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法可能傳回不正確的值，因為它會使用其值可能不會持續更新作業系統的原生函式。  
  
 如果檔案中所述`path`參數不存在，這個方法會傳回午夜 12:00，1601年西元 1 (C.E.)國際標準時間 (UTC)。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTime (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTime(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要取得其寫入日期和時間資訊的檔案或目錄。</param>
        <summary>傳回指定檔案或目錄上次被寫入的日期和時間。</summary>
        <returns>
          <see cref="T:System.DateTime" /> 結構，設定為指定檔案或目錄的上次寫入日期和時間。 這個值以本地時間表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法可能傳回不正確的值，因為它會使用其值可能不會持續更新作業系統的原生函式。 每個作業系統管理上次寫入時間根據自己的規則。 若要改善效能，系統可能未設定上次寫入時間值的最後一個寫入作業，確切的時間，但可能會將它設定為近似值而。  
  
 如果檔案中所述`path`參數不存在，這個方法會傳回午夜 12:00，1601年西元 1 (C.E.)國際標準時間 (UTC)，調整為本地時間。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會示範`GetLastWriteTime`。  
  
 [!code-cpp[File GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastWrite/CPP/file getlastwrite.cpp#1)]
 [!code-csharp[File GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastWrite/CS/file getlastwrite.cs#1)]
 [!code-vb[File GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastWrite/VB/file getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTimeUtc(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteTimeUtc (path As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime GetLastWriteTimeUtc(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要取得其寫入日期和時間資訊的檔案或目錄。</param>
        <summary>傳回指定檔案或目錄上次被寫入的日期和時間，格式為國際標準時間 (UTC)。</summary>
        <returns>
          <see cref="T:System.DateTime" /> 結構，設定為指定檔案或目錄的上次寫入日期和時間。 這個值以 UTC 時間表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  這個方法可能傳回不正確的值，因為它會使用其值可能不會持續更新作業系統的原生函式。 每個作業系統管理上次寫入時間根據自己的規則。 若要改善效能，系統可能未設定上次寫入時間值的最後一個寫入作業，確切的時間，但可能會將它設定為近似值而。  
  
 如果檔案中所述`path`參數不存在，這個方法會傳回午夜 12:00，1601年西元 1 (C.E.)國際標準時間 (UTC)。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Move(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Move (sourceFileName As String, destFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Move(System::String ^ sourceFileName, System::String ^ destFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">要移動的檔案名稱。 可包含相對或絕對路徑。</param>
        <param name="destFileName">檔案的新路徑和名稱。</param>
        <summary>移動指定的檔案至新的位置，提供指定新檔名的選項。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法適用於跨磁碟區，它不會擲回例外狀況時的來源和目的地相同。 請注意，是否您嘗試將相同名稱的檔案移到該目錄取代檔案，將取得<xref:System.IO.IOException>。 您無法使用 Move 方法覆寫現有檔案。  
  
 `sourceFileName`和`destFileName`引數可以包含相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如果您嘗試在磁碟區之間移動檔案和檔案正在使用中，將檔案複製到目的地，但不是會從來源刪除。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會移動的檔案。  
  
 [!code-cpp[File Move#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Move/CPP/file move.cpp#1)]
 [!code-csharp[File Move#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Move/CS/file move.cs#1)]
 [!code-vb[File Move#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Move/VB/file move.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">目的檔案已經存在。  -或-  找不到 <paramref name="sourceFileName" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 是長度為零的字串、只含有泛空白字元，或含有一個或多個無效的字元 (如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義)。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 中指定的路徑無效 (例如，位於未對應的磁碟上)。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> 或 <paramref name="destFileName" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取<paramref name="sourceFileName" />和寫入<paramref name="destFileName" />。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在指定路徑上開啟 <see cref="T:System.IO.FileStream" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">要開啟的檔案。</param>
        <param name="mode">
          <see cref="T:System.IO.FileMode" /> 值，指定是否要建立檔案 (如果不存在的話)，以及決定要保留或覆寫現有檔案的內容。</param>
        <summary>在指定路徑上開啟具有讀取/寫入權限且不共用的 <see cref="T:System.IO.FileStream" />。</summary>
        <returns>在指定模式和路徑中開啟的 <see cref="T:System.IO.FileStream" />，具有讀取/寫入存取而且不共用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列程式碼範例會建立暫存檔，以及一些文字寫入。 此範例接著會開啟檔案，使用 T:System.IO.FileMode.Open;也就是說，如果檔案原本不存在，它會建立。  
  
 [!code-cpp[File Open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open1/CPP/file open1.cpp#1)]
 [!code-csharp[File Open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open1/CS/file open1.cs#1)]
 [!code-vb[File Open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open1/VB/file open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。  -或-  <paramref name="mode" /> 是 <see cref="F:System.IO.FileMode.Create" />，且指定的檔案是隱藏檔案。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> 指定了無效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到在 <paramref name="path" /> 中指定的檔案。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入至指定的檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">要開啟的檔案。</param>
        <param name="mode">
          <see cref="T:System.IO.FileMode" /> 值，指定是否要建立檔案 (如果不存在的話)，以及決定要保留或覆寫現有檔案的內容。</param>
        <param name="access">
          <see cref="T:System.IO.FileAccess" /> 值，指定可以在檔案上執行的作業。</param>
        <summary>在指定路徑上開啟具有指定模式和存取權且不共用的 <see cref="T:System.IO.FileStream" />。</summary>
        <returns>不共用的 <see cref="T:System.IO.FileStream" />，提供對指定檔案 (具有指定模式和存取) 的存取。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
   
  
## Examples  
 下列範例會開啟檔案具有唯讀存取權。  
  
 [!code-cpp[file open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open2/CPP/file open2.cpp#1)]
 [!code-csharp[file open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open2/CS/file open2.cs#1)]
 [!code-vb[file open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open2/VB/file open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。  -或-  <paramref name="access" /> 指定了 <see langword="Read" />，而 <paramref name="mode" /> 指定了 <see langword="Create" />、<see langword="CreateNew" />、<see langword="Truncate" /> 或 <see langword="Append" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定為唯讀的檔案，而且 <paramref name="access" /> 不是 <see langword="Read" />。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。  -或-  <paramref name="mode" /> 是 <see cref="F:System.IO.FileMode.Create" />，且指定的檔案是隱藏檔案。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> 或 <paramref name="access" /> 指定了無效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到在 <paramref name="path" /> 中指定的檔案。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入至指定的檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, mode As FileMode, access As FileAccess, share As FileShare) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ Open(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">要開啟的檔案。</param>
        <param name="mode">
          <see cref="T:System.IO.FileMode" /> 值，指定是否要建立檔案 (如果不存在的話)，以及決定要保留或覆寫現有檔案的內容。</param>
        <param name="access">
          <see cref="T:System.IO.FileAccess" /> 值，指定可以在檔案上執行的作業。</param>
        <param name="share">
          <see cref="T:System.IO.FileShare" /> 值，指定其他執行緒對檔案擁有的存取類型。</param>
        <summary>在指定路徑上開啟 <see cref="T:System.IO.FileStream" />，假定它具有讀取、寫入或讀取/寫入存取的指定模式和指定的共用選項。</summary>
        <returns>指定路徑上的 <see cref="T:System.IO.FileStream" />，假定它具有讀取、寫入或讀取/寫入存取的指定模式和指定的共用選項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會開啟檔案具有唯讀存取權並不允許檔案共用。  
  
 [!code-cpp[file open3#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open3/CPP/file open3.cpp#1)]
 [!code-csharp[file open3#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open3/CS/file open3.cs#1)]
 [!code-vb[file open3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open3/VB/file open3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。  -或-  <paramref name="access" /> 指定了 <see langword="Read" />，而 <paramref name="mode" /> 指定了 <see langword="Create" />、<see langword="CreateNew" />、<see langword="Truncate" /> 或 <see langword="Append" />。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定為唯讀的檔案，而且 <paramref name="access" /> 不是 <see langword="Read" />。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。  -或-  <paramref name="mode" /> 是 <see cref="F:System.IO.FileMode.Create" />，且指定的檔案是隱藏檔案。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" />、<paramref name="access" /> 或 <paramref name="share" /> 指定了無效值。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到在 <paramref name="path" /> 中指定的檔案。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入至指定的檔案。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />， <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenRead (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenRead(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenRead(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRead (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenRead(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要被開啟來讀取的檔案。</param>
        <summary>開啟現有檔案來讀取。</summary>
        <returns>指定路徑上的唯讀 <see cref="T:System.IO.FileStream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法相當於<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29>建構函式多載<xref:System.IO.FileMode>值<xref:System.IO.FileMode.Open>、<xref:System.IO.FileAccess>值<xref:System.IO.FileAccess.Read>和<xref:System.IO.FileShare>值<xref:System.IO.FileShare.Read>。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會開啟檔案進行讀取。  
  
 [!code-cpp[file openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenRead/CPP/file openread.cpp#1)]
 [!code-csharp[file openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenRead/CS/file openread.cs#1)]
 [!code-vb[file openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenRead/VB/file openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到在 <paramref name="path" /> 中指定的檔案。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenText (path As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::StreamReader ^ OpenText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要被開啟來讀取的檔案。</param>
        <summary>開啟現有 UTF-8 編碼的文字檔來讀取。</summary>
        <returns>指定路徑上的 <see cref="T:System.IO.StreamReader" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法相當於<xref:System.IO.StreamReader.%23ctor%28System.String%29>建構函式多載。  
  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會開啟文字檔案進行讀取。  
  
 [!code-cpp[file opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[file opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenText/CS/file opentext.cs#1)]
 [!code-vb[file opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到在 <paramref name="path" /> 中指定的檔案。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenWrite (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenWrite(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenWrite(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenWrite (path As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::FileStream ^ OpenWrite(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要被開啟來寫入的檔案。</param>
        <summary>開啟現有檔案或建立新檔案，以進行寫入。</summary>
        <returns>在指定之路徑上具有 <see cref="T:System.IO.FileStream" /> 存取權的非共用 <see cref="F:System.IO.FileAccess.Write" /> 物件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法相當於<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29>檔案模式設定為建構函式多載<xref:System.IO.FileMode.OpenOrCreate>，若要設定的存取權<xref:System.IO.FileAccess.Write>，和共用模式設為<xref:System.IO.FileShare.None>。  
  
 <xref:System.IO.File.OpenWrite%2A>方法開啟的檔案，其中一個已存在的檔案路徑，或如果不存在的話，會建立新的檔案。 現有的檔案，它不會將新的文字附加至現有的文字。 相反地，它會覆寫現有的字元與新的字元。 如果您覆寫較長的字串 （例如，"This is OpenWrite 方法的測試)"使用較短的字串 （例如 [第二個執行]），檔案會包含字串的混合 (「 第二個 runtest OpenWrite 方法的")。  
  
 `path`參數會指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 取得目前工作目錄，請使用<xref:System.IO.Directory.GetCurrentDirectory%2A>方法。  
  
 傳回<xref:System.IO.FileStream>不支援讀取。 若要開啟檔案進行讀取和寫入，使用<xref:System.IO.File.Open%2A>。

 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會開啟檔案進行讀取和寫入。  
  
 [!code-cpp[file openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[file openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[file openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。  -或-  <paramref name="path" /> 指定唯讀檔案或目錄。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入至指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadAllBytes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllBytes (path As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要開啟用於讀取的檔案。</param>
        <summary>開啟二進位檔案，將檔案內容讀入位元組陣列，然後關閉檔案。</summary>
        <returns>包含檔案內容的位元組陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 檔案路徑，這個方法會開啟該檔案，檔案的內容讀入位元組陣列，然後關閉檔案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到在 <paramref name="path" /> 中指定的檔案。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;byte[]&gt; ReadAllBytesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; ReadAllBytesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開啟文字檔，將檔案的所有行讀入字串陣列，然後關閉檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllLines (path As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要開啟用於讀取的檔案。</param>
        <summary>開啟文字檔，讀取檔案的所有行，然後關閉檔案。</summary>
        <returns>包含檔案所有行的字串陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會開啟檔案讀取的檔案，每一行，然後加入做為字串陣列的項目每一行。 然後，它會關閉檔案。 定義為一串字元後面接著歸位字元 ('\r')、 換行字元 ('\n')，或所傳回的歸位字元後面緊跟著行換行。 產生的字串不包含結束的歸位字元和 （或）。  
  
 這個方法會嘗試自動偵測編碼的位元組順序標記存在為基礎的檔案。 編碼格式 utf-8，而且可以偵測 utf-32 （由小到大和位元組由小到大）。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.File.ReadAllLines%2A>方法，以顯示檔案的內容。 在此範例中會建立一個檔案，如果它不存在，而且加入文字。  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到在 <paramref name="path" /> 中指定的檔案。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ ReadAllLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">要開啟用於讀取的檔案。</param>
        <param name="encoding">套用至檔案內容的編碼方式。</param>
        <summary>開啟檔案，以指定的編碼方式讀取檔案的所有行，然後關閉檔案。</summary>
        <returns>包含檔案所有行的字串陣列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會開啟檔案讀取的檔案，每一行，然後將每一行加入為字串陣列的項目。 然後，它會關閉檔案。 定義為一串字元後面接著歸位字元 ('\r')、 換行字元 ('\n')，或所傳回的歸位字元後面緊跟著行換行。 產生的字串不包含結束的歸位字元和 （或）。  
  
 這個方法會嘗試自動偵測編碼的位元組順序標記存在為基礎的檔案。 編碼格式 utf-8，而且可以偵測 utf-32 （由小到大和位元組由小到大）。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.File.ReadAllLines%2A>方法，以顯示檔案的內容。 在此範例中會建立一個檔案，如果它不存在，而且加入文字。  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到在 <paramref name="path" /> 中指定的檔案。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開啟文字檔，將檔案的所有行讀入字串，然後關閉檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAllText (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要開啟用於讀取的檔案。</param>
        <summary>開啟文字檔，讀取檔案的所有行，然後關閉檔案。</summary>
        <returns>包含檔案所有行的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會開啟檔案讀取的檔案，每一行，然後將每一行加入做為字串的項目。 然後，它會關閉檔案。 定義為一串字元後面接著歸位字元 ('\r')、 換行字元 ('\n')，或所傳回的歸位字元後面緊跟著行換行。 產生的字串不包含結束的歸位字元和 （或）。  
  
 這個方法會嘗試自動偵測編碼的位元組順序標記存在為基礎的檔案。 編碼格式 utf-8，而且可以偵測 utf-32 （由小到大和位元組由小到大）。  
  
 使用<xref:System.IO.File.ReadAllText%28System.String%2CSystem.Text.Encoding%29>方法多載時讀取檔案，其中可能包含匯入的文字，因為無法辨識的字元可能無法正確讀取。  
  
 即使引發例外狀況時要使用這個方法，關閉保證的檔案控制代碼。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.File.ReadAllText%2A>方法，以顯示檔案的內容。 在此範例中會建立一個檔案，如果它不存在，而且加入文字。  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到在 <paramref name="path" /> 中指定的檔案。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadAllText(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">要開啟用於讀取的檔案。</param>
        <param name="encoding">套用至檔案內容的編碼方式。</param>
        <summary>開啟檔案，以指定的編碼方式讀取檔案的所有行，然後關閉檔案。</summary>
        <returns>包含檔案所有行的字串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會開啟檔案讀取的檔案，每一行，然後將每一行加入做為字串的項目。 然後，它會關閉檔案。 定義為一串字元後面接著歸位字元 ('\r')、 換行字元 ('\n')，或所傳回的歸位字元後面緊跟著行換行。 產生的字串不包含結束的歸位字元和 （或）。  
  
 這個方法會嘗試自動偵測編碼的位元組順序標記存在為基礎的檔案。 編碼格式 utf-8，而且可以偵測 utf-32 （由小到大和位元組由小到大）。  
  
 即使引發例外狀況時要使用這個方法，關閉保證的檔案控制代碼。  
  
 若要設定您的作業系統，請使用編碼方式的設定，指定<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>屬性`encoding`參數。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.File.ReadAllText%2A>方法，以顯示檔案的內容。 在此範例中會建立一個檔案，如果它不存在，而且加入文字。  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到在 <paramref name="path" /> 中指定的檔案。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">針對從檔案或目錄的讀取權限。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>讀取檔案的所有行。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLines (path As String) As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要讀取的檔案。</param>
        <summary>讀取檔案的所有行。</summary>
        <returns>檔案的所有行，或查詢結果的各行。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.ReadLines%2A>和<xref:System.IO.File.ReadAllLines%2A>方法不同，如下所示： 當您使用<xref:System.IO.File.ReadLines%2A>，您可以啟動之前，會傳回整個集合列舉字串的集合，當您使用<xref:System.IO.File.ReadAllLines%2A>，您必須等到整個字串陣列是傳回之前可以存取陣列。 因此，當您使用非常大型的檔案，<xref:System.IO.File.ReadLines%2A>可能會更有效率。  
  
 您可以使用<xref:System.IO.File.ReadLines%2A>方法來執行下列動作：  
  
-   執行[LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9)檔案以取得一組篩選其線條上的查詢。  
  
-   寫入的檔案所傳回之集合的行<xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType>方法，或將它們附加至現有的檔案與<xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType>方法。  
  
-   建立立即填入的集合可接受的執行個體<xref:System.Collections.Generic.IEnumerable%601>集合的字串，其建構函式，例如<xref:System.Collections.Generic.IList%601>或<xref:System.Collections.Generic.Queue%601>。  
  
 這個方法會使用<xref:System.Text.Encoding.UTF8%2A>編碼值。  
  
   
  
## Examples  
 下列範例會讀取檔案，以尋找行包含指定的字串的所有行。  
  
 [!code-csharp[System.IO.File.ReadLines#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.readlines/cs/program.cs#1)]
 [!code-vb[System.IO.File.ReadLines#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.readlines/vb/program.vb#1)]  
  
 下列範例會使用<xref:System.IO.File.ReadLines%2A>列舉所有副檔名為.txt 的檔案目錄的 LINQ 查詢中的方法會讀取檔案的每一行，然後顯示的行，如果它包含字串"Microsoft"。  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串、只包含空格或包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的一或多個無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> 無效 (例如，位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="path" /> 所指定的檔案。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> 超過系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 會指定唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 是目錄。  -或-  呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ ReadLines(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">要讀取的檔案。</param>
        <param name="encoding">套用至檔案內容的編碼方式。</param>
        <summary>讀取具有指定編碼方式的檔案所有行。</summary>
        <returns>檔案的所有行，或查詢結果的各行。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個方法來指定要使用的編碼方式讀取檔案。  
  
 <xref:System.IO.File.ReadLines%2A>和<xref:System.IO.File.ReadAllLines%2A>方法不同，如下所示： 當您使用<xref:System.IO.File.ReadLines%2A>，您可以啟動之前，會傳回整個集合列舉字串的集合。 當您使用<xref:System.IO.File.ReadAllLines%2A>，您必須等候之前可以存取陣列傳回字串的整個陣列。 因此，當您使用非常大型的檔案，<xref:System.IO.File.ReadLines%2A>可能會更有效率。  
  
 您可以使用<xref:System.IO.File.ReadLines%2A>方法來執行下列動作：  
  
-   執行[LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9)檔案以取得一組篩選其線條上的查詢。  
  
-   寫入的檔案所傳回之集合的行<xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType>方法，或將它們附加至現有的檔案與<xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType>方法。  
  
-   建立立即填入的集合可接受的執行個體<xref:System.Collections.Generic.IEnumerable%601>集合的字串，其建構函式，例如<xref:System.Collections.Generic.IList%601>或<xref:System.Collections.Generic.Queue%601>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是長度為零的字串、只包含空白字元，或包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的一個或多個無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> 無效 (例如，位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 <paramref name="path" /> 所指定的檔案。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> 超過系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 會指定唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 是目錄。  -或-  呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>用另一個檔案的內容取代指定檔案的內容，刪除原始檔案並建立已取代檔案的備份。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Replace%2A>方法以另一個檔案的內容取代指定檔案的內容。  它們也可以建立已取代檔案的備份。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">取代 <c>destinationFileName</c> 所指定之檔案的檔案名稱。</param>
        <param name="destinationFileName">已取代的檔案名稱。</param>
        <param name="destinationBackupFileName">備份檔案的名稱。</param>
        <summary>用另一個檔案的內容取代指定檔案的內容，刪除原始檔案並建立已取代檔案的備份。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Replace%2A>方法會使用另一個檔案的內容取代指定檔案的內容。  它也會建立已取代檔案的備份。  
  
 如果`sourceFileName`和`destinationFileName`會在不同的磁碟區，這個方法會引發例外狀況。 如果`destinationBackupFileName`是在原始程式檔中的不同磁碟區，將執行的動作會刪除備份檔案。  
  
 傳遞`null`至`destinationBackupFileName`參數，如果您不想建立已取代檔案的備份。  

 如果`destinationBackupFileName`已經存在將會覆寫它的內容`destinationFileName`檔案。
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.IO.File.Replace%2A>方法來取代檔案與另一個檔案，並建立已取代檔案的備份。  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> 參數所描述的路徑格式不合法。  -或-  <paramref name="destinationBackupFileName" /> 參數所描述的路徑格式不合法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DriveNotFoundException">指定了無效的磁碟機。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到目前 <see cref="T:System.IO.FileInfo" /> 物件所描述的檔案。  -或-  找不到 <paramref name="destinationBackupFileName" /> 參數所描述的檔案。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。  \- 或 -  <paramref name="sourceFileName" /> 和 <paramref name="destinationFileName" /> 參數指定相同的檔案。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.PlatformNotSupportedException">作業系統是 Windows 98 Second Edition 或更早版本，而且檔案系統不是 NTFS。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="sourceFileName" /> 或 <paramref name="destinationFileName" /> 參數指定唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  來源或目的地參數指定的是目錄，不是檔案。  -或-  呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">要寫入的權限所描述檔案<paramref name="destinationBackupFileName" />如果指定的參數。 安全性動作： 需求。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Replace (sourceFileName As String, destinationFileName As String, destinationBackupFileName As String, ignoreMetadataErrors As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Replace(System::String ^ sourceFileName, System::String ^ destinationFileName, System::String ^ destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">取代 <c>destinationFileName</c> 所指定之檔案的檔案名稱。</param>
        <param name="destinationFileName">已取代的檔案名稱。</param>
        <param name="destinationBackupFileName">備份檔案的名稱。</param>
        <param name="ignoreMetadataErrors">
          <see langword="true" /> 表示忽略發生在已取代檔案和取代檔案上的合併錯誤 (例如屬性和存取控制清單 (ACL))，否則為 <see langword="false" />。</param>
        <summary>用另一個檔案的內容取代指定檔案的內容，刪除原始檔案，建立已取代檔案的備份，並選擇性地忽略合併錯誤。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.Replace%2A>方法會使用另一個檔案的內容取代指定檔案的內容。  它也會建立已取代檔案的備份。  
  
 如果`sourceFileName`和`destinationFileName`會在不同的磁碟區，這個方法會引發例外狀況。 如果`destinationBackupFileName`是在原始程式檔中的不同磁碟區，將執行的動作會刪除備份檔案。  
  
 傳遞`null`至`destinationBackupFileName`參數，如果您不想建立已取代檔案的備份。  

 如果`destinationBackupFileName`已經存在將會覆寫它的內容`destinationFileName`檔案。
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.IO.File.Replace%2A>方法來取代檔案與另一個檔案，並建立已取代檔案的備份。  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="destinationFileName" /> 參數所描述的路徑格式不合法。  -或-  <paramref name="destinationBackupFileName" /> 參數所描述的路徑格式不合法。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destinationFileName" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DriveNotFoundException">指定了無效的磁碟機。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到目前 <see cref="T:System.IO.FileInfo" /> 物件所描述的檔案。  -或-  找不到 <paramref name="destinationBackupFileName" /> 參數所描述的檔案。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。  \- 或 -  <paramref name="sourceFileName" /> 和 <paramref name="destinationFileName" /> 參數指定相同的檔案。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.PlatformNotSupportedException">作業系統是 Windows 98 Second Edition 或更早版本，而且檔案系統不是 NTFS。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="sourceFileName" /> 或 <paramref name="destinationFileName" /> 參數指定唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  來源或目的地參數指定的是目錄，不是檔案。  -或-  呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">要寫入的權限所描述檔案<paramref name="destinationBackupFileName" />如果指定的參數。 安全性動作： 需求。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAccessControl(System::String ^ path, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">檔案，要加入或從中移除存取控制清單 (ACL) 項目。</param>
        <param name="fileSecurity">
          <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件，描述要套用至 <c>path</c> 參數所描述之檔案的 ACL 項目。</param>
        <summary>將 <see cref="T:System.Security.AccessControl.FileSecurity" /> 物件描述的存取控制清單 (ACL) 項目套用至指定的檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.File.SetAccessControl%2A>方法適用於代表 noninherited 的 ACL 清單的檔案存取控制清單 (ACL) 項目。  
  
> [!CAUTION]
>  指定 ACL`fileSecurity`參數已取代現有檔案的 ACL。 若要加入之新使用者的權限，請使用<xref:System.IO.File.GetAccessControl%2A>方法來取得現有的 ACL，修改它，然後使用<xref:System.IO.File.SetAccessControl%2A>套用回到檔案。  
  
 ACL 描述個人及/或群組，讓他們已經有或沒有，在指定的檔案上採取特定動作的權限。 如需詳細資訊，請參閱[如何：新增或移除存取控制清單項目](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md)。  
  
 <xref:System.IO.File.SetAccessControl%2A>方法仍然只存在<xref:System.Security.AccessControl.FileSecurity>物件建立後已修改的物件。  如果<xref:System.Security.AccessControl.FileSecurity>不修改物件，不會保存至檔案。  因此，不可以擷取<xref:System.Security.AccessControl.FileSecurity>物件從一個檔案，並重新套用到另一個檔案的相同物件。  
  
 若要將 ACL 資訊從一個檔案複製到另一個：  
  
1.  使用<xref:System.IO.File.GetAccessControl%2A>方法來擷取<xref:System.Security.AccessControl.FileSecurity>從原始程式檔的物件。  
  
2.  建立新<xref:System.Security.AccessControl.FileSecurity>目的地檔案的物件。  
  
3.  使用<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>或<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>來源方法<xref:System.Security.AccessControl.FileSecurity>擷取 ACL 資訊的物件。  
  
4.  使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>或<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法可複製的資訊擷取到目的地的步驟 3 中<xref:System.Security.AccessControl.FileSecurity>物件。  
  
5.  設定目的地<xref:System.Security.AccessControl.FileSecurity>物件到目的地檔案時使用<xref:System.IO.File.SetAccessControl%2A>方法。  
  
 在 NTFS 環境中，<xref:System.Security.AccessControl.FileSystemRights.ReadAttributes>和<xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>授與使用者時如果使用者具有<xref:System.Security.AccessControl.FileSystemRights.ListDirectory>父資料夾的權限。 若要拒絕<xref:System.Security.AccessControl.FileSystemRights.ReadAttributes>和<xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>，拒絕<xref:System.Security.AccessControl.FileSystemRights.ListDirectory>父目錄上。  
  
   
  
## Examples  
 下列程式碼範例使用<xref:System.IO.File.GetAccessControl%2A>和<xref:System.IO.File.SetAccessControl%2A>方法來新增，然後再移除存取控制清單 (ACL) 項目從檔案。  您必須提供有效的使用者或群組帳戶，才能執行這個範例。  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">
          <paramref name="path" /> 參數為 <see langword="null" />。</exception>
        <exception cref="T:System.SystemException">找不到檔案。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 參數指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 參數指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileSecurity" /> 參數為 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於存取檔案的使用權限。 安全性動作： 需求。 列舉型別相關聯： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />， <see cref="F:System.Security.AccessControl.AccessControlActions.Change" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetAttributes">
      <MemberSignature Language="C#" Value="public static void SetAttributes (string path, System.IO.FileAttributes fileAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttributes(string path, valuetype System.IO.FileAttributes fileAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAttributes(System.String,System.IO.FileAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttributes(System::String ^ path, System::IO::FileAttributes fileAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileAttributes" Type="System.IO.FileAttributes" />
      </Parameters>
      <Docs>
        <param name="path">檔案的路徑。</param>
        <param name="fileAttributes">列舉值的位元組合。</param>
        <summary>在指定路徑上設定檔案的指定 <see cref="T:System.IO.FileAttributes" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 某些檔案屬性例如<xref:System.IO.FileAttributes.Hidden>和<xref:System.IO.FileAttributes.ReadOnly>，可以結合。 其他屬性，例如<xref:System.IO.FileAttributes.Normal>，必須單獨使用。  
  
 不可能變更的壓縮狀態<xref:System.IO.File>物件使用<xref:System.IO.File.SetAttributes%2A>方法。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會示範`GetAttributes`和`SetAttributes`方法藉由套用`Archive`和`Hidden`屬性加入檔案。  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 是空白的、只包含泛空白字元、包含無效字元，或檔案屬性無效。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到檔案。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於讀取和寫入檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTime (path As String, creationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTime(System::String ^ path, DateTime creationTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">要設定其建立日期和時間資訊的檔案。</param>
        <param name="creationTime">
          <see cref="T:System.DateTime" />，包含要為 <c>path</c> 的建立日期和時間設定的值。 這個值以本地時間表示。</param>
        <summary>設定檔案建立的日期和時間。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 NTFS 格式化磁碟機可能會快取檔案中繼資訊，例如一段時間的檔案建立時間。 如此一來，可能需要明確地將設定檔的建立時間，如果您要覆寫或取代現有的檔案。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">找不到指定的路徑。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.IOException">執行此作業時發生 I/O 錯誤</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> 指定這個作業允許的日期、時間或兩者範圍之外的值。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入至指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCreationTimeUtc (path As String, creationTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCreationTimeUtc(System::String ^ path, DateTime creationTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">要設定其建立日期和時間資訊的檔案。</param>
        <param name="creationTimeUtc">
          <see cref="T:System.DateTime" />，包含要為 <c>path</c> 的建立日期和時間設定的值。 這個值以 UTC 時間表示。</param>
        <summary>設定檔案建立的日期和時間，格式為國際標準時間 (UTC)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 NTFS 格式化磁碟機可能會快取檔案中繼資訊，例如一段時間的檔案建立時間。 如此一來，可能需要明確地將設定檔的建立時間，如果您要覆寫或取代現有的檔案。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">找不到指定的路徑。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.IOException">執行此作業時發生 I/O 錯誤</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> 指定這個作業允許的日期、時間或兩者範圍之外的值。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入至指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTime (path As String, lastAccessTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTime(System::String ^ path, DateTime lastAccessTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">要設定其存取日期和時間資訊的檔案。</param>
        <param name="lastAccessTime">
          <see cref="T:System.DateTime" />，包含要為 <c>path</c> 的上次存取日期和時間設定的值。 這個值以本地時間表示。</param>
        <summary>取得指定檔案上一次被存取的日期和時間。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會檢查指定的檔案，如有必要，建立的檔案系統，然後設定並取得上次存取時間。  
  
 [!code-cpp[file setlastaccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastAccess/CPP/file setlastaccess.cpp#1)]
 [!code-csharp[file setlastaccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastAccess/CS/file setlastaccess.cs#1)]
 [!code-vb[file setlastaccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastAccess/VB/file setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到指定的路徑。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" /> 指定這個作業允許的日期或時間範圍以外的值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入至指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastAccessTimeUtc (path As String, lastAccessTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastAccessTimeUtc(System::String ^ path, DateTime lastAccessTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">要設定其存取日期和時間資訊的檔案。</param>
        <param name="lastAccessTimeUtc">
          <see cref="T:System.DateTime" />，包含要為 <c>path</c> 的上次存取日期和時間設定的值。 這個值以 UTC 時間表示。</param>
        <summary>設定指定檔案上次被存取的日期和時間，格式為國際標準時間 (UTC)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到指定的路徑。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" /> 指定這個作業允許的日期或時間範圍以外的值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入至指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTime (path As String, lastWriteTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTime(System::String ^ path, DateTime lastWriteTime);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">要設定其日期和時間資訊的檔案。</param>
        <param name="lastWriteTime">
          <see cref="T:System.DateTime" />，包含要為 <c>path</c> 的上次寫入日期和時間設定的值。 這個值以本地時間表示。</param>
        <summary>設定指定檔案上次被寫入的日期和時間。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
   
  
## Examples  
 下列範例會檢查檔案系統中指定的檔案，建立檔案，如有必要，然後設定和取得檔案的上次寫入時間。  
  
 [!code-cpp[file setlastwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastWrite/CPP/file setlastwrite.cpp#1)]
 [!code-csharp[file setlastwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastWrite/CS/file setlastwrite.cs#1)]
 [!code-vb[file setlastwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastWrite/VB/file setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到指定的路徑。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" /> 指定這個作業允許的日期或時間範圍以外的值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入至指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLastWriteTimeUtc (path As String, lastWriteTimeUtc As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLastWriteTimeUtc(System::String ^ path, DateTime lastWriteTimeUtc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">要設定其日期和時間資訊的檔案。</param>
        <param name="lastWriteTimeUtc">
          <see cref="T:System.DateTime" />，包含要為 <c>path</c> 的上次寫入日期和時間設定的值。 這個值以 UTC 時間表示。</param>
        <summary>設定指定檔案上次寫入的日期和時間，格式為國際標準時間 (UTC)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`參數可以指定相對或絕對路徑資訊。 相對路徑的資訊會解譯為與目前工作目錄。 若要取得目前工作目錄，請參閱<xref:System.IO.Directory.GetCurrentDirectory%2A>。  
  
 如需的一般 I/O 工作清單，請參閱[一般 I/O 工作](~/docs/standard/io/common-i-o-tasks.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到指定的路徑。</exception>
        <exception cref="T:System.UnauthorizedAccessException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" /> 指定這個作業允許的日期或時間範圍以外的值。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入至指定的檔案。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <altmember cref="T:System.IO.FileSystemWatcher" />
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string path, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllBytes(string path, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllBytes (path As String, bytes As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllBytes(System::String ^ path, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="path">要寫入其中的檔案。</param>
        <param name="bytes">要寫入檔案的位元組。</param>
        <summary>建立新檔案，將指定的位元組陣列寫入檔案，然後關閉檔案。 如果檔案已經存在，則會覆寫該檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定的位元組陣列和檔案路徑，這個方法開啟指定的檔案、 位元組陣列的內容寫入至檔案，，然後關閉檔案。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 為 <see langword="null" />，或位元組陣列為空。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入檔案或目錄的存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllBytesAsync (string path, byte[] bytes, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllBytesAsync(string path, unsigned int8[] bytes, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytesAsync(System.String,System.Byte[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllLines">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新檔案，並於檔案中寫入一或多個字串，然後關閉檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">要寫入其中的檔案。</param>
        <param name="contents">要寫入檔案的幾行內容。</param>
        <summary>建立新檔案，並於檔案中寫入字串的集合，然後關閉檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設行為<xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>方法是使用 utf-8 編碼的位元組順序標示 (BOM) 不會寫出資料。 如果需要包含 utf-8 識別碼，例如位元組順序標記，在檔案開頭使用<xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29>方法多載<xref:System.Text.Encoding.UTF8%2A>編碼方式。  
  
 如果檔案已經存在，則會覆寫該檔案。  
  
 您可以使用這個方法建立的內容的集合類別接受<xref:System.Collections.Generic.IEnumerable%601>在其建構函式，例如<xref:System.Collections.Generic.List%601.%23ctor%2A>， <xref:System.Collections.Generic.HashSet%601.%23ctor%2A>，或<xref:System.Collections.Generic.SortedSet%601.%23ctor%2A>類別。  
  
   
  
## Examples  
 下列範例從範例資料檔寫入所選的行至檔案。  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串、只包含空格或包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的一或多個無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 或 <paramref name="contents" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> 無效 (例如，位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> 超過系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 會指定唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 是目錄。  -或-  呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllLines (path As String, contents As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="path">要寫入其中的檔案。</param>
        <param name="contents">要寫入檔案的字串陣列。</param>
        <summary>建立新檔案，將指定的字串陣列寫入檔案，然後關閉檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果檔案已經存在，則會覆寫該檔案。  
  
 預設行為<xref:System.IO.File.WriteAllLines%2A>方法會寫出使用 utf-8 編碼不使用位元組順序標示 (BOM) 的資料。 如果需要包含 utf-8 識別碼，例如位元組順序標記，在檔案開頭使用<xref:System.IO.File.WriteAllLines%28System.String%2CSystem.String%5B%5D%2CSystem.Text.Encoding%29>方法多載<xref:System.Text.Encoding.UTF8%2A>編碼方式。  
  
 指定的字串陣列和檔案路徑，這個方法開啟指定的檔案，將字串陣列寫入檔案，，然後關閉檔案。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.File.WriteAllLines%2A>方法將文字寫入至檔案。 在此範例中會建立一個檔案，如果它不存在，而且加入文字。  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 或 <paramref name="contents" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入檔案或目錄的存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">要寫入其中的檔案。</param>
        <param name="contents">要寫入檔案的幾行內容。</param>
        <param name="encoding">要使用的字元編碼。</param>
        <summary>使用指定編碼方式建立新檔案，並將字串的集合寫入檔案，然後關閉檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果檔案已經存在，則會覆寫該檔案。  
  
 您可以使用這個方法來建立包含下列檔案：  
  
-   結果[LINQ to Objects](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9)取得使用的查詢上的檔案、 行<xref:System.IO.File.ReadLines%2A>方法。  
  
-   集合中實作的內容<xref:System.Collections.Generic.IEnumerable%601>的字串。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串、只包含空格或包含 <see cref="M:System.IO.Path.GetInvalidPathChars" /> 方法所定義的一或多個無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" />、<paramref name="contents" /> 或 <paramref name="encoding" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> 無效 (例如，位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> 超過系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 會指定唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 是目錄。  -或-  呼叫端沒有必要的權限。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[],System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllLines(System::String ^ path, cli::array &lt;System::String ^&gt; ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">要寫入其中的檔案。</param>
        <param name="contents">要寫入檔案的字串陣列。</param>
        <param name="encoding">
          <see cref="T:System.Text.Encoding" /> 物件，代表套用至字串陣列的字元編碼方式。</param>
        <summary>建立新檔案，使用指定的編碼方式將指定的字串陣列寫入檔案，然後關閉檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果檔案已經存在，則會覆寫該檔案。  
  
 指定的字串陣列和檔案路徑，這個方法開啟指定的檔案、 字串陣列寫入使用指定的編碼，檔案，然後關閉檔案。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.File.WriteAllLines%2A>方法將文字寫入至檔案。 在此範例中會建立一個檔案，如果它不存在，而且加入文字。  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 或 <paramref name="contents" /> 是 <see langword="null" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入檔案或目錄的存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立新檔案，將內容寫入檔案，然後關閉檔案。 如果檔案已經存在，則會覆寫該檔案。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteAllText (path As String, contents As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">要寫入其中的檔案。</param>
        <param name="contents">要寫入檔案的字串。</param>
        <summary>建立新檔案，將指定的字串寫入檔案，然後關閉檔案。 如果檔案已經存在，則會覆寫該檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會使用 utf-8 編碼方式沒有位元組順序標記 (BOM)，因此使用<xref:System.Text.Encoding.GetPreamble%2A>方法會傳回空的位元組陣列。 如果需要包含 utf-8 識別碼，例如位元組順序標記，在檔案開頭使用<xref:System.IO.File.WriteAllText%28System.String%2CSystem.String%2CSystem.Text.Encoding%29>方法多載<xref:System.Text.Encoding.UTF8%2A>編碼方式。  
  
 指定字串和檔案路徑，這個方法開啟指定的檔案、 將字串寫入檔案，然後關閉檔案。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.File.WriteAllText%2A>方法將文字寫入至檔案。 在此範例中會建立一個檔案，如果它不存在，而且加入文字。  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 是 <see langword="null" /> 或 <paramref name="contents" /> 是空的。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入檔案或目錄的存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteAllText(System::String ^ path, System::String ^ contents, System::Text::Encoding ^ encoding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">要寫入其中的檔案。</param>
        <param name="contents">要寫入檔案的字串。</param>
        <param name="encoding">要套用至字串的編碼方式。</param>
        <summary>建立新檔案，使用指定的編碼方式將指定的字串寫入檔案，然後關閉檔案。 如果檔案已經存在，則會覆寫該檔案。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定字串和檔案路徑，這個方法開啟指定的檔案，將字串寫入檔案，使用指定的編碼，，然後關閉檔案。 即使引發例外狀況時要使用這個方法，關閉保證的檔案控制代碼。  
  
   
  
## Examples  
 下列程式碼範例示範如何使用<xref:System.IO.File.WriteAllText%2A>方法將文字寫入至檔案。 在此範例中會建立一個檔案，如果它不存在，而且加入文字。  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 為零長度字串，只包含空格，或包含一或多個如 <see cref="F:System.IO.Path.InvalidPathChars" /> 所定義的無效字元。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> 是 <see langword="null" /> 或 <paramref name="contents" /> 是空的。</exception>
        <exception cref="T:System.IO.PathTooLongException">指定的路徑、檔案名稱，或兩者都超出系統定義的長度上限。 例如，在 Windows 架構的平台上，路徑必須少於 248 個字元，檔案名稱必須少於 260 個字元。</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">指定的路徑無效 (例如，它位於未對應的磁碟機上)。</exception>
        <exception cref="T:System.IO.IOException">開啟檔案時發生 I/O 錯誤。</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> 指定了唯讀的檔案。  -或-  這個作業在目前平台不受支援。  -或-  <paramref name="path" /> 指定了目錄。  -或-  呼叫端沒有必要的權限。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> 格式無效。</exception>
        <exception cref="T:System.Security.SecurityException">呼叫端沒有必要的權限。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用於寫入檔案或目錄的存取。 相關聯的列舉型別： <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>