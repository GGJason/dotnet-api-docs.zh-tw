<Type Name="Cer" FullName="System.Runtime.ConstrainedExecution.Cer">
  <TypeSignature Language="C#" Value="public enum Cer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed Cer extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.ConstrainedExecution.Cer" />
  <TypeSignature Language="VB.NET" Value="Public Enum Cer" />
  <TypeSignature Language="C++ CLI" Value="public enum class Cer" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary><span data-ttu-id="ffd51-101">指定在限制之執行區域內呼叫時的方法行為。</span><span class="sxs-lookup"><span data-stu-id="ffd51-101">Specifies a method's behavior when called within a constrained execution region.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ffd51-102"><xref:System.Runtime.ConstrainedExecution.Cer>列舉值會指定方法、 類型或組件在限制的執行區域 (CER) 內的行為。</span><span class="sxs-lookup"><span data-stu-id="ffd51-102">The <xref:System.Runtime.ConstrainedExecution.Cer> enumeration specifies the behavior of a method, type, or assembly within a constrained execution region (CER).</span></span> <span data-ttu-id="ffd51-103">使用其中一個可用的三個值，表示的實體將會成功，並不了解 CER，或者 （具決定性） 可報告成功或失敗。</span><span class="sxs-lookup"><span data-stu-id="ffd51-103">Use one of the three available values to indicate that the entity will succeed, has no knowledge of a CER, or might (deterministically) be able to report success or failure.</span></span>  
  
 <span data-ttu-id="ffd51-104">CER 提供將執行的程式碼區域的保證不會中斷即使已中止的執行緒記憶體不足例外狀況或堆疊溢位等非同步例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ffd51-104">A CER provides guarantees that the region of code will execute uninterrupted even if an asynchronous exception such as an aborted thread out-of-memory exception, or stack overflow is raised.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ffd51-105">下列程式碼範例示範如何使用<xref:System.Runtime.ConstrainedExecution.Cer>列舉指定方法的限制的執行區域時。</span><span class="sxs-lookup"><span data-stu-id="ffd51-105">The following code example demonstrates the use of the <xref:System.Runtime.ConstrainedExecution.Cer> enumeration when specifying a constrained execution region for a method.</span></span> <span data-ttu-id="ffd51-106">這個程式碼範例是針對所提供之較大範例的一部分<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute.%23ctor%2A>建構函式。</span><span class="sxs-lookup"><span data-stu-id="ffd51-106">This code example is part of a larger example provided for the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute.%23ctor%2A> constructor.</span></span>  
  
 [!code-csharp[System.Runtime.ConstrainedExecution#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.ConstrainedExecution/cs/program.cs#3)]
 [!code-vb[System.Runtime.ConstrainedExecution#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.ConstrainedExecution/vb/program.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions" />
    <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)" />
  </Docs>
  <Members>
    <Member MemberName="MayFail">
      <MemberSignature Language="C#" Value="MayFail" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Runtime.ConstrainedExecution.Cer MayFail = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.ConstrainedExecution.Cer.MayFail" />
      <MemberSignature Language="VB.NET" Value="MayFail" />
      <MemberSignature Language="C++ CLI" Value="MayFail" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.ConstrainedExecution.Cer</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary><span data-ttu-id="ffd51-107">在例外條件下，此方法可能失敗。</span><span class="sxs-lookup"><span data-stu-id="ffd51-107">In the face of exceptional conditions, the method might fail.</span></span> <span data-ttu-id="ffd51-108">在這種情況下，此方法會向呼叫方法報告成功或失敗。</span><span class="sxs-lookup"><span data-stu-id="ffd51-108">In this case, the method will report back to the calling method whether it succeeded or failed.</span></span> <span data-ttu-id="ffd51-109">此方法必須在方法主體的週圍具備 CER 以確保它可以報告傳回值。</span><span class="sxs-lookup"><span data-stu-id="ffd51-109">The method must have a CER around the method body to ensure that it can report the return value.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="None" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Runtime.ConstrainedExecution.Cer None = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.ConstrainedExecution.Cer.None" />
      <MemberSignature Language="VB.NET" Value="None" />
      <MemberSignature Language="C++ CLI" Value="None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.ConstrainedExecution.Cer</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary><span data-ttu-id="ffd51-110">方法、型別或組件沒有 CER 概念。</span><span class="sxs-lookup"><span data-stu-id="ffd51-110">The method, type, or assembly has no concept of a CER.</span></span> <span data-ttu-id="ffd51-111">它不會利用 CER 保證。</span><span class="sxs-lookup"><span data-stu-id="ffd51-111">It does not take advantage of CER guarantees.</span></span> <span data-ttu-id="ffd51-112">這具有如下表示：</span><span class="sxs-lookup"><span data-stu-id="ffd51-112">This implies the following:</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   <span data-ttu-id="ffd51-113">例外狀況的方法可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="ffd51-113">In the face of exceptional conditions the method might fail.</span></span>  
  
-   <span data-ttu-id="ffd51-114">此方法可能會或可能不會報告失敗 （它是不具決定性的）。</span><span class="sxs-lookup"><span data-stu-id="ffd51-114">The method might or might not report that it failed (it is non-deterministic).</span></span>  
  
-   <span data-ttu-id="ffd51-115">方法不會寫入與 Cer 記住 （這是最可能的案例）。</span><span class="sxs-lookup"><span data-stu-id="ffd51-115">The method is not written with CERs in mind (which is the most likely scenario).</span></span>  
  
 <span data-ttu-id="ffd51-116">如果方法、 類型或組件不明確標記為成功，隱含地標示為`Cer.None`。</span><span class="sxs-lookup"><span data-stu-id="ffd51-116">If a method, type, or assembly is not explicitly marked to succeed, it is implicitly marked as `Cer.None`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Success">
      <MemberSignature Language="C#" Value="Success" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Runtime.ConstrainedExecution.Cer Success = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.ConstrainedExecution.Cer.Success" />
      <MemberSignature Language="VB.NET" Value="Success" />
      <MemberSignature Language="C++ CLI" Value="Success" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.ConstrainedExecution.Cer</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary><span data-ttu-id="ffd51-117">在例外條件下，此方法會保證成功。</span><span class="sxs-lookup"><span data-stu-id="ffd51-117">In the face of exceptional conditions, the method is guaranteed to succeed.</span></span> <span data-ttu-id="ffd51-118">應永遠在呼叫的方法週圍建構 CER，即使它是從非 CER 區域中呼叫的也如此。</span><span class="sxs-lookup"><span data-stu-id="ffd51-118">You should always construct a CER around the method that is called, even when it is called from within a non-CER region.</span></span> <span data-ttu-id="ffd51-119">如果完成其預定要做的，則方法會成功。</span><span class="sxs-lookup"><span data-stu-id="ffd51-119">A method is successful if it accomplishes what is intended.</span></span> <span data-ttu-id="ffd51-120">例如，以 <c>ReliabilityContractAttribute(Cer.Success)</c> 標記 <see cref="P:System.Collections.ArrayList.Count" />，表示在 CER 下執行時，一律傳回 <see cref="T:System.Collections.ArrayList" /> 中的項目計數，絕不會讓內部欄位處於未定狀態。</span><span class="sxs-lookup"><span data-stu-id="ffd51-120">For example, marking <see cref="P:System.Collections.ArrayList.Count" /> with <c>ReliabilityContractAttribute(Cer.Success)</c> implies that when it is run under a CER, it always returns a count of the number of elements in the <see cref="T:System.Collections.ArrayList" /> and it can never leave the internal fields in an undetermined state.</span></span></summary>
      </Docs>
    </Member>
  </Members>
</Type>