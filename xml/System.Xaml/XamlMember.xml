<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="81d50a3ca76157834fc7eb0634ae1d13af8fe855" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36444387" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>提供 XAML 型別系統識別項給 XAML 型別的成員。 這個識別項會由 XAML 讀取器和 XAML 寫入器在處理成員節點期間 (當 XAML 讀取器位於 <see cref="F:System.Xaml.XamlNodeType.StartMember" /> 時) 使用，同時也會用於一般 XAML 型別系統邏輯。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember> 可以使用三個方法，傳回 XAML 成員的相關資訊： 標準 common language runtime (CLR) 反映;呼叫內部參考僅限反映技術 Api 該使用最佳化的位元旗標。虛擬呼叫覆寫或`Lookup*`API 所提供的可能<xref:System.Xaml.XamlMember>子類別。 對於大部分的.NET Framework XAML 服務 Api 使用和<xref:System.Xaml.XamlMember>API，您使用的預設 XAML 結構描述內容。 .NET Framework XAML 服務的預設 XAML 結構描述內容會使用 CLR 型別系統支援。 這可讓處理任何類型或成員定義在中，或其他可、 CLR 和其反映技術的 XAML 讀取器和 XAML 寫入器。  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>查閱 * Api 和 XamlMember 衍生類別  
 <xref:System.Xaml.XamlMember> 定義數個衍生類別的虛擬成員可能會覆寫。 這些成員具有一律開頭為字串的名稱`Lookup`。 API 的其餘部分名稱參考的虛擬方法影響的屬性。 例如，<xref:System.Xaml.XamlMember>衍生的類別可能會覆寫<xref:System.Xaml.XamlMember.LookupTargetType%2A>影響哪些基底定義的屬性<xref:System.Xaml.XamlMember.TargetType%2A>傳回衍生類別中。 您可以預測中這類屬性的傳回值<xref:System.Xaml.XamlMember>或現有的衍生類別所閱讀相關的文件`Lookup*`方法。  
  
 目的`Lookup*`方法是提供 XAML 類型系統擴充功能的技術，其中包含<xref:System.Xaml.XamlMember>基底類別。 由衍生自<xref:System.Xaml.XamlMember>和覆寫`Lookup`虛擬成員，您可以定義 XAML 結構描述的是 XAML 成員的概念中，XAML 類型系統而不必受限於支援類型系統或技術的細節。 您可以也使用提供的 XAML 結構描述內容在此配置下，仍會傳回您想要的結果。  
  
 例如，請考慮<xref:System.Xaml.XamlMember>屬性<xref:System.Xaml.XamlMember.IsWritePublic%2A>。 這個屬性就會通知呼叫端，該作業，例如使用<xref:System.Xaml.XamlWriter>序列化可以寫入此成員值的目標物件上。 在預設實作中，該成員是否可寫入的決定使用針對支援 CLR 反映技術<xref:System.Type>及其成員 ( <xref:System.Reflection.MemberInfo>)。 因此，根據預設，XAML 類型系統取決於 CLR 型別系統。 不過，您可以移除此依存性，您 XAML 類型系統報告的<xref:System.Xaml.XamlMember.IsWritePublic%2A>藉由覆寫應用程式開發介面<xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>。 在您的覆寫中，您可以使用例如屬於您的技術，最適合用於固定的 XAML 詞彙，或是各種其他策略來判斷是否為 XAML 成員是在可寫入的主要的查閱資料表的中繼資料的其他決定您XAML 詞彙。  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>建構 XamlMember 沒有 XAML 結構描述內容  
 大部分的建構函式的<xref:System.Xaml.XamlMember>需要<xref:System.Xaml.XamlSchemaContext>做為其初始設定的一部分。 <xref:System.Xaml.XamlSchemaContext>也是必要的許多內部<xref:System.Xaml.XamlSchemaContext>作業，例如取得轉寄從支援類型的資訊。 當您正在使用<xref:System.Xaml.XamlMember>API，您通常會有<xref:System.Xaml.XamlSchemaContext>的是可以從周圍建構例如<xref:System.Xaml.XamlWriter>。 在此情況下，您可以傳遞<xref:System.Xaml.XamlSchemaContext>透過參考所有 XAML 類型系統呼叫需要 XAML 結構描述內容。  
  
 一個特定建構函式， <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>，不需要<xref:System.Xaml.XamlSchemaContext>。 不過， <xref:System.Xaml.XamlMember> ，建構<xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>簽章傳回`true`如<xref:System.Xaml.XamlMember.IsUnknown%2A>。  
  
 適用於牽涉到的載入路徑<xref:System.Xaml.XamlObjectWriter>，這類成員無法寫入物件圖形。 使用.NET Framework XAML 服務實作中，<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType>呼叫會擲回<xref:System.Xaml.XamlObjectWriterException>時相關<xref:System.Xaml.XamlMember>報表`true`如<xref:System.Xaml.XamlMember.IsUnknown%2A>。  
  
 您不應該建構<xref:System.Xaml.XamlMember>的值`true`如<xref:System.Xaml.XamlMember.IsUnknown%2A>除非您的實作可以處理的例外狀況，從<xref:System.Xaml.XamlObjectWriter>，或者有其他方式來調整<xref:System.Xaml.XamlObjectWriter>行為。 例如，一或多個下列可能的實作，則為 true:  
  
-   稍後可 XAML 結構描述內容。  
  
-   您使用的成員啟動程式模式。  
  
-   刻意覆寫<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType>自訂 XAML 寫入器。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xaml.XamlMember" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">表示事件成員的 CLR 型別系統 <see cref="T:System.Reflection.EventInfo" />。</param>
        <param name="schemaContext">用來限定成員的 <see cref="T:System.Xaml.XamlSchemaContext" /> 內容。</param>
        <summary>使用 CLR 型別系統 <see cref="T:System.Xaml.XamlMember" /> 和 <see cref="T:System.Reflection.EventInfo" />，初始化 <see cref="T:System.Xaml.XamlSchemaContext" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成員表示的事件 （事件處理常式連接點屬性），請使用這個建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">表示屬性成員的 CLR 型別系統 <see cref="T:System.Reflection.PropertyInfo" />。</param>
        <param name="schemaContext">用來限定成員的 <see cref="T:System.Xaml.XamlSchemaContext" /> 內容。</param>
        <summary>使用 CLR 型別系統 <see cref="T:System.Xaml.XamlMember" /> 和 <see cref="T:System.Reflection.PropertyInfo" />，初始化 <see cref="T:System.Xaml.XamlSchemaContext" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成員表示的屬性 （並不特別的事件處理常式連接），請使用這個建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">表示事件成員的 CLR 型別系統 <see cref="T:System.Reflection.EventInfo" />。</param>
        <param name="schemaContext">用來限定成員的 <see cref="T:System.Xaml.XamlSchemaContext" /> 內容。</param>
        <param name="invoker">
          <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 實作，可處理對 <see cref="T:System.Xaml.XamlMember" /> 的執行階段反映呼叫。</param>
        <summary>使用 CLR 型別系統 <see cref="T:System.Xaml.XamlMember" /> 和 <see cref="T:System.Reflection.EventInfo" /> (包含 <see cref="T:System.Xaml.XamlSchemaContext" /> 資訊)，初始化 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成員表示一個事件 （或事件處理常式連接點屬性），請使用這個建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">表示屬性成員的 CLR 型別系統 <see cref="T:System.Reflection.PropertyInfo" />。</param>
        <param name="schemaContext">用來限定成員的 <see cref="T:System.Xaml.XamlSchemaContext" /> 內容。</param>
        <param name="invoker">
          <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 實作，可處理對 <see cref="T:System.Xaml.XamlMember" /> 的執行階段叫用呼叫。</param>
        <summary>使用反映 <see cref="T:System.Xaml.XamlMember" /> 和 <see cref="T:System.Reflection.PropertyInfo" /> (包含 <see cref="T:System.Xaml.XamlSchemaContext" /> 資訊)，初始化 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個建構函式，而且不是事件處理常式連接才成員表示的屬性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">可附加事件的字串名稱。</param>
        <param name="adder">可附加成員之支援實作的處理常式 <see langword="Add" /> 方法的 CLR 型別系統 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="schemaContext">用來限定成員的 <see cref="T:System.Xaml.XamlSchemaContext" /> 內容。</param>
        <summary>針對表示可附加事件的 <see cref="T:System.Xaml.XamlMember" />，初始化 <see cref="T:System.Xaml.XamlMember" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成員表示可附加的事件成員，請使用這個建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">成員的字串名稱。</param>
        <param name="declaringType">進行宣告的型別的 <see cref="T:System.Xaml.XamlType" /> 資訊。</param>
        <param name="isAttachable">
          <see langword="true" /> 表示成員為可附加成員，否則為 <see langword="false" />。</param>
        <summary>使用字串名稱並宣告 <see cref="T:System.Xaml.XamlMember" /> 資訊，初始化 <see cref="T:System.Xaml.XamlType" /> 類別的新執行個體。 使用此簽章建構的 <see cref="T:System.Xaml.XamlMember" /> 具有諸多限制。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Xaml.XamlMember> ，建構<xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>簽章傳回`true`如<xref:System.Xaml.XamlMember.IsUnknown%2A>。  
  
 適用於牽涉到的載入路徑<xref:System.Xaml.XamlObjectWriter>，這類成員無法寫入物件圖形。 使用.NET Framework XAML 服務實作中，<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType>呼叫會擲回<xref:System.Xaml.XamlObjectWriterException>時相關<xref:System.Xaml.XamlMember>報表`true`如<xref:System.Xaml.XamlMember.IsUnknown%2A>。  
  
 您不應該建構<xref:System.Xaml.XamlMember>與<xref:System.Xaml.XamlMember.IsUnknown%2A>`true`除非您的實作可以處理的例外狀況，從<xref:System.Xaml.XamlObjectWriter>，或者有其他方式來調整<xref:System.Xaml.XamlObjectWriter>行為。 例如，一或多個下列可能的實作，則為 true:  
  
-   稍後可 XAML 結構描述內容。  
  
-   您使用的成員啟動程式模式。  
  
-   刻意覆寫<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType>自訂 XAML 寫入器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> 或 <paramref name="declaringType" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">可附加屬性的字串名稱。</param>
        <param name="getter">可附加成員之支援實作的 <see langword="get" /> 存取子的 CLR 型別系統 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="setter">可附加成員之支援實作的 <see langword="set" /> 存取子的 CLR 型別系統 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="schemaContext">用來限定成員的 <see cref="T:System.Xaml.XamlSchemaContext" /> 內容。</param>
        <summary>針對表示可附加屬性的 <see cref="T:System.Xaml.XamlMember" />，初始化 <see cref="T:System.Xaml.XamlMember" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成員表示的可附加屬性，請使用這個建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">可附加事件的字串名稱。</param>
        <param name="adder">可附加成員之支援實作的處理常式 <see langword="Add" /> 方法的 CLR 型別系統 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="schemaContext">用來限定成員的 <see cref="T:System.Xaml.XamlSchemaContext" /> 內容。</param>
        <param name="invoker">
          <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 實作，可處理對 <see cref="T:System.Xaml.XamlMember" /> 的執行階段叫用呼叫。</param>
        <summary>針對表示可附加事件的 <see cref="T:System.Xaml.XamlMember" /> (包含 <see cref="T:System.Xaml.XamlMember" /> 資訊)，初始化 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成員表示可附加的事件成員，請使用這個建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">可附加屬性的字串名稱。</param>
        <param name="getter">可附加成員之支援實作的 <see langword="get" /> 存取子的 CLR 型別系統 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="setter">可附加成員之支援實作的 <see langword="set" /> 存取子的 CLR 型別系統 <see cref="T:System.Reflection.MethodInfo" />。</param>
        <param name="schemaContext">用來限定成員的 <see cref="T:System.Xaml.XamlSchemaContext" /> 內容。</param>
        <param name="invoker">
          <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 實作，可處理對 <see cref="T:System.Xaml.XamlMember" /> 的執行階段叫用呼叫。</param>
        <summary>針對表示可附加屬性的 <see cref="T:System.Xaml.XamlMember" /> (包含 <see cref="T:System.Xaml.XamlMember" /> 資訊)，初始化 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果成員表示的可附加屬性的成員，請使用這個建構函式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得型別的 <see cref="T:System.Xaml.XamlType" />，這個型別宣告與此 <see cref="T:System.Xaml.XamlMember" /> 相關聯的成員。</summary>
        <value>型別的 <see cref="T:System.Xaml.XamlType" />，這個型別宣告與此 <see cref="T:System.Xaml.XamlMember" /> 相關聯的成員。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值通常在初始化期間設定，且通常不`null`。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A> 資訊可以傳入建構函式進行初始化。 藉由直接呼叫基底建構函式，初始化<xref:System.Xaml.XamlMember>衍生的類別可以省略部分程式在基底類別中進行值檢查。 因此，衍生的初始化可以變更報告的型別成員關聯性的資訊是 XAML 成員，使它不再符合預期的方式為基礎的 CLR 宣告的型別系統資訊。 宣告型別資訊的任何安全性關鍵的檢查，請改用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 物件，這個物件用於延後載入 XAML 宣告的物件。</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />，對泛型具有 <see cref="T:System.Xaml.XamlDeferringLoader" /> 條件約束。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Xaml.XamlMember.DeferringLoader%2A>叫用<xref:System.Xaml.XamlMember.LookupDeferringLoader%2A>或特定覆寫該方法。 在其中初始的內部反映邏輯具有已設定資訊的情況下，就會發生這種行為。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Xaml.XamlMember" /> 物件的清單。 這些物件會報告因與此 <see cref="T:System.Xaml.XamlMember" /> 有相對初始設定順序而存在相依關聯性的成員。</summary>
        <value>
          <see cref="T:System.Xaml.XamlMember" /> 物件的清單。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Xaml.XamlMember.DependsOn%2A>叫用<xref:System.Xaml.XamlMember.LookupDependsOn%2A>或特定覆寫該方法。 在其中初始的內部反映邏輯具有已設定資訊的情況下，就會發生這種行為。  
  
 `DependsOn`模式可以套用至刻意有所出入一般的 XAML 規則的物件模型案例。 一般的 XAML 規則是類型的成員，不會傳遞做為初始文字 （或在 XAML 2009 中的 factory 方法） 必須能夠依任何順序指定。 藉由套用`DependsOn`模式給成員，您可以指示 XAML 寫入器永遠會處理此成員之前參考的成員。 您可以套用在目前成員的值需要內容或之後，才可設定其他成員的其他資訊的位置的情況下此模式。  
  
 `DependsOn`模式應該套用明智並保留屬性情況下，它可以做架構的用途。 慢 XAML 處理可能需要大量的相依性。 此外，很可能會產生循環相依性，在此情況下，XAML 處理行為是未定義。  
  
 範例`DependsOn`從 WPF 的情況包括某些屬性上<xref:System.Windows.Controls.ControlTemplate>和<xref:System.Windows.DataTemplate>上<xref:System.Windows.Trigger>，然後在<xref:System.Windows.Setter>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指出目前的物件和另一個物件是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要與這個物件比較的物件。</param>
        <summary>指出目前的物件和另一個物件是否相等。</summary>
        <returns>若目前的物件等於 <see langword="true" /> 參數，則為 <paramref name="obj" />，否則即為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">要與此物件進行比較的物件。</param>
        <summary>指出目前的物件是否等於另一個相同類型的物件。</summary>
        <returns>若目前的物件等於 <see langword="true" /> 參數，則為 <paramref name="other" />，否則即為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個物件的雜湊程式碼。</summary>
        <returns>整數雜湊程式碼。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 XAML 成員可能存在之 XAML 命名空間的清單。</summary>
        <returns>XAML 命名空間識別項的清單 (字串形式)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會傳回<xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType>呼叫結果<xref:System.Xaml.XamlMember.DeclaringType%2A>與此相關聯<xref:System.Xaml.XamlMember>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與這個 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 相關聯的 <see cref="T:System.Xaml.XamlMember" /> 實作。</summary>
        <value>與這個 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 相關聯的 <see cref="T:System.Xaml.XamlMember" /> 實作。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Invoker`模式是進階的 XAML 類型系統擴充功能技術。 `Invoker`模式提供插入不同的結構描述型別對應的行為，同時仍然使用.NET Framework XAML 服務 XAML 類型系統定義的方法。  
  
 如果<xref:System.Xaml.XamlMember.LookupInvoker%2A>覆寫會傳回`null`，或如果預設實作會傳回`null`因為其欠缺<xref:System.Xaml.XamlMember.UnderlyingMember%2A>這個<xref:System.Xaml.XamlMember>、<xref:System.Xaml.XamlMember.Invoker%2A>屬性會傳回<xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>。  
  
 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> 是預設值。 這適用於大部分的操作，使用.NET Framework XAML 服務和預設 XAML 結構描述內容，並在其中任何特定覆寫`Invoker`XAML 類型系統實體的建構函式傳遞模式。  
  
 呼叫<xref:System.Xaml.XamlMember.Invoker%2A>叫用<xref:System.Xaml.XamlMember.LookupInvoker%2A>或特定覆寫該方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlMember" /> 是否報告為環境屬性。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlMember" /> 報告為環境屬性，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Xaml.XamlMember.IsAmbient%2A>叫用<xref:System.Xaml.XamlMember.LookupIsAmbient%2A>或特定覆寫該方法。 在其中初始的內部反映邏輯具有已設定資訊的實作，會發生此問題。  
  
 檢查環境的內容通常以確定物件和環境的使用方式的類型限定性條件所依賴的值可以正確運作的 XAML 處理邏輯的一部分。 .NET Framework XAML 服務 Api 和預設 XAML 結構描述內容會填入這個屬性與為基礎的值<xref:System.Windows.Markup.AmbientAttribute>。 預設實作<xref:System.Xaml.XamlMember.LookupIsAmbient%2A>使用這個現有<xref:System.Windows.Markup.AmbientAttribute>技術，並傳回`true`如果<xref:System.Windows.Markup.AmbientAttribute>存在於宣告的成員。  
  
 <xref:System.Windows.Markup.AmbientAttribute> 找到的數個 WPF 類型，包括成員上<xref:System.Windows.Application>， <xref:System.Windows.Setter>，和<xref:System.Windows.Style>。 它也可以找到上<xref:System.Windows.ResourceDictionary>connotes，任何成員，會使用型別<xref:System.Windows.ResourceDictionary>為其型別應該視為環境即使未特別屬性成員。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlMember" /> 是否為可附加的成員。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlMember" /> 是可附加的成員，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsAttachable%2A>值會初始化為基礎的建構函式用來建構<xref:System.Xaml.XamlMember>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlMember" /> 是否為 XAML 指示詞。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlMember" /> 是 XAML 指示詞，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsDirective%2A>值會初始化為基礎的建構函式用來建構<xref:System.Xaml.XamlMember>。 基底<xref:System.Xaml.XamlMember>建構函式初始化以便<xref:System.Xaml.XamlMember.IsDirective%2A>是`false`。 不過，<xref:System.Xaml.XamlDirective>類別 (<xref:System.Xaml.XamlMember>衍生的類別) 會初始化以便<xref:System.Xaml.XamlMember.IsDirective%2A>是`true`。  
  
 如果您想要報告<xref:System.Xaml.XamlMember.IsDirective%2A>為`true`的 XAML 成員的自訂 XAML 結構描述類別的呼叫端，確定您衍生自<xref:System.Xaml.XamlDirective>因為這是為了允許該行為的唯一方式。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示事件成員。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlMember" /> 表示事件，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Xaml.XamlMember.IsEvent%2A>叫用<xref:System.Xaml.XamlMember.LookupIsEvent%2A>或特定覆寫該方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlMember" /> 是否是使用有效的 <see langword="xamlName" /> 字串做為其 <see cref="P:System.Xaml.XamlMember.Name" /> 進行初始化。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlMember" /> 是使用有效的 <see langword="true" /> 字串進行初始化，則為 <see langword="xamlName" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示唯讀成員。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlMember" /> 表示唯讀成員，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Xaml.XamlMember.IsReadOnly%2A>叫用<xref:System.Xaml.XamlMember.LookupIsReadOnly%2A>或特定覆寫該方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示具有可呼叫之公用 <see langword="get" /> 存取子的成員。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlMember" /> 表示可呼叫的公用 <see langword="true" /> 存取子則為 <see langword="get" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsReadPublic%2A>是否值檢查<xref:System.Xaml.XamlMember.DeclaringType%2A>是公用的。 如果<xref:System.Xaml.XamlMember.DeclaringType%2A>為非公用，`get`存取子不是實際的方式，可呼叫和<xref:System.Xaml.XamlMember.IsReadPublic%2A>傳回`false`。  
  
 呼叫<xref:System.Xaml.XamlMember.IsReadPublic%2A>叫用<xref:System.Xaml.XamlMember.LookupIsReadPublic%2A>或特定覆寫該方法。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A>方法是虛擬的因此，可以覆寫。 覆寫就可能會變更 （惡意或失敗） 的報告的存取資訊的 XAML 成員，讓它不會再預期的方式會與對應的基礎 CLR 宣告的型別系統的存取資訊。 存取層級的任何安全性關鍵的檢查，請改用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示用於型別和成員解析的支援系統是否無法解析成員。</summary>
        <value>如果無法解析成員則為 <see langword="true" />，如果可以解析成員則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Xaml.XamlMember> ，建構<xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>簽章傳回`true`如<xref:System.Xaml.XamlMember.IsUnknown%2A>。  
  
 適用於牽涉到的載入路徑<xref:System.Xaml.XamlObjectWriter>、<xref:System.Xaml.XamlMember>與`true`如<xref:System.Xaml.XamlMember.IsUnknown%2A>無法寫入物件圖形。 在.NET Framework XAML 服務 Api 中的預設實作<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType>呼叫會擲回<xref:System.Xaml.XamlObjectWriterException>時相關<xref:System.Xaml.XamlMember>報表`true`如<xref:System.Xaml.XamlMember.IsUnknown%2A>。  
  
 您不應該建構<xref:System.Xaml.XamlMember>的值`true`如<xref:System.Xaml.XamlMember.IsUnknown%2A>除非您的實作可以處理的例外狀況，從<xref:System.Xaml.XamlObjectWriter>，或者有其他方式來調整<xref:System.Xaml.XamlObjectWriter>行為。  
  
 呼叫<xref:System.Xaml.XamlMember.IsUnknown%2A>叫用<xref:System.Xaml.XamlMember.LookupIsUnknown%2A>或特定覆寫該方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示唯寫成員。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlMember" /> 表示唯寫成員，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Xaml.XamlMember.IsWriteOnly%2A>叫用<xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A>或特定覆寫該方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlMember" /> 是否表示具有可呼叫之公用 <see langword="set" /> 存取子的成員。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlMember" /> 表示可呼叫的公用 <see langword="true" /> 存取子則為 <see langword="set" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.IsWritePublic%2A>值會考慮是否<xref:System.Xaml.XamlMember.DeclaringType%2A>是公用判斷的一部分。 如果<xref:System.Xaml.XamlMember.DeclaringType%2A>為非公用，`set`存取子不是實際的方式，可呼叫和<xref:System.Xaml.XamlMember.IsWritePublic%2A>傳回`false`。  
  
 呼叫<xref:System.Xaml.XamlMember.IsWritePublic%2A>叫用<xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>或特定覆寫該方法。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>方法是虛擬的因此，可以覆寫。 覆寫就可能會變更 （惡意或失敗） 的報告的存取資訊的 XAML 成員，讓它不會再預期的方式會與對應的基礎 CLR 宣告的型別系統的存取資訊。 存取層級的任何安全性關鍵的檢查，請改用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，傳回 <see cref="T:System.Reflection.ICustomAttributeProvider" /> 實作。</summary>
        <returns>
          <see cref="T:System.Reflection.ICustomAttributeProvider" /> 實作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 覆寫這個方法以提供的替代方法，若要取得 CLR 屬性值與內部的反映。 沒有覆寫時，在內部反映程式會使用一般的 CLR 反映邏輯，例如呼叫<xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>。  
  
 預設實作會傳回 `null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 物件，這個物件用於延後載入 XAML 宣告的物件。</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />，具有對泛型的 <see cref="T:System.Xaml.XamlDeferringLoader" /> 條件約束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.DeferringLoader%2A>屬性。 如果您想要覆寫此方法<xref:System.Xaml.XamlMember.DeferringLoader%2A>傳回不同的值從預設內部反映中，會啟用的值，如果您也要提供自訂<xref:System.Xaml.Schema.XamlMemberInvoker>資訊。  
  
 預設實作會傳回物件以讀取<xref:System.Windows.Markup.XamlDeferLoadAttribute>或使用<xref:System.Xaml.XamlDeferringLoader>從宣告的型別。 如果是使用 無任何物件，這個方法可能會傳回`null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Xaml.XamlMember" /> 物件的清單。 這個清單中的項目會報告因與這個 <see cref="T:System.Xaml.XamlMember" /> 有相對初始設定順序而存在相依關聯性的成員。</summary>
        <returns>
          <see cref="T:System.Xaml.XamlMember" /> 物件的清單。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.DependsOn%2A>屬性。 如果您想要覆寫此方法<xref:System.Xaml.XamlMember.DependsOn%2A>傳回不同的值從預設內部反映中，會啟用的值，如果您也要提供自訂<xref:System.Xaml.Schema.XamlMemberInvoker>資訊。  
  
 WPF XAML 讀取器和寫入器實作的屬性與這個案例<xref:System.Windows.Markup.DependsOnAttribute>。 預設實作會使用這個現有<xref:System.Windows.Markup.DependsOnAttribute>技術。  
  
 覆寫這個方法，如果您不使用<xref:System.Windows.Markup.DependsOnAttribute>這個用途，而且想要取代該技術，指出屬性處理順序，使用您自己的技術。 如果您不想支援屬性的處理順序，您可以使用的預設實作，因為它會不傳回任何結果，哪個較合適。  
  
 清單是唯讀的。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回與這個 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 相關聯的 <see cref="T:System.Xaml.XamlMember" />。</summary>
        <returns>這個 <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> 的 <see cref="T:System.Xaml.XamlMember" /> 資訊，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會叫用呼叫<xref:System.Xaml.XamlMember.Invoker%2A>。  
  
 預設實作不需要<xref:System.Xaml.XamlMember>使用其中一種傳遞初始的建構函式會建構<xref:System.Xaml.Schema.XamlMemberInvoker>。 不過，<xref:System.Xaml.XamlMember.UnderlyingMember%2A>值必須存在<xref:System.Xaml.XamlMember>; 否則預設實作會傳回`null`。  
  
 覆寫這個方法，如果您也是衍生自<xref:System.Xaml.Schema.XamlMemberInvoker>，而且想要傳回衍生的類別。 如果您傳回`null`，<xref:System.Xaml.XamlMember.Invoker%2A>傳回<xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>給呼叫端。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Xaml.XamlMember" /> 是否報告為環境屬性。</summary>
        <returns>
          <see langword="true" /> 報告這個 <see cref="T:System.Xaml.XamlMember" /> 為環境屬性，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會叫用由內部呼叫，以檢查環境的 XAML 內容資訊。 環境屬性行為會佔用公用 API 的行為，XAML 讀取器和 XAML 寫入器。 參考的內部呼叫<xref:System.Xaml.XamlMember.LookupIsAmbient%2A>通常是先確認物件和環境的使用方式的類型限定性條件所依賴的值可以正確運作的 XAML 處理邏輯的一部分。 預設的.NET Framework XAML 服務實作會使用 CLR 屬性設定來透過支援類型，取得從反映的這項資訊。 具體來說，預設實作會檢查是否有<xref:System.Windows.Markup.AmbientAttribute>並傳回`true`如<xref:System.Xaml.XamlMember.LookupIsAmbient%2A>如果<xref:System.Windows.Markup.AmbientAttribute>存在於成員定義。  
  
 覆寫這個方法，如果您不使用<xref:System.Windows.Markup.AmbientAttribute>這個用途，而且想要取代該技術，指出環境的 XAML 屬性，使用您自己的技術。  
  
 從屬性附帶的 WPF 範例應用程式開發介面<xref:System.Windows.Markup.AmbientAttribute>是<xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType>和<xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Xaml.XamlMember" /> 是否表示事件。</summary>
        <returns>
          <see langword="true" /> 報告這個 <see cref="T:System.Xaml.XamlMember" /> 表示事件，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個預設實作會檢查是否<xref:System.Xaml.XamlMember.UnderlyingMember%2A>的型別<xref:System.Reflection.EventInfo>，如果是，會傳回與`true`。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.IsEvent%2A>。 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有特殊的可用中繼資料，可以解譯，以判斷 XAML 類型系統表示法以每個案例為基礎。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Xaml.XamlMember" /> 是否表示所需的唯讀屬性。</summary>
        <returns>
          <see langword="true" /> 報告這個 <see cref="T:System.Xaml.XamlMember" /> 為所需的唯讀屬性，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會傳回`true`如果<xref:System.Xaml.XamlMember.UnderlyingMember%2A>存在，但公用`set`存取子不存在，由內部反映所決定。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.IsReadOnly%2A>。 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有特殊的可用中繼資料，可以解譯，以判斷 XAML 類型系統表示法以每個案例為基礎。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Xaml.XamlMember" /> 是否表示具有公用 <see langword="get" /> 存取子的屬性。</summary>
        <returns>如果這個 <see cref="T:System.Xaml.XamlMember" /> 表示具有公用 <see langword="true" /> 存取子的屬性，則為 <see langword="get" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會傳回內部反映或否定結果<xref:System.Xaml.XamlMember.IsWriteOnly%2A>、 依序處理。  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> 傳回成員本身是否為公用。它會傳回`true`nonpublic，宣告類型上的公用成員。 使用<xref:System.Xaml.XamlMember.IsReadPublic%2A>相反地，如果您也想要考慮的宣告類型的可見性。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.IsReadPublic%2A>。 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有專用的中繼資料可用來判斷每個案例為基礎。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A>方法是虛擬的因此，可以覆寫。 覆寫就可能會變更 （惡意或失敗） 的報告的存取資訊的 XAML 成員，讓它不會再預期的方式會與對應的基礎 CLR 宣告的型別系統的存取資訊。 存取層級的任何安全性關鍵的檢查，請改用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Xaml.XamlMember" /> 是否表示用於型別和成員解析的支援系統所無法解析的成員。</summary>
        <returns>如果這個 <see cref="T:System.Xaml.XamlMember" /> 表示無法解析的成員則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫者取得的值時，可能會叫用這個方法<xref:System.Xaml.XamlMember.IsUnknown%2A>。 預設實作會傳回結果，會根據其中一個內部反映或檢查`null`值<xref:System.Xaml.XamlMember.UnderlyingMember%2A>、 依序處理。  
  
 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有專用的中繼資料可用來判斷每個案例為基礎。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Xaml.XamlMember" /> 是否表示具有公用 <see langword="set" /> 存取子但沒有公用 <see langword="get" /> 存取子的成員。</summary>
        <returns>如果這個 <see cref="T:System.Xaml.XamlMember" /> 表示唯寫成員，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會傳回`true`如果<xref:System.Xaml.XamlMember.UnderlyingMember%2A>存在具有公用`set`存取子和 nonpublic`get`存取子，由內部反映所決定。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.IsWriteOnly%2A>。 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有專用的中繼資料可用來判斷每個案例為基礎。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Xaml.XamlMember" /> 是否表示具有公用 <see langword="set" /> 存取子的成員。</summary>
        <returns>如果這個 <see cref="T:System.Xaml.XamlMember" /> 表示可寫入的成員，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會傳回結果基礎內部反映或否定<xref:System.Xaml.XamlMember.IsReadOnly%2A>、 依序處理。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.IsWritePublic%2A>。 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有專用的中繼資料可用來判斷每個案例為基礎。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>方法是虛擬的因此，可以覆寫。 覆寫就可能會變更 （惡意或失敗） 的報告的存取資訊的 XAML 成員，讓它不會再預期的方式會與對應的基礎 CLR 宣告的型別系統的存取資訊。 存取層級的任何安全性關鍵的檢查，請改用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回標記延伸的左右括弧字元。</summary>
        <returns>包含左右括弧字元的集合。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Xaml.XamlType" /> 可能存在之型別的 <see cref="T:System.Xaml.XamlMember" />。</summary>
        <returns>
          <see cref="T:System.Xaml.XamlMember" /> 可能存在的型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會區分可附加和非可附加成員。 對於非可附加成員，<xref:System.Xaml.XamlMember.LookupTargetType%2A>一律會傳回<xref:System.Xaml.XamlMember.DeclaringType%2A>。 可附加成員<xref:System.Xaml.XamlMember.LookupTargetType%2A>傳回結果，根據檢查<xref:System.Xaml.XamlMember.UnderlyingMember%2A>存取子參數類型和解譯類型根據 XAML 結構描述內容。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.TargetType%2A>。 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有專用的中繼資料可用來判斷每個案例為基礎。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回成員所使用型別的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>成員所使用型別的 <see cref="T:System.Xaml.XamlType" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.Type%2A>。 如果您想要覆寫此方法<xref:System.Xaml.XamlMember.Type%2A>傳回不同的值從預設內部反映中，會啟用的值，如果您也要提供自訂<xref:System.Xaml.Schema.XamlMemberInvoker>資訊。  
  
 預設實作會使用不同的程式碼路徑與概念的意義傳回<xref:System.Xaml.XamlType>，根據這<xref:System.Xaml.XamlMember>表示屬性、 方法或事件。  
  
-   屬性，傳回<xref:System.Xaml.XamlType>設定的屬性或屬性所傳回的型別。  
  
-   對於事件，傳回<xref:System.Xaml.XamlType>是所需的事件處理常式型別 （CLR 實作中的委派）。  
  
-   一種方法，如<xref:System.Xaml.XamlType>的傳回型別。  
  
 在每個案例中，XAML 結構描述內容用於評估的基礎系統類型的 XAML 型別。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.Type%2A>。 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有專用的中繼資料可用來判斷每個案例為基礎。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回與這個 <see cref="T:System.Xaml.XamlMember" /> 相關聯的型別轉換器實作。</summary>
        <returns>具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 條件約束的 <see cref="T:System.ComponentModel.TypeConverter" /> 執行個體，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會使用下列邏輯並處理順序：  
  
-   如果屬性設定存在成員層級 (<xref:System.ComponentModel.TypeConverterAttribute>)，用於呼叫的屬性資訊<xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A>對 XAML 結構描述內容。  
  
-   如果<xref:System.Xaml.XamlMember.Type%2A>有效，則會傳回與類型相關聯的類型轉換器。  
  
-   如果成員是事件，則會傳回特定事件的型別轉換子。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.TypeConverter%2A>。 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有專用的中繼資料可用來判斷每個案例為基礎。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回與這個 <see cref="T:System.Xaml.XamlMember" /> 相關聯的 <see langword="get" /> 存取子。</summary>
        <returns>相關聯 <see langword="get" /> 存取子的 <see cref="T:System.Reflection.MethodInfo" />，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會解譯<xref:System.Xaml.XamlMember.UnderlyingMember%2A>屬性做為<xref:System.Reflection.PropertyInfo>並傳回值<xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType>(參數設為`true`)，這表示傳回的方法可以是公用。 這種行為可能會導致`null`特定案例。 包括沒有相關聯的存取子存在，或該成員不是屬性。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A>屬性相關聯之<xref:System.Xaml.Schema.XamlMemberInvoker>。 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有專用的中繼資料可用來判斷每個案例為基礎。 請務必實作<xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>， <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>，和<xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A>使它們都會傳回相互關聯的結果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回與這個 <see cref="T:System.Reflection.MemberInfo" /> 相關聯的 CLR 型別系統 <see cref="T:System.Xaml.XamlMember" />。</summary>
        <returns>與這個 <see cref="T:System.Reflection.MemberInfo" /> 相關聯的 CLR 型別系統 <see cref="T:System.Xaml.XamlMember" /> 物件，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會傳回建構為基礎的基礎成員資訊。 如果<xref:System.Reflection.MemberInfo>不提供足夠的資訊來設定基礎成員的簽章與建構物件，這個方法會傳回`null`。  
  
 如果在建構期間設定為基礎的成員，您應該不需要呼叫這個方法。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.UnderlyingMember%2A>。 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有專用的中繼資料可用來判斷每個案例為基礎。 請務必實作<xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>， <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>，和<xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A>使它們都會傳回相互關聯的結果。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回與這個 <see cref="T:System.Xaml.XamlMember" /> 相關聯的 <see langword="set" /> 存取子。</summary>
        <returns>相關聯 <see langword="set" /> 存取子的 <see cref="T:System.Reflection.MethodInfo" />，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會解譯<xref:System.Xaml.XamlMember.UnderlyingMember%2A>為<xref:System.Reflection.PropertyInfo>並傳回值<xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType>(參數設為`true`)，這表示傳回的方法可以是公用。 這會導致`null`某些情況下，包括沒有這類存取子，或不是屬性之成員的狀況。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A>相關聯之<xref:System.Xaml.Schema.XamlMemberInvoker>。覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有專用的中繼資料可用來判斷每個案例為基礎。 請務必實作<xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>， <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>，和<xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A>使它們都會傳回相互關聯的結果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回與這個 <see cref="T:System.Xaml.XamlMember" /> 相關聯的值序列化程式實作。</summary>
        <returns>具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 條件約束的 <see cref="T:System.Windows.Markup.ValueSerializer" /> 執行個體，或 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會使用下列邏輯並處理順序：  
  
-   如果屬性設定存在成員層級 (<xref:System.Windows.Markup.ValueSerializerAttribute>)，用於呼叫的屬性資訊<xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A>對 XAML 結構描述內容。  
  
-   如果<xref:System.Xaml.XamlMember.Type%2A>有效，則會傳回與類型相關聯的值轉換器。  
  
-   如果上述條件不會套用，`null`傳回。  
  
 這個方法會叫用時呼叫者取得值，從<xref:System.Xaml.XamlMember.ValueSerializer%2A>。 覆寫這個方法，如果您想要報告的統一結果整個<xref:System.Xaml.XamlMember>衍生的類別，或如果您有專用的中繼資料可用來判斷每個案例為基礎。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>定義標記延伸的左右括弧字元。</summary>
        <value>包含左右括弧字元的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得宣告此 <see cref="T:System.Xaml.XamlMember" /> 的 <see langword="xamlName" /> 名稱字串。</summary>
        <value>宣告這個 <see cref="T:System.Xaml.XamlMember" /> 的 <see langword="xamlName" /> 名稱字串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個值一律是在建構期間設定。 建構函式實作的<xref:System.Xaml.XamlMember>通常擲回例外狀況如果未指定初始的名稱; 因此，不想要這個屬性`null`或空字串，如果您使用預設.NET Framework XAML 服務實作。  
  
 [XamlName 文法](~/docs/framework/xaml-services/xamlname-grammar.md)而且命名規則的 CLR 型別和成員不精確的交集。 它是宣告是合法的在 CLR 成員名稱，但卻無效下 XAML 命名。 您應該儘可能避免這種情況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
          <see cref="T:System.Xaml.XamlMember" /> 或 <see langword="null" />。</param>
        <param name="xamlMember2">
          <see cref="T:System.Xaml.XamlMember" /> 或 <see langword="null" />。</param>
        <summary>判斷兩個指定的 <see cref="T:System.Xaml.XamlMember" /> 物件是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 的值與 <paramref name="xamlMember1" /> 的值相同，則為 <paramref name="xamlMember2" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
          <see cref="T:System.Xaml.XamlMember" /> 或 <see langword="null" />。</param>
        <param name="xamlMember2">
          <see cref="T:System.Xaml.XamlMember" /> 或 <see langword="null" />。</param>
        <summary>判斷兩個指定的 <see cref="T:System.Xaml.XamlMember" /> 物件是否具有不同的值。</summary>
        <returns>如果 <paramref name="xamlMember1" /> 的值與 <paramref name="xamlMember2" /> 的值不同，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得單一 XAML 命名空間 URI，這個 URI 識別此 <see cref="T:System.Xaml.XamlMember" /> 的主要 XAML 命名空間。</summary>
        <value>這個 <see cref="T:System.Xaml.XamlMember" /> 之主要 XAML 命名空間的識別項 (字串形式)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A>屬性會提供相同的值與呼叫<xref:System.Xaml.XamlMember.GetXamlNamespaces%2A>然後從傳回的清單中取得的第一個值的字串。 撰寫回到文字或 XAML 命名空間資訊會保留其他表示相互轉換的成員時，應該使用慣用的 XAML 命名空間。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> 值，這個值表示視覺化設計工具應該如何處理成員。</summary>
        <value>
          <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> 列舉的值。 預設值為 <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Xaml.XamlType" /> 可能存在之型別的 <see cref="T:System.Xaml.XamlMember" />。</summary>
        <value>
          <see cref="T:System.Xaml.XamlMember" /> 可能存在的型別。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 傳回的值是不同的可附加和非可附加成員。 對於非可附加成員，<xref:System.Xaml.XamlMember.TargetType%2A>傳回<xref:System.Xaml.XamlMember.DeclaringType%2A>。 可附加成員<xref:System.Xaml.XamlMember.LookupTargetType%2A>傳回結果，取決於此邏輯：  
  
-   如果反映無法解決備份 (<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`)，這個方法會傳回代表一般物件類型的內部常數。  
  
-   如果之前的條件不適用，<xref:System.Xaml.XamlMember.LookupTargetType%2A>呼叫。 預設實作會傳回<xref:System.Xaml.XamlType>檢查實作的方法，根據`get`和`set`存取子。 類別可能會覆寫<xref:System.Xaml.XamlMember.LookupTargetType%2A>来使用不同的行為，例如其他中繼資料表單，可能會報告目標類型的可附加成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Xaml.XamlMember" /> 的字串表示。</summary>
        <returns>這個 <see cref="T:System.Xaml.XamlMember" /> 的字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個實作會傳回<xref:System.Xaml.XamlMember.Name%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得成員所使用型別的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <value>成員所使用型別的 <see cref="T:System.Xaml.XamlType" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Xaml.XamlMember.Type%2A>叫用<xref:System.Xaml.XamlMember.LookupType%2A>或特定覆寫該方法。 會發生這種情況時的初始內部反映邏輯已設定資訊。  
  
 此預設行為 (沒有<xref:System.Xaml.XamlMember.LookupType%2A>覆寫)，傳回<xref:System.Xaml.XamlType>可以具有不同的概念意義。 適用於哪一個的意義取決於是否這<xref:System.Xaml.XamlMember>表示屬性、 方法或事件，如下列清單所示：  
  
-   屬性，傳回<xref:System.Xaml.XamlType>設定的屬性或屬性所傳回的型別。  
  
-   對於事件，傳回<xref:System.Xaml.XamlType>是所需的事件處理常式型別 （CLR 實作中的委派）。  
  
-   一種方法，如<xref:System.Xaml.XamlType>是可能是該方法的傳回型別`null`。  
  
 在每個案例中，XAML 結構描述內容用於評估的支援類型的 XAML 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 物件，這個物件可用於建構 XAML 宣告物件的型別轉換。</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />，對泛型具有 <see cref="T:System.ComponentModel.TypeConverter" /> 條件約束。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Xaml.XamlMember.TypeConverter%2A>叫用<xref:System.Xaml.XamlMember.LookupTypeConverter%2A>或特定覆寫該方法。 初始內部反映邏輯已設定資訊時，就會發生這種行為。  
  
 實作會傳回非 null 屬性值<xref:System.Xaml.XamlMember.TypeConverter%2A>不一定可運作的<xref:System.ComponentModel.TypeConverter>。 下列是可能的非 null 傳回值的一份<xref:System.Xaml.XamlMember.TypeConverter%2A>和這些值所代表的意義：  
  
-   傳回值會報告該成員為或更廣泛地目標型別轉換子的屬性型別轉換子。 這種行為通常是何種大部分的 XAML 類型系統和 XAML 處理器尋找才能具現化類型轉換器，並叫用其方法。  
  
-   傳回值會報告內建值轉換器。 這些轉換存在特定 XAML 寫入器所執行的內部作業。 特別是，這些內建的值轉換器會將原始屬性字串值轉換成 XAML 語言層級基本類型。 如需.NET Framework XAML 服務實作，這些內建型別轉換通常轉送給系統組件中定義的類型轉換器。 比方說，轉換為<xref:System.Int32>值沒有內建的轉送轉換，因此<xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A>值參考<xref:System.ComponentModel.Int32Converter>。  
  
-   傳回值會報告未受限制的物件模型; 特殊的案例也就是說，<xref:System.Xaml.XamlMember>具有<xref:System.Xaml.XamlMember.Type%2A>值<xref:System.Object>。 在此情況下，<xref:System.Xaml.Schema.XamlValueConverter%601>報告<xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType>是 {`Object}`。 不過，<xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>是`null`因為沒有實際的類型或執行個體是可用來執行這項轉換。 相反地，無法判斷物件模型的行為，直到執行階段，當特定技術的執行階段會判定其物件圖形的處理。  
  
 如果您可以存取工作<xref:System.ComponentModel.TypeConverter>從<xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>，您可以叫用其轉換方法。 不過，許多轉換方法都倚賴服務內容。 如果您沒有可用的類型轉換器撰寫物件的物件圖形的其一般角色必須要有相同的服務內容，轉換器方法可以擲回例外狀況。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>針對以 <see cref="T:System.Reflection.MemberInfo" />、<see cref="T:System.Reflection.PropertyInfo" /> 或 <see cref="T:System.Reflection.MethodInfo" /> 所建構的成員，取得可用的 CLR 型別系統 <see cref="T:System.Reflection.EventInfo" />。</summary>
        <value>從初始建構函式參數轉型的 CLR 型別系統 <see cref="T:System.Reflection.MemberInfo" /> 資訊。 以 <see cref="T:System.Xaml.XamlMember" /> 簽章建構的 <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" /> 會傳回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Xaml.XamlMember.UnderlyingMember%2A>叫用<xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A>或特定覆寫該方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 物件，這個物件用於對 XAML 宣告的物件進行值序列化。</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />，對泛型具有 <see cref="T:System.Windows.Markup.ValueSerializer" /> 條件約束。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫<xref:System.Xaml.XamlMember.ValueSerializer%2A>叫用<xref:System.Xaml.XamlMember.LookupValueSerializer%2A>或特定覆寫該方法。 初始內部反映邏輯已設定資訊時，就會發生這種行為。  
  
 並非所有的情況下，傳回非 null 屬性的值<xref:System.Xaml.XamlMember.ValueSerializer%2A>一定都可運作的<xref:System.Windows.Markup.ValueSerializer>。 請參閱<xref:System.Xaml.XamlMember.TypeConverter%2A>; 考量同樣適用於<xref:System.Xaml.XamlMember.ValueSerializer%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>