<Type Name="XamlType" FullName="System.Xaml.XamlType">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="80d4822e5991e5067db28caf8beba0afd9792221" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48607817" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlType : IEquatable&lt;System.Xaml.XamlType&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlType extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlType&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlType" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlType&#xA;Implements IEquatable(Of XamlType)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlType : IEquatable&lt;System::Xaml::XamlType ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlType = class&#xA;    interface IEquatable&lt;XamlType&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlType&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>報告在 .NET Framework XAML 服務實作的整體 XAML 系統中，XAML 型別的相關資訊。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中的許多 Api<xref:System.Xaml.XamlType>類別提供 XAML 型別，其中它們報告的概念是類似於特定的 XAML 規格 [MS-XAML] 區段的相關資訊。  
  
 <xref:System.Xaml.XamlType> 是廣泛使用.NET Framework XAML 服務 API 中的 XAML 型別相關的報告資訊。 <xref:System.Xaml.XamlType> 報告的資訊，您可能需要了解 XAML 型別，若要使用的執行個體，或從 XAML 節點資料流或類似的 XAML 表示中存取其成員。 其報告是類似於如何<xref:System.Type>在 CLR 類型系統，以及反映類別例如<xref:System.Reflection.MemberInfo>，提供 CLR 型別和其使用方式的相關資訊。  
  
 若要擴充的 XAML 類型系統，您可以從衍生<xref:System.Xaml.XamlType>。 若要有效地讓執行，您可能也需要實作<xref:System.Xaml.Schema.XamlTypeInvoker>。 <xref:System.Xaml.Schema.XamlTypeInvoker>使通用的 XAML 類型系統，才能支援您指定的引動過程行為一部分的型別系統使用。 特定的自訂<xref:System.Xaml.Schema.XamlTypeInvoker>可用來減少 CLR 型別系統中，所使用的預設值的相依性<xref:System.Xaml.XamlType>行為。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xaml.XamlType" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="underlyingType">要建構之 XAML 型別的基礎 CLR <see cref="T:System.Type" />。</param>
        <param name="schemaContext">XAML 讀取器或 XAML 寫入器的 XAML 結構描述內容。</param>
        <summary>根據基礎 CLR 型別資訊，初始化 <see cref="T:System.Xaml.XamlType" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">一個或多個 <paramref name="underlyingType" /> 或 <paramref name="schemaContext" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XamlType (string typeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string typeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (typeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XamlType(System::String ^ typeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (typeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="typeName">要建立之型別的名稱。</param>
        <param name="typeArguments">表示泛型型別之 <see cref="T:System.Xaml.XamlType" /> 的型別引數。 可以是 (而且通常是) <see langword="null" />，指出所表示的型別不是泛型型別。</param>
        <param name="schemaContext">XAML 讀取器及 XAML 寫入器的 XAML 結構描述內容。</param>
        <summary>根據型別的字串名稱，初始化 <see cref="T:System.Xaml.XamlType" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這是受保護的建構函式。 目前的公用衍生的類別有可用於建構這個特定的路徑。 為現有消費者<xref:System.Xaml.XamlType>，您必須使用其他建構函式簽章 (<xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%2CSystem.Xaml.Schema.XamlTypeInvoker%29>， <xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%29>，或<xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29>) 初始化<xref:System.Xaml.XamlType>物件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一個或多個 <paramref name="typeName" /> 或 <paramref name="schemaContext" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlTypeInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlTypeInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlTypeInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext, invoker As XamlTypeInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlTypeInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlTypeInvoker -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlTypeInvoker" />
      </Parameters>
      <Docs>
        <param name="underlyingType">要建構之 XAML 型別的基礎型別。</param>
        <param name="schemaContext">XAML 讀取器的 XAML 結構描述內容。</param>
        <param name="invoker">
          <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 實作，可處理對 <see cref="T:System.Xaml.XamlType" /> 的執行階段反映呼叫。</param>
        <summary>根據基礎型別資訊和 <see cref="T:System.Xaml.XamlType" /> 實作，初始化 <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">一個或多個 <paramref name="underlyingType" /> 或 <paramref name="schemaContext" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (string unknownTypeNamespace, string unknownTypeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string unknownTypeNamespace, string unknownTypeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (unknownTypeNamespace As String, unknownTypeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(System::String ^ unknownTypeNamespace, System::String ^ unknownTypeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (unknownTypeNamespace, unknownTypeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="unknownTypeNamespace" Type="System.String" />
        <Parameter Name="unknownTypeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="unknownTypeNamespace">型別的 XAML 命名空間 (字串形式)。</param>
        <param name="unknownTypeName">型別在所提供 <c>unknownTypeNamespace</c> XAML 命名空間中的名稱。</param>
        <param name="typeArguments">表示泛型型別之 <see cref="T:System.Xaml.XamlType" /> 的型別引數。 可以是 (而且通常是) <see langword="null" />，指出所表示的型別不是泛型型別。</param>
        <param name="schemaContext">XAML 讀取器或 XAML 寫入器的 XAML 結構描述內容。</param>
        <summary>根據型別的 XAML 命名空間和字串名稱，初始化 <see cref="T:System.Xaml.XamlType" /> 類別的新執行個體。 這個建構函式是專門針對已知在支援型別系統和 XAML 結構描述內容中沒有支援的型別使用方式，進行分析及 XAML 節點記錄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用這個建構函式只適用於 「 不明 」 的類型對應到基礎的型別系統的 XAML 型別所在無法使用。 這個建構函式可能不會產生結果所在<xref:System.Xaml.XamlType.IsUnknown%2A?displayProperty=nameWithType>是`true`。 預設 reflector 邏輯相反地，報告的基礎類型<xref:System.Xaml.XamlLanguage.Object%2A?displayProperty=nameWithType>。 不過，此行為可以變更因為<xref:System.Xaml.XamlType.LookupIsUnknown%2A>覆寫。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">一個或多個 <paramref name="unknownTypeNamespace" />、<paramref name="unknownTypeName" /> 或 <paramref name="schemaContext" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedContentTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; AllowedContentTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; AllowedContentTypes" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.AllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowedContentTypes As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ AllowedContentTypes { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowedContentTypes : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.AllowedContentTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得型別的唯讀集合，這些型別可做為這個 <see cref="P:System.Xaml.XamlType.ContentProperty" /> 的 <see cref="T:System.Xaml.XamlType" /> 值。</summary>
        <value>可能內容型別的唯讀集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可指派的類型特定的內容類型 （例如，指派給基底類型所允許的內容類型） 不會考慮多個類型，其目的為<xref:System.Xaml.XamlType.AllowedContentTypes%2A>。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupAllowedContentTypes%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ BaseType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個 XAML 型別之直接基底型別的 <see cref="T:System.Xaml.XamlType" />。 此值取決於這個 <see cref="T:System.Xaml.XamlType" /> 的基礎型別和結構描述內容。</summary>
        <value>這個 XAML 型別之直接基底型別的 <see cref="T:System.Xaml.XamlType" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupBaseType%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupBaseType%2A>這個型別上。 根據預設，<xref:System.Xaml.XamlType.BaseType%2A>傳回內部的常數，表示<xref:System.Object>如果<xref:System.Xaml.XamlType.UnderlyingType%2A>是`null`。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> 是虛擬的且因此，可以覆寫。 覆寫有可能 (是否惡意或其他) 變更 XAML 型別相關的報告的類型資訊，使它不再符合預期的方式基礎 CLR 型別的型別系統資訊。 針對指派作業和存取的任何安全性關鍵的檢查，請改為使用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAssignTo">
      <MemberSignature Language="C#" Value="public virtual bool CanAssignTo (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanAssignTo(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.CanAssignTo(System.Xaml.XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanAssignTo(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="abstract member CanAssignTo : System.Xaml.XamlType -&gt; bool&#xA;override this.CanAssignTo : System.Xaml.XamlType -&gt; bool" Usage="xamlType.CanAssignTo xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">要根據目前 <see cref="T:System.Xaml.XamlType" /> 檢查的型別。</param>
        <summary>傳回值，這個值表示在此 <see cref="T:System.Xaml.XamlType" /> 的執行個體的可指派型別清單中，是否有指定的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>如果 <paramref name="xamlType" /> 在可指派型別清單中則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 雖然可指派型別並沒有參考類型的所有功能，則您可以使用它進行指派。 比方說，您可以使用指派來進行型別相符項目屬性的值。 CLR 型別系統中，XAML 中的指派類型的概念是向上轉型的概念類似。 比方說，在 CLR 型別系統中，每個類型都有<xref:System.Object>其可指派類型 清單中。  
  
 如果兩個的其中一個<xref:System.Xaml.XamlType>所使用的執行個體比較有<xref:System.Xaml.XamlType.IsUnknown%2A>等於`true`，這個方法有特殊未知的模式，會傳回`true`如果兩個<xref:System.Xaml.XamlType>執行個體是否相等。  
  
 預設實作會使用 CLR<xref:System.Type>從<xref:System.Xaml.XamlType.UnderlyingType%2A>這個<xref:System.Xaml.XamlType>並輸入<xref:System.Xaml.XamlType>，並呼叫<xref:System.Type.IsAssignableFrom%2A>。 如果您想要不同的可指派型別判定，覆寫這個方法。  
  
 將 null 傳遞`xamlType`不會擲回例外狀況，而且一律傳回`false`。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.CanAssignTo%2A> 是虛擬的且因此，可以覆寫。 覆寫有可能 (是否惡意或其他) 若要變更之 XAML 型別的可指派性，讓它不再符合預期的方式與基礎 CLR 型別的型別轉換行為。 針對指派作業和存取的任何安全性關鍵的檢查，請改為使用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="public bool ConstructionRequiresArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ConstructionRequiresArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructionRequiresArguments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ConstructionRequiresArguments { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ConstructionRequiresArguments : bool" Usage="System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否必須有引數 (透過 <see langword="x:TypeArguments" />、初始設定文字或其他 XAML 技術的泛型條件約束)，才能建構型別的有效執行個體。</summary>
        <value>如果建構執行個體時需要一些引數值則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember ContentProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlMember ContentProperty" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentProperty As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlMember ^ ContentProperty { System::Xaml::XamlMember ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentProperty : System.Xaml.XamlMember" Usage="System.Xaml.XamlType.ContentProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個 <see cref="T:System.Xaml.XamlMember" /> 之內容屬性的 <see cref="T:System.Xaml.XamlType" /> 資訊。</summary>
        <value>這個 <see cref="T:System.Xaml.XamlMember" /> 之內容屬性的 <see cref="T:System.Xaml.XamlType" /> 資訊。 如果沒有內容屬性，則可以是 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當使用繫結的 CLR 型別系統備份，XAML 內容屬性可指定或類型上套用<xref:System.Windows.Markup.ContentPropertyAttribute>型別定義。  
  
 這個屬性與`[content property]`[MS-XAML] 規格中的資訊項目。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupContentProperty%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupContentProperty%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentWrappers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; ContentWrappers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; ContentWrappers" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentWrappers As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ ContentWrappers { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentWrappers : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.ContentWrappers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得型別，這些型別會在內容屬性並非嚴格型別相符 (例如強型別 <see langword="Collection&lt;T&gt;" /> 中的字串) 時，用於包裝該內容屬性的內容。</summary>
        <value>可能內容包裝函式的唯讀集合，否則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不有任何的包裝函式，以負責放寬相符的型別，這個屬性是`null`。  
  
 評估為的型別<xref:System.Xaml.XamlType.CanAssignTo%2A>特定的內容類型不會被視為多個類型，其目的為<xref:System.Xaml.XamlType.ContentWrappers%2A>。  
  
 中的 CLR 繫結<xref:System.Xaml>並<xref:System.Xaml.XamlType>，可以做為類型上指定的 XAML 內容包裝函式型別<xref:System.Windows.Markup.ContentWrapperAttribute>。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupContentWrappers%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupContentWrappers%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlType.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得表示此型別之延後載入轉換行為的 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />。</summary>
        <value>具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 條件約束的 <see cref="T:System.Xaml.XamlDeferringLoader" />，這個條件約束表示此型別的延後載入行為。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在 WPF 中的 XAML 範本行為是延後的載入行為的範例。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupDeferringLoader%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupDeferringLoader%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指出目前的物件和另一個物件是否相等。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlType.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要與這個物件比較的物件。</param>
        <summary>指出目前的物件和另一個物件是否相等。</summary>
        <returns>若目前的物件等於 <see langword="true" /> 參數，則為 <paramref name="obj" />，否則即為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlType other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlType other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlType ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlType -&gt; bool" Usage="xamlType.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="other">要與此物件進行比較的物件。</param>
        <summary>指出目前的物件是否等於另一個相同類型的物件。</summary>
        <returns>若目前的物件等於 <see langword="true" /> 參數，則為 <paramref name="other" />，否則即為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasedProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="member this.GetAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">要尋找別名化成員的指示詞。</param>
        <summary>傳回由這個 <see cref="T:System.Xaml.XamlType" /> 別名化為 XAML 指示詞的 XAML 成員。</summary>
        <returns>如果找到則為別名化成員，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫此方法可以叫用<xref:System.Xaml.XamlType.LookupAliasedProperty%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupAliasedProperty%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllAttachableMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllAttachableMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllAttachableMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回集合，這個集合包含由此 <see cref="T:System.Xaml.XamlType" /> 公開之所有可附加的屬性。</summary>
        <returns>集合，包含零個或更多個 <see cref="T:System.Xaml.XamlMember" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每個<xref:System.Xaml.XamlMember>傳回集合中應包含支援的值，<xref:System.Xaml.XamlMember>是可附加的成員。 比方說，應該傳回成員`true`for <xref:System.Xaml.XamlMember.IsAttachable%2A>，類型<xref:System.Xaml.XamlMember.TargetType%2A>，依此類推。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫此方法可以叫用<xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回集合，這個集合包含由此 <see cref="T:System.Xaml.XamlType" /> 公開的所有成員。</summary>
        <returns>集合，包含零個或更多個 <see cref="T:System.Xaml.XamlMember" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫此方法可以叫用<xref:System.Xaml.XamlType.LookupAllMembers%2A>會覆寫上<xref:System.Xaml.XamlType>衍生的類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttachableMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要取得之可附加成員的名稱，格式為：<c>ownerTypeName.MemberName</c>。</param>
        <summary>傳回代表此 <see cref="T:System.Xaml.XamlType" /> 之指定具名可附加成員的 <see cref="T:System.Xaml.XamlMember" />。</summary>
        <returns>代表要求之可附加成員的 <see cref="T:System.Xaml.XamlMember" /> 物件；如果沒有該名稱的可附加成員存在則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫此方法可以叫用<xref:System.Xaml.XamlType.LookupAttachableMember%2A>會覆寫上<xref:System.Xaml.XamlType>衍生的類別。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> 是虛擬的且因此，可以覆寫。 覆寫有可能 (是否惡意或其他) 若要變更報告的 XAML 型別的成員，讓它們不會再與預期的方式對齊<xref:System.ComponentModel.TypeDescriptor>`Get*`基礎 CLR 型別資訊。 針對成員報告任何安全性關鍵的檢查，請改為使用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlType.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個物件的雜湊程式碼。</summary>
        <returns>整數雜湊程式碼。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要取得之成員的名稱 (字串形式)。</param>
        <summary>從這個 <see cref="T:System.Xaml.XamlMember" /> 傳回特定具名成員的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>如果找到成員，則為該成員的 <see cref="T:System.Xaml.XamlMember" /> 資訊，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值`name`應為不合格。 表示附加的成員的類型限定名稱應該提交到<xref:System.Xaml.XamlType.GetAttachableMember%2A>改。 做為前置詞名稱不應該使用; 的成員前置詞是環境的使用方式和 XAML 類型系統不知道這樣的使用方式的內容和前置詞對應的方式。  
  
 呼叫此方法可以叫用<xref:System.Xaml.XamlType.LookupMember%2A>會覆寫上<xref:System.Xaml.XamlType>衍生的類別。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> 是虛擬的且因此，可以覆寫。 覆寫有可能 (是否惡意或其他) 若要變更報告的 XAML 型別的成員，讓它們不會再與預期的方式對齊<xref:System.ComponentModel.TypeDescriptor>`Get*`基礎 CLR 型別資訊。 針對成員報告任何安全性關鍵的檢查，請改為使用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionalParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; GetPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; GetPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ GetPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="member this.GetPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.GetPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">您想要取得相關資訊之特定語法或建構函式模式的計數 (Arity)。</param>
        <summary>如果是標記延伸型別，則傳回這個 <see cref="T:System.Xaml.XamlType" /> 的特定標記延伸用法所支援之位置參數的型別。</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> 值的清單，其中每個 <see cref="T:System.Xaml.XamlType" /> 都是語法中該位置適用的型別。 指定這些型別時，順序必須與您為標記延伸提供標記輸入時的順序相同。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此 API 僅適用於此<xref:System.Xaml.XamlType>代表標記延伸 (<xref:System.Xaml.XamlType.IsMarkupExtension%2A>是`true`)。  
  
 輸入`parameterCount`不是用來要求特定的位置參數的型別。 這是指定套組 arity 的標記延伸使用方式。 標記延伸使用方式通常有多個 「 簽章 」，並使用不同的參數 arity （計數） 的位置參數來區分。 不過，您可以設定結構描述內容允許重複的 arities，並且使用位置參數的類型差異化。 如需詳細資訊，請參閱<xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>。 針對特定套組 arity （計數），參數的位置和類型而有所不同。 若要取得特定套組 arity 的標記延伸使用方式的位置類型，您先呼叫<xref:System.Xaml.XamlType.GetPositionalParameters%2A>指定引數數目計數。 然後從傳回的集合，該位置取得項目。  
  
 呼叫此方法可以叫用<xref:System.Xaml.XamlType.LookupPositionalParameters%2A>會覆寫上<xref:System.Xaml.XamlType>衍生的類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlType.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回字串識別項清單，這些字串識別項會識別型別所在的 XAML 命名空間。</summary>
        <returns>字串值的清單，其中每個字串都是 XAML 命名空間的 URI 識別項。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般 XAML 命名空間識別項是 URI 形式的字串。  
  
 預設實作會檢查下列命令，在順序中： 在建構中提供的 XAML 命名空間 (<xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29>只有簽章); 和命名空間所提供的結構描述內容。 若為每個`null`，新的清單，會產生包含單一的空字串。 您可以覆寫此方法以變更查閱方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlTypeInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlTypeInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlTypeInvoker ^ Invoker { System::Xaml::Schema::XamlTypeInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlTypeInvoker" Usage="System.Xaml.XamlType.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得與這個 <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 相關聯的 <see cref="T:System.Xaml.XamlType" /> 實作。</summary>
        <value>與這個 <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 相關聯的 <see cref="T:System.Xaml.XamlType" /> 實作。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，則呼叫<xref:System.Xaml.XamlType.Invoker%2A>可以叫用其中一個<xref:System.Xaml.XamlType.LookupInvoker%2A>或特定覆寫該方法。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupInvoker%2A>這個型別上。  
  
 如果<xref:System.Xaml.XamlType.LookupInvoker%2A>覆寫會傳回`null`，則預設實作會傳回`null`因為缺乏<xref:System.Xaml.XamlType.UnderlyingType%2A>這個<xref:System.Xaml.XamlType>，然後<xref:System.Xaml.XamlType.Invoker%2A>傳回<xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlType.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XAML 定義的環境型別。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示環境型別，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupIsAmbient%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupIsAmbient%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Xaml.XamlType.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表陣列。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示陣列，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupCollectionKind%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupCollectionKind%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollection">
      <MemberSignature Language="C#" Value="public bool IsCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollection : bool" Usage="System.Xaml.XamlType.IsCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表集合。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示集合，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupCollectionKind%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupCollectionKind%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructible">
      <MemberSignature Language="C#" Value="public bool IsConstructible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructible" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsConstructible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructible : bool" Usage="System.Xaml.XamlType.IsConstructible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XAML 定義的可建構型別。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示可建構的型別則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性與`[is default constructible]`[MS-XAML] 規格中的資訊項目。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupIsConstructible%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupIsConstructible%2A>這個型別上。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      </Docs>
    </Member>
    <Member MemberName="IsDictionary">
      <MemberSignature Language="C#" Value="public bool IsDictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDictionary" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsDictionary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDictionary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDictionary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDictionary : bool" Usage="System.Xaml.XamlType.IsDictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XAML 定義的字典。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示字典，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性與`[is dictionary]`[MS-XAML] 規格中的資訊項目。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupCollectionKind%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupCollectionKind%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGeneric">
      <MemberSignature Language="C#" Value="public bool IsGeneric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGeneric" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsGeneric" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGeneric As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGeneric { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGeneric : bool" Usage="System.Xaml.XamlType.IsGeneric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表泛型型別。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示泛型型別，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性是會檢查是否有 null 值的協助程式屬性<xref:System.Xaml.XamlType.TypeArguments%2A>。 沒有任何特定`Lookup`方法的相關<xref:System.Xaml.XamlType.IsGeneric%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarkupExtension">
      <MemberSignature Language="C#" Value="public bool IsMarkupExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarkupExtension" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarkupExtension As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarkupExtension { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarkupExtension : bool" Usage="System.Xaml.XamlType.IsMarkupExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表標記延伸。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示標記延伸，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XAML 規格而言，此類型必須是指派給`x:MarkupExtension`來傳回`true`如<xref:System.Xaml.XamlType.IsMarkupExtension%2A>。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameScope">
      <MemberSignature Language="C#" Value="public bool IsNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameScope { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameScope : bool" Usage="System.Xaml.XamlType.IsNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XAML 定義的 XAML 名稱範圍。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示 XAML 名稱範圍，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XAML 名稱範圍會強制執行或多個屬性所使用的名稱唯一性`x:Name`  /  `[name property]`。 如果<xref:System.Xaml.XamlType.IsNameScope%2A>是`true`，應該存在，且應該評估從擁有 XAML 名稱範圍這種觀點來看一些機制來強制執行唯一性。 直到偵測到另一個 XAML 名稱範圍擁有類型的 XAML 名稱範圍然後延伸類型的內容。  
  
 這個屬性與`[is name scope]`[MS-XAML] 規格中的資訊項目。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupIsNameScope%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlType.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否使用有效的 <see langword="xamlName" /> 字串做為其 <see cref="P:System.Xaml.XamlType.Name" /> 以進行初始化。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 使用有效的 <see langword="true" /> 字串進行初始化則為 <see langword="xamlName" />，否則為 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public bool IsNullable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNullable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNullable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool" Usage="System.Xaml.XamlType.IsNullable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XAML 定義之可為 Null 的型別。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示可為 Null 的型別則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性與`[is nullable]`[MS-XAML] 規格中的資訊項目。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupIsNullable%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Xaml.XamlType.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表相關型別系統中的公用型別。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示公用型別則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupIsPublic%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> 是虛擬的且因此，可以覆寫。 覆寫有可能 (是否惡意或其他) 變更 XAML 類型中報告的存取權的資訊，使它不再符合預期的方式在其基礎的 CLR 類型的型別系統和存取資訊。 針對指派作業和存取的任何安全性關鍵的檢查，請改為使用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlType.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表基礎型別系統中無法解析的型別。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示無法解析的型別則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupIsUnknown%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。  
  
 適用於牽涉到的載入路徑<xref:System.Xaml.XamlObjectWriter>，則<xref:System.Xaml.XamlType>具有`true`如<xref:System.Xaml.XamlType.IsUnknown%2A>無法寫入物件圖形。 中的預設實作下<xref:System.Xaml>，則<xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A?displayProperty=nameWithType>呼叫會擲回<xref:System.Xaml.XamlObjectWriterException>時相關<xref:System.Xaml.XamlType>報告`true`如<xref:System.Xaml.XamlType.IsUnknown%2A>。 您不應該傳遞<xref:System.Xaml.XamlType>具有<xref:System.Xaml.XamlType.IsUnknown%2A>作為`true`除非您準備處理的例外狀況，從<xref:System.Xaml.XamlObjectWriter>，或您可以透過其他方式調整<xref:System.Xaml.XamlObjectWriter>行為或 XAML 節點資料流之前寫入的物件圖形。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUsableDuringInitialization">
      <MemberSignature Language="C#" Value="public bool IsUsableDuringInitialization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUsableDuringInitialization" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUsableDuringInitialization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUsableDuringInitialization { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUsableDuringInitialization : bool" Usage="System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示在 XAML 初始化期間是否由上往下建立這個 <see cref="T:System.Xaml.XamlType" />。</summary>
        <value>如果在 XAML 初始化期間由上往下建立這個 <see cref="T:System.Xaml.XamlType" />，則為 <see langword="true" />，否則為 <see langword="false" />。 預設值為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由上而下是近似 XAML 處理器行為，建立物件圖形時的比喻。 建置由上而下，為型別會具現化，附加至父代，，然後設定其屬性。 由上而下建構可避免多次叫用屬性變更處理常式。 這類處理 ripples 向上物件圖形和因此，排除多個處理常式呼叫，並提供的物件圖形的啟動逾時的效能最佳化。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A>這個型別上。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
        <altmember cref="P:System.Windows.FrameworkElement.IsInitialized" />
      </Docs>
    </Member>
    <Member MemberName="IsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="public bool IsWhitespaceSignificantCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWhitespaceSignificantCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWhitespaceSignificantCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWhitespaceSignificantCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWhitespaceSignificantCollection : bool" Usage="System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XML 定義的空白有效集合。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示空白有效集合，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsXData">
      <MemberSignature Language="C#" Value="public bool IsXData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsXData" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsXData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsXData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsXData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsXData : bool" Usage="System.Xaml.XamlType.IsXData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XAML 定義的 XML <see langword="XDATA" />。</summary>
        <value>如果此 <see cref="T:System.Xaml.XamlType" /> 表示 <see langword="true" /> 則為 <see langword="XDATA" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性與`[is xdata]`[MS-XAML] 規格中的資訊項目。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupIsXData%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupIsXData%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType ItemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType ItemType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ ItemType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值提供此 <see cref="T:System.Xaml.XamlType" /> 之 <see langword="Items" /> 屬性的型別資訊。</summary>
        <value>集合中之項目型別的 <see cref="T:System.Xaml.XamlType" /> 物件，如果此 <see cref="T:System.Xaml.XamlType" /> 不表示集合，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性才適用，如果這個<xref:System.Xaml.XamlType>表示集合 (<xref:System.Xaml.XamlType.IsCollection%2A>是`true`)。 `Items`屬性是任何屬性會保留在該類型的集合或陣列中的項目。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupItemType%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupItemType%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType KeyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType KeyType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.KeyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ KeyType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.KeyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，如果 <see cref="T:System.Xaml.XamlType" /> 表示字典，則這個值提供此 <see cref="T:System.Xaml.XamlType" /> 之索引鍵屬性的型別資訊。</summary>
        <value>字典用法索引鍵型別的 <see cref="T:System.Xaml.XamlType" /> 物件，如果這個 <see cref="T:System.Xaml.XamlType" /> 不表示字典，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性才適用，如果這個<xref:System.Xaml.XamlType>表示的字典 (<xref:System.Xaml.XamlType.IsDictionary%2A>是`true`)。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupKeyType%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupKeyType%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAliasedProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="abstract member LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember&#xA;override this.LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">要尋找別名化成員的指示詞。</param>
        <summary>傳回由這個 <see cref="T:System.Xaml.XamlType" /> 別名化為 XAML 指示詞的 XAML 成員。</summary>
        <returns>如果找到則為別名化成員，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫者取得的值時，可以叫用這個方法<xref:System.Xaml.XamlType.GetAliasedProperty%2A>。  
  
 預設的實作可能會傳回結果，如下列 XAML 指示詞： `Key`;`Name`;`Uid`; 和`xml:lang`。 值，這些相依於基礎反映，並仍可能會傳回`null`如果不找到任何別名的屬性。  
  
 如果您不會依賴預設內部的 CLR 反映，並使用中繼資料或其他技術進行報告的 XAML 類型系統資訊或類型的結構描述資訊，請覆寫這個方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xaml.XamlDirective" />
        <altmember cref="T:System.Xaml.XamlLanguage" />
      </Docs>
    </Member>
    <Member MemberName="LookupAllAttachableMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllAttachableMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回可列舉的集合，這個集合包含由此 <see cref="T:System.Xaml.XamlType" /> 公開之所有可附加的屬性。</summary>
        <returns>包含零個或更多個 <see cref="T:System.Xaml.XamlMember" /> 值的可列舉集合，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫者取得的值時，可以叫用這個方法<xref:System.Xaml.XamlType.GetAllAttachableMembers%2A>。  
  
 雖然<xref:System.Xaml.XamlType.GetAllAttachableMembers%2A>傳回的泛型集合，這`Lookup`方法會傳回一般的可列舉集。  
  
 預設實作會使用內部的 CLR 反映。 當<xref:System.Xaml.XamlType.UnderlyingType%2A>已`null`，可以使用的預設實作<xref:System.Xaml.XamlType.BaseType%2A>、 如果有的話。 此行為會呼叫<xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A>嘗試尋找有效的基底型別和傳回遞迴`null`如果沒有有效的基底型別。  
  
 如果您不會依賴預設內部的 CLR 反映，而使用中繼資料或其他技術報告的 XAML 類型系統資訊或型別的結構描述資訊，請覆寫這個方法。 因為缺少系統或反映支援的類型無法判斷資訊的情況下，應該保留 null 傳回。 如果型別是否有效，並反映或其他技術可供使用，但類型沒有可附加成員，您應改為傳回空<xref:System.Collections.Generic.IEnumerable%601>設定。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回可列舉的集合，這個集合包含由此 <see cref="T:System.Xaml.XamlType" /> 公開的所有成員。</summary>
        <returns>可舉列的集合，包含零個或更多個 <see cref="T:System.Xaml.XamlMember" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫者取得的值時，可以叫用這個方法<xref:System.Xaml.XamlType.GetAllMembers%2A>。  
  
 雖然<xref:System.Xaml.XamlType.GetAllMembers%2A>傳回的泛型集合，這`Lookup`方法會傳回一般的可列舉集。  
  
 預設實作會使用內部的 CLR 反映。 案例所在<xref:System.Xaml.XamlType.UnderlyingType%2A>是`null`，可以使用的預設實作<xref:System.Xaml.XamlType.BaseType%2A>、 如果有的話。 此行為會呼叫<xref:System.Xaml.XamlType.LookupAllMembers%2A>嘗試尋找有效的基底型別，並傳回遞迴`null`如果沒有有效的基底型別。  
  
 如果您不會依賴預設內部的 CLR 反映，而使用中繼資料或其他技術報告的 XAML 類型系統資訊或型別的結構描述資訊，請覆寫這個方法。 因為缺少系統或反映支援的類型無法判斷資訊的情況下，應該保留 null 傳回。 如果類型是有效的反映或其他技術可;如果類型沒有成員，您應改為傳回空<xref:System.Collections.Generic.IEnumerable%601>設定。  
  
 傳回值<xref:System.Xaml.XamlType.LookupAllMembers%2A>和<xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A>應該是互斥的。 如果您有支援型別系統屬性，其中可支援的標準執行個體的使用方式，以及可附加的使用方式的情況下，該成員應該報告為兩個不同<xref:System.Xaml.XamlMember>值，並不會出現在可附加的清單，而在另一個的一個值標準的成員 清單中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllowedContentTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupAllowedContentTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupAllowedContentTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllowedContentTypes () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupAllowedContentTypes();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupAllowedContentTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回型別的清單，這些型別可做為此 <see cref="P:System.Xaml.XamlType.ContentProperty" /> 的 <see cref="T:System.Xaml.XamlType" /> 值。</summary>
        <returns>可能內容型別的清單。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫者取得的值時，可以叫用這個方法<xref:System.Xaml.XamlType.AllowedContentTypes%2A>。  
  
 評估為的型別<xref:System.Xaml.XamlType.CanAssignTo%2A>特定的內容類型不會被視為多個類型，其目的為<xref:System.Xaml.XamlType.AllowedContentTypes%2A>。  
  
 可用的其他屬性的預設實作。 <xref:System.Xaml.XamlType> (<xref:System.Xaml.XamlType.ContentWrappers%2A>， <xref:System.Xaml.XamlType.ContentProperty%2A>，或<xref:System.Xaml.XamlType.ItemType%2A>) 以取得結果。 `Lookup`會為上述的屬性清單也可在這項決定叫用覆寫。  
  
 如果您不會依賴預設內部的 CLR 反映，而使用中繼資料或其他技術報告的 XAML 類型系統資訊或型別的結構描述資訊，請覆寫這個方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAttachableMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member LookupAttachableMember : string -&gt; System.Xaml.XamlMember&#xA;override this.LookupAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要取得之可附加成員的名稱，格式為：<c>ownerTypeName.MemberName</c>。</param>
        <summary>從這個 <see cref="T:System.Xaml.XamlType" /> 傳回 <see cref="T:System.Xaml.XamlMember" /> 以代表特定的具名可附加成員。</summary>
        <returns>代表要求之可附加成員的 <see cref="T:System.Xaml.XamlMember" /> 物件；如果沒有該名稱的可附加成員存在則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫者取得的值時，可以叫用這個方法<xref:System.Xaml.XamlType.GetAttachableMember%2A>。  
  
 預設實作會使用內部的 CLR 反映。 當<xref:System.Xaml.XamlType.UnderlyingType%2A>已`null`，可以使用的預設實作<xref:System.Xaml.XamlType.BaseType%2A>、 如果有的話。 此行為會呼叫<xref:System.Xaml.XamlType.LookupAttachableMember%2A>嘗試尋找有效的基底型別和傳回遞迴`null`如果沒有有效的基底型別。  
  
 如果您不會依賴預設內部的 CLR 反映，而使用中繼資料或其他技術報告的 XAML 類型系統資訊或型別的結構描述資訊，請覆寫這個方法。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> 是虛擬的且因此，可以覆寫。 覆寫有可能 (是否惡意或其他) 若要變更報告的 XAML 型別的成員，讓它們不會再與預期的方式對齊<xref:System.ComponentModel.TypeDescriptor>`Get*`基礎 CLR 型別資訊。 針對成員報告任何安全性關鍵的檢查，請改為使用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupBaseType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupBaseType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupBaseType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupBaseType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupBaseType();" />
      <MemberSignature Language="F#" Value="abstract member LookupBaseType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupBaseType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupBaseType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 XAML 型別之直接基底型別的 <see cref="T:System.Xaml.XamlType" />。 此值取決於這個 <see cref="T:System.Xaml.XamlType" /> 的基礎型別和結構描述內容。</summary>
        <returns>這個 XAML 型別之直接基底型別的 <see cref="T:System.Xaml.XamlType" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫者取得的值時，可以叫用這個方法<xref:System.Xaml.XamlType.BaseType%2A>。  
  
 預設的實作可能會傳回內部的常數，表示<xref:System.Object>如果<xref:System.Xaml.XamlType.UnderlyingType%2A>是`null`。  
  
 如果您不會依賴預設內部的 CLR 反映，而使用中繼資料或其他技術報告的 XAML 類型系統資訊或型別的結構描述資訊，請覆寫這個方法。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> 是虛擬的且因此，可以覆寫。 覆寫有可能 (是否惡意或其他) 變更 XAML 型別相關的報告的類型資訊，使它不再符合預期的方式基礎 CLR 型別的型別系統資訊。 針對指派作業和存取的任何安全性關鍵的檢查，請改為使用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCollectionKind">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlCollectionKind LookupCollectionKind ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Xaml.Schema.XamlCollectionKind LookupCollectionKind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCollectionKind" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCollectionKind () As XamlCollectionKind" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlCollectionKind LookupCollectionKind();" />
      <MemberSignature Language="F#" Value="abstract member LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind&#xA;override this.LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind" Usage="xamlType.LookupCollectionKind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlCollectionKind</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> 列舉的值，這個值宣告此 <see cref="T:System.Xaml.XamlType" /> 使用的特定集合型別。</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> 列舉的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 內部的私用方法叫用此方法 (沒有公開`CollectionKind`或是`GetCollectionKind`API 存在於<xref:System.Xaml.XamlType>)。  
  
 預設實作會使用內部的 CLR 反映。 案例所在<xref:System.Xaml.XamlType.UnderlyingType%2A>是`null`，可以使用的預設實作<xref:System.Xaml.XamlType.BaseType%2A>、 如果有的話。 此行為會間接呼叫<xref:System.Xaml.XamlType.LookupCollectionKind%2A>遞迴地嘗試找不到有效的基底類型; 它會傳回<xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>如果沒有有效的基底型別。 預設實作一般情況下，會嘗試尋找`Add`所反映之基礎類型的方法。 如果找不到，<xref:System.Reflection.MethodInfo>的`Add`方法是足夠的資訊來判斷哪些<xref:System.Xaml.Schema.XamlCollectionKind>應該傳回值。 否則它會傳回 <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>。  
  
 如果您不會依賴預設內部的 CLR 反映，而使用中繼資料或其他技術報告的 XAML 類型系統資訊或型別的結構描述資訊，請覆寫這個方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="protected virtual bool LookupConstructionRequiresArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupConstructionRequiresArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupConstructionRequiresArguments () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupConstructionRequiresArguments();" />
      <MemberSignature Language="F#" Value="abstract member LookupConstructionRequiresArguments : unit -&gt; bool&#xA;override this.LookupConstructionRequiresArguments : unit -&gt; bool" Usage="xamlType.LookupConstructionRequiresArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否必須有引數 (透過 <see langword="x:TypeArguments" /> 的泛型條件約束、初始設定文字或其他 XAML 技術)，才能建構型別的有效執行個體。</summary>
        <returns>如果建構執行個體時需要一些引數值，則為 <see langword="true" />，否則為 false。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫者取得的值時，可以叫用這個方法<xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>。  
  
 預設實作會傳回`false`類型視為實值型別在 CLR 型別系統。 適用於其他實值型別，CLR 反映比<xref:System.Reflection.ConstructorInfo>用來判斷是否已存在的預設建構函式。  
  
 如果您不會依賴預設內部的 CLR 反映，而使用中繼資料或其他技術報告的 XAML 類型系統資訊或型別的結構描述資訊，請覆寫這個方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupContentProperty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupContentProperty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentProperty () As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupContentProperty();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentProperty : unit -&gt; System.Xaml.XamlMember&#xA;override this.LookupContentProperty : unit -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupContentProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Xaml.XamlMember" /> 之內容屬性的 <see cref="T:System.Xaml.XamlType" /> 資訊。</summary>
        <returns>這個 <see cref="T:System.Xaml.XamlMember" /> 之內容屬性的 <see cref="T:System.Xaml.XamlType" /> 資訊。 可以是 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫者取得的值時，可以叫用這個方法<xref:System.Xaml.XamlType.ContentProperty%2A>。  
  
 預設實作會檢查<xref:System.Windows.Markup.ContentPropertyAttribute>的型別定義。 它也可以檢查<xref:System.Xaml.XamlType.BaseType%2A>如果屬性不立即的基礎型別上找到的屬性。 如果這些檢查不會探索的內容類型，則預設實作會傳回`null`。  
  
 如果您不會依賴預設內部的 CLR 反映，而使用中繼資料或其他技術報告的 XAML 類型系統資訊或型別的結構描述資訊，請覆寫這個方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentWrappers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupContentWrappers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupContentWrappers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentWrappers () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupContentWrappers();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupContentWrappers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>取得 <see cref="T:System.Xaml.XamlType" /> 值的清單，這些值表示這個 <see cref="T:System.Xaml.XamlType" /> 的內容包裝函式。</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> 值的清單，表示這個 <see cref="T:System.Xaml.XamlType" /> 的內容包裝函式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 內容的包裝函式是類別，表示內容的集合型別時使用該集合中的類型並不是連續類型系統。 內容的包裝函式的集合項目類型會以某種方式超出限制<xref:System.Object>或中性物件相等。 不過，這項限制只會強制執行的設計或目的使用該類型的屬性，而不是由型別系統。 類型可以有一個以上的內容包裝函式。  
  
 如需範例類別和從 WPF XAML 實作的案例，請參閱<xref:System.Windows.Documents.InlineCollection>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlType.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在衍生類別中實作時，傳回 <see cref="T:System.Reflection.ICustomAttributeProvider" /> 實作。</summary>
        <returns>
          <see cref="T:System.Reflection.ICustomAttributeProvider" /> 實作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 覆寫此方法以提供內部反映替代的方法，若要取得 CLR 屬性的值。 沒有覆寫時，在內部的反映程式會使用一般 CLR 反映邏輯。  
  
 預設實作會傳回 `null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlType.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 物件，這個物件用於延後載入 XAML 宣告的物件。</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />，具有對泛型的 <see cref="T:System.Xaml.XamlDeferringLoader" /> 條件約束。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼叫者取得的值時，可以叫用這個方法<xref:System.Xaml.XamlType.DeferringLoader%2A>。 覆寫這個方法，如果您想<xref:System.Xaml.XamlType.DeferringLoader%2A>傳回不同的值不會啟用預設內部反映，而且也提供自訂<xref:System.Xaml.Schema.XamlTypeInvoker>資訊。  
  
 預設實作會傳回根據讀取物件<xref:System.Windows.Markup.XamlDeferLoadAttribute>。 它也可以檢查<xref:System.Xaml.XamlType.BaseType%2A>如果屬性不立即的基礎型別上找到的屬性。 如果值是無法使用，則這個方法會傳回`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlTypeInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlTypeInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlTypeInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker" Usage="xamlType.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回與這個 <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 相關聯的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>這個 <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> 的 <see cref="T:System.Xaml.XamlType" /> 資訊，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.Invoker%2A>。  
  
 預設實作不需要<xref:System.Xaml.XamlType>使用其中一種傳遞初始的建構函式會建構<xref:System.Xaml.Schema.XamlTypeInvoker>。 不過，<xref:System.Xaml.XamlType.UnderlyingType%2A>值必須存在<xref:System.Xaml.XamlType>; 否則預設實作會傳回`null`。  
  
 如果您也可以建立從衍生的類別覆寫此方法<xref:System.Xaml.Schema.XamlTypeInvoker>，而且想要傳回衍生的類別。 如果您傳回`null`，<xref:System.Xaml.XamlType.Invoker%2A>傳回<xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType>向呼叫端。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlType.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XAML 定義的環境型別。</summary>
        <returns>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示環境型別，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.IsAmbient%2A>。  
  
 預設實作會使用 CLR 反映上<xref:System.Xaml.XamlType.UnderlyingType%2A>會檢查基底型別。 此實作會檢查<xref:System.Windows.Markup.AmbientAttribute>其會套用至類別層級的相關型別定義，並傳回`true`在此情況下。 所有其他情況下傳回`false`。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.IsAmbient%2A>傳回不同的值，不會啟用預設內部反映。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsConstructible">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsConstructible ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsConstructible() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsConstructible" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsConstructible () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsConstructible();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsConstructible : unit -&gt; bool&#xA;override this.LookupIsConstructible : unit -&gt; bool" Usage="xamlType.LookupIsConstructible " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XAML 定義的可建構型別。</summary>
        <returns>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示可建構的型別則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.IsConstructible%2A>。  
  
 預設實作會使用 CLR 反映上<xref:System.Xaml.XamlType.UnderlyingType%2A>。 類型必須是具體、 非巢狀，並已關閉。 預設實作會檢查型別是實值類型和傳回<xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>。 Null <xref:System.Xaml.XamlType.UnderlyingType%2A>，這個方法會傳回`true`。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.IsConstructible%2A>傳回不同的值，不會啟用預設內部反映。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsMarkupExtension">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsMarkupExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsMarkupExtension() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsMarkupExtension () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsMarkupExtension();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsMarkupExtension : unit -&gt; bool&#xA;override this.LookupIsMarkupExtension : unit -&gt; bool" Usage="xamlType.LookupIsMarkupExtension " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表標記延伸。</summary>
        <returns>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示標記延伸，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.IsMarkupExtension%2A>。  
  
 預設實作只包含此呼叫：  
  
 `return CanAssignTo(XamlLanguage.MarkupExtension);`  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.IsMarkupExtension%2A>使用不同的邏輯。  
  
 XAML 規格而言，此類型必須是指派給`x:MarkupExtension`來傳回`true`如<xref:System.Xaml.XamlType.IsMarkupExtension%2A>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsNameScope">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNameScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNameScope" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNameScope () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNameScope();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNameScope : unit -&gt; bool&#xA;override this.LookupIsNameScope : unit -&gt; bool" Usage="xamlType.LookupIsNameScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XAML 定義的 XAML 名稱範圍。</summary>
        <returns>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示 XAML 名稱範圍，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.IsNameScope%2A>。  
  
 預設實作會製作<xref:System.Xaml.XamlType.CanAssignTo%2A>間接呼叫針對型別<xref:System.Windows.Markup.INameScope>。 <xref:System.Windows.Markup.INameScope> 是 WindowsBase.dll 組件中定義的介面。 XAML 名稱範圍識別這項技術會使用這兩者的 XAML 的 WPF 和 Windows Workflow Foundation 實作。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.IsNameScope%2A>使用不同的邏輯。  
  
 XAML 名稱範圍會強制執行或多個屬性所使用的名稱唯一性`x:Name`  /  `[name property]`。 如果<xref:System.Xaml.XamlType.IsNameScope%2A>是`true`，則應該存在，且應該評估從擁有 XAML 名稱範圍這種觀點來看一些機制來強制執行唯一性。 XAML 名稱範圍然後會延伸至類型的內容，直到遇到另一個 XAML 名稱範圍擁有者型別之前。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsNullable">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNullable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNullable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNullable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNullable () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNullable();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNullable : unit -&gt; bool&#xA;override this.LookupIsNullable : unit -&gt; bool" Usage="xamlType.LookupIsNullable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XAML 定義之可為 Null 的型別。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示可為 Null 的型別則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.IsNullable%2A>。  
  
 預設實作會判定概念為基礎 CLR 核心程式庫可為 null，根據檢查<xref:System.Xaml.XamlType.UnderlyingType%2A>。 Null <xref:System.Xaml.XamlType.UnderlyingType%2A>，它會傳回`true`。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.IsNullable%2A>使用不同的邏輯。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsPublic : unit -&gt; bool&#xA;override this.LookupIsPublic : unit -&gt; bool" Usage="xamlType.LookupIsPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表相關型別系統中的公用型別。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示公用型別則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.IsPublic%2A>。  
  
 預設實作會使用針對非 null 的 CLR 反映<xref:System.Xaml.XamlType.UnderlyingType%2A>。 Null <xref:System.Xaml.XamlType.UnderlyingType%2A>，它會傳回`true`。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.IsPublic%2A>使用不同的邏輯。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> 是虛擬的且因此，可以覆寫。 覆寫有可能 (是否惡意或其他) 變更 XAML 類型中報告的存取權的資訊，使它不再符合預期的方式在其基礎的 CLR 類型的型別系統或存取資訊。 針對指派作業和存取的任何安全性關鍵的檢查，請改為使用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlType.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表基礎型別系統中無法解析的型別。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示無法解析的型別則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.IsUnknown%2A>。  
  
 預設實作都可以使用 CLR 反映。 Null <xref:System.Xaml.XamlType.UnderlyingType%2A>，它會傳回`true`。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.IsUnknown%2A>使用不同的邏輯。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWhitespaceSignificantCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWhitespaceSignificantCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWhitespaceSignificantCollection () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWhitespaceSignificantCollection();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWhitespaceSignificantCollection : unit -&gt; bool&#xA;override this.LookupIsWhitespaceSignificantCollection : unit -&gt; bool" Usage="xamlType.LookupIsWhitespaceSignificantCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XML 定義的空白有效集合。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示空白字元有效集合則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A>。  
  
 預設實作會傳回值，根據讀取<xref:System.Windows.Markup.WhitespaceSignificantCollectionAttribute>。 它也可以檢查<xref:System.Xaml.XamlType.BaseType%2A>如果屬性不立即的基礎型別上找到的屬性。 如果值不是可用的它會傳回`false`。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A>使用不同的邏輯。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsXData">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsXData ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsXData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsXData" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsXData () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsXData();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsXData : unit -&gt; bool&#xA;override this.LookupIsXData : unit -&gt; bool" Usage="xamlType.LookupIsXData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否代表符合 XAML 定義的 XML <see langword="XDATA" />。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 表示 <see langword="true" /> 則為 <see langword="XDATA" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.IsXData%2A>。  
  
 預設實作會製作<xref:System.Xaml.XamlType.CanAssignTo%2A>間接呼叫針對型別<xref:System.Xml.Serialization.IXmlSerializable>。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.IsXData%2A>使用不同的邏輯。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupItemType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupItemType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupItemType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupItemType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupItemType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupItemType();" />
      <MemberSignature Language="F#" Value="abstract member LookupItemType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupItemType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupItemType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值提供此 <see cref="T:System.Xaml.XamlType" /> 之 <see langword="Items" /> 屬性的型別資訊。</summary>
        <returns>集合中之項目型別的 <see cref="T:System.Xaml.XamlType" /> 物件，如果此 <see cref="T:System.Xaml.XamlType" /> 不表示集合，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.ItemType%2A>。  
  
 預設實作都可以使用 CLR 反映概念，例如檢查`Add`方法所<xref:System.Reflection.MethodInfo>並使用<xref:System.Reflection.ParameterInfo>; 檢查<xref:System.Xaml.XamlType.IsArray%2A>; 並檢查<xref:System.Xaml.XamlType.BaseType%2A>及試用那里相同的邏輯。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.ItemType%2A>使用不同的邏輯。 情況<xref:System.Xaml.XamlType.LookupCollectionKind%2A>會傳回<xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>應該會傳回`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupKeyType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupKeyType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupKeyType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupKeyType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupKeyType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupKeyType();" />
      <MemberSignature Language="F#" Value="abstract member LookupKeyType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupKeyType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupKeyType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，如果 <see cref="T:System.Xaml.XamlType" /> 表示字典，則這個值提供此 <see cref="T:System.Xaml.XamlType" /> 之索引鍵屬性的型別資訊。</summary>
        <returns>字典用法之索引鍵型別的 <see cref="T:System.Xaml.XamlType" /> 物件，如果這個 <see cref="T:System.Xaml.XamlType" /> 不表示字典，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.KeyType%2A>。  
  
 預設實作都可以使用 CLR 反映概念，例如檢查`Add`方法所<xref:System.Reflection.MethodInfo>並使用<xref:System.Reflection.ParameterInfo>; 並檢查<xref:System.Xaml.XamlType.BaseType%2A>及試用那里相同的邏輯。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.KeyType%2A>使用不同的邏輯。 情況<xref:System.Xaml.XamlType.LookupCollectionKind%2A>不會傳回<xref:System.Xaml.Schema.XamlCollectionKind.Dictionary?displayProperty=nameWithType>應該會傳回`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupMarkupExtensionReturnType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupMarkupExtensionReturnType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionReturnType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupMarkupExtensionReturnType();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupMarkupExtensionReturnType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值提供此 <see cref="T:System.Xaml.XamlType" /> (如果表示標記延伸的話) 傳回之 <see langword="ProvideValue" /> 的型別資訊。</summary>
        <returns>標記延伸使用方式之傳回型別的 <see cref="T:System.Xaml.XamlType" /> 物件，如果這個 <see cref="T:System.Xaml.XamlType" /> 不表示標記延伸，則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A>。  
  
 預設實作會傳回<xref:System.Xaml.XamlType>根據讀取<xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute>。 它也可以檢查<xref:System.Xaml.XamlType.BaseType%2A>如果屬性不立即的基礎型別上找到的屬性。 如果值不是可用的它會傳回`null`。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A>使用不同的邏輯。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupMember (string name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupMember(string name, bool skipReadOnlyCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMember(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMember (name As String, skipReadOnlyCheck As Boolean) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupMember(System::String ^ name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="F#" Value="abstract member LookupMember : string * bool -&gt; System.Xaml.XamlMember&#xA;override this.LookupMember : string * bool -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupMember (name, skipReadOnlyCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="skipReadOnlyCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">要取得之成員的名稱 (字串形式)。</param>
        <param name="skipReadOnlyCheck">
          <see langword="true" /> 表示即使成員的 <see cref="P:System.Xaml.XamlMember.IsReadOnly" /> 是 <see langword="true" /> 值，還是傳回該成員。<see langword="false" /> 表示不傳回 <see cref="P:System.Xaml.XamlMember.IsReadOnly" /> 成員。 預設值為 <see langword="false" />。</param>
        <summary>從這個 <see cref="T:System.Xaml.XamlMember" /> 傳回特定具名成員的 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>如果找到成員，則為成員的 <see cref="T:System.Xaml.XamlMember" /> 資訊，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.GetMember%2A>。  
  
 預設實作會傳回<xref:System.Xaml.XamlType>內部的 CLR 反映和評估針對結構描述內容為基礎。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.GetMember%2A>使用不同的邏輯。  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> 是虛擬的且因此，可以覆寫。 覆寫有可能 (是否惡意或其他) 若要變更報告的 XAML 型別的成員，讓它們不會再與預期的方式對齊<xref:System.ComponentModel.TypeDescriptor>`Get*`基礎 CLR 型別資訊。 針對成員報告任何安全性關鍵的檢查，請改為使用基礎 CLR 型別。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupPositionalParameters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="abstract member LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">您想要取得相關資訊之特定語法或建構函式模式的計數 (Arity)。</param>
        <summary>如果是標記延伸型別，則傳回這個 <see cref="T:System.Xaml.XamlType" /> 的特定標記延伸用法所支援之位置參數的型別。</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> 值的清單，其中每個 <see cref="T:System.Xaml.XamlType" /> 都是語法中該位置適用的型別。 為標記延伸提供標記輸入時，您必須以相同順序指定這些型別。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.GetPositionalParameters%2A>。  
  
 預設實作會使用根據尋找建構函式，並檢查套組 arity 的內部的反映資訊。 如果您想要覆寫此方法<xref:System.Xaml.XamlType.GetPositionalParameters%2A>使用不同的邏輯。  
  
 此 API 僅適用於此<xref:System.Xaml.XamlType>代表標記延伸 (<xref:System.Xaml.XamlType.IsMarkupExtension%2A>是`true`)。  
  
 輸入`parameterCount`不是用來要求特定的位置參數的型別。 這是指定套組 arity 的標記延伸使用方式。 標記延伸使用方式通常有多個簽章，並使用不同的參數 arity （計數） 的位置參數來區分。 不過，您可以設定結構描述內容允許重複的 arities，並且使用位置參數的類型差異化。 如需詳細資訊，請參閱<xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>。 針對特定的引數數目計數的參數位置和類型而有所不同。 若要取得特定套組 arity 的標記延伸使用方式的位置類型，您先呼叫<xref:System.Xaml.XamlType.GetPositionalParameters%2A>引數數目計數。 然後從傳回的集合，該位置取得項目。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetMarkupExtensionHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetMarkupExtensionHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetMarkupExtensionHandler () As EventHandler(Of XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^&gt; ^ LookupSetMarkupExtensionHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;&#xA;override this.LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;" Usage="xamlType.LookupSetMarkupExtensionHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回用於標記延伸設定作業的處理常式回呼。</summary>
        <returns>用於標記延伸設定作業的處理常式回呼。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會傳回值，根據讀取<xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute>。 它也可以檢查<xref:System.Xaml.XamlType.BaseType%2A>如果屬性不立即的基礎型別上找到的屬性。 如果值是無法使用，它會傳回`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetTypeConverterHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetTypeConverterHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetTypeConverterHandler () As EventHandler(Of XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetTypeConverterEventArgs ^&gt; ^ LookupSetTypeConverterHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;&#xA;override this.LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;" Usage="xamlType.LookupSetTypeConverterHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回用於型別轉換子設定案例的處理常式。</summary>
        <returns>用於型別轉換子設定案例的處理常式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 預設實作會傳回值，根據讀取<xref:System.Windows.Markup.XamlSetTypeConverterAttribute>。 它也可以檢查<xref:System.Xaml.XamlType.BaseType%2A>如果屬性不立即的基礎型別上找到的屬性。 如果值是無法使用，它會傳回`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="protected virtual bool LookupTrimSurroundingWhitespace ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupTrimSurroundingWhitespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTrimSurroundingWhitespace () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupTrimSurroundingWhitespace();" />
      <MemberSignature Language="F#" Value="abstract member LookupTrimSurroundingWhitespace : unit -&gt; bool&#xA;override this.LookupTrimSurroundingWhitespace : unit -&gt; bool" Usage="xamlType.LookupTrimSurroundingWhitespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否應使用修剪前後空白字元的模式進行序列化。</summary>
        <returns>如果此 <see cref="T:System.Xaml.XamlType" /> 應以修剪前後空白字元的模式進行序列化則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.TrimSurroundingWhitespace%2A>。  
  
 預設實作會傳回值，根據讀取<xref:System.Windows.Markup.TrimSurroundingWhitespaceAttribute>。 它也可以檢查<xref:System.Xaml.XamlType.BaseType%2A>如果屬性不立即的基礎型別上找到的屬性。 如果值是無法使用，它會傳回`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlType.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 條件約束的 <see cref="T:System.ComponentModel.TypeConverter" />，這個條件約束表示此 <see cref="T:System.Xaml.XamlType" /> 之值的型別轉換行為。</summary>
        <returns>具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 條件約束的 <see cref="T:System.ComponentModel.TypeConverter" /> (這個條件約束表示此 <see cref="T:System.Xaml.XamlType" /> 之值的型別轉換行為)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.TypeConverter%2A>。  
  
 預設實作會傳回值，根據讀取<xref:System.ComponentModel.TypeConverterAttribute>。 預設實作也可以檢查<xref:System.Xaml.XamlType.BaseType%2A>如果屬性不立即的基礎型別上找到的屬性。 它也包含特殊的列舉型別，一般的實值型別和泛型的預設轉換邏輯。 如果值是無法使用，它會傳回`null`。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.TypeConverter%2A>使用不同的邏輯。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingType">
      <MemberSignature Language="C#" Value="protected virtual Type LookupUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type LookupUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ LookupUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingType : unit -&gt; Type&#xA;override this.LookupUnderlyingType : unit -&gt; Type" Usage="xamlType.LookupUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回做為此 <see cref="T:System.Type" /> 之基礎的 CLR <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>做為此 <see cref="T:System.Type" /> 之基礎的 CLR <see cref="T:System.Xaml.XamlType" />，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.UnderlyingType%2A>。  
  
 預設實作會傳回內部欄位。 通常在建構時初始化該欄位，其值為基礎的建構函式呼叫和您所提供的資訊。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.UnderlyingType%2A>使用不同的邏輯。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUsableDuringInitialization">
      <MemberSignature Language="C#" Value="protected virtual bool LookupUsableDuringInitialization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupUsableDuringInitialization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUsableDuringInitialization () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupUsableDuringInitialization();" />
      <MemberSignature Language="F#" Value="abstract member LookupUsableDuringInitialization : unit -&gt; bool&#xA;override this.LookupUsableDuringInitialization : unit -&gt; bool" Usage="xamlType.LookupUsableDuringInitialization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回值，這個值表示在 XAML 初始化期間是否由上往下建立這個 <see cref="T:System.Xaml.XamlType" />。</summary>
        <returns>如果在 XAML 初始化期間由上往下建立這個 <see cref="T:System.Xaml.XamlType" />，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由上而下是近似 XAML 處理器行為，建立物件圖形時的比喻。 建置由上而下，為型別會具現化，附加至父代，並設定其屬性。 由上而下建構可避免多次叫用屬性變更處理常式。 這類處理 ripples 向上物件圖形和因此，排除多個處理常式呼叫，並提供的物件圖形的啟動逾時的效能最佳化。  
  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A>。  
  
 預設實作會傳回值，根據讀取<xref:System.Windows.Markup.UsableDuringInitializationAttribute>。 它也可以檢查<xref:System.Xaml.XamlType.BaseType%2A>如果屬性不立即的基礎型別上找到的屬性。 如果值是無法使用，它會傳回`false`。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A>使用不同的邏輯。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlType.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 條件約束的 <see cref="T:System.Windows.Markup.ValueSerializer" />，這個條件約束表示此 <see cref="T:System.Xaml.XamlType" /> 之值的值序列化行為。</summary>
        <returns>具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 條件約束的 <see cref="T:System.Windows.Markup.ValueSerializer" /> (這個條件約束表示此 <see cref="T:System.Xaml.XamlType" /> 之值的值序列化行為)，否則為 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以叫用這個方法，藉由呼叫<xref:System.Xaml.XamlType.ValueSerializer%2A>。  
  
 預設實作會傳回值，根據讀取<xref:System.Windows.Markup.ValueSerializerAttribute>。 它也可以檢查<xref:System.Xaml.XamlType.BaseType%2A>如果屬性不立即的基礎型別上找到的屬性。 它也包含特殊邏輯的列舉型別、 常見的實值類型或泛型的預設序列化。 如果值是無法使用，它會傳回`null`。  
  
 如果您想要覆寫此方法<xref:System.Xaml.XamlType.ValueSerializer%2A>使用不同的邏輯。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType MarkupExtensionReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType MarkupExtensionReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionReturnType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ MarkupExtensionReturnType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionReturnType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值提供此 <see cref="T:System.Xaml.XamlType" /> (如果表示標記延伸的話) 傳回之 <see langword="ProvideValue" /> 的型別資訊。</summary>
        <value>標記延伸使用方式之傳回型別的 <see cref="T:System.Xaml.XamlType" /> 物件，如果這個 <see cref="T:System.Xaml.XamlType" /> 不表示標記延伸，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性才適用，如果這個<xref:System.Xaml.XamlType>代表標記延伸 (`x:MarkupExtension`可指派型別清單中)。  
  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlType.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得這個 <see cref="T:System.Xaml.XamlType" /> 表示之型別的字串名稱。</summary>
        <value>這個 XAML 型別的字串名稱。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性通常會取得結構描述建構的名稱 (每<xref:System.Xaml.XamlType.%23ctor%2A>簽章)，或名稱<xref:System.Type>，如果它使用適當的建構函式的 CLR 型別系統所建構。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Equality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="xamlType1 = xamlType2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">
          <see cref="T:System.Xaml.XamlType" /> 或 <see langword="null" />。</param>
        <param name="xamlType2">
          <see cref="T:System.Xaml.XamlType" /> 或 <see langword="null" />。</param>
        <summary>判斷兩個指定的 <see cref="T:System.Xaml.XamlType" /> 物件是否具有相同的值。</summary>
        <returns>如果 <see langword="true" /> 的值與 <paramref name="xamlType1" /> 的值相同，則為 <paramref name="xamlType2" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Inequality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="System.Xaml.XamlType.op_Inequality (xamlType1, xamlType2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">
          <see cref="T:System.Xaml.XamlType" /> 或 <see langword="null" />。</param>
        <param name="xamlType2">
          <see cref="T:System.Xaml.XamlType" /> 或 <see langword="null" />。</param>
        <summary>判斷兩個指定的 <see cref="T:System.Xaml.XamlType" /> 物件是否具有不同的值。</summary>
        <returns>如果 <see langword="true" /> 的值與 <paramref name="xamlType1" /> 的值不同，則為 <paramref name="xamlType2" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得單一 XAML 命名空間，這是此 <see cref="T:System.Xaml.XamlType" /> 的主要 XAML 命名空間。</summary>
        <value>這個 XAML 型別之主要 XAML 命名空間的識別項 (字串形式)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此實作會提供相同的值，與呼叫<xref:System.Xaml.XamlType.GetXamlNamespaces%2A>，然後從傳回的可列舉集合中取得的第一個值的字串。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlType.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得處理這個 <see cref="T:System.Xaml.XamlSchemaContext" /> 的作用中 <see cref="T:System.Xaml.XamlType" />。</summary>
        <value>用於處理這個 <see cref="T:System.Xaml.XamlSchemaContext" /> 的作用中 <see cref="T:System.Xaml.XamlType" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlSchemaContext> 在建構時是必要的參數的項目<xref:System.Xaml.XamlType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>傳回這個 <see cref="T:System.Xaml.XamlType" /> 的字串表示。</summary>
        <returns>這個 <see cref="T:System.Xaml.XamlType" /> 的字串表示。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlType>實作<xref:System.Object.ToString%2A>會傳回<xref:System.Xaml.XamlType.Name%2A>屬性<xref:System.Xaml.XamlType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="public bool TrimSurroundingWhitespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimSurroundingWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TrimSurroundingWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimSurroundingWhitespace { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.TrimSurroundingWhitespace : bool" Usage="System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值表示此 <see cref="T:System.Xaml.XamlType" /> 是否有序列化的空白字元處理行為會修剪其內容中的前後空白字元。</summary>
        <value>如果這個 <see cref="T:System.Xaml.XamlType" /> 表示使用空白修剪的型別，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; TypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; TypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArguments As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ TypeArguments { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeArguments : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.TypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>當這個 <see cref="T:System.Xaml.XamlType" /> 表示泛型時，取得型別引數的清單。</summary>
        <value>型別引數型別的清單，如果這個 <see cref="T:System.Xaml.XamlType" /> 不表示泛型，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有特定案例<xref:System.Xaml.XamlType>其中呼叫<xref:System.Xaml.XamlType.TypeArguments%2A>參數傳回的清單，其中類型是仍處於開啟狀態。 在此情況下，一或多個傳回<xref:System.Xaml.XamlType>值將會擁有預留位置值<xref:System.Xaml.XamlType.Name%2A?displayProperty=nameWithType>，例如`T`，以代表泛型是仍處於開啟狀態。 如果您收到，就會發生這種情況下<xref:System.Xaml.XamlType>呼叫<xref:System.Xaml.XamlSchemaContext.GetXamlType%2A>，而不是從 XAML 讀取器實作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlType.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 條件約束的 <see cref="T:System.ComponentModel.TypeConverter" />，這個條件約束表示此 <see cref="T:System.Xaml.XamlType" /> 之值的型別轉換行為。</summary>
        <value>具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 條件約束的 <see cref="T:System.ComponentModel.TypeConverter" />，這個條件約束表示此 <see cref="T:System.Xaml.XamlType" /> 之值的型別轉換行為。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupTypeConverter%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupTypeConverter%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingType">
      <MemberSignature Language="C#" Value="public Type UnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.UnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ UnderlyingType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingType : Type" Usage="System.Xaml.XamlType.UnderlyingType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得做為此 <see cref="T:System.Type" /> 之基礎的 CLR <see cref="T:System.Xaml.XamlType" />。</summary>
        <value>做為此 <see cref="T:System.Type" /> 之基礎的 CLR <see cref="T:System.Xaml.XamlType" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlType.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 條件約束的 <see cref="T:System.Windows.Markup.ValueSerializer" />，這個條件約束表示此 <see cref="T:System.Xaml.XamlType" /> 之值的值序列化行為。</summary>
        <value>具有 <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> 條件約束的 <see cref="T:System.Windows.Markup.ValueSerializer" /> (這個條件約束表示此 <see cref="T:System.Xaml.XamlType" /> 之值的值序列化行為)，否則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您未使用的預設內部 CLR 反映技巧<xref:System.Xaml.XamlType>，呼叫這個屬性可以叫用<xref:System.Xaml.XamlType.LookupValueSerializer%2A>覆寫上<xref:System.Xaml.XamlType>衍生的類別。 如需傳回值和其他行為的詳細資訊，請參閱文件<xref:System.Xaml.XamlType.LookupValueSerializer%2A>這個型別上。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>