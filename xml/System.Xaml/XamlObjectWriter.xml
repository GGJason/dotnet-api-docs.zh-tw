<Type Name="XamlObjectWriter" FullName="System.Xaml.XamlObjectWriter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="88e6ca45083f7c3b687072f89d33f2067088da08" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53390855" /></Metadata><TypeSignature Language="C#" Value="public class XamlObjectWriter : System.Xaml.XamlWriter, System.Xaml.IXamlLineInfoConsumer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlObjectWriter extends System.Xaml.XamlWriter implements class System.Xaml.IXamlLineInfoConsumer" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlObjectWriter" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlObjectWriter&#xA;Inherits XamlWriter&#xA;Implements IXamlLineInfoConsumer" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlObjectWriter : System::Xaml::XamlWriter, System::Xaml::IXamlLineInfoConsumer" />
  <TypeSignature Language="F#" Value="type XamlObjectWriter = class&#xA;    inherit XamlWriter&#xA;    interface IXamlLineInfoConsumer" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xaml.XamlWriter</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xaml.IXamlLineInfoConsumer</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>從來源 XAML 節點資料流建立物件圖形。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`方法<xref:System.Xaml.XamlObjectWriter>實作模式以便<xref:System.Xaml.XamlObjectWriter>會使用<xref:System.Xaml.XamlWriter>藉由定義<xref:System.Xaml.XamlWriter.WriteNode%2A>方法。 <xref:System.Xaml.XamlWriter.WriteNode%2A> 邏輯交換器之間`Write`方法，取決於哪一個節點型別是讀取器中目前的位置。  
  
## <a name="scope"></a>範圍  
 A<xref:System.Xaml.XamlObjectWriter>有的範圍; 概念、<xref:System.Xaml.XamlObjectWriter>維護概念及其輸出物件圖形中的參考點。 針對特定的範圍中，某些作業可能會有效或無效，或產生無作業結果。 例如，如果您呼叫<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A>已初始化的物件上存在的執行個體，請撰寫指示詞，預設實作會擲回例外狀況。  
  
 可能的技巧，來追蹤在自訂的範圍<xref:System.Xaml.XamlObjectWriter>對齊的堆疊或框架類別節點動作。 框架的堆疊可以追蹤的 push 和 pop 的每個層級的物件模型的深度，進入或離開時<xref:System.Xaml.XamlObjectWriter>寫入物件圖形。  
  
## <a name="callbacks"></a>回呼  
 若要支援中階和進階<xref:System.Xaml.XamlObjectWriter>案例中，寫入物件圖形的機制提供回呼進入點發生時<xref:System.Xaml.XamlObjectWriter>認可或即將認可特定動作。 某些回呼中設定已啟用，而且不是特定的物件型別或成員正在寫入;不過，回呼資訊通常是在內容中使用，或者是在事件會透過回呼傳送的資料。 以下是一份相關的回呼：  
  
-   所宣告的回呼<xref:System.Xaml.XamlObjectWriterSettings.AfterBeginInitHandler%2A>時的範圍會移至新的物件，並在叫用<xref:System.ComponentModel.ISupportInitialize.BeginInit%2A>針對每個建立物件的物件存留期階段。  
  
-   所宣告的回呼<xref:System.Xaml.XamlObjectWriterSettings.AfterEndInitHandler%2A>時的範圍會移至新的物件，並在叫用<xref:System.ComponentModel.ISupportInitialize.EndInit%2A>針對每個建立物件的物件存留期階段。  
  
-   所宣告的回呼<xref:System.Xaml.XamlObjectWriterSettings.BeforePropertiesHandler%2A>範圍中的物件，會啟動，並發生時叫用時的第一個<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A>呼叫該物件的範圍是所做的但尚未認可。  
  
-   所宣告的回呼<xref:System.Xaml.XamlObjectWriterSettings.AfterPropertiesHandler%2A>當範圍在物件中，會啟動，且發生時叫用時<xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A>呼叫該物件的範圍是所做的但尚未認可。  
  
-   所宣告的回呼<xref:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler%2A>時叫用<xref:System.Xaml.XamlObjectWriter.OnSetValue%2A>呼叫。  
  
## <a name="writing-dictionary-keys"></a>手寫字典索引鍵  
 預設實作<xref:System.Xaml.XamlObjectWriter>支援型別轉換的條件約束<xref:System.Collections.Generic.Dictionary%602>之前字典的內容會加入至物件圖形。 如此一來，在泛型字典可以當成索引鍵在執行階段物件，而且符合的相關泛型`Add`和索引子行為。 不過，做為實作基底<xref:System.Xaml.XamlObjectWriter>，這項功能只存在於物件圖形建立基底<xref:System.Collections.Generic.Dictionary%602>類別，不能用於衍生類別的<xref:System.Collections.Generic.Dictionary%602>。  
  
## <a name="checks-for-disposed"></a>檢查有無處置  
 XAML 寫入器可能用來延後的作業，或針對 XAML 寫入器執行個體已經處置在過渡時期進行呼叫。 各種 Api<xref:System.Xaml.XamlObjectWriter>可能會擲回<xref:System.ObjectDisposedException>在這些情況下。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlWriter" />
    <altmember cref="T:System.Xaml.XamlObjectReader" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xaml.XamlObjectWriter" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlObjectWriter (System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.#ctor(System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlObjectWriter(System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlObjectWriter : System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlObjectWriter" Usage="new System.Xaml.XamlObjectWriter schemaContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="schemaContext">與提供寫入之節點的 XAML 讀取器共用的 XAML 結構描述內容。</param>
        <summary>使用 <see cref="T:System.Xaml.XamlObjectWriter" /> 所使用的 XAML 結構描述內容，初始化 <see cref="T:System.Xaml.XamlReader" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="schemaContext" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlObjectWriter (System.Xaml.XamlSchemaContext schemaContext, System.Xaml.XamlObjectWriterSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.XamlObjectWriterSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.#ctor(System.Xaml.XamlSchemaContext,System.Xaml.XamlObjectWriterSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (schemaContext As XamlSchemaContext, settings As XamlObjectWriterSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlObjectWriter(System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::XamlObjectWriterSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlObjectWriter : System.Xaml.XamlSchemaContext * System.Xaml.XamlObjectWriterSettings -&gt; System.Xaml.XamlObjectWriter" Usage="new System.Xaml.XamlObjectWriter (schemaContext, settings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="settings" Type="System.Xaml.XamlObjectWriterSettings" />
      </Parameters>
      <Docs>
        <param name="schemaContext">與提供寫入之節點的 XAML 讀取器共用的 XAML 結構描述內容。</param>
        <param name="settings">指定 <see cref="T:System.Xaml.XamlObjectWriter" /> 行為和輸出之特定選項的設定物件。</param>
        <summary>使用 <see cref="T:System.Xaml.XamlObjectWriter" /> 所使用的內容和其設定，初始化 <see cref="T:System.Xaml.XamlReader" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="schemaContext" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="xamlObjectWriter.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重設所有可能的框架並清除物件圖形。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="xamlObjectWriter.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示釋放 Managed 資源，否則為 <see langword="false" />。</param>
        <summary>釋放 <see cref="T:System.Xaml.XamlObjectWriter" /> 所使用的 Unmanaged 資源，並選擇性釋放 Managed 資源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterBeginInit">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterBeginInit (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterBeginInit(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterBeginInit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterBeginInit (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterBeginInit(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnAfterBeginInit : obj -&gt; unit&#xA;override this.OnAfterBeginInit : obj -&gt; unit" Usage="xamlObjectWriter.OnAfterBeginInit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要報告的物件。 叫用處理常式時，會將物件封裝至 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 中。</param>
        <summary>叫用與這個 <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterBeginInitHandler" /> 之 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 相關聯的任何 <see cref="T:System.Xaml.XamlObjectWriter" /> 方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterEndInit">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterEndInit (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterEndInit(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterEndInit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterEndInit (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterEndInit(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnAfterEndInit : obj -&gt; unit&#xA;override this.OnAfterEndInit : obj -&gt; unit" Usage="xamlObjectWriter.OnAfterEndInit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要報告的物件。 叫用處理常式時，值會封裝至 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 中。</param>
        <summary>叫用與這個 <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterEndInitHandler" /> 之 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 相關聯的任何 <see cref="T:System.Xaml.XamlObjectWriter" /> 方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterProperties">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterProperties (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterProperties(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterProperties (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterProperties(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnAfterProperties : obj -&gt; unit&#xA;override this.OnAfterProperties : obj -&gt; unit" Usage="xamlObjectWriter.OnAfterProperties value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要報告的物件。 會在叫用處理常式將其封裝至 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 中。</param>
        <summary>叫用與這個 <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterPropertiesHandler" /> 之 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 相關聯的任何 <see cref="T:System.Xaml.XamlObjectWriter" /> 參考方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeforeProperties">
      <MemberSignature Language="C#" Value="protected virtual void OnBeforeProperties (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeforeProperties(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnBeforeProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBeforeProperties (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBeforeProperties(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnBeforeProperties : obj -&gt; unit&#xA;override this.OnBeforeProperties : obj -&gt; unit" Usage="xamlObjectWriter.OnBeforeProperties value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">在叫用處理常式時要透過 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 傳遞的值。</param>
        <summary>叫用與這個 <see cref="P:System.Xaml.XamlObjectWriterSettings.BeforePropertiesHandler" /> 之 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 相關聯的任何 <see cref="T:System.Xaml.XamlObjectWriter" /> 參考方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSetValue">
      <MemberSignature Language="C#" Value="protected virtual bool OnSetValue (object eventSender, System.Xaml.XamlMember member, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnSetValue(object eventSender, class System.Xaml.XamlMember member, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnSetValue(System.Object,System.Xaml.XamlMember,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnSetValue (eventSender As Object, member As XamlMember, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnSetValue(System::Object ^ eventSender, System::Xaml::XamlMember ^ member, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member OnSetValue : obj * System.Xaml.XamlMember * obj -&gt; bool&#xA;override this.OnSetValue : obj * System.Xaml.XamlMember * obj -&gt; bool" Usage="xamlObjectWriter.OnSetValue (eventSender, member, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSender" Type="System.Object" />
        <Parameter Name="member" Type="System.Xaml.XamlMember" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="eventSender">要向處理常式報告做為來源的物件。</param>
        <param name="member">要設定之屬性的名稱，這個名稱會在 <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" /> 中傳遞至處理常式。</param>
        <param name="value">要提供給由 <paramref name="property" /> 命名之屬性的值。 這個值會在 <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" /> 中傳遞至處理常式。</param>
        <summary>叫用與這個寫入器之 <see cref="P:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler" /> 相關聯的任何 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 參考方法 (只要 <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" /> 事件資料中的 <paramref name="handled" /> 不是 <see langword="true" /> 即可)。</summary>
        <returns>任何相關聯處理常式所設定的布林值，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`SetValue`這個 XAML 寫入器的作業有關聯的處理常式 (<xref:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler%2A>中宣告<xref:System.Xaml.XamlObjectWriterSettings>)，這個方法建立新<xref:System.Windows.Markup.XamlSetValueEventArgs>並將它們傳遞至處理常式。 傳回的值由讀取設定<xref:System.Windows.Markup.XamlSetValueEventArgs.Handled%2A>事件資料會傳遞的值。 如果處理常式不存在，而且這個方法會叫用，則呼叫會傳回`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public virtual object Result { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Result" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.Result" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Result As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ Result { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Result : obj" Usage="System.Xaml.XamlObjectWriter.Result" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得最後一個寫入的物件。 通常只有在節點資料流位在結尾且物件圖形完成時才會加以呼叫。</summary>
        <value>最後一個寫入的物件，或 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常見的使用方式的<xref:System.Xaml.XamlObjectWriter.Result%2A>是已知節點資料流為在其結尾，且物件圖形完成時，才呼叫它。 否則，物件圖形可能會不完整，，並不適用於大部分的平台案例。  
  
 <xref:System.Xaml.XamlObjectWriter.Result%2A> 如果在呼叫之後立即呼叫通常只包含非 null 值<xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A>，而且目前的範圍位於其中的物件會提供值的成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootNameScope">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.INameScope RootNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.INameScope RootNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RootNameScope As INameScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::INameScope ^ RootNameScope { System::Windows::Markup::INameScope ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RootNameScope : System.Windows.Markup.INameScope" Usage="System.Xaml.XamlObjectWriter.RootNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.INameScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Windows.Markup.INameScope" /> 服務，這個服務會維護 XAML 物件寫入器之絕對節點根的 XAML 名稱範圍。</summary>
        <value><see cref="T:System.Windows.Markup.INameScope" /> 服務，這個服務會維護物件寫入器目前根的 XAML 名稱範圍。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的值可能來自物件寫入器內容。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public override System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlObjectWriter.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得作用中 XAML 結構描述內容。</summary>
        <value>XAML 結構描述內容。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XAML 結構描述內容是最實用的物件撰寫案例所需的資訊來源。 XAML 結構描述內容會影響備份類型的型別對應，並保留支援型別所在的組件的相關資訊。 預設 XAML 結構描述內容為基礎 CLR 型別對應規則。 架構通常會提供自己的 XAML 結構描述內容，以確保組件載入機制相符架構的程式設計 amd 應用程式模型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLineInfo">
      <MemberSignature Language="C#" Value="public void SetLineInfo (int lineNumber, int linePosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLineInfo(int32 lineNumber, int32 linePosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.SetLineInfo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetLineInfo (lineNumber As Integer, linePosition As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetLineInfo(int lineNumber, int linePosition);" />
      <MemberSignature Language="F#" Value="abstract member SetLineInfo : int * int -&gt; unit&#xA;override this.SetLineInfo : int * int -&gt; unit" Usage="xamlObjectWriter.SetLineInfo (lineNumber, linePosition)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lineNumber" Type="System.Int32" />
        <Parameter Name="linePosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="lineNumber">來自讀取器的行號。</param>
        <param name="linePosition">來自讀取器的行位置。</param>
        <summary>實作 <see cref="M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)" />，並提供例外狀況的行資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此服務方法的目的不是直接從您的程式碼呼叫。 不過，如果您要建立從衍生的類別<xref:System.Xaml.XamlObjectWriter>並預期要報告的內容位置的行號是無法使用或不實用，這個方法可能會被呼叫。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldProvideLineInfo">
      <MemberSignature Language="C#" Value="public bool ShouldProvideLineInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldProvideLineInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.ShouldProvideLineInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShouldProvideLineInfo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldProvideLineInfo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShouldProvideLineInfo : bool" Usage="System.Xaml.XamlObjectWriter.ShouldProvideLineInfo" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xaml.IXamlLineInfoConsumer.ShouldProvideLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值會報告行資訊服務是否應該提供值 (因此也應該在必要時呼叫 <see cref="M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)" /> 方法)。</summary>
        <value>如果寫入器會使用行資訊，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個實作一律會傳回 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEndMember">
      <MemberSignature Language="C#" Value="public override void WriteEndMember ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteEndMember" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndMember ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndMember();" />
      <MemberSignature Language="F#" Value="override this.WriteEndMember : unit -&gt; unit" Usage="xamlObjectWriter.WriteEndMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉目前成員範圍，並且可能在關閉成員範圍期間寫入其值。 新的範圍會成為成員的父物件範圍。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">無法從在這次呼叫和前一次 <see langword="StartMember" /> 之間遇到的值節點建立成員值。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndObject">
      <MemberSignature Language="C#" Value="public override void WriteEndObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteEndObject" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndObject ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndObject();" />
      <MemberSignature Language="F#" Value="override this.WriteEndObject : unit -&gt; unit" Usage="xamlObjectWriter.WriteEndObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉寫入器中的目前物件範圍。 新的物件範圍會成為父成員範圍。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個`EndObject`位置範圍關閉的根物件，新的物件範圍會成為根範圍。  
  
 若要呼叫<xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>可能尚未建立物件因為該物件成員可能需要的初始化路徑，例如初始設定文字或初始化參數。 在這些情況下，呼叫<xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A>實際寫入的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteGetObject">
      <MemberSignature Language="C#" Value="public override void WriteGetObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteGetObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteGetObject" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteGetObject ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteGetObject();" />
      <MemberSignature Language="F#" Value="override this.WriteGetObject : unit -&gt; unit" Usage="xamlObjectWriter.WriteGetObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>當指定之物件為父屬性的預設值或隱含值時，將概念 <see langword="StartObject" /> 寫入物件圖形。 隱含值來自從 XAML 結構描述內容及支援型別資訊取得的資訊，而非指定為在輸入 XAML 節點集中的物件值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 撰寫之間的差異<xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A>和寫入與<xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>產生的物件圖形中可以看到。 <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A> 不會建構類型的執行個體，因為<xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A>API 有任何的資訊來通知功能建構的物件圖形。 初始化 parent 屬性; 時，相反地，建立物件因此<xref:System.Xaml.XamlObjectWriter>不需要建構它。 相反地，<xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>指定應建構該類型的執行個體，而插入的物件圖形。  
  
 如果您將 XAML 節點資料流視為一系列的框架<xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A>平衡傳輸至<xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A>呼叫。 因此，數目<xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A>加上<xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>呼叫的數目應該相等<xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A>呼叫做為 XAML 節點資料流的完整物件撰寫評估的一部分。  
  
 概念`StartObject`放置隱含的物件，物件圖形中為必要，因為雖然本身的物件值是隱含的預設值，該物件可能仍有需要可寫入基礎 XAML 節點資料流的成員。 典型的案例，這種情況是當<xref:System.Xaml.XamlObjectWriter>寫入成員節點的集合屬性，以及集合初始設定是隱含建立擁有集合屬性的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteNamespace">
      <MemberSignature Language="C#" Value="public override void WriteNamespace (System.Xaml.NamespaceDeclaration namespaceDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteNamespace(class System.Xaml.NamespaceDeclaration namespaceDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteNamespace(System.Xaml.NamespaceDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteNamespace(System::Xaml::NamespaceDeclaration ^ namespaceDeclaration);" />
      <MemberSignature Language="F#" Value="override this.WriteNamespace : System.Xaml.NamespaceDeclaration -&gt; unit" Usage="xamlObjectWriter.WriteNamespace namespaceDeclaration" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceDeclaration" Type="System.Xaml.NamespaceDeclaration" />
      </Parameters>
      <Docs>
        <param name="namespaceDeclaration">要寫入的命名空間宣告。</param>
        <summary>定義會套用至下一個物件範圍或成員範圍的命名空間宣告。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前的範圍是根範圍，物件範圍或成員範圍可寫入的命名空間宣告。 不過， <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A> lze volat pouze 之前呼叫下列其中之一： <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A>， <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>，或<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A>。 連續<xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A>案例是以相同的節點中寫入多個命名空間宣告。 最後，請<xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>或<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A>必須呼叫。  
  
 <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A> 不會使用`Start` / `End`比喻。 雖然 XAML 命名空間具有 CLR 中代表意義的成員，成員已知，且不需要表示為一種特殊型別的<xref:System.Xaml.XamlMember>擴充性。 若要存取的值<xref:System.Xaml.NamespaceDeclaration>，您存取其<xref:System.Xaml.NamespaceDeclaration.Namespace%2A>和<xref:System.Xaml.NamespaceDeclaration.Prefix%2A>屬性。  
  
 命名空間宣告可能<xref:System.String.Empty?displayProperty=nameWithType>前置詞的值。 A<xref:System.String.Empty?displayProperty=nameWithType>前置詞表示的預設 XAML 命名空間宣告。 請勿嘗試使用 null 來代表預設前置詞; 此 API 中擲回例外狀況。 如需詳細資訊，請參閱<xref:System.Xaml.NamespaceDeclaration>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="namespaceDeclaration" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="namespaceDeclaration" /> 的元件為 <see langword="null" />。</exception>
        <exception cref="T:System.Xaml.XamlObjectReaderException">嘗試在無效的範圍中寫入 XAML 命名空間節點。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartMember">
      <MemberSignature Language="C#" Value="public override void WriteStartMember (System.Xaml.XamlMember property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartMember(class System.Xaml.XamlMember property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteStartMember(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartMember (property As XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartMember(System::Xaml::XamlMember ^ property);" />
      <MemberSignature Language="F#" Value="override this.WriteStartMember : System.Xaml.XamlMember -&gt; unit" Usage="xamlObjectWriter.WriteStartMember property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="property">要寫入的 XAML 屬性。 您通常會從 XAML 讀取器透過 XAML 節點資料流媒介取得這個值。</param>
        <summary>將新的成員節點寫入至目前物件範圍，而這個範圍會成為新的成員範圍。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  監看<xref:System.Xaml.XamlDuplicateMemberException>，就會出現兩次會在輸入 XAML 中設定相同的 XAML 屬性時。 在簡單的情況下，例如當相同的屬性設定在屬性語法和屬性項目語法，您可以輕鬆地看到這個輸入標記中的例外狀況。 不過，多個難以察覺的情況下，可能會發生更難以找出。 例如，如果您將 XAML 內容屬性，如果涉及 XAML 的環境屬性，而且如果屬性可讓可附加的使用量和執行個體使用量可能會發生這個例外狀況。 開發的偵錯的階段，在中，您通常可以藉由檢視連接讀取的標記和物件圖形寫入中繼 XAML 節點表示，以尋找這個例外狀況。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException"><paramref name="property" /> 的 <see cref="P:System.Xaml.XamlMember.IsUnknown" /> 已設定為 <see langword="true" />。  
  
-或- 
 傳遞 <see cref="P:System.Xaml.XamlLanguage.UnknownContent" />，表示不支援內容之物件內容所包含的 XAML 節點資料流。  
  
-或- 
嘗試在無效的範圍中寫入開始成員。</exception>
        <exception cref="T:System.Xaml.XamlDuplicateMemberException"><paramref name="property" /> 會指定已經在父代物件範圍中明確設定的屬性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="property" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public override void WriteStartObject (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartObject(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteStartObject(System.Xaml.XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartObject(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="override this.WriteStartObject : System.Xaml.XamlType -&gt; unit" Usage="xamlObjectWriter.WriteStartObject xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">要寫入的型別。 您通常是從 XAML 讀取器取得這個值。</param>
        <summary>將物件節點寫入至目前範圍，並將這個範圍設為新的物件範圍。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">正在處理 <see cref="P:System.Xaml.XamlType.IsUnknown" /> 型別，而且無法建立物件。  
  
-或- 
嘗試在無效的範圍中寫入一個開始物件。</exception>
        <exception cref="T:System.Xaml.XamlParseException">嘗試於已經在設定中提供根物件時寫入根物件。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlType" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="overrides"><para>如果目前的範圍內的集合、 字典或陣列中，新的執行個體應該將集合、 字典或陣列使用<see langword="Add" />相關類型的方法。 否則，成員應該指派給新的執行個體。</para></block>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public override void WriteValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteValue (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.WriteValue : obj -&gt; unit" Usage="xamlObjectWriter.WriteValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要寫入的值。</param>
        <summary>將值寫入至目前成員範圍。 如果目前範圍在集合、字典或陣列物件內，則應將此值加入至集合、字典或陣列。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">嘗試在無效的範圍中寫入值。</exception>
      </Docs>
    </Member>
  </Members>
</Type>