<Type Name="XamlObjectWriter" FullName="System.Xaml.XamlObjectWriter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ca402de94a9fb4c2404a3eb885b3a1fc9d0fc4b6" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-TW" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30721012" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlObjectWriter : System.Xaml.XamlWriter, System.Xaml.IXamlLineInfoConsumer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlObjectWriter extends System.Xaml.XamlWriter implements class System.Xaml.IXamlLineInfoConsumer" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlObjectWriter" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlObjectWriter&#xA;Inherits XamlWriter&#xA;Implements IXamlLineInfoConsumer" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlObjectWriter : System::Xaml::XamlWriter, System::Xaml::IXamlLineInfoConsumer" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xaml.XamlWriter</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xaml.IXamlLineInfoConsumer</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>從來源 XAML 節點資料流建立物件圖形。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`方法<xref:System.Xaml.XamlObjectWriter>實作模式，讓<xref:System.Xaml.XamlObjectWriter>使用<xref:System.Xaml.XamlWriter>所定義的<xref:System.Xaml.XamlWriter.WriteNode%2A>方法。 <xref:System.Xaml.XamlWriter.WriteNode%2A> 邏輯交換器之間`Write`方法，根據哪個節點型別是讀取器中目前的位置。  
  
## <a name="scope"></a>範圍  
 A<xref:System.Xaml.XamlObjectWriter>範圍; 的概念、<xref:System.Xaml.XamlObjectWriter>維護概念的其輸出的物件圖形中的參考點。 針對特定範圍，某些作業可能會有效或無效，或產生無作業的結果。 例如，如果您呼叫<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A>物件上的初始化已存在做為執行個體，請撰寫指示詞的預設實作會擲回例外狀況。  
  
 追蹤中自訂的範圍可能技巧<xref:System.Xaml.XamlObjectWriter>是對齊堆疊或框架的類別使用的節點動作。 框架的堆疊可以追蹤的 push 和 pop 每個層級的物件模型的深度，進入或離開時<xref:System.Xaml.XamlObjectWriter>寫入物件圖形。  
  
## <a name="callbacks"></a>回呼  
 若要支援中繼和進階<xref:System.Xaml.XamlObjectWriter>案例中，撰寫物件圖形的機制提供回呼發生的進入點時<xref:System.Xaml.XamlObjectWriter>認可或即將認可某些動作。 某些回呼會在設定中啟用和並非所特有物件類型或成員正在寫入;不過，回呼資訊通常是在內容中使用，或者是在事件會透過回呼傳送的資料。 下列是一份相關回呼：  
  
-   由宣告回呼<xref:System.Xaml.XamlObjectWriterSettings.AfterBeginInitHandler%2A>時範圍會移入新的物件，並在叫用<xref:System.ComponentModel.ISupportInitialize.BeginInit%2A>階段建立的每個物件的物件存留期。  
  
-   由宣告回呼<xref:System.Xaml.XamlObjectWriterSettings.AfterEndInitHandler%2A>時範圍會移入新的物件，並在叫用<xref:System.ComponentModel.ISupportInitialize.EndInit%2A>階段建立的每個物件的物件存留期。  
  
-   由宣告回呼<xref:System.Xaml.XamlObjectWriterSettings.BeforePropertiesHandler%2A>範圍物件，一開始，而發生時叫用時第一個<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A>呼叫該物件範圍時進行，但尚未認可。  
  
-   由宣告回呼<xref:System.Xaml.XamlObjectWriterSettings.AfterPropertiesHandler%2A>範圍物件，一開始，而發生時叫用時<xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A>呼叫該物件範圍時進行，但尚未認可。  
  
-   由宣告回呼<xref:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler%2A>時叫用<xref:System.Xaml.XamlObjectWriter.OnSetValue%2A>呼叫。  
  
## <a name="writing-dictionary-keys"></a>手寫字典索引鍵  
 預設實作<xref:System.Xaml.XamlObjectWriter>支援類型轉換的條件約束<xref:System.Collections.Generic.Dictionary%602>之前字典內容加入物件圖形。 如此一來，在泛型字典可以在執行階段物件索引鍵，而且符合相關的一般`Add`和索引子的行為。 不過，做為基底實作<xref:System.Xaml.XamlObjectWriter>，這項功能只存在於物件圖形建立基底<xref:System.Collections.Generic.Dictionary%602>類別，衍生的類別不能用於<xref:System.Collections.Generic.Dictionary%602>。  
  
## <a name="checks-for-disposed"></a>檢查有無處置  
 XAML 寫入器可能會用來延後的作業，或針對在過渡期中已處置的 XAML 寫入器執行個體進行呼叫的位置。 各種 Api<xref:System.Xaml.XamlObjectWriter>可能會擲回<xref:System.ObjectDisposedException>在這些情況下。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlWriter" />
    <altmember cref="T:System.Xaml.XamlObjectReader" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Xaml.XamlObjectWriter" /> 類別的新執行個體。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlObjectWriter (System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.#ctor(System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlObjectWriter(System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="schemaContext">與提供寫入之節點的 XAML 讀取器共用的 XAML 結構描述內容。</param>
        <summary>使用 <see cref="T:System.Xaml.XamlObjectWriter" /> 所使用的 XAML 結構描述內容，初始化 <see cref="T:System.Xaml.XamlReader" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="schemaContext" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlObjectWriter (System.Xaml.XamlSchemaContext schemaContext, System.Xaml.XamlObjectWriterSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.XamlObjectWriterSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.#ctor(System.Xaml.XamlSchemaContext,System.Xaml.XamlObjectWriterSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (schemaContext As XamlSchemaContext, settings As XamlObjectWriterSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlObjectWriter(System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::XamlObjectWriterSettings ^ settings);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="settings" Type="System.Xaml.XamlObjectWriterSettings" />
      </Parameters>
      <Docs>
        <param name="schemaContext">與提供寫入之節點的 XAML 讀取器共用的 XAML 結構描述內容。</param>
        <param name="settings">指定 <see cref="T:System.Xaml.XamlObjectWriter" /> 行為和輸出之特定選項的設定物件。</param>
        <summary>使用 <see cref="T:System.Xaml.XamlObjectWriter" /> 所使用的內容和其設定，初始化 <see cref="T:System.Xaml.XamlReader" /> 類別的新執行個體。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="schemaContext" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重設所有可能的框架並清除物件圖形。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> 表示釋放 Managed 資源，否則為 <see langword="false" />。</param>
        <summary>釋放 <see cref="T:System.Xaml.XamlObjectWriter" /> 所使用的 Unmanaged 資源，並選擇性釋放 Managed 資源。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterBeginInit">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterBeginInit (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterBeginInit(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterBeginInit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterBeginInit (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterBeginInit(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要報告的物件。 叫用處理常式時，會將物件封裝至 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 中。</param>
        <summary>叫用與這個 <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterBeginInitHandler" /> 之 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 相關聯的任何 <see cref="T:System.Xaml.XamlObjectWriter" /> 方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterEndInit">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterEndInit (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterEndInit(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterEndInit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterEndInit (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterEndInit(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要報告的物件。 叫用處理常式時，值會封裝至 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 中。</param>
        <summary>叫用與這個 <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterEndInitHandler" /> 之 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 相關聯的任何 <see cref="T:System.Xaml.XamlObjectWriter" /> 方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterProperties">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterProperties (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterProperties(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnAfterProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAfterProperties (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAfterProperties(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要報告的物件。 會在叫用處理常式將其封裝至 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 中。</param>
        <summary>叫用與這個 <see cref="P:System.Xaml.XamlObjectWriterSettings.AfterPropertiesHandler" /> 之 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 相關聯的任何 <see cref="T:System.Xaml.XamlObjectWriter" /> 參考方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeforeProperties">
      <MemberSignature Language="C#" Value="protected virtual void OnBeforeProperties (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeforeProperties(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnBeforeProperties(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBeforeProperties (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBeforeProperties(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">在叫用處理常式時要透過 <see cref="T:System.Xaml.XamlObjectEventArgs" /> 傳遞的值。</param>
        <summary>叫用與這個 <see cref="P:System.Xaml.XamlObjectWriterSettings.BeforePropertiesHandler" /> 之 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 相關聯的任何 <see cref="T:System.Xaml.XamlObjectWriter" /> 參考方法。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSetValue">
      <MemberSignature Language="C#" Value="protected virtual bool OnSetValue (object eventSender, System.Xaml.XamlMember member, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnSetValue(object eventSender, class System.Xaml.XamlMember member, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.OnSetValue(System.Object,System.Xaml.XamlMember,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnSetValue (eventSender As Object, member As XamlMember, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnSetValue(System::Object ^ eventSender, System::Xaml::XamlMember ^ member, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSender" Type="System.Object" />
        <Parameter Name="member" Type="System.Xaml.XamlMember" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="eventSender">要向處理常式報告做為來源的物件。</param>
        <param name="member">要設定之屬性的名稱，這個名稱會在 <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" /> 中傳遞至處理常式。</param>
        <param name="value">要提供給由 <c>property</c> 命名之屬性的值。 這個值會在 <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" /> 中傳遞至處理常式。</param>
        <summary>叫用與這個寫入器之 <see cref="P:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler" /> 相關聯的任何 <see cref="T:System.Xaml.XamlObjectWriterSettings" /> 參考方法 (只要 <see cref="T:System.Windows.Markup.XamlSetValueEventArgs" /> 事件資料中的 <paramref name="handled" /> 不是 <see langword="true" /> 即可)。</summary>
        <returns>任何相關聯處理常式所設定的布林值，否則為 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`SetValue`此 XAML 寫入器的作業有關聯的處理常式 (<xref:System.Xaml.XamlObjectWriterSettings.XamlSetValueHandler%2A>中宣告<xref:System.Xaml.XamlObjectWriterSettings>)，這個方法建立新<xref:System.Windows.Markup.XamlSetValueEventArgs>並將其傳遞至處理常式。 傳回的值由讀取設定<xref:System.Windows.Markup.XamlSetValueEventArgs.Handled%2A>事件資料會傳遞的值。 如果處理常式不存在，而且這個方法會叫用，則呼叫會傳回`false`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public virtual object Result { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Result" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.Result" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Result As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ Result { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得最後一個寫入的物件。 通常只有在節點資料流位在結尾且物件圖形完成時才會加以呼叫。</summary>
        <value>最後一個寫入的物件，或 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最常見的使用方式的<xref:System.Xaml.XamlObjectWriter.Result%2A>是只有在節點資料流是否已知為其結尾，且已完成的物件圖形呼叫它。 否則，物件圖形可能會不完整，並不是適用於大部分平台案例。  
  
 <xref:System.Xaml.XamlObjectWriter.Result%2A> 如果呼叫之後立即呼叫通常只包含非 null 值<xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A>，而且如果目前的範圍是處於其中的物件會提供值的成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootNameScope">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.INameScope RootNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.INameScope RootNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RootNameScope As INameScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::INameScope ^ RootNameScope { System::Windows::Markup::INameScope ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.INameScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得 <see cref="T:System.Windows.Markup.INameScope" /> 服務，這個服務會維護 XAML 物件寫入器之絕對節點根的 XAML 名稱範圍。</summary>
        <value>
          <see cref="T:System.Windows.Markup.INameScope" /> 服務，這個服務會維護物件寫入器目前根的 XAML 名稱範圍。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個屬性的值可能來自物件寫入器內容。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public override System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得作用中 XAML 結構描述內容。</summary>
        <value>XAML 結構描述內容。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XAML 結構描述內容是最實用的物件撰寫案例所需的資訊來源。 XAML 結構描述內容影響的備份類型的型別查閱，並保留其中備份類型，存在於組件的相關資訊。 預設 XAML 結構描述內容為基礎 CLR 型別對應規則。 通常，架構會提供自己的 XAML 結構描述內容以確保組件載入機制符合架構的程式設計 amd 應用程式模型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetLineInfo">
      <MemberSignature Language="C#" Value="public void SetLineInfo (int lineNumber, int linePosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLineInfo(int32 lineNumber, int32 linePosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.SetLineInfo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetLineInfo (lineNumber As Integer, linePosition As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetLineInfo(int lineNumber, int linePosition);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lineNumber" Type="System.Int32" />
        <Parameter Name="linePosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="lineNumber">來自讀取器的行號。</param>
        <param name="linePosition">來自讀取器的行位置。</param>
        <summary>實作 <see cref="M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)" />，並提供例外狀況的行資訊。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此服務方法不是直接從您的程式碼呼叫。 不過，如果您要建立衍生的類別從<xref:System.Xaml.XamlObjectWriter>並預期要報告的內容位置的行號會無法使用或不實用，這個方法可能會呼叫。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldProvideLineInfo">
      <MemberSignature Language="C#" Value="public bool ShouldProvideLineInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldProvideLineInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlObjectWriter.ShouldProvideLineInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShouldProvideLineInfo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldProvideLineInfo { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xaml.IXamlLineInfoConsumer.ShouldProvideLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得值，這個值會報告行資訊服務是否應該提供值 (因此也應該在必要時呼叫 <see cref="M:System.Xaml.IXamlLineInfoConsumer.SetLineInfo(System.Int32,System.Int32)" /> 方法)。</summary>
        <value>
          如果寫入器會使用行資訊，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個實作永遠會傳回 `true`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteEndMember">
      <MemberSignature Language="C#" Value="public override void WriteEndMember ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteEndMember" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndMember ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndMember();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉目前成員範圍，並且可能在關閉成員範圍期間寫入其值。 新的範圍會成為成員的父物件範圍。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">無法從在這次呼叫和前一次 <see langword="StartMember" /> 之間遇到的值節點建立成員值。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEndObject">
      <MemberSignature Language="C#" Value="public override void WriteEndObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteEndObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteEndObject" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteEndObject ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteEndObject();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>關閉寫入器中的目前物件範圍。 新的物件範圍會成為父成員範圍。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果這個`EndObject`位置範圍關閉的根物件，新的物件範圍會成為根範圍。  
  
 若要呼叫<xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>可能尚未建立物件由於該物件成員可能是必要的初始化路徑，例如初始文字或初始化參數。 這些情況下，呼叫<xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A>實際寫入的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteGetObject">
      <MemberSignature Language="C#" Value="public override void WriteGetObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteGetObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteGetObject" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteGetObject ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteGetObject();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>當指定之物件為父屬性的預設值或隱含值時，將概念 <see langword="StartObject" /> 寫入物件圖形。 隱含值來自從 XAML 結構描述內容及支援型別資訊取得的資訊，而非指定為在輸入 XAML 節點集中的物件值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 與寫入之間的差異<xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A>和寫入與<xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>結果物件圖形中可以看到。 <xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A> 將不會建構類型的執行個體因為<xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A>應用程式開發介面有任何資訊來通知所要建構的物件圖形。 初始化 parent 屬性; 時，相反地，建立物件因此<xref:System.Xaml.XamlObjectWriter>不必建構它。 相反地，<xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>指定應該建構該類型的執行個體，並插入的物件圖形。  
  
 如果您將一系列的框架，視為 XAML 節點資料流<xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A>平衡轉送到<xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A>呼叫。 因此，數目<xref:System.Xaml.XamlObjectWriter.WriteGetObject%2A>加上<xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>呼叫應該會等於數目<xref:System.Xaml.XamlObjectWriter.WriteEndObject%2A>呼叫做為 XAML 節點資料流的完整物件寫入評估的一部分。  
  
 將概念`StartObject`位置物件圖形中的隱含物件是必要的因為雖然本身的物件值的隱含預設值，該物件仍可能需要寫入可根據 XAML 節點資料流的成員。 典型的案例，這種情況是當<xref:System.Xaml.XamlObjectWriter>寫入成員節點的集合屬性，以及集合初始設定是隱含建立擁有集合屬性的物件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteNamespace">
      <MemberSignature Language="C#" Value="public override void WriteNamespace (System.Xaml.NamespaceDeclaration namespaceDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteNamespace(class System.Xaml.NamespaceDeclaration namespaceDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteNamespace(System.Xaml.NamespaceDeclaration)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteNamespace(System::Xaml::NamespaceDeclaration ^ namespaceDeclaration);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceDeclaration" Type="System.Xaml.NamespaceDeclaration" />
      </Parameters>
      <Docs>
        <param name="namespaceDeclaration">要寫入的命名空間宣告。</param>
        <summary>定義會套用至下一個物件範圍或成員範圍的命名空間宣告。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果目前的範圍是根範圍、 物件範圍或成員範圍可以寫入命名空間宣告。 不過，<xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A>只能呼叫之前呼叫下列其中之一： <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A>， <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>，或<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A>。 連續<xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A>案例是撰寫多個命名空間宣告相同的節點。 最後，請<xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A>或<xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A>必須呼叫。  
  
 <xref:System.Xaml.XamlObjectWriter.WriteNamespace%2A> 不會使用`Start` / `End`比喻。 雖然 XAML 命名空間中的 CLR 表示意義成員，成員為已知，而且不需要表示為一種特殊型別的<xref:System.Xaml.XamlMember>擴充性。 若要存取的值<xref:System.Xaml.NamespaceDeclaration>，您存取其<xref:System.Xaml.NamespaceDeclaration.Namespace%2A>和<xref:System.Xaml.NamespaceDeclaration.Prefix%2A>屬性。  
  
 命名空間宣告可能<xref:System.String.Empty?displayProperty=nameWithType>前置詞的值。 A<xref:System.String.Empty?displayProperty=nameWithType>前置詞表示的預設 XAML 命名空間宣告。 請勿嘗試使用 null 來代表預設前置詞。 這個 API 中擲回例外狀況。 如需詳細資訊，請參閱<xref:System.Xaml.NamespaceDeclaration>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="namespaceDeclaration" /> 為 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="namespaceDeclaration" /> 的元件為 <see langword="null" />。</exception>
        <exception cref="T:System.Xaml.XamlObjectReaderException">嘗試在無效的範圍中寫入 XAML 命名空間節點。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartMember">
      <MemberSignature Language="C#" Value="public override void WriteStartMember (System.Xaml.XamlMember property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartMember(class System.Xaml.XamlMember property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteStartMember(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteStartMember (property As XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartMember(System::Xaml::XamlMember ^ property);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="property">要寫入的 XAML 屬性。 您通常會從 XAML 讀取器透過 XAML 節點資料流媒介取得這個值。</param>
        <summary>將新的成員節點寫入至目前物件範圍，而這個範圍會成為新的成員範圍。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  監看<xref:System.Xaml.XamlDuplicateMemberException>，它發生於兩次輸入 XAML 中設定相同的 XAML 屬性。 在簡單的情況下，例如當相同的屬性設定的屬性語法和屬性項目語法，您可以輕鬆地查看此輸入標記中的例外狀況。 不過，多個難以察覺的情況下，可能會發生更難以找出。 例如，如果您將 XAML 內容屬性，如果涉及 XAML 環境的屬性，且如果屬性可讓可附加的使用量和執行個體使用，可能會發生這個例外狀況。 在偵錯開發階段，您通常可以找到此例外狀況檢視讀取的標記和物件圖形寫入連接 XAML 中繼節點表示。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">
          <paramref name="property" /> 的 <see cref="P:System.Xaml.XamlMember.IsUnknown" /> 已設定為 <see langword="true" />。  
  
 -或-  
  
 傳遞 <see cref="P:System.Xaml.XamlLanguage.UnknownContent" />，表示不支援內容之物件內容所包含的 XAML 節點資料流。  
  
 -或-  
  
 嘗試在無效的範圍中寫入開始成員。</exception>
        <exception cref="T:System.Xaml.XamlDuplicateMemberException">
          <paramref name="property" /> 會指定已經在父代物件範圍中明確設定的屬性。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="property" /> 為 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteStartObject">
      <MemberSignature Language="C#" Value="public override void WriteStartObject (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteStartObject(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteStartObject(System.Xaml.XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteStartObject(System::Xaml::XamlType ^ xamlType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">要寫入的型別。 您通常是從 XAML 讀取器取得這個值。</param>
        <summary>將物件節點寫入至目前範圍，並將這個範圍設為新的物件範圍。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">正在處理 <see cref="P:System.Xaml.XamlType.IsUnknown" /> 型別，而且無法建立物件。  
  
 -或-  
  
 嘗試在無效的範圍中寫入一個開始物件。</exception>
        <exception cref="T:System.Xaml.XamlParseException">嘗試於已經在設定中提供根物件時寫入根物件。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xamlType" /> 為 <see langword="null" />。</exception>
        <block subset="none" type="overrides">
          <para>如果目前的範圍內的集合、 字典或陣列，新的執行個體應該加入至集合、 字典或陣列使用<see langword="Add" />相關類型的方法。 否則，成員應該指派到的新執行個體。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WriteValue">
      <MemberSignature Language="C#" Value="public override void WriteValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlObjectWriter.WriteValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteValue (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteValue(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要寫入的值。</param>
        <summary>將值寫入至目前成員範圍。 如果目前範圍在集合、字典或陣列物件內，則應將此值加入至集合、字典或陣列。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Xaml.XamlObjectWriterException">嘗試在無效的範圍中寫入值。</exception>
      </Docs>
    </Member>
  </Members>
</Type>