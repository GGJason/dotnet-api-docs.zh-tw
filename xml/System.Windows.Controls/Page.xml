<Type Name="Page" FullName="System.Windows.Controls.Page">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4917cb83354477917d223c2e3124c4aa111778f3" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-TW" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55361477" /></Metadata><TypeSignature Language="C#" Value="public class Page : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits FrameworkElement&#xA;Implements IAddChild" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Windows::FrameworkElement, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type Page = class&#xA;    inherit FrameworkElement&#xA;    interface IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Content")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>封裝 Windows Internet Explorer、<see cref="T:System.Windows.Navigation.NavigationWindow" /> 和 <see cref="T:System.Windows.Controls.Frame" /> 可巡覽及裝載的一頁內容。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page> 會封裝一頁，可以瀏覽，並具有下列索引鍵成員的內容：  
  
-   **生命週期管理**: <xref:System.Windows.Controls.Page.KeepAlive%2A>。  
  
-   **瀏覽**: <xref:System.Windows.Controls.Page.NavigationService%2A>。  
  
-   **外觀**: <xref:System.Windows.Controls.Page.Background%2A>， <xref:System.Windows.Controls.Page.Content%2A>， <xref:System.Windows.Controls.Page.FontFamily%2A>， <xref:System.Windows.Controls.Page.FontSize%2A>， <xref:System.Windows.Controls.Page.Foreground%2A>， <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>， <xref:System.Windows.Controls.Page.Template%2A>， <xref:System.Windows.Controls.Page.Title%2A>。  
  
-   **主控視窗外觀**: <xref:System.Windows.Controls.Page.WindowHeight%2A>， <xref:System.Windows.Controls.Page.WindowWidth%2A>， <xref:System.Windows.Controls.Page.WindowTitle%2A>。  
  
 可以使用標記、 標記和程式碼後置或程式碼定義 頁面。 頁面會是封裝內容以供巡覽，較好的方法，原因如下：  
  
-   它是定義、 重複使用，以及管理變得更加容易。  
  
-   它可以存取和使用<xref:System.Windows.Navigation.NavigationService>，導覽到它。  
  
-   它可以改變標題、 寬度、 高度和瀏覽[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]其主視窗 (<xref:System.Windows.Controls.Page.WindowTitle%2A>， <xref:System.Windows.Controls.Page.WindowWidth%2A>， <xref:System.Windows.Controls.Page.WindowHeight%2A>， <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>)。  
  
-   它有設計工具支援[!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)]。  
  
 可以與裝載網頁<xref:System.Windows.Window>， <xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>，或從瀏覽器。 若要裝載，頁面可以是：  
  
-   直接子系<xref:System.Windows.Window>， <xref:System.Windows.Navigation.NavigationWindow>，或<xref:System.Windows.Controls.Frame>中的項目[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]。  
  
-   具現化，並將設定的值為`Content`的屬性<xref:System.Windows.Window>， <xref:System.Windows.Navigation.NavigationWindow>，和<xref:System.Windows.Controls.Frame>。  
  
-   設定為[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]根源`Source`property<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>。  
  
-   設定為<xref:System.Windows.Application.StartupUri%2A>獨立應用程式。  
  
-   設定為<xref:System.Windows.Application.StartupUri%2A>在[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]。  
  
 應用程式通常會有兩個或多個頁面，可以使用下列機制之間巡覽：  
  
-   以宣告方式是藉由使用<xref:System.Windows.Documents.Hyperlink>。  
  
-   以程式設計方式使用<xref:System.Windows.Navigation.NavigationService>。  
  
-   以視覺化方式是藉由使用 瀏覽[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]主控件，包括[!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]， <xref:System.Windows.Navigation.NavigationWindow>，和<xref:System.Windows.Controls.Frame>。  
  
 使用頁面函式的結構化巡覽 (<xref:System.Windows.Navigation.PageFunction%601>)，請參閱 <<c2> [ 結構化巡覽概觀](~/docs/framework/wpf/app-development/structured-navigation-overview.md)並[巡覽拓撲概觀](~/docs/framework/wpf/app-development/navigation-topologies-overview.md)。  
  
 此控制項的相依性屬性可能會設定控制項的預設樣式。  如果屬性設定為預設樣式，屬性可能會變更其預設值，當控制項出現在應用程式。 預設樣式會決定由哪一個桌面佈景主題時，會使用應用程式正在執行。  如需詳細資訊，請參閱 <<c0> [ 預設 WPF 佈景主題](https://go.microsoft.com/fwlink/?LinkID=158252)。  
  
   
  
## Examples  
 下列範例顯示如何在標準頁面上定義 只使用標記：  
  
 [!code-xaml[PageSnippets#MarkupPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupPage.xaml#markuppagemarkup)]  
  
 下列範例示範如何使用定義在標準頁面上只有程式碼：  
  
 [!code-csharp[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/CodePage.cs#codepagecodebehind)]
 [!code-vb[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/codepage.vb#codepagecodebehind)]  
  
 下列範例示範的標準網頁的方式使用標記和程式碼後置的組合所定義。  
  
 [!code-xaml[PageSnippets#MarkupAndCodeBehindPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml#markupandcodebehindpagemarkup)]  
  
 [!code-csharp[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml.cs#markupandcodebehindpagecodebehind)]
 [!code-vb[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/markupandcodebehindpage.xaml.vb#markupandcodebehindpagecodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Navigation.PageFunction`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Windows.Controls.Page" /> 類別的新執行個體。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.Windows.Controls.Page>不在保持運作 (請參閱 < <xref:System.Windows.Controls.Page.KeepAlive%2A>)，它必須實作的預設建構函式，以允許[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]建立時在上一步瀏覽至的新執行個體，或巡覽歷程記錄。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="page.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">要用來排列子項目的大小。</param>
        <summary>排列 <see cref="T:System.Windows.Controls.Page" /> 的內容 (子項目)。</summary>
        <returns><see cref="T:System.Windows.Size" />，表示頁面的排列大小。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Background : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.Page.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Controls.Page" /> 的背景。</summary>
        <value><see cref="T:System.Windows.Media.Brush" /> 用來繪製其背景的 <see cref="T:System.Windows.Controls.Page" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageBackground"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Controls.Page.BackgroundProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、 <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BackgroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Controls.Page.Background" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Controls.Page.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Controls.Page" /> 的內容。</summary>
        <value>包含 <see cref="T:System.Windows.Controls.Page" /> 之內容的物件。 預設為 <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Controls.Page>可以有單一子元素。 上的所有其他元素<xref:System.Windows.Controls.Page>必須是該元素的下階。 一般而言，內容<xref:System.Windows.Controls.Page>這類裝載的版面配置項目- <xref:System.Windows.Controls.Grid>， <xref:System.Windows.Controls.StackPanel>，以及<xref:System.Windows.Controls.DockPanel>-裝載的內容<xref:System.Windows.Controls.Page>。  
  
<a name="dependencyPropertyInfo_PageContent"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Controls.Page.ContentProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.ContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Controls.Page.Content" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FontFamily : System.Windows.Media.FontFamily with get, set" Usage="System.Windows.Controls.Page.FontFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定所指定之字型系列的名稱。</summary>
        <value><see cref="T:System.Windows.Media.FontFamily" />，它是 <see cref="T:System.Windows.Controls.Page" /> 內容的字型系列。 預設為 <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageFontFamily"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Controls.Page.FontFamilyProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontFamilyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Controls.Page.FontFamily" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.FontFamily%2A> 相依性屬性的識別項。  
  
   
  
## Examples  
 [相依性屬性概觀](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.FontSize : double with get, set" Usage="System.Windows.Controls.Page.FontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定字型大小。</summary>
        <value><see cref="T:System.Windows.Controls.Page" /> 內容的字型大小。 預設為 <see cref="P:System.Windows.SystemFonts.MessageFontSize" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字型大小必須是正號和範圍內的<xref:System.Windows.SystemFonts.MessageFontSize%2A>。  
  
<a name="dependencyPropertyInfo_PageFontSize"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Controls.Page.FontSizeProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.FontSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Controls.Page.FontSize" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.FontSize%2A> 相依性屬性的識別項。  
  
   
  
## Examples  
 [相依性屬性概觀](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Foreground : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.Page.Foreground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Controls.Page" /> 的前景。</summary>
        <value><see cref="T:System.Windows.Media.Brush" /> 用來繪製其前景的 <see cref="T:System.Windows.Controls.Page" />。 預設為 <see cref="P:System.Windows.Media.Brushes.Black" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageForeground"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Controls.Page.ForegroundProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForegroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.ForegroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Controls.Page.Foreground" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.Foreground%2A> 相依性屬性的識別項。  
  
   
  
## Examples  
 [相依性屬性概觀](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.KeepAlive" />
      <MemberSignature Language="VB.NET" Value="Public Property KeepAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeepAlive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.KeepAlive : bool with get, set" Usage="System.Windows.Controls.Page.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，這個值表示 <see cref="T:System.Windows.Controls.Page" /> 執行個體是否要保留在巡覽記錄中。</summary>
        <value>如果 <see cref="T:System.Windows.Controls.Page" /> 執行個體要保留在巡覽記錄中，則為 <see langword="true" />，否則為 <see langword="false" />。 預設為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 當頁面第一次瀏覽至的新執行個體<xref:System.Windows.Controls.Page>建立類別。 當頁面巡覽離開 （上一頁或下一頁） 時，頁面項目會新增至巡覽記錄中。 根據預設，項目未參考頁面物件。 相反地，項目包含網頁組件統一資源識別元 (URI)。 當頁面項目會巡覽至使用巡覽記錄時的 pack URI 用來建立頁面的新執行個體。 此行為是預設值，以避免過多的記憶體使用量： 保留頁面執行個體可能會快速消耗記憶體，尤其是具有大量內容。 此問題會不斷擴大，因為沒有任何限制可以儲存在後端的項目數和向前巡覽記錄堆疊。 相較之下，儲存網頁的 pack Uri 對幾乎不會影響記憶體耗用量。  
  
 主要的副作用，建立網頁的新執行個體的是，網頁狀態並不會記住從頁面的一個執行個體到另一個。 在這些情況下，Windows Presentation Foundation 提供數種技巧可記住其狀態。  
  
 若要讓頁面保持運作，您設定<xref:System.Windows.Controls.Page.KeepAlive%2A>屬性，以`true`(預設值是`false`)。  
  
> [!NOTE]
>  具現化並巡覽至使用只有程式碼的頁面 (例如，呼叫<xref:System.Windows.Navigation.NavigationService.Navigate%2A>)，會自動保持運作。  
  
 您應該避免設定<xref:System.Windows.Controls.Page.KeepAlive%2A>至`true`除非您需要：  
  
-   當頁面有許多內容時，可能需要很長的時間，來具現化。 如果頁面不保持運作，且頁面經常瀏覽至，不斷地具現化頁面的成本可能會對使用者經驗的負面影響。 不過，從效能觀點來看，您應依賴預設設定並分析您的應用程式的效能;如果測試發現有低於應用程式所需範圍的載入時間的頁面，設定頁面保持運作可能會解決此問題的方法之一。  
  
> [!NOTE]
>  項目會維持開啟的頁面不會保留在巡覽記錄中的[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]如果使用者巡覽離開再回到[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]。 只有不保持運作的頁面日誌項目會保留在巡覽記錄中。  
  
<a name="dependencyPropertyInfo_PageKeepAlive"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Controls.Page.KeepAliveProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
> [!NOTE]
>  此相依性屬性的中繼資料型別是<xref:System.Windows.PropertyMetadata>，而非<xref:System.Windows.FrameworkPropertyMetadata>。  
  
   
  
## Examples  
 下列範例示範如何使用[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]保留的執行個體<xref:System.Windows.Controls.Page>跨多個巡覽的類別。  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml2)]  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang2)]  
  
 [!code-csharp[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml.cs#setpagekeepalivecodebehind)]
 [!code-vb[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageKeepAliveSnippets/visualbasic/homepage.xaml.vb#setpagekeepalivecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.JournalEntry.KeepAlive" />
      </Docs>
    </Member>
    <Member MemberName="KeepAliveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty KeepAliveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty KeepAliveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeepAliveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ KeepAliveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeepAliveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Controls.Page.KeepAlive" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.KeepAlive%2A> 相依性屬性的識別項。  
  
   
  
## Examples  
 [相依性屬性概觀](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.Page.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>傳回 <see cref="T:System.Windows.Controls.Page" /> 之邏輯子項目的列舉程式。</summary>
        <value><see cref="T:System.Collections.IEnumerator" /> 之邏輯子項目的 <see cref="T:System.Windows.Controls.Page" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="page.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">視窗可提供給其子系的可用區域。</param>
        <summary>測量 <see cref="T:System.Windows.Controls.Page" /> 的子項目。</summary>
        <returns><see cref="T:System.Windows.Size" />，此為視窗的實際大小。 該方法可能會傳回較大的值，若是如此，父代可能需要加入捲軸。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationService">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationService NavigationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Navigation.NavigationService NavigationService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.NavigationService" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NavigationService As NavigationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Navigation::NavigationService ^ NavigationService { System::Windows::Navigation::NavigationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NavigationService : System.Windows.Navigation.NavigationService" Usage="System.Windows.Controls.Page.NavigationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得頁面主應用程式用來管理巡覽的巡覽服務。</summary>
        <value>頁面主應用程式用來管理巡覽的 <see cref="T:System.Windows.Navigation.NavigationService" /> 物件，如果該主應用程式不支援巡覽，則為 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 頁面可以裝載多個類型的主機，包括<xref:System.Windows.Window>， <xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>，與瀏覽器。  
  
 頁面通常需要其主應用程式的瀏覽至提供的頁面巡覽支援與整合。 不過，由於頁面可能不知道其主應用程式將會在執行階段，它不能直接整合其主機的瀏覽成員若要這樣做。  
  
 相反地，它可以嘗試使用瀏覽服務，也就是一項服務，支援瀏覽器式巡覽，而且由封裝<xref:System.Windows.Navigation.NavigationService>類別。 無法建立您自己<xref:System.Windows.Navigation.NavigationService>執行個體，不過。 相反地，這類裝載類型<xref:System.Windows.Navigation.NavigationWindow>， <xref:System.Windows.Controls.Frame>，或瀏覽器建立他們自己<xref:System.Windows.Navigation.NavigationService>執行個體，您可以從存取<xref:System.Windows.Controls.Page.NavigationService%2A>屬性。  
  
 從傳回的巡覽服務<xref:System.Windows.Controls.Page.NavigationService%2A>屬性是的執行個體<xref:System.Windows.Navigation.NavigationService>由第一個視覺化樹狀結構中向上巡覽器所管理的類別。 如果沒有找到其中一個項目，是`null`傳回，表示頁面的主機不支援導覽。  
  
> [!NOTE]
>  <xref:System.Windows.Window>類別不支援瀏覽，而且不會提供巡覽服務。  
  
   
  
## Examples  
 下列範例會示範如何頁面可以巡覽服務是否可用，請檢查，如果是的話，使用它來瀏覽回到前一個頁面。  
  
 [!code-csharp[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageNavigationServiceSnippets/CSharp/HomePage.xaml.cs#getpagenavigationservicecodebehind)]
 [!code-vb[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageNavigationServiceSnippets/visualbasic/homepage.xaml.vb#getpagenavigationservicecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTemplateChanged (oldTemplate As ControlTemplate, newTemplate As ControlTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTemplateChanged(System::Windows::Controls::ControlTemplate ^ oldTemplate, System::Windows::Controls::ControlTemplate ^ newTemplate);" />
      <MemberSignature Language="F#" Value="abstract member OnTemplateChanged : System.Windows.Controls.ControlTemplate * System.Windows.Controls.ControlTemplate -&gt; unit&#xA;override this.OnTemplateChanged : System.Windows.Controls.ControlTemplate * System.Windows.Controls.ControlTemplate -&gt; unit" Usage="page.OnTemplateChanged (oldTemplate, newTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">舊的範本。</param>
        <param name="newTemplate">新的範本。</param>
        <summary>在 <see cref="T:System.Windows.Controls.Page" /> 的樣板變更時呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 請參閱 <xref:System.Windows.Controls.Control.OnTemplateChanged%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Page.Template" />
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="page.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">先前的父代。 如果 <see cref="T:System.Windows.DependencyObject" /> 沒有先前的父代，則設為 <see langword="null" />。</param>
        <summary>在 <see cref="T:System.Windows.Controls.Page" /> 的父代變更時呼叫。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.UIElement.OnVisualParentChanged%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">新的父代既不是 <see cref="T:System.Windows.Window" />，也不是 <see cref="T:System.Windows.Controls.Frame" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeShowsNavigationUI ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeShowsNavigationUI() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeShowsNavigationUI () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeShowsNavigationUI();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeShowsNavigationUI : unit -&gt; bool" Usage="page.ShouldSerializeShowsNavigationUI " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如此一來，衍生類別就可以判斷 <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> 屬性的序列化行為。</summary>
        <returns>如果應該序列化內容，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTitle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTitle : unit -&gt; bool" Usage="page.ShouldSerializeTitle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如此一來，衍生類別就可以判斷 <see cref="P:System.Windows.Controls.Page.Title" /> 屬性的序列化行為。</summary>
        <returns>如果應該序列化內容，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowHeight">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowHeight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowHeight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowHeight () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowHeight();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowHeight : unit -&gt; bool" Usage="page.ShouldSerializeWindowHeight " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如此一來，衍生類別就可以判斷 <see cref="P:System.Windows.Controls.Page.WindowHeight" /> 屬性的序列化行為。</summary>
        <returns>如果應該序列化內容，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowTitle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowTitle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowTitle : unit -&gt; bool" Usage="page.ShouldSerializeWindowTitle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如此一來，衍生類別就可以判斷 <see cref="P:System.Windows.Controls.Page.WindowTitle" /> 屬性的序列化行為。</summary>
        <returns>如果應該序列化內容，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowWidth">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowWidth ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowWidth() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeWindowWidth () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeWindowWidth();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeWindowWidth : unit -&gt; bool" Usage="page.ShouldSerializeWindowWidth " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>如此一來，衍生類別就可以判斷 <see cref="P:System.Windows.Controls.Page.WindowWidth" /> 屬性的序列化行為。</summary>
        <returns>如果應該序列化內容，則為 <see langword="true" />，否則為 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShowsNavigationUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsNavigationUI" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowsNavigationUI As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowsNavigationUI { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowsNavigationUI : bool with get, set" Usage="System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定值，指出是否可以在 [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)] 上看見 <see cref="T:System.Windows.Navigation.NavigationWindow" /> 的導覽 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]。</summary>
        <value>如果可以看見裝載 <see cref="T:System.Windows.Navigation.NavigationWindow" /> 的巡覽 [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]，則為 <see langword="true" />，否則為 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationWindow> 顯示瀏覽[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]預設為啟用瀏覽器樣式向前及向後巡覽。 如果頁面設定為<xref:System.Windows.Application.StartupUri%2A>，<xref:System.Windows.Application>會自動開啟<xref:System.Windows.Navigation.NavigationWindow>裝載中的頁面。 如果頁面不想使用預設<xref:System.Windows.Navigation.NavigationWindow>瀏覽[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]，它可以設定<xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>至`false`。  
  
> [!NOTE]
>  因為[!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]沒有與導覽整合[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]for [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)]，它提供自己的巡覽[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]，這可以是您要顯示或隱藏設定<xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>。 [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] 未整合[!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)]瀏覽[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]，因此設定<xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>中的頁面上[!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)]沒有任何作用。  
  
   
  
## Examples  
 下列範例示範如何使用[!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]若要隱藏巡覽[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]的<xref:System.Windows.Navigation.NavigationWindow>。  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml2)]  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang2)]  
  
 [!code-csharp[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml.cs#setpageshowsnavigationuicodebehind)]
 [!code-vb[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageShowsNavigationUISnippets/visualbasic/homepage.xaml.vb#setpageshowsnavigationuicodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在非由 <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" />、<see cref="T:System.Windows.Controls.Page" /> 或瀏覽器裝載的 <see cref="T:System.Windows.Window" /> 執行個體上，會檢查 <see cref="T:System.Windows.Navigation.NavigationWindow" /> 屬性。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (obj As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ obj) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">要加入的子物件。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Windows.Controls.Page> 執行個體轉換成 <xref:System.Windows.Markup.IAddChild> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string str);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (str As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ str) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要加入物件中的文字。</param>
        <summary>如需這個成員的說明，請參閱 <see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 這個成員是明確介面成員實作， 只有在 <xref:System.Windows.Controls.Page> 執行個體轉換成 <xref:System.Windows.Markup.IAddChild> 介面時，才能使用這個成員。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Template" />
      <MemberSignature Language="VB.NET" Value="Public Property Template As ControlTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ControlTemplate ^ Template { System::Windows::Controls::ControlTemplate ^ get(); void set(System::Windows::Controls::ControlTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Template : System.Windows.Controls.ControlTemplate with get, set" Usage="System.Windows.Controls.Page.Template" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Controls.Page" /> 的控制項樣板。</summary>
        <value><see cref="T:System.Windows.Controls.ControlTemplate" /> 的 <see cref="T:System.Windows.Controls.Page" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_ContentTemplate"></a>   
## <a name="xaml-attribute-usage"></a>XAML Attribute Usage  
  
```  
<object Template="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlValues_ContentTemplate"></a>   
## <a name="xaml-values"></a>XAML 值  
 *resourceExtension*  
 識別如何將參考的範本資源，可能是標記延伸`StaticResource`或`DynamicResource`。 請參閱[XAML 資源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
 *styleResourceKey*  
 識別要求的範本選取器的索引鍵。 索引鍵參考中的現有資源<xref:System.Windows.ResourceDictionary>。  
  
> [!NOTE]
>  屬性元素語法是技術上可行，但不是建議使用。 如需詳細資訊，請參閱 <<c0> [ 內嵌樣式和範本](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)。  
  
<a name="dependencyPropertyInfo_PageTemplate"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Controls.Page.TemplateProperty>|  
|若要設定的中繼資料屬性 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TemplateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TemplateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.TemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Controls.Page.Template" /> 相依性屬性。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Controls.Page.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Controls.Page" /> 的標題。</summary>
        <value><see cref="T:System.Windows.Controls.Page" /> 的標題。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值<xref:System.Windows.Controls.Page.Title%2A>屬性不會顯示<xref:System.Windows.Controls.Page>，也會顯示從裝載之視窗的標題列<xref:System.Windows.Controls.Page>。 相反地，您將設定<xref:System.Windows.Controls.Page.WindowTitle%2A>變更主視窗的標題。  
  
 <xref:System.Windows.Controls.Page.Title%2A> 也可以用來產生一種巡覽內容之巡覽歷程記錄項目名稱。 下列資料片段用來自動建構巡覽歷程記錄項目名稱，依照優先順序：  
  
-   附加<xref:System.Windows.Navigation.JournalEntry.Name%2A>屬性。  
  
-   <xref:System.Windows.Controls.Page.Title%2A> 屬性。  
  
-   <xref:System.Windows.Controls.Page.WindowTitle%2A>屬性和[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]目前頁面  
  
-   目前頁面的 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]。  
  
 如果您已建立關聯<xref:System.Windows.Navigation.CustomContentState>物件具有一種巡覽記錄中的內容中，您可以指定所顯示的名稱在巡覽記錄項目中藉由覆寫<xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>。  
  
<a name="dependencyPropertyInfo_PageTitle"></a>   
## <a name="dependency-property-information"></a>相依性屬性資訊  
  
|||  
|-|-|  
|識別項欄位|<xref:System.Windows.Controls.Page.TitleProperty>|  
|若要設定的中繼資料屬性 `true`|無|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Page.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>識別 <see cref="P:System.Windows.Controls.Page.Title" /> 相依性屬性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.Title%2A> 相依性屬性的識別項。  
  
   
  
## Examples  
 [相依性屬性概觀](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public double WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.WindowHeight : double with get, set" Usage="System.Windows.Controls.Page.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Window" /> 之裝載 <see cref="T:System.Windows.Navigation.NavigationWindow" /> 或 <see cref="T:System.Windows.Controls.Page" /> 的高度。</summary>
        <value>直接裝載 <see cref="T:System.Windows.Controls.Page" /> 之視窗的高度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowHeight%2A> 只有當套用<xref:System.Windows.Controls.Page>直接裝載的視窗，其中包括：  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 如果<xref:System.Windows.Controls.Page>由裝載<xref:System.Windows.Controls.Frame>，將<xref:System.Windows.Controls.Page.WindowHeight%2A>沒有任何作用，但您仍然可以取得的值<xref:System.Windows.Controls.Page.WindowHeight%2A>。  
  
 A<xref:System.Windows.Controls.Page>中[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]可以只使用<xref:System.Windows.Controls.Page.WindowHeight%2A>若要變更的高度[!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; 設定也無法變更高度<xref:System.Windows.FrameworkElement.Height%2A>， <xref:System.Windows.FrameworkElement.MinHeight%2A>，或<xref:System.Windows.FrameworkElement.MaxHeight%2A>。  
  
 最小高度[!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]視窗是 150 個像素。 瀏覽器裝載的頁面，這表示的值<xref:System.Windows.Controls.Page.WindowHeight%2A>可能不會套用在可能的總高度[!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]為不超過 150 位的像素的視窗。  
  
   
  
## Examples  
 下列範例示範如何從頁面設定視窗的高度。  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowHeightPage.xaml#setpagewindowheightxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTitle">
      <MemberSignature Language="C#" Value="public string WindowTitle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WindowTitle { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTitle : string with get, set" Usage="System.Windows.Controls.Page.WindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Window" /> 之裝載 <see cref="T:System.Windows.Navigation.NavigationWindow" /> 或 <see cref="T:System.Windows.Controls.Page" /> 的標題。</summary>
        <value>直接裝載 <see cref="T:System.Windows.Controls.Page" /> 之視窗的標題。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 根據預設，裝載的頁面上，視窗的標題包括<xref:System.Windows.Navigation.NavigationWindow>並[!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]，是目前裝載的檔案名稱 (具有.xaml 副檔名，如果頁面是鬆散[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]，或是副檔名為.xbap 頁面是否屬於[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).  
  
 頁面上可以變更預設值，藉由設定其<xref:System.Windows.Controls.Page.WindowTitle%2A>屬性。  
  
 一旦頁面設定視窗的標題，如此一來，視窗的標題不會變更直到另一個頁面會設定<xref:System.Windows.Controls.Page.WindowTitle%2A>具有不同的值。  
  
> [!NOTE]
>  <xref:System.Windows.Controls.Page>必須是最上層的視窗中的內容片段<xref:System.Windows.Controls.Page.WindowTitle%2A>造成影響; 如果<xref:System.Windows.Controls.Page>裝載於<xref:System.Windows.Controls.Frame>，例如，設定<xref:System.Windows.Controls.Page.WindowTitle%2A>不會變更主視窗的標題。  
  
 <xref:System.Windows.Controls.Page.WindowTitle%2A> 也可以用來產生一種巡覽內容之巡覽歷程記錄項目名稱。 下列資料片段用來自動建構巡覽歷程記錄項目名稱，依照優先順序：  
  
-   附加<xref:System.Windows.Navigation.JournalEntry.Name%2A>屬性。  
  
-   <xref:System.Windows.Controls.Page.Title%2A> 屬性。  
  
-   <xref:System.Windows.Controls.Page.WindowTitle%2A>屬性和[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]目前頁面  
  
-   目前頁面的 [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]。  
  
 如果您已建立關聯<xref:System.Windows.Navigation.CustomContentState>物件與巡覽記錄中內容的部分，您可以藉由覆寫指定瀏覽歷程記錄項目的名稱值<xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下列範例示範如何設定視窗的標題，從頁面。  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowTitleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowTitlePage.xaml#setpagewindowtitlexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public double WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double WindowWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.WindowWidth : double with get, set" Usage="System.Windows.Controls.Page.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得或設定 <see cref="T:System.Windows.Window" /> 之裝載 <see cref="T:System.Windows.Navigation.NavigationWindow" /> 或 <see cref="T:System.Windows.Controls.Page" /> 的寬度。</summary>
        <value>直接裝載 <see cref="T:System.Windows.Controls.Page" /> 之視窗的寬度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowWidth%2A> 只有當套用<xref:System.Windows.Controls.Page>直接裝載的視窗，其中包括：  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 如果<xref:System.Windows.Controls.Page>由裝載<xref:System.Windows.Controls.Frame>，將<xref:System.Windows.Controls.Page.WindowWidth%2A>沒有任何作用，但您仍然可以取得的值<xref:System.Windows.Controls.Page.WindowWidth%2A>。  
  
 A<xref:System.Windows.Controls.Page>中[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]可以只使用<xref:System.Windows.Controls.Page.WindowWidth%2A>若要變更的寬度[!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; 設定也無法變更寬度<xref:System.Windows.FrameworkElement.Width%2A>， <xref:System.Windows.FrameworkElement.MinWidth%2A>，或<xref:System.Windows.FrameworkElement.MaxWidth%2A>。  
  
 最小寬度[!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]視窗是 250 個像素。 瀏覽器裝載的頁面，這表示的值<xref:System.Windows.Controls.Page.WindowWidth%2A>可能不會套用在可能的總寬度[!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]為人數少於 250 位的像素的視窗。  
  
   
  
## Examples  
 下列範例示範如何從頁面設定視窗的寬度。  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowWidthXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowWidthPage.xaml#setpagewindowwidthxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>